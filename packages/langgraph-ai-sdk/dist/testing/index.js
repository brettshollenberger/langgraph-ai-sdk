import { i as __toESM, r as __require, t as __commonJS } from "../chunk-C3Lxiq5Q.js";
import { v7 } from "uuid";
import { AIMessage, AIMessageChunk, HumanMessage } from "@langchain/core/messages";
import { kebabCase } from "change-case";
import { FakeStreamingChatModel } from "@langchain/core/utils/testing";
import { AsyncLocalStorage } from "node:async_hooks";
import { z } from "zod";
import { ChatAnthropic } from "@langchain/anthropic";
import path from "path";
import { Annotation, END, START, StateGraph, messagesStateReducer } from "@langchain/langgraph";
import { StructuredOutputParser } from "@langchain/core/output_parsers";
import { createAgent } from "langchain";
import { tool } from "@langchain/core/tools";
import { readFile, writeFile } from "fs/promises";

//#region src/testing/node/withContext.ts
const nodeContext = new AsyncLocalStorage();
function getNodeContext() {
	return nodeContext.getStore();
}
/**
* Wraps a node function with context that includes node name and graph name
* The graph name is automatically extracted from config.configurable (thread_id or checkpoint_ns)
*/
const withContext = (nodeFunction, options) => {
	return (state, config) => {
		const nodeName = config?.metadata?.langgraph_node;
		const graphName = config?.context?.graphName;
		return nodeContext.run({
			name: nodeName,
			graphName
		}, () => {
			return nodeFunction(state, config);
		});
	};
};

//#endregion
//#region src/testing/llm/types.ts
const LLMNames = {
	Haiku: "claude-haiku-4-5",
	Sonnet: "claude-sonnet-4-5",
	GptOss: "gpt-oss:20b",
	GeminiFlash: "gemini-1.5-flash-latest",
	LlamaInstant: "llama-3.1-8b-instant",
	Fake: "fake"
};
const temperatureSchema = z.number().min(0).max(1);

//#endregion
//#region src/testing/llm/test.ts
var StructuredOutputAwareFakeModel = class extends FakeStreamingChatModel {
	useStructuredOutput = false;
	structuredSchema = null;
	boundTools = [];
	includeRaw = false;
	streamingChunks = [];
	withStructuredOutput(schema, config) {
		this.useStructuredOutput = true;
		this.structuredSchema = schema;
		this.includeRaw = config?.includeRaw ?? false;
		return this;
	}
	convertResponsesToStructuredChunks(responses) {
		if (!responses || responses.length === 0 || !this.useStructuredOutput) return [];
		const allChunks = [];
		for (const response of responses) {
			const content = typeof response === "string" ? response : response.content || "";
			const stripped = content.replace(/```json\n?/g, "").replace(/```/g, "").trim();
			try {
				const parsed = JSON.parse(stripped);
				const jsonString = JSON.stringify(parsed);
				const chunkSize = 20;
				const chunks = [];
				for (let i$8 = 0; i$8 < jsonString.length; i$8 += chunkSize) chunks.push(jsonString.substring(i$8, i$8 + chunkSize));
				chunks.forEach((argsChunk, idx) => {
					const toolCallChunk = {
						args: argsChunk,
						id: "extract-1",
						index: 0
					};
					if (idx === 0) toolCallChunk.name = "extract-structured_output";
					const messageChunk = new AIMessageChunk({
						content: "",
						tool_call_chunks: [toolCallChunk],
						id: `msg-${idx}`
					});
					if (this.includeRaw) allChunks.push({
						raw: messageChunk,
						parsed: idx === chunks.length - 1 ? parsed : void 0
					});
					else allChunks.push(messageChunk);
				});
			} catch (e) {
				const errorChunk = new AIMessageChunk({ content });
				if (this.includeRaw) allChunks.push({
					raw: errorChunk,
					parsed: null
				});
				else allChunks.push(errorChunk);
			}
		}
		return allChunks;
	}
	bindTools(tools, config) {
		const clone$2 = Object.create(Object.getPrototypeOf(this));
		Object.assign(clone$2, this);
		clone$2.boundTools = tools;
		if (tools.some((t) => t.name?.startsWith("extract-"))) {
			clone$2.useStructuredOutput = true;
			clone$2.structuredSchema = tools.find((t) => t.name?.startsWith("extract-"))?.parameters;
		}
		return clone$2;
	}
	async *_streamResponseChunks(messages, options, runManager) {
		if (this.useStructuredOutput) {
			const originalResponses = this.responses || [];
			this.streamingChunks = this.convertResponsesToStructuredChunks(originalResponses);
			for (let i$8 = 0; i$8 < this.streamingChunks.length; i$8++) {
				const chunk = this.streamingChunks[i$8];
				const messageChunk = this.includeRaw ? chunk.raw : chunk;
				yield {
					message: messageChunk,
					chunk: messageChunk,
					generation_info: options?.tags ? { metadata: { tags: options.tags } } : void 0
				};
				await new Promise((resolve$6) => setTimeout(resolve$6, 1));
			}
		} else yield* super._streamResponseChunks(messages, options, runManager);
	}
	async invoke(input, options) {
		if (this.useStructuredOutput) {
			const response = await super.invoke(input, options);
			if (response && response.tool_calls && response.tool_calls.length > 0) {
				const toolCall = response.tool_calls[0];
				if (!toolCall) return response;
				const parsed = toolCall.args;
				if (this.includeRaw) return {
					raw: response,
					parsed
				};
				return parsed;
			}
			return response;
		}
		return await super.invoke(input, options);
	}
};
const FakeConfig = {
	provider: "fake",
	model: "Fake",
	modelCard: LLMNames.Fake,
	temperature: 0,
	maxTokens: 128e3
};
var TestLLMManager = class {
	responses = {};
	get(...args) {
		const nodeContext$1 = getNodeContext();
		const graphName = nodeContext$1?.graphName;
		const nodeName = nodeContext$1?.name;
		if (!graphName || !nodeName) throw new Error("Graph name or node name is missing! Cannot get test LLM without proper context.");
		const graphResponses = this.responses[graphName];
		if (!graphResponses || !graphResponses[nodeName]) throw new Error("No responses configured for this graph/node combination.");
		return new StructuredOutputAwareFakeModel({
			responses: graphResponses[nodeName].map((responseStr) => {
				return new AIMessage({ content: responseStr });
			}),
			sleep: 0
		});
	}
};
const manager = new TestLLMManager();
/**
* Convert a response value to a string format suitable for FakeListChatModel
* - Objects are converted to ```json ... ``` format
* - Strings are returned as-is
*/
function normalizeResponse(response) {
	if (typeof response === "string") return response;
	return `\`\`\`json\n${JSON.stringify(response, null, 2)}\n\`\`\``;
}
/**
* Configure mock responses for specific nodes in test environment
* Organized by graph identifier (thread_id or checkpoint_ns) to avoid collisions
*
* Supports both string responses and object responses:
* - Strings are used as-is
* - Objects are automatically converted to ```json ... ``` format
*
* @example
* configureResponses({
*   "thread-123": {
*     nameProjectNode: ["project-paris"],
*     // Both formats work:
*     responseNode: [{ intro: 'It just works', examples: ['ex1'], conclusion: 'Done' }]
*     // Or: responseNode: ["```json { \"intro\": \"It just works\" }```"]
*   },
*   "thread-456": {
*     nameProjectNode: ["project-london"],
*     responseNode: [{ intro: 'Also works' }]
*   }
* })
*/
function configureResponses$1(responses) {
	const normalizedResponses = {};
	for (const [graphName, graphResponses] of Object.entries(responses)) {
		normalizedResponses[graphName] = {};
		for (const [nodeName, nodeResponses] of Object.entries(graphResponses)) normalizedResponses[graphName][nodeName] = nodeResponses.map(normalizeResponse);
	}
	manager.responses = normalizedResponses;
}
/**
* Reset all configured responses
* Useful in afterEach hooks to clean up test state
*
* @example
* afterEach(() => {
*   resetLLMConfig();
* });
*/
function resetLLMConfig$1() {
	manager.responses = {};
}
/**
* Get a test LLM instance (StructuredOutputAwareFakeModel) based on the current node context
* Returns null if no responses are configured for the current graph/node combination,
* allowing the main getLLM function to fall back to core LLM
*/
function getTestLLM(...args) {
	return manager.get(...args);
}
/**
* Check if test responses are configured for a specific graph and node
* Useful for conditional test logic
*/
function hasConfiguredResponses(graphName, nodeName) {
	return !!manager.responses[graphName]?.[nodeName];
}

//#endregion
//#region src/testing/llm/core.ts
const anthropicApiKey = process.env.ANTHROPIC_API_KEY;
if (!anthropicApiKey) throw new Error("Anthropic API key (ANTHROPIC_API_KEY) is missing!");
const HaikuConfig = {
	provider: "anthropic",
	model: "Haiku",
	modelCard: LLMNames.Haiku,
	temperature: 0,
	maxTokens: 18e4,
	apiKey: anthropicApiKey
};
const SonnetConfig = {
	provider: "anthropic",
	model: "Sonnet",
	modelCard: LLMNames.Sonnet,
	temperature: 0,
	maxTokens: 18e4,
	apiKey: anthropicApiKey
};
LLMNames.GptOss;
const freeSlowConfig = {
	planning: SonnetConfig,
	writing: HaikuConfig,
	coding: SonnetConfig,
	reasoning: HaikuConfig
};
const freeFastConfig = {
	planning: HaikuConfig,
	writing: HaikuConfig,
	coding: HaikuConfig,
	reasoning: HaikuConfig
};
const paidSlowConfig = {
	planning: HaikuConfig,
	writing: HaikuConfig,
	coding: SonnetConfig,
	reasoning: SonnetConfig
};
const paidFastConfig = {
	planning: SonnetConfig,
	writing: SonnetConfig,
	coding: SonnetConfig,
	reasoning: SonnetConfig
};
const coreLLMConfig = {
	"free": {
		"fast": freeFastConfig,
		"slow": freeSlowConfig
	},
	"paid": {
		"fast": paidFastConfig,
		"slow": paidSlowConfig
	}
};
function hasApiKey(config) {
	return "apiKey" in config;
}
var LLMManager = class {
	llmInstances = {};
	get(llmSkill, llmSpeed, llmCost) {
		const cacheKey = `${llmSkill}-${llmSpeed}-${llmCost}`;
		if (this.llmInstances[cacheKey]) return this.llmInstances[cacheKey];
		const speedConfig = coreLLMConfig[llmCost]?.[llmSpeed];
		if (!speedConfig) throw new Error(`LLM configuration not found for tier '${llmCost}' and speed '${llmSpeed}'.`);
		const config = speedConfig[llmSkill];
		if (!config) throw new Error(`LLM configuration not found for skill '${llmSkill}' within tier '${llmCost}' and speed '${llmSpeed}'.`);
		let modelInstance;
		switch (config.provider) {
			case "anthropic":
				if (!hasApiKey(config)) throw new Error("Anthropic API key (ANTHROPIC_API_KEY) is missing!");
				modelInstance = new ChatAnthropic({
					apiKey: config.apiKey,
					model: config.modelCard,
					temperature: config.temperature
				});
				break;
			default: throw new Error(`Unsupported LLM provider: ${config.provider}`);
		}
		this.llmInstances[cacheKey] = modelInstance;
		return modelInstance;
	}
};
/**
* Get a core LLM instance based on skill and speed
* This is used for development and production environments with real LLM providers
*/
function getCoreLLM(llmSkill, llmSpeed, llmCost = "free") {
	return new LLMManager().get(llmSkill, llmSpeed, llmCost);
}

//#endregion
//#region src/testing/llm/llm.ts
const isTestEnvironment = process.env.NODE_ENV === "test";
const LLM_SPEED_DEFAULT = process.env.LLM_SPEED === "fast" ? "fast" : "slow";
const LLM_COST_DEFAULT = process.env.LLM_COST === "paid" ? "paid" : "free";
const LLM_SKILL_DEFAULT = "writing";
/**
* Get an LLM instance based on the current environment
*
* Behavior:
* - In test environment (NODE_ENV=test):
*   - If mock responses are configured for the current graph/node: Returns FakeListChatModel
*   - If no mock responses are configured: Falls back to core LLM (real implementation)
* - In development/production: Always returns core LLM instances (Anthropic, Ollama, etc.)
*
* This fallback behavior allows you to:
* 1. Mock specific nodes in tests while using real LLMs for others
* 2. Run tests without mocking everything upfront
* 3. Gradually add mocks as needed
*
* @param llmSkill - The skill needed (planning, writing, coding, reasoning)
* @param llmSpeed - Speed preference (fast or slow), defaults to LLM_SPEED env var
* @returns BaseChatModel instance
*/
function getLLM(llmSkill = LLM_SKILL_DEFAULT, llmSpeed = LLM_SPEED_DEFAULT, llmCost = LLM_COST_DEFAULT) {
	const nodeContext$1 = getNodeContext();
	const graphName = nodeContext$1?.graphName;
	const nodeName = nodeContext$1?.name;
	if (!graphName) throw new Error("No graph name found in context, configure it with .config({name: 'my-graph-name'})");
	if (isTestEnvironment && hasConfiguredResponses(graphName, nodeName)) return getTestLLM(llmSkill, llmSpeed, llmCost);
	return getCoreLLM(llmSkill, llmSpeed, llmCost);
}
/**
* Configure mock responses for test environment
* Organized by graph identifier (thread_id or checkpoint_ns) to avoid collisions
*
* @example
* configureResponses({
*   "thread-123": {
*     nameProjectNode: ["project-paris"],
*     responseNode: ["```json { intro: 'It just works' }```"]
*   }
* })
*/
const configureResponses = configureResponses$1;
/**
* Reset all configured mock responses
* Use this in afterEach hooks to clean up test state
*
* @example
* afterEach(() => {
*   resetLLMConfig();
* });
*/
const resetLLMConfig = resetLLMConfig$1;

//#endregion
//#region src/testing/node/withErrorHandling.ts
const preconfiguredReporters = { console: (error) => console.error(error) };
var Reporters = class {
	reporters = [];
	addReporter(reporter) {
		if (typeof reporter === "string") {
			if (!preconfiguredReporters[reporter]) throw new Error(`Reporter ${reporter} not found`);
			this.reporters.push(preconfiguredReporters[reporter]);
		} else this.reporters.push(reporter);
		return this;
	}
	list() {
		return this.reporters;
	}
	report(error) {
		this.reporters.forEach((reporter) => reporter(error));
	}
};
const ErrorReporters = new Reporters();
/**
* Wraps a node function with error handling
*/
const withErrorHandling = (nodeFunction, options) => {
	return async (state, config) => {
		try {
			return await nodeFunction(state, config);
		} catch (error) {
			ErrorReporters.report(error);
			throw error;
		}
	};
};

//#endregion
//#region src/testing/node/withNotifications.ts
function notify$5(taskName, config, task$5) {
	if (!task$5 || !config?.writer) return;
	if (!task$5.id) task$5.id = v7();
	config.writer({
		id: task$5.id,
		event: taskName,
		task: task$5
	});
}
/**
* Wraps a node function with error handling
*/
const withNotifications = (nodeFunction, options) => {
	return async (state, config) => {
		const defaultName = getNodeContext()?.name;
		const task$5 = { title: typeof options?.taskName === "function" ? await options.taskName(state, config) : typeof options?.taskName === "string" ? options.taskName : defaultName };
		try {
			notify$5("NOTIFY_TASK_START", config, task$5);
			const result = await nodeFunction(state, config);
			notify$5("NOTIFY_TASK_COMPLETE", config, task$5);
			return result;
		} catch (error) {
			notify$5("NOTIFY_TASK_ERROR", config, task$5);
			throw error;
		}
	};
};

//#endregion
//#region src/testing/node/nodeMiddlewareFactory.ts
var NodeMiddlewareFactory = class {
	middlewares;
	constructor() {
		this.middlewares = {};
	}
	addMiddleware(name, middleware$1) {
		this.middlewares[name] = middleware$1;
		return this;
	}
	use(config = {}, node$1) {
		return this.getMiddlewaresToApply(config).reduceRight((wrappedNode, [name, middleware$1]) => {
			const middlewareConfig = config[name];
			return middleware$1(wrappedNode, middlewareConfig);
		}, node$1);
	}
	getMiddlewaresToApply(config) {
		const allNames = Object.keys(this.middlewares);
		let selectedNames = allNames;
		if (config.only) selectedNames = allNames.filter((name) => config.only.includes(name));
		if (config.except) selectedNames = selectedNames.filter((name) => !config.except.includes(name));
		return selectedNames.map((name) => [name, this.middlewares[name]]);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/requires-port@1.0.0/node_modules/requires-port/index.js
var require_requires_port = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/requires-port@1.0.0/node_modules/requires-port/index.js": ((exports, module) => {
	/**
	* Check if we're required to add a port number.
	*
	* @see https://url.spec.whatwg.org/#default-port
	* @param {Number|String} port Port number we need to check
	* @param {String} protocol Protocol we need to check against.
	* @returns {Boolean} Is it a default port for the given protocol
	* @api private
	*/
	module.exports = function required$1(port$6, protocol) {
		protocol = protocol.split(":")[0];
		port$6 = +port$6;
		if (!port$6) return false;
		switch (protocol) {
			case "http":
			case "ws": return port$6 !== 80;
			case "https":
			case "wss": return port$6 !== 443;
			case "ftp": return port$6 !== 21;
			case "gopher": return port$6 !== 70;
			case "file": return false;
		}
		return port$6 !== 0;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/querystringify@2.2.0/node_modules/querystringify/index.js
var require_querystringify = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/querystringify@2.2.0/node_modules/querystringify/index.js": ((exports) => {
	var has$7 = Object.prototype.hasOwnProperty, undef;
	/**
	* Decode a URI encoded string.
	*
	* @param {String} input The URI encoded string.
	* @returns {String|Null} The decoded string.
	* @api private
	*/
	function decode$4(input) {
		try {
			return decodeURIComponent(input.replace(/\+/g, " "));
		} catch (e) {
			return null;
		}
	}
	/**
	* Attempts to encode a given input.
	*
	* @param {String} input The string that needs to be encoded.
	* @returns {String|Null} The encoded string.
	* @api private
	*/
	function encode$2(input) {
		try {
			return encodeURIComponent(input);
		} catch (e) {
			return null;
		}
	}
	/**
	* Simple query string parser.
	*
	* @param {String} query The query string that needs to be parsed.
	* @returns {Object}
	* @api public
	*/
	function querystring$4(query$1) {
		var parser$1 = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
		while (part = parser$1.exec(query$1)) {
			var key$1 = decode$4(part[1]), value = decode$4(part[2]);
			if (key$1 === null || value === null || key$1 in result) continue;
			result[key$1] = value;
		}
		return result;
	}
	/**
	* Transform a query string to an object.
	*
	* @param {Object} obj Object that should be transformed.
	* @param {String} prefix Optional prefix.
	* @returns {String}
	* @api public
	*/
	function querystringify(obj, prefix) {
		prefix = prefix || "";
		var pairs = [], value, key$1;
		if ("string" !== typeof prefix) prefix = "?";
		for (key$1 in obj) if (has$7.call(obj, key$1)) {
			value = obj[key$1];
			if (!value && (value === null || value === undef || isNaN(value))) value = "";
			key$1 = encode$2(key$1);
			value = encode$2(value);
			if (key$1 === null || value === null) continue;
			pairs.push(key$1 + "=" + value);
		}
		return pairs.length ? prefix + pairs.join("&") : "";
	}
	exports.stringify = querystringify;
	exports.parse = querystring$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/url-parse@1.5.10/node_modules/url-parse/index.js
var require_url_parse = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/url-parse@1.5.10/node_modules/url-parse/index.js": ((exports, module) => {
	var required = require_requires_port(), qs$3 = require_querystringify(), controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port$5 = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
	/**
	* Remove control characters and whitespace from the beginning of a string.
	*
	* @param {Object|String} str String to trim.
	* @returns {String} A new string representing `str` stripped of control
	*     characters and whitespace from its beginning.
	* @public
	*/
	function trimLeft(str) {
		return (str ? str : "").toString().replace(controlOrWhitespace, "");
	}
	/**
	* These are the parse rules for the URL parser, it informs the parser
	* about:
	*
	* 0. The char it Needs to parse, if it's a string it should be done using
	*    indexOf, RegExp using exec and NaN means set as current value.
	* 1. The property we should set when parsing this value.
	* 2. Indication if it's backwards or forward parsing, when set as number it's
	*    the value of extra chars that should be split off.
	* 3. Inherit from location if non existing in the parser.
	* 4. `toLowerCase` the resulting value.
	*/
	var rules = [
		["#", "hash"],
		["?", "query"],
		function sanitize$1(address, url$6) {
			return isSpecial(url$6.protocol) ? address.replace(/\\/g, "/") : address;
		},
		["/", "pathname"],
		[
			"@",
			"auth",
			1
		],
		[
			NaN,
			"host",
			void 0,
			1,
			1
		],
		[
			/:(\d*)$/,
			"port",
			void 0,
			1
		],
		[
			NaN,
			"hostname",
			void 0,
			1,
			1
		]
	];
	/**
	* These properties should not be copied or inherited from. This is only needed
	* for all non blob URL's as a blob URL does not include a hash, only the
	* origin.
	*
	* @type {Object}
	* @private
	*/
	var ignore = {
		hash: 1,
		query: 1
	};
	/**
	* The location object differs when your code is loaded through a normal page,
	* Worker or through a worker using a blob. And with the blobble begins the
	* trouble as the location object will contain the URL of the blob, not the
	* location of the page where our code is loaded in. The actual origin is
	* encoded in the `pathname` so we can thankfully generate a good "default"
	* location from it so we can generate proper relative URL's again.
	*
	* @param {Object|String} loc Optional default location object.
	* @returns {Object} lolcation object.
	* @public
	*/
	function lolcation(loc) {
		var globalVar;
		if (typeof window !== "undefined") globalVar = window;
		else if (typeof global !== "undefined") globalVar = global;
		else if (typeof self !== "undefined") globalVar = self;
		else globalVar = {};
		var location = globalVar.location || {};
		loc = loc || location;
		var finaldestination = {}, type = typeof loc, key$1;
		if ("blob:" === loc.protocol) finaldestination = new Url$1(unescape(loc.pathname), {});
		else if ("string" === type) {
			finaldestination = new Url$1(loc, {});
			for (key$1 in ignore) delete finaldestination[key$1];
		} else if ("object" === type) {
			for (key$1 in loc) {
				if (key$1 in ignore) continue;
				finaldestination[key$1] = loc[key$1];
			}
			if (finaldestination.slashes === void 0) finaldestination.slashes = slashes.test(loc.href);
		}
		return finaldestination;
	}
	/**
	* Check whether a protocol scheme is special.
	*
	* @param {String} The protocol scheme of the URL
	* @return {Boolean} `true` if the protocol scheme is special, else `false`
	* @private
	*/
	function isSpecial(scheme) {
		return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
	}
	/**
	* @typedef ProtocolExtract
	* @type Object
	* @property {String} protocol Protocol matched in the URL, in lowercase.
	* @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
	* @property {String} rest Rest of the URL that is not part of the protocol.
	*/
	/**
	* Extract protocol information from a URL with/without double slash ("//").
	*
	* @param {String} address URL we want to extract from.
	* @param {Object} location
	* @return {ProtocolExtract} Extracted information.
	* @private
	*/
	function extractProtocol(address, location) {
		address = trimLeft(address);
		address = address.replace(CRHTLF, "");
		location = location || {};
		var match$1 = protocolre.exec(address);
		var protocol = match$1[1] ? match$1[1].toLowerCase() : "";
		var forwardSlashes = !!match$1[2];
		var otherSlashes = !!match$1[3];
		var slashesCount = 0;
		var rest;
		if (forwardSlashes) if (otherSlashes) {
			rest = match$1[2] + match$1[3] + match$1[4];
			slashesCount = match$1[2].length + match$1[3].length;
		} else {
			rest = match$1[2] + match$1[4];
			slashesCount = match$1[2].length;
		}
		else if (otherSlashes) {
			rest = match$1[3] + match$1[4];
			slashesCount = match$1[3].length;
		} else rest = match$1[4];
		if (protocol === "file:") {
			if (slashesCount >= 2) rest = rest.slice(2);
		} else if (isSpecial(protocol)) rest = match$1[4];
		else if (protocol) {
			if (forwardSlashes) rest = rest.slice(2);
		} else if (slashesCount >= 2 && isSpecial(location.protocol)) rest = match$1[4];
		return {
			protocol,
			slashes: forwardSlashes || isSpecial(protocol),
			slashesCount,
			rest
		};
	}
	/**
	* Resolve a relative URL pathname against a base URL pathname.
	*
	* @param {String} relative Pathname of the relative URL.
	* @param {String} base Pathname of the base URL.
	* @return {String} Resolved pathname.
	* @private
	*/
	function resolve$5(relative$1, base) {
		if (relative$1 === "") return base;
		var path$19 = (base || "/").split("/").slice(0, -1).concat(relative$1.split("/")), i$8 = path$19.length, last = path$19[i$8 - 1], unshift = false, up = 0;
		while (i$8--) if (path$19[i$8] === ".") path$19.splice(i$8, 1);
		else if (path$19[i$8] === "..") {
			path$19.splice(i$8, 1);
			up++;
		} else if (up) {
			if (i$8 === 0) unshift = true;
			path$19.splice(i$8, 1);
			up--;
		}
		if (unshift) path$19.unshift("");
		if (last === "." || last === "..") path$19.push("");
		return path$19.join("/");
	}
	/**
	* The actual URL instance. Instead of returning an object we've opted-in to
	* create an actual constructor as it's much more memory efficient and
	* faster and it pleases my OCD.
	*
	* It is worth noting that we should not use `URL` as class name to prevent
	* clashes with the global URL instance that got introduced in browsers.
	*
	* @constructor
	* @param {String} address URL we want to parse.
	* @param {Object|String} [location] Location defaults for relative paths.
	* @param {Boolean|Function} [parser] Parser for the query string.
	* @private
	*/
	function Url$1(address, location, parser$1) {
		address = trimLeft(address);
		address = address.replace(CRHTLF, "");
		if (!(this instanceof Url$1)) return new Url$1(address, location, parser$1);
		var relative$1, extracted, parse$18, instruction, index$1, key$1, instructions = rules.slice(), type = typeof location, url$6 = this, i$8 = 0;
		if ("object" !== type && "string" !== type) {
			parser$1 = location;
			location = null;
		}
		if (parser$1 && "function" !== typeof parser$1) parser$1 = qs$3.parse;
		location = lolcation(location);
		extracted = extractProtocol(address || "", location);
		relative$1 = !extracted.protocol && !extracted.slashes;
		url$6.slashes = extracted.slashes || relative$1 && location.slashes;
		url$6.protocol = extracted.protocol || location.protocol || "";
		address = extracted.rest;
		if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url$6.protocol))) instructions[3] = [/(.*)/, "pathname"];
		for (; i$8 < instructions.length; i$8++) {
			instruction = instructions[i$8];
			if (typeof instruction === "function") {
				address = instruction(address, url$6);
				continue;
			}
			parse$18 = instruction[0];
			key$1 = instruction[1];
			if (parse$18 !== parse$18) url$6[key$1] = address;
			else if ("string" === typeof parse$18) {
				index$1 = parse$18 === "@" ? address.lastIndexOf(parse$18) : address.indexOf(parse$18);
				if (~index$1) if ("number" === typeof instruction[2]) {
					url$6[key$1] = address.slice(0, index$1);
					address = address.slice(index$1 + instruction[2]);
				} else {
					url$6[key$1] = address.slice(index$1);
					address = address.slice(0, index$1);
				}
			} else if (index$1 = parse$18.exec(address)) {
				url$6[key$1] = index$1[1];
				address = address.slice(0, index$1.index);
			}
			url$6[key$1] = url$6[key$1] || (relative$1 && instruction[3] ? location[key$1] || "" : "");
			if (instruction[4]) url$6[key$1] = url$6[key$1].toLowerCase();
		}
		if (parser$1) url$6.query = parser$1(url$6.query);
		if (relative$1 && location.slashes && url$6.pathname.charAt(0) !== "/" && (url$6.pathname !== "" || location.pathname !== "")) url$6.pathname = resolve$5(url$6.pathname, location.pathname);
		if (url$6.pathname.charAt(0) !== "/" && isSpecial(url$6.protocol)) url$6.pathname = "/" + url$6.pathname;
		if (!required(url$6.port, url$6.protocol)) {
			url$6.host = url$6.hostname;
			url$6.port = "";
		}
		url$6.username = url$6.password = "";
		if (url$6.auth) {
			index$1 = url$6.auth.indexOf(":");
			if (~index$1) {
				url$6.username = url$6.auth.slice(0, index$1);
				url$6.username = encodeURIComponent(decodeURIComponent(url$6.username));
				url$6.password = url$6.auth.slice(index$1 + 1);
				url$6.password = encodeURIComponent(decodeURIComponent(url$6.password));
			} else url$6.username = encodeURIComponent(decodeURIComponent(url$6.auth));
			url$6.auth = url$6.password ? url$6.username + ":" + url$6.password : url$6.username;
		}
		url$6.origin = url$6.protocol !== "file:" && isSpecial(url$6.protocol) && url$6.host ? url$6.protocol + "//" + url$6.host : "null";
		url$6.href = url$6.toString();
	}
	/**
	* This is convenience method for changing properties in the URL instance to
	* insure that they all propagate correctly.
	*
	* @param {String} part          Property we need to adjust.
	* @param {Mixed} value          The newly assigned value.
	* @param {Boolean|Function} fn  When setting the query, it will be the function
	*                               used to parse the query.
	*                               When setting the protocol, double slash will be
	*                               removed from the final url if it is true.
	* @returns {URL} URL instance for chaining.
	* @public
	*/
	function set$2(part, value, fn) {
		var url$6 = this;
		switch (part) {
			case "query":
				if ("string" === typeof value && value.length) value = (fn || qs$3.parse)(value);
				url$6[part] = value;
				break;
			case "port":
				url$6[part] = value;
				if (!required(value, url$6.protocol)) {
					url$6.host = url$6.hostname;
					url$6[part] = "";
				} else if (value) url$6.host = url$6.hostname + ":" + value;
				break;
			case "hostname":
				url$6[part] = value;
				if (url$6.port) value += ":" + url$6.port;
				url$6.host = value;
				break;
			case "host":
				url$6[part] = value;
				if (port$5.test(value)) {
					value = value.split(":");
					url$6.port = value.pop();
					url$6.hostname = value.join(":");
				} else {
					url$6.hostname = value;
					url$6.port = "";
				}
				break;
			case "protocol":
				url$6.protocol = value.toLowerCase();
				url$6.slashes = !fn;
				break;
			case "pathname":
			case "hash":
				if (value) {
					var char = part === "pathname" ? "/" : "#";
					url$6[part] = value.charAt(0) !== char ? char + value : value;
				} else url$6[part] = value;
				break;
			case "username":
			case "password":
				url$6[part] = encodeURIComponent(value);
				break;
			case "auth":
				var index$1 = value.indexOf(":");
				if (~index$1) {
					url$6.username = value.slice(0, index$1);
					url$6.username = encodeURIComponent(decodeURIComponent(url$6.username));
					url$6.password = value.slice(index$1 + 1);
					url$6.password = encodeURIComponent(decodeURIComponent(url$6.password));
				} else url$6.username = encodeURIComponent(decodeURIComponent(value));
		}
		for (var i$8 = 0; i$8 < rules.length; i$8++) {
			var ins = rules[i$8];
			if (ins[4]) url$6[ins[1]] = url$6[ins[1]].toLowerCase();
		}
		url$6.auth = url$6.password ? url$6.username + ":" + url$6.password : url$6.username;
		url$6.origin = url$6.protocol !== "file:" && isSpecial(url$6.protocol) && url$6.host ? url$6.protocol + "//" + url$6.host : "null";
		url$6.href = url$6.toString();
		return url$6;
	}
	/**
	* Transform the properties back in to a valid and full URL string.
	*
	* @param {Function} stringify Optional query stringify function.
	* @returns {String} Compiled version of the URL.
	* @public
	*/
	function toString$14(stringify$14) {
		if (!stringify$14 || "function" !== typeof stringify$14) stringify$14 = qs$3.stringify;
		var query$1, url$6 = this, host = url$6.host, protocol = url$6.protocol;
		if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
		var result = protocol + (url$6.protocol && url$6.slashes || isSpecial(url$6.protocol) ? "//" : "");
		if (url$6.username) {
			result += url$6.username;
			if (url$6.password) result += ":" + url$6.password;
			result += "@";
		} else if (url$6.password) {
			result += ":" + url$6.password;
			result += "@";
		} else if (url$6.protocol !== "file:" && isSpecial(url$6.protocol) && !host && url$6.pathname !== "/") result += "@";
		if (host[host.length - 1] === ":" || port$5.test(url$6.hostname) && !url$6.port) host += ":";
		result += host + url$6.pathname;
		query$1 = "object" === typeof url$6.query ? stringify$14(url$6.query) : url$6.query;
		if (query$1) result += "?" !== query$1.charAt(0) ? "?" + query$1 : query$1;
		if (url$6.hash) result += url$6.hash;
		return result;
	}
	Url$1.prototype = {
		set: set$2,
		toString: toString$14
	};
	Url$1.extractProtocol = extractProtocol;
	Url$1.location = lolcation;
	Url$1.trimLeft = trimLeft;
	Url$1.qs = qs$3;
	module.exports = Url$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js": ((exports, module) => {
	/** @type {import('./type')} */
	module.exports = TypeError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js
var require_util_inspect = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js": ((exports, module) => {
	module.exports = __require("util").inspect;
}) });

//#endregion
//#region ../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js
var require_object_inspect = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js": ((exports, module) => {
	var hasMap = typeof Map === "function" && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === "function" && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var weakMapHas = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap.prototype.has : null;
	var weakSetHas = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet.prototype.has : null;
	var weakRefDeref = typeof WeakRef === "function" && WeakRef.prototype ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString$3 = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var $match = String.prototype.match;
	var $slice = String.prototype.slice;
	var $replace$1 = String.prototype.replace;
	var $toUpperCase = String.prototype.toUpperCase;
	var $toLowerCase = String.prototype.toLowerCase;
	var $test = RegExp.prototype.test;
	var $concat$1 = Array.prototype.concat;
	var $join = Array.prototype.join;
	var $arrSlice = Array.prototype.slice;
	var $floor = Math.floor;
	var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
	var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
		return O.__proto__;
	} : null);
	function addNumericSeparator(num, str) {
		if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) return str;
		var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
		if (typeof num === "number") {
			var int = num < 0 ? -$floor(-num) : $floor(num);
			if (int !== num) {
				var intStr = String(int);
				var dec = $slice.call(str, intStr.length + 1);
				return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
			}
		}
		return $replace$1.call(str, sepRegex, "$&_");
	}
	var utilInspect = require_util_inspect();
	var inspectCustom = utilInspect.custom;
	var inspectSymbol = isSymbol$7(inspectCustom) ? inspectCustom : null;
	var quotes = {
		__proto__: null,
		"double": "\"",
		single: "'"
	};
	var quoteREs = {
		__proto__: null,
		"double": /(["\\])/g,
		single: /(['\\])/g
	};
	module.exports = function inspect_(obj, options, depth, seen) {
		var opts = options || {};
		if (has$6(opts, "quoteStyle") && !has$6(quotes, opts.quoteStyle)) throw new TypeError("option \"quoteStyle\" must be \"single\" or \"double\"");
		if (has$6(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) throw new TypeError("option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`");
		var customInspect = has$6(opts, "customInspect") ? opts.customInspect : true;
		if (typeof customInspect !== "boolean" && customInspect !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
		if (has$6(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError("option \"indent\" must be \"\\t\", an integer > 0, or `null`");
		if (has$6(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") throw new TypeError("option \"numericSeparator\", if provided, must be `true` or `false`");
		var numericSeparator = opts.numericSeparator;
		if (typeof obj === "undefined") return "undefined";
		if (obj === null) return "null";
		if (typeof obj === "boolean") return obj ? "true" : "false";
		if (typeof obj === "string") return inspectString(obj, opts);
		if (typeof obj === "number") {
			if (obj === 0) return Infinity / obj > 0 ? "0" : "-0";
			var str = String(obj);
			return numericSeparator ? addNumericSeparator(obj, str) : str;
		}
		if (typeof obj === "bigint") {
			var bigIntStr = String(obj) + "n";
			return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
		}
		var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
		if (typeof depth === "undefined") depth = 0;
		if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") return isArray$10(obj) ? "[Array]" : "[Object]";
		var indent$1 = getIndent(opts, depth);
		if (typeof seen === "undefined") seen = [];
		else if (indexOf(seen, obj) >= 0) return "[Circular]";
		function inspect$5(value, from, noIndent) {
			if (from) {
				seen = $arrSlice.call(seen);
				seen.push(from);
			}
			if (noIndent) {
				var newOpts = { depth: opts.depth };
				if (has$6(opts, "quoteStyle")) newOpts.quoteStyle = opts.quoteStyle;
				return inspect_(value, newOpts, depth + 1, seen);
			}
			return inspect_(value, opts, depth + 1, seen);
		}
		if (typeof obj === "function" && !isRegExp$2(obj)) {
			var name = nameOf(obj);
			var keys$6 = arrObjKeys(obj, inspect$5);
			return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys$6.length > 0 ? " { " + $join.call(keys$6, ", ") + " }" : "");
		}
		if (isSymbol$7(obj)) {
			var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
			return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
		}
		if (isElement(obj)) {
			var s$3 = "<" + $toLowerCase.call(String(obj.nodeName));
			var attrs = obj.attributes || [];
			for (var i$8 = 0; i$8 < attrs.length; i$8++) s$3 += " " + attrs[i$8].name + "=" + wrapQuotes(quote(attrs[i$8].value), "double", opts);
			s$3 += ">";
			if (obj.childNodes && obj.childNodes.length) s$3 += "...";
			s$3 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
			return s$3;
		}
		if (isArray$10(obj)) {
			if (obj.length === 0) return "[]";
			var xs = arrObjKeys(obj, inspect$5);
			if (indent$1 && !singleLineValues(xs)) return "[" + indentedJoin(xs, indent$1) + "]";
			return "[ " + $join.call(xs, ", ") + " ]";
		}
		if (isError(obj)) {
			var parts = arrObjKeys(obj, inspect$5);
			if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) return "{ [" + String(obj) + "] " + $join.call($concat$1.call("[cause]: " + inspect$5(obj.cause), parts), ", ") + " }";
			if (parts.length === 0) return "[" + String(obj) + "]";
			return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
		}
		if (typeof obj === "object" && customInspect) {
			if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) return utilInspect(obj, { depth: maxDepth - depth });
			else if (customInspect !== "symbol" && typeof obj.inspect === "function") return obj.inspect();
		}
		if (isMap(obj)) {
			var mapParts = [];
			if (mapForEach) mapForEach.call(obj, function(value, key$1) {
				mapParts.push(inspect$5(key$1, obj, true) + " => " + inspect$5(value, obj));
			});
			return collectionOf("Map", mapSize.call(obj), mapParts, indent$1);
		}
		if (isSet(obj)) {
			var setParts = [];
			if (setForEach) setForEach.call(obj, function(value) {
				setParts.push(inspect$5(value, obj));
			});
			return collectionOf("Set", setSize.call(obj), setParts, indent$1);
		}
		if (isWeakMap(obj)) return weakCollectionOf("WeakMap");
		if (isWeakSet(obj)) return weakCollectionOf("WeakSet");
		if (isWeakRef(obj)) return weakCollectionOf("WeakRef");
		if (isNumber(obj)) return markBoxed(inspect$5(Number(obj)));
		if (isBigInt(obj)) return markBoxed(inspect$5(bigIntValueOf.call(obj)));
		if (isBoolean(obj)) return markBoxed(booleanValueOf.call(obj));
		if (isString(obj)) return markBoxed(inspect$5(String(obj)));
		if (typeof window !== "undefined" && obj === window) return "{ [object Window] }";
		if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) return "{ [object globalThis] }";
		if (!isDate$1(obj) && !isRegExp$2(obj)) {
			var ys = arrObjKeys(obj, inspect$5);
			var isPlainObject$3 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
			var protoTag = obj instanceof Object ? "" : "null prototype";
			var stringTag$1 = !isPlainObject$3 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr$1(obj), 8, -1) : protoTag ? "Object" : "";
			var tag = (isPlainObject$3 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "") + (stringTag$1 || protoTag ? "[" + $join.call($concat$1.call([], stringTag$1 || [], protoTag || []), ": ") + "] " : "");
			if (ys.length === 0) return tag + "{}";
			if (indent$1) return tag + "{" + indentedJoin(ys, indent$1) + "}";
			return tag + "{ " + $join.call(ys, ", ") + " }";
		}
		return String(obj);
	};
	function wrapQuotes(s$3, defaultStyle, opts) {
		var quoteChar = quotes[opts.quoteStyle || defaultStyle];
		return quoteChar + s$3 + quoteChar;
	}
	function quote(s$3) {
		return $replace$1.call(String(s$3), /"/g, "&quot;");
	}
	function canTrustToString(obj) {
		return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
	}
	function isArray$10(obj) {
		return toStr$1(obj) === "[object Array]" && canTrustToString(obj);
	}
	function isDate$1(obj) {
		return toStr$1(obj) === "[object Date]" && canTrustToString(obj);
	}
	function isRegExp$2(obj) {
		return toStr$1(obj) === "[object RegExp]" && canTrustToString(obj);
	}
	function isError(obj) {
		return toStr$1(obj) === "[object Error]" && canTrustToString(obj);
	}
	function isString(obj) {
		return toStr$1(obj) === "[object String]" && canTrustToString(obj);
	}
	function isNumber(obj) {
		return toStr$1(obj) === "[object Number]" && canTrustToString(obj);
	}
	function isBoolean(obj) {
		return toStr$1(obj) === "[object Boolean]" && canTrustToString(obj);
	}
	function isSymbol$7(obj) {
		if (hasShammedSymbols) return obj && typeof obj === "object" && obj instanceof Symbol;
		if (typeof obj === "symbol") return true;
		if (!obj || typeof obj !== "object" || !symToString) return false;
		try {
			symToString.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	function isBigInt(obj) {
		if (!obj || typeof obj !== "object" || !bigIntValueOf) return false;
		try {
			bigIntValueOf.call(obj);
			return true;
		} catch (e) {}
		return false;
	}
	var hasOwn$1 = Object.prototype.hasOwnProperty || function(key$1) {
		return key$1 in this;
	};
	function has$6(obj, key$1) {
		return hasOwn$1.call(obj, key$1);
	}
	function toStr$1(obj) {
		return objectToString$3.call(obj);
	}
	function nameOf(f) {
		if (f.name) return f.name;
		var m$3 = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
		if (m$3) return m$3[1];
		return null;
	}
	function indexOf(xs, x) {
		if (xs.indexOf) return xs.indexOf(x);
		for (var i$8 = 0, l = xs.length; i$8 < l; i$8++) if (xs[i$8] === x) return i$8;
		return -1;
	}
	function isMap(x) {
		if (!mapSize || !x || typeof x !== "object") return false;
		try {
			mapSize.call(x);
			try {
				setSize.call(x);
			} catch (s$3) {
				return true;
			}
			return x instanceof Map;
		} catch (e) {}
		return false;
	}
	function isWeakMap(x) {
		if (!weakMapHas || !x || typeof x !== "object") return false;
		try {
			weakMapHas.call(x, weakMapHas);
			try {
				weakSetHas.call(x, weakSetHas);
			} catch (s$3) {
				return true;
			}
			return x instanceof WeakMap;
		} catch (e) {}
		return false;
	}
	function isWeakRef(x) {
		if (!weakRefDeref || !x || typeof x !== "object") return false;
		try {
			weakRefDeref.call(x);
			return true;
		} catch (e) {}
		return false;
	}
	function isSet(x) {
		if (!setSize || !x || typeof x !== "object") return false;
		try {
			setSize.call(x);
			try {
				mapSize.call(x);
			} catch (m$3) {
				return true;
			}
			return x instanceof Set;
		} catch (e) {}
		return false;
	}
	function isWeakSet(x) {
		if (!weakSetHas || !x || typeof x !== "object") return false;
		try {
			weakSetHas.call(x, weakSetHas);
			try {
				weakMapHas.call(x, weakMapHas);
			} catch (s$3) {
				return true;
			}
			return x instanceof WeakSet;
		} catch (e) {}
		return false;
	}
	function isElement(x) {
		if (!x || typeof x !== "object") return false;
		if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) return true;
		return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
	}
	function inspectString(str, opts) {
		if (str.length > opts.maxStringLength) {
			var remaining = str.length - opts.maxStringLength;
			var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
			return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
		}
		var quoteRE = quoteREs[opts.quoteStyle || "single"];
		quoteRE.lastIndex = 0;
		return wrapQuotes($replace$1.call($replace$1.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte), "single", opts);
	}
	function lowbyte(c) {
		var n = c.charCodeAt(0);
		var x = {
			8: "b",
			9: "t",
			10: "n",
			12: "f",
			13: "r"
		}[n];
		if (x) return "\\" + x;
		return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
	}
	function markBoxed(str) {
		return "Object(" + str + ")";
	}
	function weakCollectionOf(type) {
		return type + " { ? }";
	}
	function collectionOf(type, size, entries, indent$1) {
		var joinedEntries = indent$1 ? indentedJoin(entries, indent$1) : $join.call(entries, ", ");
		return type + " (" + size + ") {" + joinedEntries + "}";
	}
	function singleLineValues(xs) {
		for (var i$8 = 0; i$8 < xs.length; i$8++) if (indexOf(xs[i$8], "\n") >= 0) return false;
		return true;
	}
	function getIndent(opts, depth) {
		var baseIndent;
		if (opts.indent === "	") baseIndent = "	";
		else if (typeof opts.indent === "number" && opts.indent > 0) baseIndent = $join.call(Array(opts.indent + 1), " ");
		else return null;
		return {
			base: baseIndent,
			prev: $join.call(Array(depth + 1), baseIndent)
		};
	}
	function indentedJoin(xs, indent$1) {
		if (xs.length === 0) return "";
		var lineJoiner = "\n" + indent$1.prev + indent$1.base;
		return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent$1.prev;
	}
	function arrObjKeys(obj, inspect$5) {
		var isArr = isArray$10(obj);
		var xs = [];
		if (isArr) {
			xs.length = obj.length;
			for (var i$8 = 0; i$8 < obj.length; i$8++) xs[i$8] = has$6(obj, i$8) ? inspect$5(obj[i$8], obj) : "";
		}
		var syms = typeof gOPS === "function" ? gOPS(obj) : [];
		var symMap;
		if (hasShammedSymbols) {
			symMap = {};
			for (var k$7 = 0; k$7 < syms.length; k$7++) symMap["$" + syms[k$7]] = syms[k$7];
		}
		for (var key$1 in obj) {
			if (!has$6(obj, key$1)) continue;
			if (isArr && String(Number(key$1)) === key$1 && key$1 < obj.length) continue;
			if (hasShammedSymbols && symMap["$" + key$1] instanceof Symbol) continue;
			else if ($test.call(/[^\w$]/, key$1)) xs.push(inspect$5(key$1, obj) + ": " + inspect$5(obj[key$1], obj));
			else xs.push(key$1 + ": " + inspect$5(obj[key$1], obj));
		}
		if (typeof gOPS === "function") {
			for (var j$7 = 0; j$7 < syms.length; j$7++) if (isEnumerable.call(obj, syms[j$7])) xs.push("[" + inspect$5(syms[j$7]) + "]: " + inspect$5(obj[syms[j$7]], obj));
		}
		return xs;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js
var require_side_channel_list = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js": ((exports, module) => {
	var inspect$4 = require_object_inspect();
	var $TypeError$5 = require_type();
	/** @type {import('./list.d.ts').listGetNode} */
	var listGetNode = function(list, key$1, isDelete) {
		/** @type {typeof list | NonNullable<(typeof list)['next']>} */
		var prev = list;
		/** @type {(typeof list)['next']} */
		var curr;
		for (; (curr = prev.next) != null; prev = curr) if (curr.key === key$1) {
			prev.next = curr.next;
			if (!isDelete) {
				curr.next = list.next;
				list.next = curr;
			}
			return curr;
		}
	};
	/** @type {import('./list.d.ts').listGet} */
	var listGet = function(objects, key$1) {
		if (!objects) return;
		var node$1 = listGetNode(objects, key$1);
		return node$1 && node$1.value;
	};
	/** @type {import('./list.d.ts').listSet} */
	var listSet = function(objects, key$1, value) {
		var node$1 = listGetNode(objects, key$1);
		if (node$1) node$1.value = value;
		else objects.next = {
			key: key$1,
			next: objects.next,
			value
		};
	};
	/** @type {import('./list.d.ts').listHas} */
	var listHas = function(objects, key$1) {
		if (!objects) return false;
		return !!listGetNode(objects, key$1);
	};
	/** @type {import('./list.d.ts').listDelete} */
	var listDelete = function(objects, key$1) {
		if (objects) return listGetNode(objects, key$1, true);
	};
	/** @type {import('.')} */
	module.exports = function getSideChannelList$1() {
		/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;
		/** @type {Channel} */
		var channel$5 = {
			assert: function(key$1) {
				if (!channel$5.has(key$1)) throw new $TypeError$5("Side channel does not contain " + inspect$4(key$1));
			},
			"delete": function(key$1) {
				var root$3 = $o && $o.next;
				var deletedNode = listDelete($o, key$1);
				if (deletedNode && root$3 && root$3 === deletedNode) $o = void 0;
				return !!deletedNode;
			},
			get: function(key$1) {
				return listGet($o, key$1);
			},
			has: function(key$1) {
				return listHas($o, key$1);
			},
			set: function(key$1, value) {
				if (!$o) $o = { next: void 0 };
				listSet($o, key$1, value);
			}
		};
		return channel$5;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js": ((exports, module) => {
	/** @type {import('.')} */
	module.exports = Object;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js": ((exports, module) => {
	/** @type {import('.')} */
	module.exports = Error;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js": ((exports, module) => {
	/** @type {import('./eval')} */
	module.exports = EvalError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js": ((exports, module) => {
	/** @type {import('./range')} */
	module.exports = RangeError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js": ((exports, module) => {
	/** @type {import('./ref')} */
	module.exports = ReferenceError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js": ((exports, module) => {
	/** @type {import('./syntax')} */
	module.exports = SyntaxError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js": ((exports, module) => {
	/** @type {import('./uri')} */
	module.exports = URIError;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js": ((exports, module) => {
	/** @type {import('./abs')} */
	module.exports = Math.abs;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js": ((exports, module) => {
	/** @type {import('./floor')} */
	module.exports = Math.floor;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js": ((exports, module) => {
	/** @type {import('./max')} */
	module.exports = Math.max;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js": ((exports, module) => {
	/** @type {import('./min')} */
	module.exports = Math.min;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js": ((exports, module) => {
	/** @type {import('./pow')} */
	module.exports = Math.pow;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js": ((exports, module) => {
	/** @type {import('./round')} */
	module.exports = Math.round;
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js": ((exports, module) => {
	/** @type {import('./isNaN')} */
	module.exports = Number.isNaN || function isNaN$1(a) {
		return a !== a;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js": ((exports, module) => {
	var $isNaN = require_isNaN();
	/** @type {import('./sign')} */
	module.exports = function sign$2(number) {
		if ($isNaN(number) || number === 0) return number;
		return number < 0 ? -1 : 1;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js": ((exports, module) => {
	/** @type {import('./gOPD')} */
	module.exports = Object.getOwnPropertyDescriptor;
}) });

//#endregion
//#region ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js": ((exports, module) => {
	/** @type {import('.')} */
	var $gOPD$1 = require_gOPD();
	if ($gOPD$1) try {
		$gOPD$1([], "length");
	} catch (e) {
		$gOPD$1 = null;
	}
	module.exports = $gOPD$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js": ((exports, module) => {
	/** @type {import('.')} */
	var $defineProperty$8 = Object.defineProperty || false;
	if ($defineProperty$8) try {
		$defineProperty$8({}, "a", { value: 1 });
	} catch (e) {
		$defineProperty$8 = false;
	}
	module.exports = $defineProperty$8;
}) });

//#endregion
//#region ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js": ((exports, module) => {
	/** @type {import('./shams')} */
	module.exports = function hasSymbols$1() {
		if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") return false;
		if (typeof Symbol.iterator === "symbol") return true;
		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol("test");
		var symObj = Object(sym);
		if (typeof sym === "string") return false;
		if (Object.prototype.toString.call(sym) !== "[object Symbol]") return false;
		if (Object.prototype.toString.call(symObj) !== "[object Symbol]") return false;
		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) return false;
		if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) return false;
		if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) return false;
		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) return false;
		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
		if (typeof Object.getOwnPropertyDescriptor === "function") {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
		}
		return true;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js": ((exports, module) => {
	var origSymbol = typeof Symbol !== "undefined" && Symbol;
	var hasSymbolSham = require_shams();
	/** @type {import('.')} */
	module.exports = function hasNativeSymbols() {
		if (typeof origSymbol !== "function") return false;
		if (typeof Symbol !== "function") return false;
		if (typeof origSymbol("foo") !== "symbol") return false;
		if (typeof Symbol("bar") !== "symbol") return false;
		return hasSymbolSham();
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js": ((exports, module) => {
	/** @type {import('./Reflect.getPrototypeOf')} */
	module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
}) });

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js": ((exports, module) => {
	var $Object$9 = require_es_object_atoms();
	/** @type {import('./Object.getPrototypeOf')} */
	module.exports = $Object$9.getPrototypeOf || null;
}) });

//#endregion
//#region ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js": ((exports, module) => {
	var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
	var toStr = Object.prototype.toString;
	var max$8 = Math.max;
	var funcType = "[object Function]";
	var concatty = function concatty$1(a, b) {
		var arr = [];
		for (var i$8 = 0; i$8 < a.length; i$8 += 1) arr[i$8] = a[i$8];
		for (var j$7 = 0; j$7 < b.length; j$7 += 1) arr[j$7 + a.length] = b[j$7];
		return arr;
	};
	var slicy = function slicy$1(arrLike, offset) {
		var arr = [];
		for (var i$8 = offset || 0, j$7 = 0; i$8 < arrLike.length; i$8 += 1, j$7 += 1) arr[j$7] = arrLike[i$8];
		return arr;
	};
	var joiny = function(arr, joiner) {
		var str = "";
		for (var i$8 = 0; i$8 < arr.length; i$8 += 1) {
			str += arr[i$8];
			if (i$8 + 1 < arr.length) str += joiner;
		}
		return str;
	};
	module.exports = function bind$4(that) {
		var target = this;
		if (typeof target !== "function" || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
		var args = slicy(arguments, 1);
		var bound;
		var binder = function() {
			if (this instanceof bound) {
				var result = target.apply(this, concatty(args, arguments));
				if (Object(result) === result) return result;
				return this;
			}
			return target.apply(that, concatty(args, arguments));
		};
		var boundLength = max$8(0, target.length - args.length);
		var boundArgs = [];
		for (var i$8 = 0; i$8 < boundLength; i$8++) boundArgs[i$8] = "$" + i$8;
		bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
		if (target.prototype) {
			var Empty$7 = function Empty$8() {};
			Empty$7.prototype = target.prototype;
			bound.prototype = new Empty$7();
			Empty$7.prototype = null;
		}
		return bound;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js": ((exports, module) => {
	var implementation = require_implementation();
	module.exports = Function.prototype.bind || implementation;
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js": ((exports, module) => {
	/** @type {import('./functionCall')} */
	module.exports = Function.prototype.call;
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js": ((exports, module) => {
	/** @type {import('./functionApply')} */
	module.exports = Function.prototype.apply;
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js": ((exports, module) => {
	/** @type {import('./reflectApply')} */
	module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js": ((exports, module) => {
	var bind$3 = require_function_bind();
	var $apply$1 = require_functionApply();
	var $call$2 = require_functionCall();
	var $reflectApply = require_reflectApply();
	/** @type {import('./actualApply')} */
	module.exports = $reflectApply || bind$3.call($call$2, $apply$1);
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js": ((exports, module) => {
	var bind$2 = require_function_bind();
	var $TypeError$4 = require_type();
	var $call$1 = require_functionCall();
	var $actualApply = require_actualApply();
	/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
	module.exports = function callBindBasic$1(args) {
		if (args.length < 1 || typeof args[0] !== "function") throw new $TypeError$4("a function is required");
		return $actualApply(bind$2, $call$1, args);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js": ((exports, module) => {
	var callBind = require_call_bind_apply_helpers();
	var gOPD$11 = require_gopd();
	var hasProtoAccessor;
	try {
		hasProtoAccessor = [].__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") throw e;
	}
	var desc = !!hasProtoAccessor && gOPD$11 && gOPD$11(Object.prototype, "__proto__");
	var $Object$13 = Object;
	var $getPrototypeOf = $Object$13.getPrototypeOf;
	/** @type {import('./get')} */
	module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
		return $getPrototypeOf(value == null ? value : $Object$13(value));
	} : false;
}) });

//#endregion
//#region ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js": ((exports, module) => {
	var reflectGetProto = require_Reflect_getPrototypeOf();
	var originalGetProto = require_Object_getPrototypeOf();
	var getDunderProto = require_get();
	/** @type {import('.')} */
	module.exports = reflectGetProto ? function getProto$1(O) {
		return reflectGetProto(O);
	} : originalGetProto ? function getProto$1(O) {
		if (!O || typeof O !== "object" && typeof O !== "function") throw new TypeError("getProto: not an object");
		return originalGetProto(O);
	} : getDunderProto ? function getProto$1(O) {
		return getDunderProto(O);
	} : null;
}) });

//#endregion
//#region ../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js": ((exports, module) => {
	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind$1 = require_function_bind();
	/** @type {import('.')} */
	module.exports = bind$1.call(call, $hasOwn);
}) });

//#endregion
//#region ../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js": ((exports, module) => {
	var undefined$1;
	var $Object$12 = require_es_object_atoms();
	var $Error = require_es_errors();
	var $EvalError = require_eval();
	var $RangeError = require_range();
	var $ReferenceError = require_ref();
	var $SyntaxError = require_syntax();
	var $TypeError$3 = require_type();
	var $URIError = require_uri();
	var abs = require_abs();
	var floor$7 = require_floor();
	var max$7 = require_max();
	var min$11 = require_min();
	var pow = require_pow();
	var round = require_round();
	var sign$1 = require_sign();
	var $Function = Function;
	var getEvalledConstructor = function(expressionSyntax) {
		try {
			return $Function("\"use strict\"; return (" + expressionSyntax + ").constructor;")();
		} catch (e) {}
	};
	var $gOPD = require_gopd();
	var $defineProperty$7 = require_es_define_property();
	var throwTypeError = function() {
		throw new $TypeError$3();
	};
	var ThrowTypeError = $gOPD ? function() {
		try {
			arguments.callee;
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				return $gOPD(arguments, "callee").get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}() : throwTypeError;
	var hasSymbols = require_has_symbols()();
	var getProto = require_get_proto();
	var $ObjectGPO = require_Object_getPrototypeOf();
	var $ReflectGPO = require_Reflect_getPrototypeOf();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var needsEval = {};
	var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
	var INTRINSICS = {
		__proto__: null,
		"%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
		"%Array%": Array,
		"%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
		"%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
		"%AsyncFromSyncIteratorPrototype%": undefined$1,
		"%AsyncFunction%": needsEval,
		"%AsyncGenerator%": needsEval,
		"%AsyncGeneratorFunction%": needsEval,
		"%AsyncIteratorPrototype%": needsEval,
		"%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
		"%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
		"%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
		"%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
		"%Boolean%": Boolean,
		"%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
		"%Date%": Date,
		"%decodeURI%": decodeURI,
		"%decodeURIComponent%": decodeURIComponent,
		"%encodeURI%": encodeURI,
		"%encodeURIComponent%": encodeURIComponent,
		"%Error%": $Error,
		"%eval%": eval,
		"%EvalError%": $EvalError,
		"%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
		"%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
		"%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
		"%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
		"%Function%": $Function,
		"%GeneratorFunction%": needsEval,
		"%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
		"%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
		"%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
		"%isFinite%": isFinite,
		"%isNaN%": isNaN,
		"%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		"%JSON%": typeof JSON === "object" ? JSON : undefined$1,
		"%Map%": typeof Map === "undefined" ? undefined$1 : Map,
		"%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
		"%Math%": Math,
		"%Number%": Number,
		"%Object%": $Object$12,
		"%Object.getOwnPropertyDescriptor%": $gOPD,
		"%parseFloat%": parseFloat,
		"%parseInt%": parseInt,
		"%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
		"%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
		"%RangeError%": $RangeError,
		"%ReferenceError%": $ReferenceError,
		"%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
		"%RegExp%": RegExp,
		"%Set%": typeof Set === "undefined" ? undefined$1 : Set,
		"%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
		"%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
		"%String%": String,
		"%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
		"%Symbol%": hasSymbols ? Symbol : undefined$1,
		"%SyntaxError%": $SyntaxError,
		"%ThrowTypeError%": ThrowTypeError,
		"%TypedArray%": TypedArray,
		"%TypeError%": $TypeError$3,
		"%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
		"%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
		"%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
		"%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
		"%URIError%": $URIError,
		"%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
		"%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
		"%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
		"%Function.prototype.call%": $call,
		"%Function.prototype.apply%": $apply,
		"%Object.defineProperty%": $defineProperty$7,
		"%Object.getPrototypeOf%": $ObjectGPO,
		"%Math.abs%": abs,
		"%Math.floor%": floor$7,
		"%Math.max%": max$7,
		"%Math.min%": min$11,
		"%Math.pow%": pow,
		"%Math.round%": round,
		"%Math.sign%": sign$1,
		"%Reflect.getPrototypeOf%": $ReflectGPO
	};
	if (getProto) try {
		null.error;
	} catch (e) {
		INTRINSICS["%Error.prototype%"] = getProto(getProto(e));
	}
	var doEval = function doEval$1(name) {
		var value;
		if (name === "%AsyncFunction%") value = getEvalledConstructor("async function () {}");
		else if (name === "%GeneratorFunction%") value = getEvalledConstructor("function* () {}");
		else if (name === "%AsyncGeneratorFunction%") value = getEvalledConstructor("async function* () {}");
		else if (name === "%AsyncGenerator%") {
			var fn = doEval$1("%AsyncGeneratorFunction%");
			if (fn) value = fn.prototype;
		} else if (name === "%AsyncIteratorPrototype%") {
			var gen = doEval$1("%AsyncGenerator%");
			if (gen && getProto) value = getProto(gen.prototype);
		}
		INTRINSICS[name] = value;
		return value;
	};
	var LEGACY_ALIASES = {
		__proto__: null,
		"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
		"%ArrayPrototype%": ["Array", "prototype"],
		"%ArrayProto_entries%": [
			"Array",
			"prototype",
			"entries"
		],
		"%ArrayProto_forEach%": [
			"Array",
			"prototype",
			"forEach"
		],
		"%ArrayProto_keys%": [
			"Array",
			"prototype",
			"keys"
		],
		"%ArrayProto_values%": [
			"Array",
			"prototype",
			"values"
		],
		"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
		"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
		"%AsyncGeneratorPrototype%": [
			"AsyncGeneratorFunction",
			"prototype",
			"prototype"
		],
		"%BooleanPrototype%": ["Boolean", "prototype"],
		"%DataViewPrototype%": ["DataView", "prototype"],
		"%DatePrototype%": ["Date", "prototype"],
		"%ErrorPrototype%": ["Error", "prototype"],
		"%EvalErrorPrototype%": ["EvalError", "prototype"],
		"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
		"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
		"%FunctionPrototype%": ["Function", "prototype"],
		"%Generator%": ["GeneratorFunction", "prototype"],
		"%GeneratorPrototype%": [
			"GeneratorFunction",
			"prototype",
			"prototype"
		],
		"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
		"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
		"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
		"%JSONParse%": ["JSON", "parse"],
		"%JSONStringify%": ["JSON", "stringify"],
		"%MapPrototype%": ["Map", "prototype"],
		"%NumberPrototype%": ["Number", "prototype"],
		"%ObjectPrototype%": ["Object", "prototype"],
		"%ObjProto_toString%": [
			"Object",
			"prototype",
			"toString"
		],
		"%ObjProto_valueOf%": [
			"Object",
			"prototype",
			"valueOf"
		],
		"%PromisePrototype%": ["Promise", "prototype"],
		"%PromiseProto_then%": [
			"Promise",
			"prototype",
			"then"
		],
		"%Promise_all%": ["Promise", "all"],
		"%Promise_reject%": ["Promise", "reject"],
		"%Promise_resolve%": ["Promise", "resolve"],
		"%RangeErrorPrototype%": ["RangeError", "prototype"],
		"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
		"%RegExpPrototype%": ["RegExp", "prototype"],
		"%SetPrototype%": ["Set", "prototype"],
		"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
		"%StringPrototype%": ["String", "prototype"],
		"%SymbolPrototype%": ["Symbol", "prototype"],
		"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
		"%TypedArrayPrototype%": ["TypedArray", "prototype"],
		"%TypeErrorPrototype%": ["TypeError", "prototype"],
		"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
		"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
		"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
		"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
		"%URIErrorPrototype%": ["URIError", "prototype"],
		"%WeakMapPrototype%": ["WeakMap", "prototype"],
		"%WeakSetPrototype%": ["WeakSet", "prototype"]
	};
	var bind = require_function_bind();
	var hasOwn = require_hasown();
	var $concat = bind.call($call, Array.prototype.concat);
	var $spliceApply = bind.call($apply, Array.prototype.splice);
	var $replace = bind.call($call, String.prototype.replace);
	var $strSlice = bind.call($call, String.prototype.slice);
	var $exec = bind.call($call, RegExp.prototype.exec);
	var rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar$1 = /\\(\\)?/g;
	var stringToPath$1 = function stringToPath$2(string) {
		var first$3 = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first$3 === "%" && last !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
		else if (last === "%" && first$3 !== "%") throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
		var result = [];
		$replace(string, rePropName$1, function(match$1, number, quote$1, subString) {
			result[result.length] = quote$1 ? $replace(subString, reEscapeChar$1, "$1") : number || match$1;
		});
		return result;
	};
	var getBaseIntrinsic = function getBaseIntrinsic$1(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = "%" + alias[0] + "%";
		}
		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) value = doEval(intrinsicName);
			if (typeof value === "undefined" && !allowMissing) throw new $TypeError$3("intrinsic " + name + " exists, but is not available. Please file an issue!");
			return {
				alias,
				name: intrinsicName,
				value
			};
		}
		throw new $SyntaxError("intrinsic " + name + " does not exist!");
	};
	module.exports = function GetIntrinsic$3(name, allowMissing) {
		if (typeof name !== "string" || name.length === 0) throw new $TypeError$3("intrinsic name must be a non-empty string");
		if (arguments.length > 1 && typeof allowMissing !== "boolean") throw new $TypeError$3("\"allowMissing\" argument must be a boolean");
		if ($exec(/^%?[^%]*%?$/, name) === null) throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
		var parts = stringToPath$1(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
		var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;
		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}
		for (var i$8 = 1, isOwn = true; i$8 < parts.length; i$8 += 1) {
			var part = parts[i$8];
			var first$3 = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if ((first$3 === "\"" || first$3 === "'" || first$3 === "`" || last === "\"" || last === "'" || last === "`") && first$3 !== last) throw new $SyntaxError("property names with quotes must have matching quotes");
			if (part === "constructor" || !isOwn) skipFurtherCaching = true;
			intrinsicBaseName += "." + part;
			intrinsicRealName = "%" + intrinsicBaseName + "%";
			if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
			else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) throw new $TypeError$3("base intrinsic for " + name + " exists, but the property is not available.");
					return;
				}
				if ($gOPD && i$8 + 1 >= parts.length) {
					var desc$1 = $gOPD(value, part);
					isOwn = !!desc$1;
					if (isOwn && "get" in desc$1 && !("originalValue" in desc$1.get)) value = desc$1.get;
					else value = value[part];
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}
				if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
			}
		}
		return value;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js
var require_call_bound = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js": ((exports, module) => {
	var GetIntrinsic$2 = require_get_intrinsic();
	var callBindBasic = require_call_bind_apply_helpers();
	/** @type {(thisArg: string, searchString: string, position?: number) => number} */
	var $indexOf = callBindBasic([GetIntrinsic$2("%String.prototype.indexOf%")]);
	/** @type {import('.')} */
	module.exports = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic$2(name, !!allowMissing);
		if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) return callBindBasic([intrinsic]);
		return intrinsic;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js
var require_side_channel_map = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js": ((exports, module) => {
	var GetIntrinsic$1 = require_get_intrinsic();
	var callBound$1 = require_call_bound();
	var inspect$3 = require_object_inspect();
	var $TypeError$2 = require_type();
	var $Map = GetIntrinsic$1("%Map%", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
	var $mapGet = callBound$1("Map.prototype.get", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
	var $mapSet = callBound$1("Map.prototype.set", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapHas = callBound$1("Map.prototype.has", true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapDelete = callBound$1("Map.prototype.delete", true);
	/** @type {<K, V>(thisArg: Map<K, V>) => number} */
	var $mapSize = callBound$1("Map.prototype.size", true);
	/** @type {import('.')} */
	module.exports = !!$Map && function getSideChannelMap$2() {
		/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {Map<K, V> | undefined} */ var $m;
		/** @type {Channel} */
		var channel$5 = {
			assert: function(key$1) {
				if (!channel$5.has(key$1)) throw new $TypeError$2("Side channel does not contain " + inspect$3(key$1));
			},
			"delete": function(key$1) {
				if ($m) {
					var result = $mapDelete($m, key$1);
					if ($mapSize($m) === 0) $m = void 0;
					return result;
				}
				return false;
			},
			get: function(key$1) {
				if ($m) return $mapGet($m, key$1);
			},
			has: function(key$1) {
				if ($m) return $mapHas($m, key$1);
				return false;
			},
			set: function(key$1, value) {
				if (!$m) $m = new $Map();
				$mapSet($m, key$1, value);
			}
		};
		return channel$5;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js": ((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var callBound = require_call_bound();
	var inspect$2 = require_object_inspect();
	var getSideChannelMap$1 = require_side_channel_map();
	var $TypeError$1 = require_type();
	var $WeakMap = GetIntrinsic("%WeakMap%", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
	var $weakMapGet = callBound("WeakMap.prototype.get", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
	var $weakMapSet = callBound("WeakMap.prototype.set", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapHas = callBound("WeakMap.prototype.has", true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
	/** @type {import('.')} */
	module.exports = $WeakMap ? function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */
		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;
		/** @type {Channel} */
		var channel$5 = {
			assert: function(key$1) {
				if (!channel$5.has(key$1)) throw new $TypeError$1("Side channel does not contain " + inspect$2(key$1));
			},
			"delete": function(key$1) {
				if ($WeakMap && key$1 && (typeof key$1 === "object" || typeof key$1 === "function")) {
					if ($wm) return $weakMapDelete($wm, key$1);
				} else if (getSideChannelMap$1) {
					if ($m) return $m["delete"](key$1);
				}
				return false;
			},
			get: function(key$1) {
				if ($WeakMap && key$1 && (typeof key$1 === "object" || typeof key$1 === "function")) {
					if ($wm) return $weakMapGet($wm, key$1);
				}
				return $m && $m.get(key$1);
			},
			has: function(key$1) {
				if ($WeakMap && key$1 && (typeof key$1 === "object" || typeof key$1 === "function")) {
					if ($wm) return $weakMapHas($wm, key$1);
				}
				return !!$m && $m.has(key$1);
			},
			set: function(key$1, value) {
				if ($WeakMap && key$1 && (typeof key$1 === "object" || typeof key$1 === "function")) {
					if (!$wm) $wm = new $WeakMap();
					$weakMapSet($wm, key$1, value);
				} else if (getSideChannelMap$1) {
					if (!$m) $m = getSideChannelMap$1();
					/** @type {NonNullable<typeof $m>} */ $m.set(key$1, value);
				}
			}
		};
		return channel$5;
	} : getSideChannelMap$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js
var require_side_channel = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js": ((exports, module) => {
	var $TypeError = require_type();
	var inspect$1 = require_object_inspect();
	var getSideChannelList = require_side_channel_list();
	var getSideChannelMap = require_side_channel_map();
	var makeChannel = require_side_channel_weakmap() || getSideChannelMap || getSideChannelList;
	/** @type {import('.')} */
	module.exports = function getSideChannel$2() {
		/** @typedef {ReturnType<typeof getSideChannel>} Channel */
		/** @type {Channel | undefined} */ var $channelData;
		/** @type {Channel} */
		var channel$5 = {
			assert: function(key$1) {
				if (!channel$5.has(key$1)) throw new $TypeError("Side channel does not contain " + inspect$1(key$1));
			},
			"delete": function(key$1) {
				return !!$channelData && $channelData["delete"](key$1);
			},
			get: function(key$1) {
				return $channelData && $channelData.get(key$1);
			},
			has: function(key$1) {
				return !!$channelData && $channelData.has(key$1);
			},
			set: function(key$1, value) {
				if (!$channelData) $channelData = makeChannel();
				$channelData.set(key$1, value);
			}
		};
		return channel$5;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/formats.js
var require_formats$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/formats.js": ((exports, module) => {
	var replace$1 = String.prototype.replace;
	var percentTwenties$1 = /%20/g;
	var Format$1 = {
		RFC1738: "RFC1738",
		RFC3986: "RFC3986"
	};
	module.exports = {
		"default": Format$1.RFC3986,
		formatters: {
			RFC1738: function(value) {
				return replace$1.call(value, percentTwenties$1, "+");
			},
			RFC3986: function(value) {
				return String(value);
			}
		},
		RFC1738: Format$1.RFC1738,
		RFC3986: Format$1.RFC3986
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/utils.js
var require_utils$4 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/utils.js": ((exports, module) => {
	var formats$5 = require_formats$1();
	var has$5 = Object.prototype.hasOwnProperty;
	var isArray$9 = Array.isArray;
	var hexTable$1 = function() {
		var array = [];
		for (var i$8 = 0; i$8 < 256; ++i$8) array.push("%" + ((i$8 < 16 ? "0" : "") + i$8.toString(16)).toUpperCase());
		return array;
	}();
	var compactQueue$1 = function compactQueue$2(queue$5) {
		while (queue$5.length > 1) {
			var item = queue$5.pop();
			var obj = item.obj[item.prop];
			if (isArray$9(obj)) {
				var compacted = [];
				for (var j$7 = 0; j$7 < obj.length; ++j$7) if (typeof obj[j$7] !== "undefined") compacted.push(obj[j$7]);
				item.obj[item.prop] = compacted;
			}
		}
	};
	var arrayToObject$1 = function arrayToObject$2(source, options) {
		var obj = options && options.plainObjects ? { __proto__: null } : {};
		for (var i$8 = 0; i$8 < source.length; ++i$8) if (typeof source[i$8] !== "undefined") obj[i$8] = source[i$8];
		return obj;
	};
	var merge$5 = function merge$6(target, source, options) {
		if (!source) return target;
		if (typeof source !== "object" && typeof source !== "function") {
			if (isArray$9(target)) target.push(source);
			else if (target && typeof target === "object") {
				if (options && (options.plainObjects || options.allowPrototypes) || !has$5.call(Object.prototype, source)) target[source] = true;
			} else return [target, source];
			return target;
		}
		if (!target || typeof target !== "object") return [target].concat(source);
		var mergeTarget = target;
		if (isArray$9(target) && !isArray$9(source)) mergeTarget = arrayToObject$1(target, options);
		if (isArray$9(target) && isArray$9(source)) {
			source.forEach(function(item, i$8) {
				if (has$5.call(target, i$8)) {
					var targetItem = target[i$8];
					if (targetItem && typeof targetItem === "object" && item && typeof item === "object") target[i$8] = merge$6(targetItem, item, options);
					else target.push(item);
				} else target[i$8] = item;
			});
			return target;
		}
		return Object.keys(source).reduce(function(acc, key$1) {
			var value = source[key$1];
			if (has$5.call(acc, key$1)) acc[key$1] = merge$6(acc[key$1], value, options);
			else acc[key$1] = value;
			return acc;
		}, mergeTarget);
	};
	var assign$2 = function assignSingleSource(target, source) {
		return Object.keys(source).reduce(function(acc, key$1) {
			acc[key$1] = source[key$1];
			return acc;
		}, target);
	};
	var decode$3 = function(str, defaultDecoder, charset$1) {
		var strWithoutPlus = str.replace(/\+/g, " ");
		if (charset$1 === "iso-8859-1") return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
		try {
			return decodeURIComponent(strWithoutPlus);
		} catch (e) {
			return strWithoutPlus;
		}
	};
	var limit$1 = 1024;
	var encode$1 = function encode$3(str, defaultEncoder, charset$1, kind, format$6) {
		if (str.length === 0) return str;
		var string = str;
		if (typeof str === "symbol") string = Symbol.prototype.toString.call(str);
		else if (typeof str !== "string") string = String(str);
		if (charset$1 === "iso-8859-1") return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
			return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
		});
		var out = "";
		for (var j$7 = 0; j$7 < string.length; j$7 += limit$1) {
			var segment = string.length >= limit$1 ? string.slice(j$7, j$7 + limit$1) : string;
			var arr = [];
			for (var i$8 = 0; i$8 < segment.length; ++i$8) {
				var c = segment.charCodeAt(i$8);
				if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format$6 === formats$5.RFC1738 && (c === 40 || c === 41)) {
					arr[arr.length] = segment.charAt(i$8);
					continue;
				}
				if (c < 128) {
					arr[arr.length] = hexTable$1[c];
					continue;
				}
				if (c < 2048) {
					arr[arr.length] = hexTable$1[192 | c >> 6] + hexTable$1[128 | c & 63];
					continue;
				}
				if (c < 55296 || c >= 57344) {
					arr[arr.length] = hexTable$1[224 | c >> 12] + hexTable$1[128 | c >> 6 & 63] + hexTable$1[128 | c & 63];
					continue;
				}
				i$8 += 1;
				c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i$8) & 1023);
				arr[arr.length] = hexTable$1[240 | c >> 18] + hexTable$1[128 | c >> 12 & 63] + hexTable$1[128 | c >> 6 & 63] + hexTable$1[128 | c & 63];
			}
			out += arr.join("");
		}
		return out;
	};
	var compact$1 = function compact$2(value) {
		var queue$5 = [{
			obj: { o: value },
			prop: "o"
		}];
		var refs = [];
		for (var i$8 = 0; i$8 < queue$5.length; ++i$8) {
			var item = queue$5[i$8];
			var obj = item.obj[item.prop];
			var keys$6 = Object.keys(obj);
			for (var j$7 = 0; j$7 < keys$6.length; ++j$7) {
				var key$1 = keys$6[j$7];
				var val = obj[key$1];
				if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
					queue$5.push({
						obj,
						prop: key$1
					});
					refs.push(val);
				}
			}
		}
		compactQueue$1(queue$5);
		return value;
	};
	var isRegExp$1 = function isRegExp$3(obj) {
		return Object.prototype.toString.call(obj) === "[object RegExp]";
	};
	var isBuffer$2 = function isBuffer$3(obj) {
		if (!obj || typeof obj !== "object") return false;
		return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};
	var combine$1 = function combine$2(a, b) {
		return [].concat(a, b);
	};
	var maybeMap$1 = function maybeMap$2(val, fn) {
		if (isArray$9(val)) {
			var mapped = [];
			for (var i$8 = 0; i$8 < val.length; i$8 += 1) mapped.push(fn(val[i$8]));
			return mapped;
		}
		return fn(val);
	};
	module.exports = {
		arrayToObject: arrayToObject$1,
		assign: assign$2,
		combine: combine$1,
		compact: compact$1,
		decode: decode$3,
		encode: encode$1,
		isBuffer: isBuffer$2,
		isRegExp: isRegExp$1,
		maybeMap: maybeMap$1,
		merge: merge$5
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/stringify.js
var require_stringify$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/stringify.js": ((exports, module) => {
	var getSideChannel$1 = require_side_channel();
	var utils$9 = require_utils$4();
	var formats$4 = require_formats$1();
	var has$4 = Object.prototype.hasOwnProperty;
	var arrayPrefixGenerators$1 = {
		brackets: function brackets(prefix) {
			return prefix + "[]";
		},
		comma: "comma",
		indices: function indices(prefix, key$1) {
			return prefix + "[" + key$1 + "]";
		},
		repeat: function repeat(prefix) {
			return prefix;
		}
	};
	var isArray$8 = Array.isArray;
	var push$1 = Array.prototype.push;
	var pushToArray$1 = function(arr, valueOrArray) {
		push$1.apply(arr, isArray$8(valueOrArray) ? valueOrArray : [valueOrArray]);
	};
	var toISO$1 = Date.prototype.toISOString;
	var defaultFormat$1 = formats$4["default"];
	var defaults$4 = {
		addQueryPrefix: false,
		allowDots: false,
		allowEmptyArrays: false,
		arrayFormat: "indices",
		charset: "utf-8",
		charsetSentinel: false,
		commaRoundTrip: false,
		delimiter: "&",
		encode: true,
		encodeDotInKeys: false,
		encoder: utils$9.encode,
		encodeValuesOnly: false,
		filter: void 0,
		format: defaultFormat$1,
		formatter: formats$4.formatters[defaultFormat$1],
		indices: false,
		serializeDate: function serializeDate(date) {
			return toISO$1.call(date);
		},
		skipNulls: false,
		strictNullHandling: false
	};
	var isNonNullishPrimitive$1 = function isNonNullishPrimitive$2(v) {
		return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
	};
	var sentinel$1 = {};
	var stringify$13 = function stringify$14(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format$6, formatter, encodeValuesOnly, charset$1, sideChannel) {
		var obj = object;
		var tmpSc = sideChannel;
		var step = 0;
		var findFlag = false;
		while ((tmpSc = tmpSc.get(sentinel$1)) !== void 0 && !findFlag) {
			var pos = tmpSc.get(object);
			step += 1;
			if (typeof pos !== "undefined") if (pos === step) throw new RangeError("Cyclic object value");
			else findFlag = true;
			if (typeof tmpSc.get(sentinel$1) === "undefined") step = 0;
		}
		if (typeof filter === "function") obj = filter(prefix, obj);
		else if (obj instanceof Date) obj = serializeDate(obj);
		else if (generateArrayPrefix === "comma" && isArray$8(obj)) obj = utils$9.maybeMap(obj, function(value$1) {
			if (value$1 instanceof Date) return serializeDate(value$1);
			return value$1;
		});
		if (obj === null) {
			if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults$4.encoder, charset$1, "key", format$6) : prefix;
			obj = "";
		}
		if (isNonNullishPrimitive$1(obj) || utils$9.isBuffer(obj)) {
			if (encoder) return [formatter(encodeValuesOnly ? prefix : encoder(prefix, defaults$4.encoder, charset$1, "key", format$6)) + "=" + formatter(encoder(obj, defaults$4.encoder, charset$1, "value", format$6))];
			return [formatter(prefix) + "=" + formatter(String(obj))];
		}
		var values = [];
		if (typeof obj === "undefined") return values;
		var objKeys;
		if (generateArrayPrefix === "comma" && isArray$8(obj)) {
			if (encodeValuesOnly && encoder) obj = utils$9.maybeMap(obj, encoder);
			objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
		} else if (isArray$8(filter)) objKeys = filter;
		else {
			var keys$6 = Object.keys(obj);
			objKeys = sort ? keys$6.sort(sort) : keys$6;
		}
		var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
		var adjustedPrefix = commaRoundTrip && isArray$8(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
		if (allowEmptyArrays && isArray$8(obj) && obj.length === 0) return adjustedPrefix + "[]";
		for (var j$7 = 0; j$7 < objKeys.length; ++j$7) {
			var key$1 = objKeys[j$7];
			var value = typeof key$1 === "object" && key$1 && typeof key$1.value !== "undefined" ? key$1.value : obj[key$1];
			if (skipNulls && value === null) continue;
			var encodedKey = allowDots && encodeDotInKeys ? String(key$1).replace(/\./g, "%2E") : String(key$1);
			var keyPrefix = isArray$8(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
			sideChannel.set(object, step);
			var valueSideChannel = getSideChannel$1();
			valueSideChannel.set(sentinel$1, sideChannel);
			pushToArray$1(values, stringify$14(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray$8(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format$6, formatter, encodeValuesOnly, charset$1, valueSideChannel));
		}
		return values;
	};
	var normalizeStringifyOptions$1 = function normalizeStringifyOptions$2(opts) {
		if (!opts) return defaults$4;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") throw new TypeError("Encoder has to be a function.");
		var charset$1 = opts.charset || defaults$4.charset;
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		var format$6 = formats$4["default"];
		if (typeof opts.format !== "undefined") {
			if (!has$4.call(formats$4.formatters, opts.format)) throw new TypeError("Unknown format option provided.");
			format$6 = opts.format;
		}
		var formatter = formats$4.formatters[format$6];
		var filter = defaults$4.filter;
		if (typeof opts.filter === "function" || isArray$8(opts.filter)) filter = opts.filter;
		var arrayFormat$1;
		if (opts.arrayFormat in arrayPrefixGenerators$1) arrayFormat$1 = opts.arrayFormat;
		else if ("indices" in opts) arrayFormat$1 = opts.indices ? "indices" : "repeat";
		else arrayFormat$1 = defaults$4.arrayFormat;
		if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
		var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults$4.allowDots : !!opts.allowDots;
		return {
			addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$4.addQueryPrefix,
			allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$4.allowEmptyArrays,
			arrayFormat: arrayFormat$1,
			charset: charset$1,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$4.charsetSentinel,
			commaRoundTrip: !!opts.commaRoundTrip,
			delimiter: typeof opts.delimiter === "undefined" ? defaults$4.delimiter : opts.delimiter,
			encode: typeof opts.encode === "boolean" ? opts.encode : defaults$4.encode,
			encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$4.encodeDotInKeys,
			encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$4.encoder,
			encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$4.encodeValuesOnly,
			filter,
			format: format$6,
			formatter,
			serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$4.serializeDate,
			skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$4.skipNulls,
			sort: typeof opts.sort === "function" ? opts.sort : null,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$4.strictNullHandling
		};
	};
	module.exports = function(object, opts) {
		var obj = object;
		var options = normalizeStringifyOptions$1(opts);
		var objKeys;
		var filter;
		if (typeof options.filter === "function") {
			filter = options.filter;
			obj = filter("", obj);
		} else if (isArray$8(options.filter)) {
			filter = options.filter;
			objKeys = filter;
		}
		var keys$6 = [];
		if (typeof obj !== "object" || obj === null) return "";
		var generateArrayPrefix = arrayPrefixGenerators$1[options.arrayFormat];
		var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
		if (!objKeys) objKeys = Object.keys(obj);
		if (options.sort) objKeys.sort(options.sort);
		var sideChannel = getSideChannel$1();
		for (var i$8 = 0; i$8 < objKeys.length; ++i$8) {
			var key$1 = objKeys[i$8];
			var value = obj[key$1];
			if (options.skipNulls && value === null) continue;
			pushToArray$1(keys$6, stringify$13(value, key$1, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
		}
		var joined = keys$6.join(options.delimiter);
		var prefix = options.addQueryPrefix === true ? "?" : "";
		if (options.charsetSentinel) if (options.charset === "iso-8859-1") prefix += "utf8=%26%2310003%3B&";
		else prefix += "utf8=%E2%9C%93&";
		return joined.length > 0 ? prefix + joined : "";
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/parse.js
var require_parse$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/parse.js": ((exports, module) => {
	var utils$8 = require_utils$4();
	var has$3 = Object.prototype.hasOwnProperty;
	var isArray$7 = Array.isArray;
	var defaults$3 = {
		allowDots: false,
		allowEmptyArrays: false,
		allowPrototypes: false,
		allowSparse: false,
		arrayLimit: 20,
		charset: "utf-8",
		charsetSentinel: false,
		comma: false,
		decodeDotInKeys: false,
		decoder: utils$8.decode,
		delimiter: "&",
		depth: 5,
		duplicates: "combine",
		ignoreQueryPrefix: false,
		interpretNumericEntities: false,
		parameterLimit: 1e3,
		parseArrays: true,
		plainObjects: false,
		strictDepth: false,
		strictNullHandling: false,
		throwOnLimitExceeded: false
	};
	var interpretNumericEntities$1 = function(str) {
		return str.replace(/&#(\d+);/g, function($0, numberStr) {
			return String.fromCharCode(parseInt(numberStr, 10));
		});
	};
	var parseArrayValue$1 = function(val, options, currentArrayLength) {
		if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) return val.split(",");
		if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
		return val;
	};
	var isoSentinel$1 = "utf8=%26%2310003%3B";
	var charsetSentinel$1 = "utf8=%E2%9C%93";
	var parseValues$1 = function parseQueryStringValues(str, options) {
		var obj = { __proto__: null };
		var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
		cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
		var limit$2 = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
		var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit$2 + 1 : limit$2);
		if (options.throwOnLimitExceeded && parts.length > limit$2) throw new RangeError("Parameter limit exceeded. Only " + limit$2 + " parameter" + (limit$2 === 1 ? "" : "s") + " allowed.");
		var skipIndex = -1;
		var i$8;
		var charset$1 = options.charset;
		if (options.charsetSentinel) {
			for (i$8 = 0; i$8 < parts.length; ++i$8) if (parts[i$8].indexOf("utf8=") === 0) {
				if (parts[i$8] === charsetSentinel$1) charset$1 = "utf-8";
				else if (parts[i$8] === isoSentinel$1) charset$1 = "iso-8859-1";
				skipIndex = i$8;
				i$8 = parts.length;
			}
		}
		for (i$8 = 0; i$8 < parts.length; ++i$8) {
			if (i$8 === skipIndex) continue;
			var part = parts[i$8];
			var bracketEqualsPos = part.indexOf("]=");
			var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
			var key$1;
			var val;
			if (pos === -1) {
				key$1 = options.decoder(part, defaults$3.decoder, charset$1, "key");
				val = options.strictNullHandling ? null : "";
			} else {
				key$1 = options.decoder(part.slice(0, pos), defaults$3.decoder, charset$1, "key");
				val = utils$8.maybeMap(parseArrayValue$1(part.slice(pos + 1), options, isArray$7(obj[key$1]) ? obj[key$1].length : 0), function(encodedVal) {
					return options.decoder(encodedVal, defaults$3.decoder, charset$1, "value");
				});
			}
			if (val && options.interpretNumericEntities && charset$1 === "iso-8859-1") val = interpretNumericEntities$1(String(val));
			if (part.indexOf("[]=") > -1) val = isArray$7(val) ? [val] : val;
			var existing = has$3.call(obj, key$1);
			if (existing && options.duplicates === "combine") obj[key$1] = utils$8.combine(obj[key$1], val);
			else if (!existing || options.duplicates === "last") obj[key$1] = val;
		}
		return obj;
	};
	var parseObject$1 = function(chain, val, options, valuesParsed) {
		var currentArrayLength = 0;
		if (chain.length > 0 && chain[chain.length - 1] === "[]") {
			var parentKey = chain.slice(0, -1).join("");
			currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
		}
		var leaf = valuesParsed ? val : parseArrayValue$1(val, options, currentArrayLength);
		for (var i$8 = chain.length - 1; i$8 >= 0; --i$8) {
			var obj;
			var root$3 = chain[i$8];
			if (root$3 === "[]" && options.parseArrays) obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils$8.combine([], leaf);
			else {
				obj = options.plainObjects ? { __proto__: null } : {};
				var cleanRoot = root$3.charAt(0) === "[" && root$3.charAt(root$3.length - 1) === "]" ? root$3.slice(1, -1) : root$3;
				var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
				var index$1 = parseInt(decodedRoot, 10);
				if (!options.parseArrays && decodedRoot === "") obj = { 0: leaf };
				else if (!isNaN(index$1) && root$3 !== decodedRoot && String(index$1) === decodedRoot && index$1 >= 0 && options.parseArrays && index$1 <= options.arrayLimit) {
					obj = [];
					obj[index$1] = leaf;
				} else if (decodedRoot !== "__proto__") obj[decodedRoot] = leaf;
			}
			leaf = obj;
		}
		return leaf;
	};
	var parseKeys$1 = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
		if (!givenKey) return;
		var key$1 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
		var brackets = /(\[[^[\]]*])/;
		var child = /(\[[^[\]]*])/g;
		var segment = options.depth > 0 && brackets.exec(key$1);
		var parent = segment ? key$1.slice(0, segment.index) : key$1;
		var keys$6 = [];
		if (parent) {
			if (!options.plainObjects && has$3.call(Object.prototype, parent)) {
				if (!options.allowPrototypes) return;
			}
			keys$6.push(parent);
		}
		var i$8 = 0;
		while (options.depth > 0 && (segment = child.exec(key$1)) !== null && i$8 < options.depth) {
			i$8 += 1;
			if (!options.plainObjects && has$3.call(Object.prototype, segment[1].slice(1, -1))) {
				if (!options.allowPrototypes) return;
			}
			keys$6.push(segment[1]);
		}
		if (segment) {
			if (options.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
			keys$6.push("[" + key$1.slice(segment.index) + "]");
		}
		return parseObject$1(keys$6, val, options, valuesParsed);
	};
	var normalizeParseOptions$1 = function normalizeParseOptions$2(opts) {
		if (!opts) return defaults$3;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") throw new TypeError("Decoder has to be a function.");
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
		var charset$1 = typeof opts.charset === "undefined" ? defaults$3.charset : opts.charset;
		var duplicates = typeof opts.duplicates === "undefined" ? defaults$3.duplicates : opts.duplicates;
		if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
		return {
			allowDots: typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults$3.allowDots : !!opts.allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$3.allowEmptyArrays,
			allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$3.allowPrototypes,
			allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults$3.allowSparse,
			arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$3.arrayLimit,
			charset: charset$1,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$3.charsetSentinel,
			comma: typeof opts.comma === "boolean" ? opts.comma : defaults$3.comma,
			decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults$3.decodeDotInKeys,
			decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$3.decoder,
			delimiter: typeof opts.delimiter === "string" || utils$8.isRegExp(opts.delimiter) ? opts.delimiter : defaults$3.delimiter,
			depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults$3.depth,
			duplicates,
			ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
			interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$3.interpretNumericEntities,
			parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$3.parameterLimit,
			parseArrays: opts.parseArrays !== false,
			plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$3.plainObjects,
			strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults$3.strictDepth,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$3.strictNullHandling,
			throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
		};
	};
	module.exports = function(str, opts) {
		var options = normalizeParseOptions$1(opts);
		if (str === "" || str === null || typeof str === "undefined") return options.plainObjects ? { __proto__: null } : {};
		var tempObj = typeof str === "string" ? parseValues$1(str, options) : str;
		var obj = options.plainObjects ? { __proto__: null } : {};
		var keys$6 = Object.keys(tempObj);
		for (var i$8 = 0; i$8 < keys$6.length; ++i$8) {
			var key$1 = keys$6[i$8];
			var newObj = parseKeys$1(key$1, tempObj[key$1], options, typeof str === "string");
			obj = utils$8.merge(obj, newObj, options);
		}
		if (options.allowSparse === true) return obj;
		return utils$8.compact(obj);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/index.js
var require_lib$5 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/index.js": ((exports, module) => {
	var stringify$12 = require_stringify$2();
	var parse$17 = require_parse$1();
	var formats$3 = require_formats$1();
	module.exports = {
		formats: formats$3,
		parse: parse$17,
		stringify: stringify$12
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/@pollyjs+utils@6.0.6/node_modules/@pollyjs/utils/dist/cjs/pollyjs-utils.js
var require_pollyjs_utils = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/@pollyjs+utils@6.0.6/node_modules/@pollyjs/utils/dist/cjs/pollyjs-utils.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function _interopDefault$6(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var URLParse = _interopDefault$6(require_url_parse());
	var qs$2 = _interopDefault$6(require_lib$5());
	var buffer$4 = __require("buffer");
	var modes = {
		RECORD: "record",
		REPLAY: "replay",
		PASSTHROUGH: "passthrough",
		STOPPED: "stopped"
	};
	var actions = {
		RECORD: "record",
		REPLAY: "replay",
		INTERCEPT: "intercept",
		PASSTHROUGH: "passthrough"
	};
	var httpMethods = [
		"GET",
		"PUT",
		"POST",
		"DELETE",
		"PATCH",
		"MERGE",
		"HEAD",
		"OPTIONS"
	];
	var httpStatusCodes = {
		100: "Continue",
		101: "Switching Protocols",
		200: "OK",
		201: "Created",
		202: "Accepted",
		203: "Non-Authoritative Information",
		204: "No Content",
		205: "Reset Content",
		206: "Partial Content",
		207: "Multi-Status",
		300: "Multiple Choice",
		301: "Moved Permanently",
		302: "Found",
		303: "See Other",
		304: "Not Modified",
		305: "Use Proxy",
		307: "Temporary Redirect",
		400: "Bad Request",
		401: "Unauthorized",
		402: "Payment Required",
		403: "Forbidden",
		404: "Not Found",
		405: "Method Not Allowed",
		406: "Not Acceptable",
		407: "Proxy Authentication Required",
		408: "Request Timeout",
		409: "Conflict",
		410: "Gone",
		411: "Length Required",
		412: "Precondition Failed",
		413: "Request Entity Too Large",
		414: "Request-URI Too Long",
		415: "Unsupported Media Type",
		416: "Requested Range Not Satisfiable",
		417: "Expectation Failed",
		422: "Unprocessable Entity",
		500: "Internal Server Error",
		501: "Not Implemented",
		502: "Bad Gateway",
		503: "Service Unavailable",
		504: "Gateway Timeout",
		505: "HTTP Version Not Supported"
	};
	var expiryStrategies = {
		RECORD: "record",
		WARN: "warn",
		ERROR: "error"
	};
	var PollyError = class PollyError extends Error {
		constructor(message, ...args) {
			super(`[Polly] ${message}`, ...args);
			if (Error.captureStackTrace) Error.captureStackTrace(this, PollyError);
			this.name = "PollyError";
		}
	};
	function assert$3(msg, condition) {
		if (!condition) throw new PollyError(msg);
	}
	function unwrapExports$6(x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
	}
	function createCommonjsModule$6(fn, module$2) {
		return module$2 = { exports: {} }, fn(module$2, module$2.exports), module$2.exports;
	}
	function getCjsExportFromNamespace$4(n) {
		return n && n["default"] || n;
	}
	var _global$6 = createCommonjsModule$6(function(module$2) {
		var global$1 = module$2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
		if (typeof __g == "number") __g = global$1;
	});
	var _core$6 = createCommonjsModule$6(function(module$2) {
		var core = module$2.exports = { version: "2.6.9" };
		if (typeof __e == "number") __e = core;
	});
	_core$6.version;
	var _aFunction$6 = function(it) {
		if (typeof it != "function") throw TypeError(it + " is not a function!");
		return it;
	};
	var _ctx$6 = function(fn, that, length) {
		_aFunction$6(fn);
		if (that === void 0) return fn;
		switch (length) {
			case 1: return function(a) {
				return fn.call(that, a);
			};
			case 2: return function(a, b) {
				return fn.call(that, a, b);
			};
			case 3: return function(a, b, c) {
				return fn.call(that, a, b, c);
			};
		}
		return function() {
			return fn.apply(that, arguments);
		};
	};
	var _isObject$6 = function(it) {
		return typeof it === "object" ? it !== null : typeof it === "function";
	};
	var _anObject$6 = function(it) {
		if (!_isObject$6(it)) throw TypeError(it + " is not an object!");
		return it;
	};
	var _fails$6 = function(exec) {
		try {
			return !!exec();
		} catch (e) {
			return true;
		}
	};
	var _descriptors$6 = !_fails$6(function() {
		return Object.defineProperty({}, "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var document$1$7 = _global$6.document;
	var is$7 = _isObject$6(document$1$7) && _isObject$6(document$1$7.createElement);
	var _domCreate$6 = function(it) {
		return is$7 ? document$1$7.createElement(it) : {};
	};
	var _ie8DomDefine$6 = !_descriptors$6 && !_fails$6(function() {
		return Object.defineProperty(_domCreate$6("div"), "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var _toPrimitive$6 = function(it, S) {
		if (!_isObject$6(it)) return it;
		var fn, val;
		if (S && typeof (fn = it.toString) == "function" && !_isObject$6(val = fn.call(it))) return val;
		if (typeof (fn = it.valueOf) == "function" && !_isObject$6(val = fn.call(it))) return val;
		if (!S && typeof (fn = it.toString) == "function" && !_isObject$6(val = fn.call(it))) return val;
		throw TypeError("Can't convert object to primitive value");
	};
	var dP$11 = Object.defineProperty;
	var _objectDp$6 = { f: _descriptors$6 ? Object.defineProperty : function defineProperty$8(O, P, Attributes) {
		_anObject$6(O);
		P = _toPrimitive$6(P, true);
		_anObject$6(Attributes);
		if (_ie8DomDefine$6) try {
			return dP$11(O, P, Attributes);
		} catch (e) {}
		if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
		if ("value" in Attributes) O[P] = Attributes.value;
		return O;
	} };
	var _propertyDesc$6 = function(bitmap, value) {
		return {
			enumerable: !(bitmap & 1),
			configurable: !(bitmap & 2),
			writable: !(bitmap & 4),
			value
		};
	};
	var _hide$6 = _descriptors$6 ? function(object, key$1, value) {
		return _objectDp$6.f(object, key$1, _propertyDesc$6(1, value));
	} : function(object, key$1, value) {
		object[key$1] = value;
		return object;
	};
	var hasOwnProperty$10 = {}.hasOwnProperty;
	var _has$6 = function(it, key$1) {
		return hasOwnProperty$10.call(it, key$1);
	};
	var PROTOTYPE$6 = "prototype";
	var $export$6 = function(type, name, source) {
		var IS_FORCED = type & $export$6.F;
		var IS_GLOBAL = type & $export$6.G;
		var IS_STATIC = type & $export$6.S;
		var IS_PROTO = type & $export$6.P;
		var IS_BIND = type & $export$6.B;
		var IS_WRAP = type & $export$6.W;
		var exports$1 = IS_GLOBAL ? _core$6 : _core$6[name] || (_core$6[name] = {});
		var expProto = exports$1[PROTOTYPE$6];
		var target = IS_GLOBAL ? _global$6 : IS_STATIC ? _global$6[name] : (_global$6[name] || {})[PROTOTYPE$6];
		var key$1, own, out;
		if (IS_GLOBAL) source = name;
		for (key$1 in source) {
			own = !IS_FORCED && target && target[key$1] !== void 0;
			if (own && _has$6(exports$1, key$1)) continue;
			out = own ? target[key$1] : source[key$1];
			exports$1[key$1] = IS_GLOBAL && typeof target[key$1] != "function" ? source[key$1] : IS_BIND && own ? _ctx$6(out, _global$6) : IS_WRAP && target[key$1] == out ? (function(C) {
				var F = function(a, b, c) {
					if (this instanceof C) {
						switch (arguments.length) {
							case 0: return new C();
							case 1: return new C(a);
							case 2: return new C(a, b);
						}
						return new C(a, b, c);
					}
					return C.apply(this, arguments);
				};
				F[PROTOTYPE$6] = C[PROTOTYPE$6];
				return F;
			})(out) : IS_PROTO && typeof out == "function" ? _ctx$6(Function.call, out) : out;
			if (IS_PROTO) {
				(exports$1.virtual || (exports$1.virtual = {}))[key$1] = out;
				if (type & $export$6.R && expProto && !expProto[key$1]) _hide$6(expProto, key$1, out);
			}
		}
	};
	$export$6.F = 1;
	$export$6.G = 2;
	$export$6.S = 4;
	$export$6.P = 8;
	$export$6.B = 16;
	$export$6.W = 32;
	$export$6.U = 64;
	$export$6.R = 128;
	var _export$6 = $export$6;
	var _defined$6 = function(it) {
		if (it == void 0) throw TypeError("Can't call method on  " + it);
		return it;
	};
	var _stringWs$3 = "	\n\v\f\r \xA0\u2028\u2029";
	var space$3 = "[" + _stringWs$3 + "]";
	var non$3 = "";
	var ltrim$3 = RegExp("^" + space$3 + space$3 + "*");
	var rtrim$3 = RegExp(space$3 + space$3 + "*$");
	var exporter$3 = function(KEY, exec, ALIAS) {
		var exp = {};
		var FORCE = _fails$6(function() {
			return !!_stringWs$3[KEY]() || non$3[KEY]() != non$3;
		});
		var fn = exp[KEY] = FORCE ? exec(trim$3) : _stringWs$3[KEY];
		if (ALIAS) exp[ALIAS] = fn;
		_export$6(_export$6.P + _export$6.F * FORCE, "String", exp);
	};
	var trim$3 = exporter$3.trim = function(string, TYPE) {
		string = String(_defined$6(string));
		if (TYPE & 1) string = string.replace(ltrim$3, "");
		if (TYPE & 2) string = string.replace(rtrim$3, "");
		return string;
	};
	var _stringTrim$3 = exporter$3;
	var $parseInt$2 = _global$6.parseInt;
	var $trim$3 = _stringTrim$3.trim;
	var hex$2 = /^[-+]?0[xX]/;
	var _parseInt$3 = $parseInt$2(_stringWs$3 + "08") !== 8 || $parseInt$2(_stringWs$3 + "0x16") !== 22 ? function parseInt$1(str, radix) {
		var string = $trim$3(String(str), 3);
		return $parseInt$2(string, radix >>> 0 || (hex$2.test(string) ? 16 : 10));
	} : $parseInt$2;
	_export$6(_export$6.G + _export$6.F * (parseInt != _parseInt$3), { parseInt: _parseInt$3 });
	var _parseInt$2$4 = _core$6.parseInt;
	var es6_object_toString$4 = /* @__PURE__ */ Object.freeze({});
	var ceil$6 = Math.ceil;
	var floor$6 = Math.floor;
	var _toInteger$6 = function(it) {
		return isNaN(it = +it) ? 0 : (it > 0 ? floor$6 : ceil$6)(it);
	};
	var _stringAt$4 = function(TO_STRING) {
		return function(that, pos) {
			var s$3 = String(_defined$6(that));
			var i$8 = _toInteger$6(pos);
			var l = s$3.length;
			var a, b;
			if (i$8 < 0 || i$8 >= l) return TO_STRING ? "" : void 0;
			a = s$3.charCodeAt(i$8);
			return a < 55296 || a > 56319 || i$8 + 1 === l || (b = s$3.charCodeAt(i$8 + 1)) < 56320 || b > 57343 ? TO_STRING ? s$3.charAt(i$8) : a : TO_STRING ? s$3.slice(i$8, i$8 + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
		};
	};
	var _library$6 = true;
	var _redefine$6 = _hide$6;
	var _iterators$4 = {};
	var toString$9 = {}.toString;
	var _cof$6 = function(it) {
		return toString$9.call(it).slice(8, -1);
	};
	var _iobject$6 = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
		return _cof$6(it) == "String" ? it.split("") : Object(it);
	};
	var _toIobject$6 = function(it) {
		return _iobject$6(_defined$6(it));
	};
	var min$6 = Math.min;
	var _toLength$6 = function(it) {
		return it > 0 ? min$6(_toInteger$6(it), 9007199254740991) : 0;
	};
	var max$6 = Math.max;
	var min$1$10 = Math.min;
	var _toAbsoluteIndex$6 = function(index$1, length) {
		index$1 = _toInteger$6(index$1);
		return index$1 < 0 ? max$6(index$1 + length, 0) : min$1$10(index$1, length);
	};
	var _arrayIncludes$6 = function(IS_INCLUDES) {
		return function($this, el, fromIndex) {
			var O = _toIobject$6($this);
			var length = _toLength$6(O.length);
			var index$1 = _toAbsoluteIndex$6(fromIndex, length);
			var value;
			if (IS_INCLUDES && el != el) while (length > index$1) {
				value = O[index$1++];
				if (value != value) return true;
			}
			else for (; length > index$1; index$1++) if (IS_INCLUDES || index$1 in O) {
				if (O[index$1] === el) return IS_INCLUDES || index$1 || 0;
			}
			return !IS_INCLUDES && -1;
		};
	};
	var _shared$6 = createCommonjsModule$6(function(module$2) {
		var SHARED = "__core-js_shared__";
		var store = _global$6[SHARED] || (_global$6[SHARED] = {});
		(module$2.exports = function(key$1, value) {
			return store[key$1] || (store[key$1] = value !== void 0 ? value : {});
		})("versions", []).push({
			version: _core$6.version,
			mode: "pure",
			copyright: " 2019 Denis Pushkarev (zloirock.ru)"
		});
	});
	var id$6 = 0;
	var px$6 = Math.random();
	var _uid$6 = function(key$1) {
		return "Symbol(".concat(key$1 === void 0 ? "" : key$1, ")_", (++id$6 + px$6).toString(36));
	};
	var shared$6 = _shared$6("keys");
	var _sharedKey$6 = function(key$1) {
		return shared$6[key$1] || (shared$6[key$1] = _uid$6(key$1));
	};
	var arrayIndexOf$6 = _arrayIncludes$6(false);
	var IE_PROTO$6 = _sharedKey$6("IE_PROTO");
	var _objectKeysInternal$6 = function(object, names) {
		var O = _toIobject$6(object);
		var i$8 = 0;
		var result = [];
		var key$1;
		for (key$1 in O) if (key$1 != IE_PROTO$6) _has$6(O, key$1) && result.push(key$1);
		while (names.length > i$8) if (_has$6(O, key$1 = names[i$8++])) ~arrayIndexOf$6(result, key$1) || result.push(key$1);
		return result;
	};
	var _enumBugKeys$6 = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
	var _objectKeys$6 = Object.keys || function keys$6(O) {
		return _objectKeysInternal$6(O, _enumBugKeys$6);
	};
	var _objectDps$6 = _descriptors$6 ? Object.defineProperties : function defineProperties(O, Properties) {
		_anObject$6(O);
		var keys$6 = _objectKeys$6(Properties);
		var length = keys$6.length;
		var i$8 = 0;
		var P;
		while (length > i$8) _objectDp$6.f(O, P = keys$6[i$8++], Properties[P]);
		return O;
	};
	var document$2$5 = _global$6.document;
	var _html$6 = document$2$5 && document$2$5.documentElement;
	var IE_PROTO$1$10 = _sharedKey$6("IE_PROTO");
	var Empty$6 = function() {};
	var PROTOTYPE$1$11 = "prototype";
	var createDict$6 = function() {
		var iframe = _domCreate$6("iframe");
		var i$8 = _enumBugKeys$6.length;
		var lt = "<";
		var gt = ">";
		var iframeDocument;
		iframe.style.display = "none";
		_html$6.appendChild(iframe);
		iframe.src = "javascript:";
		iframeDocument = iframe.contentWindow.document;
		iframeDocument.open();
		iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
		iframeDocument.close();
		createDict$6 = iframeDocument.F;
		while (i$8--) delete createDict$6[PROTOTYPE$1$11][_enumBugKeys$6[i$8]];
		return createDict$6();
	};
	var _objectCreate$6 = Object.create || function create(O, Properties) {
		var result;
		if (O !== null) {
			Empty$6[PROTOTYPE$1$11] = _anObject$6(O);
			result = new Empty$6();
			Empty$6[PROTOTYPE$1$11] = null;
			result[IE_PROTO$1$10] = O;
		} else result = createDict$6();
		return Properties === void 0 ? result : _objectDps$6(result, Properties);
	};
	var _wks$6 = createCommonjsModule$6(function(module$2) {
		var store = _shared$6("wks");
		var Symbol$2 = _global$6.Symbol;
		var USE_SYMBOL = typeof Symbol$2 == "function";
		var $exports = module$2.exports = function(name) {
			return store[name] || (store[name] = USE_SYMBOL && Symbol$2[name] || (USE_SYMBOL ? Symbol$2 : _uid$6)("Symbol." + name));
		};
		$exports.store = store;
	});
	var def$6 = _objectDp$6.f;
	var TAG$6 = _wks$6("toStringTag");
	var _setToStringTag$6 = function(it, tag, stat$4) {
		if (it && !_has$6(it = stat$4 ? it : it.prototype, TAG$6)) def$6(it, TAG$6, {
			configurable: true,
			value: tag
		});
	};
	var IteratorPrototype$4 = {};
	_hide$6(IteratorPrototype$4, _wks$6("iterator"), function() {
		return this;
	});
	var _iterCreate$4 = function(Constructor, NAME$5, next) {
		Constructor.prototype = _objectCreate$6(IteratorPrototype$4, { next: _propertyDesc$6(1, next) });
		_setToStringTag$6(Constructor, NAME$5 + " Iterator");
	};
	var _toObject$6 = function(it) {
		return Object(_defined$6(it));
	};
	var IE_PROTO$2$7 = _sharedKey$6("IE_PROTO");
	var ObjectProto$6 = Object.prototype;
	var _objectGpo$4 = Object.getPrototypeOf || function(O) {
		O = _toObject$6(O);
		if (_has$6(O, IE_PROTO$2$7)) return O[IE_PROTO$2$7];
		if (typeof O.constructor == "function" && O instanceof O.constructor) return O.constructor.prototype;
		return O instanceof Object ? ObjectProto$6 : null;
	};
	var ITERATOR$7 = _wks$6("iterator");
	var BUGGY$4 = !([].keys && "next" in [].keys());
	var FF_ITERATOR$4 = "@@iterator";
	var KEYS$4 = "keys";
	var VALUES$4 = "values";
	var returnThis$4 = function() {
		return this;
	};
	var _iterDefine$4 = function(Base, NAME$5, Constructor, next, DEFAULT, IS_SET, FORCED) {
		_iterCreate$4(Constructor, NAME$5, next);
		var getMethod$1 = function(kind) {
			if (!BUGGY$4 && kind in proto$7) return proto$7[kind];
			switch (kind) {
				case KEYS$4: return function keys$6() {
					return new Constructor(this, kind);
				};
				case VALUES$4: return function values() {
					return new Constructor(this, kind);
				};
			}
			return function entries() {
				return new Constructor(this, kind);
			};
		};
		var TAG$7 = NAME$5 + " Iterator";
		var DEF_VALUES = DEFAULT == VALUES$4;
		var VALUES_BUG = false;
		var proto$7 = Base.prototype;
		var $native = proto$7[ITERATOR$7] || proto$7[FF_ITERATOR$4] || DEFAULT && proto$7[DEFAULT];
		var $default = $native || getMethod$1(DEFAULT);
		var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod$1("entries") : void 0;
		var $anyNative = NAME$5 == "Array" ? proto$7.entries || $native : $native;
		var methods$3, key$1, IteratorPrototype$5;
		if ($anyNative) {
			IteratorPrototype$5 = _objectGpo$4($anyNative.call(new Base()));
			if (IteratorPrototype$5 !== Object.prototype && IteratorPrototype$5.next) _setToStringTag$6(IteratorPrototype$5, TAG$7, true);
		}
		if (DEF_VALUES && $native && $native.name !== VALUES$4) {
			VALUES_BUG = true;
			$default = function values() {
				return $native.call(this);
			};
		}
		if (FORCED && (BUGGY$4 || VALUES_BUG || !proto$7[ITERATOR$7])) _hide$6(proto$7, ITERATOR$7, $default);
		_iterators$4[NAME$5] = $default;
		_iterators$4[TAG$7] = returnThis$4;
		if (DEFAULT) {
			methods$3 = {
				values: DEF_VALUES ? $default : getMethod$1(VALUES$4),
				keys: IS_SET ? $default : getMethod$1(KEYS$4),
				entries: $entries
			};
			if (FORCED) {
				for (key$1 in methods$3) if (!(key$1 in proto$7)) _redefine$6(proto$7, key$1, methods$3[key$1]);
			} else _export$6(_export$6.P + _export$6.F * (BUGGY$4 || VALUES_BUG), NAME$5, methods$3);
		}
		return methods$3;
	};
	var $at$4 = _stringAt$4(true);
	_iterDefine$4(String, "String", function(iterated) {
		this._t = String(iterated);
		this._i = 0;
	}, function() {
		var O = this._t;
		var index$1 = this._i;
		var point;
		if (index$1 >= O.length) return {
			value: void 0,
			done: true
		};
		point = $at$4(O, index$1);
		this._i += point.length;
		return {
			value: point,
			done: false
		};
	});
	var _iterStep$4 = function(done, value) {
		return {
			value,
			done: !!done
		};
	};
	_iterDefine$4(Array, "Array", function(iterated, kind) {
		this._t = _toIobject$6(iterated);
		this._i = 0;
		this._k = kind;
	}, function() {
		var O = this._t;
		var kind = this._k;
		var index$1 = this._i++;
		if (!O || index$1 >= O.length) {
			this._t = void 0;
			return _iterStep$4(1);
		}
		if (kind == "keys") return _iterStep$4(0, index$1);
		if (kind == "values") return _iterStep$4(0, O[index$1]);
		return _iterStep$4(0, [index$1, O[index$1]]);
	}, "values");
	_iterators$4.Arguments = _iterators$4.Array;
	var TO_STRING_TAG$4 = _wks$6("toStringTag");
	var DOMIterables$4 = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
	for (var i$7 = 0; i$7 < DOMIterables$4.length; i$7++) {
		var NAME$4 = DOMIterables$4[i$7];
		var Collection$4 = _global$6[NAME$4];
		var proto$6 = Collection$4 && Collection$4.prototype;
		if (proto$6 && !proto$6[TO_STRING_TAG$4]) _hide$6(proto$6, TO_STRING_TAG$4, NAME$4);
		_iterators$4[NAME$4] = _iterators$4.Array;
	}
	var TAG$1$5 = _wks$6("toStringTag");
	var ARG$4 = _cof$6(function() {
		return arguments;
	}()) == "Arguments";
	var tryGet$4 = function(it, key$1) {
		try {
			return it[key$1];
		} catch (e) {}
	};
	var _classof$4 = function(it) {
		var O, T, B;
		return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet$4(O = Object(it), TAG$1$5)) == "string" ? T : ARG$4 ? _cof$6(O) : (B = _cof$6(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
	};
	var _anInstance$4 = function(it, Constructor, name, forbiddenField) {
		if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) throw TypeError(name + ": incorrect invocation!");
		return it;
	};
	var _iterCall$4 = function(iterator, fn, value, entries) {
		try {
			return entries ? fn(_anObject$6(value)[0], value[1]) : fn(value);
		} catch (e) {
			var ret = iterator["return"];
			if (ret !== void 0) _anObject$6(ret.call(iterator));
			throw e;
		}
	};
	var ITERATOR$1$10 = _wks$6("iterator");
	var ArrayProto$4 = Array.prototype;
	var _isArrayIter$4 = function(it) {
		return it !== void 0 && (_iterators$4.Array === it || ArrayProto$4[ITERATOR$1$10] === it);
	};
	var ITERATOR$2$8 = _wks$6("iterator");
	var core_getIteratorMethod$4 = _core$6.getIteratorMethod = function(it) {
		if (it != void 0) return it[ITERATOR$2$8] || it["@@iterator"] || _iterators$4[_classof$4(it)];
	};
	var _forOf$4 = createCommonjsModule$6(function(module$2) {
		var BREAK = {};
		var RETURN = {};
		var exports$1 = module$2.exports = function(iterable, entries, fn, that, ITERATOR$5) {
			var iterFn = ITERATOR$5 ? function() {
				return iterable;
			} : core_getIteratorMethod$4(iterable);
			var f = _ctx$6(fn, that, entries ? 2 : 1);
			var index$1 = 0;
			var length, step, iterator, result;
			if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
			if (_isArrayIter$4(iterFn)) for (length = _toLength$6(iterable.length); length > index$1; index$1++) {
				result = entries ? f(_anObject$6(step = iterable[index$1])[0], step[1]) : f(iterable[index$1]);
				if (result === BREAK || result === RETURN) return result;
			}
			else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
				result = _iterCall$4(iterator, f, step.value, entries);
				if (result === BREAK || result === RETURN) return result;
			}
		};
		exports$1.BREAK = BREAK;
		exports$1.RETURN = RETURN;
	});
	var SPECIES$4 = _wks$6("species");
	var _speciesConstructor$4 = function(O, D) {
		var C = _anObject$6(O).constructor;
		var S;
		return C === void 0 || (S = _anObject$6(C)[SPECIES$4]) == void 0 ? D : _aFunction$6(S);
	};
	var _invoke$4 = function(fn, args, that) {
		var un = that === void 0;
		switch (args.length) {
			case 0: return un ? fn() : fn.call(that);
			case 1: return un ? fn(args[0]) : fn.call(that, args[0]);
			case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
			case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
			case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
		}
		return fn.apply(that, args);
	};
	var process$4 = _global$6.process;
	var setTask$4 = _global$6.setImmediate;
	var clearTask$4 = _global$6.clearImmediate;
	var MessageChannel$4 = _global$6.MessageChannel;
	var Dispatch$4 = _global$6.Dispatch;
	var counter$4 = 0;
	var queue$4 = {};
	var ONREADYSTATECHANGE$4 = "onreadystatechange";
	var defer$7, channel$4, port$4;
	var run$4 = function() {
		var id$7 = +this;
		if (queue$4.hasOwnProperty(id$7)) {
			var fn = queue$4[id$7];
			delete queue$4[id$7];
			fn();
		}
	};
	var listener$5 = function(event) {
		run$4.call(event.data);
	};
	if (!setTask$4 || !clearTask$4) {
		setTask$4 = function setImmediate$3(fn) {
			var args = [];
			var i$8 = 1;
			while (arguments.length > i$8) args.push(arguments[i$8++]);
			queue$4[++counter$4] = function() {
				_invoke$4(typeof fn == "function" ? fn : Function(fn), args);
			};
			defer$7(counter$4);
			return counter$4;
		};
		clearTask$4 = function clearImmediate$1(id$7) {
			delete queue$4[id$7];
		};
		if (_cof$6(process$4) == "process") defer$7 = function(id$7) {
			process$4.nextTick(_ctx$6(run$4, id$7, 1));
		};
		else if (Dispatch$4 && Dispatch$4.now) defer$7 = function(id$7) {
			Dispatch$4.now(_ctx$6(run$4, id$7, 1));
		};
		else if (MessageChannel$4) {
			channel$4 = new MessageChannel$4();
			port$4 = channel$4.port2;
			channel$4.port1.onmessage = listener$5;
			defer$7 = _ctx$6(port$4.postMessage, port$4, 1);
		} else if (_global$6.addEventListener && typeof postMessage == "function" && !_global$6.importScripts) {
			defer$7 = function(id$7) {
				_global$6.postMessage(id$7 + "", "*");
			};
			_global$6.addEventListener("message", listener$5, false);
		} else if (ONREADYSTATECHANGE$4 in _domCreate$6("script")) defer$7 = function(id$7) {
			_html$6.appendChild(_domCreate$6("script"))[ONREADYSTATECHANGE$4] = function() {
				_html$6.removeChild(this);
				run$4.call(id$7);
			};
		};
		else defer$7 = function(id$7) {
			setTimeout(_ctx$6(run$4, id$7, 1), 0);
		};
	}
	var _task$4 = {
		set: setTask$4,
		clear: clearTask$4
	};
	var macrotask$4 = _task$4.set;
	var Observer$4 = _global$6.MutationObserver || _global$6.WebKitMutationObserver;
	var process$1$6 = _global$6.process;
	var Promise$5 = _global$6.Promise;
	var isNode$7 = _cof$6(process$1$6) == "process";
	var _microtask$4 = function() {
		var head, last, notify$6;
		var flush = function() {
			var parent, fn;
			if (isNode$7 && (parent = process$1$6.domain)) parent.exit();
			while (head) {
				fn = head.fn;
				head = head.next;
				try {
					fn();
				} catch (e) {
					if (head) notify$6();
					else last = void 0;
					throw e;
				}
			}
			last = void 0;
			if (parent) parent.enter();
		};
		if (isNode$7) notify$6 = function() {
			process$1$6.nextTick(flush);
		};
		else if (Observer$4 && !(_global$6.navigator && _global$6.navigator.standalone)) {
			var toggle = true;
			var node$1 = document.createTextNode("");
			new Observer$4(flush).observe(node$1, { characterData: true });
			notify$6 = function() {
				node$1.data = toggle = !toggle;
			};
		} else if (Promise$5 && Promise$5.resolve) {
			var promise = Promise$5.resolve(void 0);
			notify$6 = function() {
				promise.then(flush);
			};
		} else notify$6 = function() {
			macrotask$4.call(_global$6, flush);
		};
		return function(fn) {
			var task$5 = {
				fn,
				next: void 0
			};
			if (last) last.next = task$5;
			if (!head) {
				head = task$5;
				notify$6();
			}
			last = task$5;
		};
	};
	function PromiseCapability$4(C) {
		var resolve$6, reject;
		this.promise = new C(function($$resolve, $$reject) {
			if (resolve$6 !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
			resolve$6 = $$resolve;
			reject = $$reject;
		});
		this.resolve = _aFunction$6(resolve$6);
		this.reject = _aFunction$6(reject);
	}
	var f$1 = function(C) {
		return new PromiseCapability$4(C);
	};
	var _newPromiseCapability$4 = { f: f$1 };
	var _perform$4 = function(exec) {
		try {
			return {
				e: false,
				v: exec()
			};
		} catch (e) {
			return {
				e: true,
				v: e
			};
		}
	};
	var navigator$4 = _global$6.navigator;
	var _userAgent$4 = navigator$4 && navigator$4.userAgent || "";
	var _promiseResolve$4 = function(C, x) {
		_anObject$6(C);
		if (_isObject$6(x) && x.constructor === C) return x;
		var promiseCapability = _newPromiseCapability$4.f(C);
		var resolve$6 = promiseCapability.resolve;
		resolve$6(x);
		return promiseCapability.promise;
	};
	var _redefineAll$4 = function(target, src$1, safe) {
		for (var key$1 in src$1) if (safe && target[key$1]) target[key$1] = src$1[key$1];
		else _hide$6(target, key$1, src$1[key$1]);
		return target;
	};
	var SPECIES$1$9 = _wks$6("species");
	var _setSpecies$4 = function(KEY) {
		var C = typeof _core$6[KEY] == "function" ? _core$6[KEY] : _global$6[KEY];
		if (_descriptors$6 && C && !C[SPECIES$1$9]) _objectDp$6.f(C, SPECIES$1$9, {
			configurable: true,
			get: function() {
				return this;
			}
		});
	};
	var ITERATOR$3$8 = _wks$6("iterator");
	var SAFE_CLOSING$4 = false;
	try {
		var riter$4 = [7][ITERATOR$3$8]();
		riter$4["return"] = function() {
			SAFE_CLOSING$4 = true;
		};
		Array.from(riter$4, function() {
			throw 2;
		});
	} catch (e) {}
	var _iterDetect$4 = function(exec, skipClosing) {
		if (!skipClosing && !SAFE_CLOSING$4) return false;
		var safe = false;
		try {
			var arr = [7];
			var iter = arr[ITERATOR$3$8]();
			iter.next = function() {
				return { done: safe = true };
			};
			arr[ITERATOR$3$8] = function() {
				return iter;
			};
			exec(arr);
		} catch (e) {}
		return safe;
	};
	var task$4 = _task$4.set;
	var microtask$4 = _microtask$4();
	var PROMISE$4 = "Promise";
	var TypeError$1$4 = _global$6.TypeError;
	var process$2$8 = _global$6.process;
	var versions$4 = process$2$8 && process$2$8.versions;
	var v8$4 = versions$4 && versions$4.v8 || "";
	var $Promise$4 = _global$6[PROMISE$4];
	var isNode$1$8 = _classof$4(process$2$8) == "process";
	var empty$4 = function() {};
	var Internal$4, newGenericPromiseCapability$4, OwnPromiseCapability$4, Wrapper$4;
	var newPromiseCapability$4 = newGenericPromiseCapability$4 = _newPromiseCapability$4.f;
	var USE_NATIVE$6 = !!function() {
		try {
			var promise = $Promise$4.resolve(1);
			var FakePromise = (promise.constructor = {})[_wks$6("species")] = function(exec) {
				exec(empty$4, empty$4);
			};
			return (isNode$1$8 || typeof PromiseRejectionEvent == "function") && promise.then(empty$4) instanceof FakePromise && v8$4.indexOf("6.6") !== 0 && _userAgent$4.indexOf("Chrome/66") === -1;
		} catch (e) {}
	}();
	var isThenable$4 = function(it) {
		var then;
		return _isObject$6(it) && typeof (then = it.then) == "function" ? then : false;
	};
	var notify$4 = function(promise, isReject) {
		if (promise._n) return;
		promise._n = true;
		var chain = promise._c;
		microtask$4(function() {
			var value = promise._v;
			var ok = promise._s == 1;
			var i$8 = 0;
			var run$5 = function(reaction) {
				var handler = ok ? reaction.ok : reaction.fail;
				var resolve$6 = reaction.resolve;
				var reject = reaction.reject;
				var domain = reaction.domain;
				var result, then, exited;
				try {
					if (handler) {
						if (!ok) {
							if (promise._h == 2) onHandleUnhandled$4(promise);
							promise._h = 1;
						}
						if (handler === true) result = value;
						else {
							if (domain) domain.enter();
							result = handler(value);
							if (domain) {
								domain.exit();
								exited = true;
							}
						}
						if (result === reaction.promise) reject(TypeError$1$4("Promise-chain cycle"));
						else if (then = isThenable$4(result)) then.call(result, resolve$6, reject);
						else resolve$6(result);
					} else reject(value);
				} catch (e) {
					if (domain && !exited) domain.exit();
					reject(e);
				}
			};
			while (chain.length > i$8) run$5(chain[i$8++]);
			promise._c = [];
			promise._n = false;
			if (isReject && !promise._h) onUnhandled$4(promise);
		});
	};
	var onUnhandled$4 = function(promise) {
		task$4.call(_global$6, function() {
			var value = promise._v;
			var unhandled = isUnhandled$4(promise);
			var result, handler, console$1;
			if (unhandled) {
				result = _perform$4(function() {
					if (isNode$1$8) process$2$8.emit("unhandledRejection", value, promise);
					else if (handler = _global$6.onunhandledrejection) handler({
						promise,
						reason: value
					});
					else if ((console$1 = _global$6.console) && console$1.error) console$1.error("Unhandled promise rejection", value);
				});
				promise._h = isNode$1$8 || isUnhandled$4(promise) ? 2 : 1;
			}
			promise._a = void 0;
			if (unhandled && result.e) throw result.v;
		});
	};
	var isUnhandled$4 = function(promise) {
		return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled$4 = function(promise) {
		task$4.call(_global$6, function() {
			var handler;
			if (isNode$1$8) process$2$8.emit("rejectionHandled", promise);
			else if (handler = _global$6.onrejectionhandled) handler({
				promise,
				reason: promise._v
			});
		});
	};
	var $reject$4 = function(value) {
		var promise = this;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		promise._v = value;
		promise._s = 2;
		if (!promise._a) promise._a = promise._c.slice();
		notify$4(promise, true);
	};
	var $resolve$4 = function(value) {
		var promise = this;
		var then;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		try {
			if (promise === value) throw TypeError$1$4("Promise can't be resolved itself");
			if (then = isThenable$4(value)) microtask$4(function() {
				var wrapper = {
					_w: promise,
					_d: false
				};
				try {
					then.call(value, _ctx$6($resolve$4, wrapper, 1), _ctx$6($reject$4, wrapper, 1));
				} catch (e) {
					$reject$4.call(wrapper, e);
				}
			});
			else {
				promise._v = value;
				promise._s = 1;
				notify$4(promise, false);
			}
		} catch (e) {
			$reject$4.call({
				_w: promise,
				_d: false
			}, e);
		}
	};
	if (!USE_NATIVE$6) {
		$Promise$4 = function Promise$6(executor) {
			_anInstance$4(this, $Promise$4, PROMISE$4, "_h");
			_aFunction$6(executor);
			Internal$4.call(this);
			try {
				executor(_ctx$6($resolve$4, this, 1), _ctx$6($reject$4, this, 1));
			} catch (err) {
				$reject$4.call(this, err);
			}
		};
		Internal$4 = function Promise$6(executor) {
			this._c = [];
			this._a = void 0;
			this._s = 0;
			this._d = false;
			this._v = void 0;
			this._h = 0;
			this._n = false;
		};
		Internal$4.prototype = _redefineAll$4($Promise$4.prototype, {
			then: function then(onFulfilled, onRejected) {
				var reaction = newPromiseCapability$4(_speciesConstructor$4(this, $Promise$4));
				reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
				reaction.fail = typeof onRejected == "function" && onRejected;
				reaction.domain = isNode$1$8 ? process$2$8.domain : void 0;
				this._c.push(reaction);
				if (this._a) this._a.push(reaction);
				if (this._s) notify$4(this, false);
				return reaction.promise;
			},
			"catch": function(onRejected) {
				return this.then(void 0, onRejected);
			}
		});
		OwnPromiseCapability$4 = function() {
			var promise = new Internal$4();
			this.promise = promise;
			this.resolve = _ctx$6($resolve$4, promise, 1);
			this.reject = _ctx$6($reject$4, promise, 1);
		};
		_newPromiseCapability$4.f = newPromiseCapability$4 = function(C) {
			return C === $Promise$4 || C === Wrapper$4 ? new OwnPromiseCapability$4(C) : newGenericPromiseCapability$4(C);
		};
	}
	_export$6(_export$6.G + _export$6.W + _export$6.F * !USE_NATIVE$6, { Promise: $Promise$4 });
	_setToStringTag$6($Promise$4, PROMISE$4);
	_setSpecies$4(PROMISE$4);
	Wrapper$4 = _core$6[PROMISE$4];
	_export$6(_export$6.S + _export$6.F * !USE_NATIVE$6, PROMISE$4, { reject: function reject(r) {
		var capability = newPromiseCapability$4(this);
		var $$reject = capability.reject;
		$$reject(r);
		return capability.promise;
	} });
	_export$6(_export$6.S + _export$6.F * _library$6, PROMISE$4, { resolve: function resolve$6(x) {
		return _promiseResolve$4(this === Wrapper$4 ? $Promise$4 : this, x);
	} });
	_export$6(_export$6.S + _export$6.F * !(USE_NATIVE$6 && _iterDetect$4(function(iter) {
		$Promise$4.all(iter)["catch"](empty$4);
	})), PROMISE$4, {
		all: function all(iterable) {
			var C = this;
			var capability = newPromiseCapability$4(C);
			var resolve$6 = capability.resolve;
			var reject = capability.reject;
			var result = _perform$4(function() {
				var values = [];
				var index$1 = 0;
				var remaining = 1;
				_forOf$4(iterable, false, function(promise) {
					var $index = index$1++;
					var alreadyCalled = false;
					values.push(void 0);
					remaining++;
					C.resolve(promise).then(function(value) {
						if (alreadyCalled) return;
						alreadyCalled = true;
						values[$index] = value;
						--remaining || resolve$6(values);
					}, reject);
				});
				--remaining || resolve$6(values);
			});
			if (result.e) reject(result.v);
			return capability.promise;
		},
		race: function race(iterable) {
			var C = this;
			var capability = newPromiseCapability$4(C);
			var reject = capability.reject;
			var result = _perform$4(function() {
				_forOf$4(iterable, false, function(promise) {
					C.resolve(promise).then(capability.resolve, reject);
				});
			});
			if (result.e) reject(result.v);
			return capability.promise;
		}
	});
	_export$6(_export$6.P + _export$6.R, "Promise", { "finally": function(onFinally) {
		var C = _speciesConstructor$4(this, _core$6.Promise || _global$6.Promise);
		var isFunction$3 = typeof onFinally == "function";
		return this.then(isFunction$3 ? function(x) {
			return _promiseResolve$4(C, onFinally()).then(function() {
				return x;
			});
		} : onFinally, isFunction$3 ? function(e) {
			return _promiseResolve$4(C, onFinally()).then(function() {
				throw e;
			});
		} : onFinally);
	} });
	_export$6(_export$6.S, "Promise", { "try": function(callbackfn) {
		var promiseCapability = _newPromiseCapability$4.f(this);
		var result = _perform$4(callbackfn);
		(result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
		return promiseCapability.promise;
	} });
	getCjsExportFromNamespace$4(es6_object_toString$4);
	var promise$1$4 = _core$6.Promise;
	function timeout(time) {
		const ms$2 = _parseInt$2$4(time, 10);
		return new promise$1$4((resolve$6) => ms$2 > 0 ? setTimeout(resolve$6, ms$2) : resolve$6());
	}
	function timestamp() {
		return (/* @__PURE__ */ new Date()).toISOString();
	}
	var _objectSap$6 = function(KEY, exec) {
		var fn = (_core$6.Object || {})[KEY] || Object[KEY];
		var exp = {};
		exp[KEY] = exec(fn);
		_export$6(_export$6.S + _export$6.F * _fails$6(function() {
			fn(1);
		}), "Object", exp);
	};
	_objectSap$6("keys", function() {
		return function keys$6(it) {
			return _objectKeys$6(_toObject$6(it));
		};
	});
	var keys$1$6 = _core$6.Object.keys;
	var _meta$6 = createCommonjsModule$6(function(module$2) {
		var META$7 = _uid$6("meta");
		var setDesc = _objectDp$6.f;
		var id$7 = 0;
		var isExtensible = Object.isExtensible || function() {
			return true;
		};
		var FREEZE = !_fails$6(function() {
			return isExtensible(Object.preventExtensions({}));
		});
		var setMeta = function(it) {
			setDesc(it, META$7, { value: {
				i: "O" + ++id$7,
				w: {}
			} });
		};
		var fastKey$2 = function(it, create) {
			if (!_isObject$6(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
			if (!_has$6(it, META$7)) {
				if (!isExtensible(it)) return "F";
				if (!create) return "E";
				setMeta(it);
			}
			return it[META$7].i;
		};
		var getWeak$2 = function(it, create) {
			if (!_has$6(it, META$7)) {
				if (!isExtensible(it)) return true;
				if (!create) return false;
				setMeta(it);
			}
			return it[META$7].w;
		};
		var onFreeze = function(it) {
			if (FREEZE && meta.NEED && isExtensible(it) && !_has$6(it, META$7)) setMeta(it);
			return it;
		};
		var meta = module$2.exports = {
			KEY: META$7,
			NEED: false,
			fastKey: fastKey$2,
			getWeak: getWeak$2,
			onFreeze
		};
	});
	_meta$6.KEY;
	_meta$6.NEED;
	_meta$6.fastKey;
	_meta$6.getWeak;
	_meta$6.onFreeze;
	var _wksExt$6 = { f: _wks$6 };
	var defineProperty$6 = _objectDp$6.f;
	var _wksDefine$6 = function(name) {
		var $Symbol$7 = _core$6.Symbol || (_core$6.Symbol = {});
		if (name.charAt(0) != "_" && !(name in $Symbol$7)) defineProperty$6($Symbol$7, name, { value: _wksExt$6.f(name) });
	};
	var _objectGops$6 = { f: Object.getOwnPropertySymbols };
	var _objectPie$6 = { f: {}.propertyIsEnumerable };
	var _enumKeys$6 = function(it) {
		var result = _objectKeys$6(it);
		var getSymbols = _objectGops$6.f;
		if (getSymbols) {
			var symbols = getSymbols(it);
			var isEnum$7 = _objectPie$6.f;
			var i$8 = 0;
			var key$1;
			while (symbols.length > i$8) if (isEnum$7.call(it, key$1 = symbols[i$8++])) result.push(key$1);
		}
		return result;
	};
	var _isArray$6 = Array.isArray || function isArray$11(arg) {
		return _cof$6(arg) == "Array";
	};
	var hiddenKeys$6 = _enumBugKeys$6.concat("length", "prototype");
	var _objectGopn$6 = { f: Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		return _objectKeysInternal$6(O, hiddenKeys$6);
	} };
	var gOPN$6 = _objectGopn$6.f;
	var toString$1$13 = {}.toString;
	var windowNames$6 = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
	var getWindowNames$6 = function(it) {
		try {
			return gOPN$6(it);
		} catch (e) {
			return windowNames$6.slice();
		}
	};
	var _objectGopnExt$6 = { f: function getOwnPropertyNames(it) {
		return windowNames$6 && toString$1$13.call(it) == "[object Window]" ? getWindowNames$6(it) : gOPN$6(_toIobject$6(it));
	} };
	var gOPD$6 = Object.getOwnPropertyDescriptor;
	var _objectGopd$6 = { f: _descriptors$6 ? gOPD$6 : function getOwnPropertyDescriptor(O, P) {
		O = _toIobject$6(O);
		P = _toPrimitive$6(P, true);
		if (_ie8DomDefine$6) try {
			return gOPD$6(O, P);
		} catch (e) {}
		if (_has$6(O, P)) return _propertyDesc$6(!_objectPie$6.f.call(O, P), O[P]);
	} };
	var META$6 = _meta$6.KEY;
	var gOPD$1$10 = _objectGopd$6.f;
	var dP$1$12 = _objectDp$6.f;
	var gOPN$1$10 = _objectGopnExt$6.f;
	var $Symbol$6 = _global$6.Symbol;
	var $JSON$6 = _global$6.JSON;
	var _stringify$6 = $JSON$6 && $JSON$6.stringify;
	var PROTOTYPE$2$10 = "prototype";
	var HIDDEN$6 = _wks$6("_hidden");
	var TO_PRIMITIVE$6 = _wks$6("toPrimitive");
	var isEnum$6 = {}.propertyIsEnumerable;
	var SymbolRegistry$6 = _shared$6("symbol-registry");
	var AllSymbols$6 = _shared$6("symbols");
	var OPSymbols$6 = _shared$6("op-symbols");
	var ObjectProto$1$5 = Object[PROTOTYPE$2$10];
	var USE_NATIVE$1$5 = typeof $Symbol$6 == "function" && !!_objectGops$6.f;
	var QObject$6 = _global$6.QObject;
	var setter$6 = !QObject$6 || !QObject$6[PROTOTYPE$2$10] || !QObject$6[PROTOTYPE$2$10].findChild;
	var setSymbolDesc$6 = _descriptors$6 && _fails$6(function() {
		return _objectCreate$6(dP$1$12({}, "a", { get: function() {
			return dP$1$12(this, "a", { value: 7 }).a;
		} })).a != 7;
	}) ? function(it, key$1, D) {
		var protoDesc = gOPD$1$10(ObjectProto$1$5, key$1);
		if (protoDesc) delete ObjectProto$1$5[key$1];
		dP$1$12(it, key$1, D);
		if (protoDesc && it !== ObjectProto$1$5) dP$1$12(ObjectProto$1$5, key$1, protoDesc);
	} : dP$1$12;
	var wrap$9 = function(tag) {
		var sym = AllSymbols$6[tag] = _objectCreate$6($Symbol$6[PROTOTYPE$2$10]);
		sym._k = tag;
		return sym;
	};
	var isSymbol$6 = USE_NATIVE$1$5 && typeof $Symbol$6.iterator == "symbol" ? function(it) {
		return typeof it == "symbol";
	} : function(it) {
		return it instanceof $Symbol$6;
	};
	var $defineProperty$6 = function defineProperty$8(it, key$1, D) {
		if (it === ObjectProto$1$5) $defineProperty$6(OPSymbols$6, key$1, D);
		_anObject$6(it);
		key$1 = _toPrimitive$6(key$1, true);
		_anObject$6(D);
		if (_has$6(AllSymbols$6, key$1)) {
			if (!D.enumerable) {
				if (!_has$6(it, HIDDEN$6)) dP$1$12(it, HIDDEN$6, _propertyDesc$6(1, {}));
				it[HIDDEN$6][key$1] = true;
			} else {
				if (_has$6(it, HIDDEN$6) && it[HIDDEN$6][key$1]) it[HIDDEN$6][key$1] = false;
				D = _objectCreate$6(D, { enumerable: _propertyDesc$6(0, false) });
			}
			return setSymbolDesc$6(it, key$1, D);
		}
		return dP$1$12(it, key$1, D);
	};
	var $defineProperties$6 = function defineProperties(it, P) {
		_anObject$6(it);
		var keys$6 = _enumKeys$6(P = _toIobject$6(P));
		var i$8 = 0;
		var l = keys$6.length;
		var key$1;
		while (l > i$8) $defineProperty$6(it, key$1 = keys$6[i$8++], P[key$1]);
		return it;
	};
	var $create$6 = function create(it, P) {
		return P === void 0 ? _objectCreate$6(it) : $defineProperties$6(_objectCreate$6(it), P);
	};
	var $propertyIsEnumerable$6 = function propertyIsEnumerable$1(key$1) {
		var E = isEnum$6.call(this, key$1 = _toPrimitive$6(key$1, true));
		if (this === ObjectProto$1$5 && _has$6(AllSymbols$6, key$1) && !_has$6(OPSymbols$6, key$1)) return false;
		return E || !_has$6(this, key$1) || !_has$6(AllSymbols$6, key$1) || _has$6(this, HIDDEN$6) && this[HIDDEN$6][key$1] ? E : true;
	};
	var $getOwnPropertyDescriptor$6 = function getOwnPropertyDescriptor(it, key$1) {
		it = _toIobject$6(it);
		key$1 = _toPrimitive$6(key$1, true);
		if (it === ObjectProto$1$5 && _has$6(AllSymbols$6, key$1) && !_has$6(OPSymbols$6, key$1)) return;
		var D = gOPD$1$10(it, key$1);
		if (D && _has$6(AllSymbols$6, key$1) && !(_has$6(it, HIDDEN$6) && it[HIDDEN$6][key$1])) D.enumerable = true;
		return D;
	};
	var $getOwnPropertyNames$6 = function getOwnPropertyNames(it) {
		var names = gOPN$1$10(_toIobject$6(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (!_has$6(AllSymbols$6, key$1 = names[i$8++]) && key$1 != HIDDEN$6 && key$1 != META$6) result.push(key$1);
		return result;
	};
	var $getOwnPropertySymbols$6 = function getOwnPropertySymbols$2(it) {
		var IS_OP = it === ObjectProto$1$5;
		var names = gOPN$1$10(IS_OP ? OPSymbols$6 : _toIobject$6(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (_has$6(AllSymbols$6, key$1 = names[i$8++]) && (IS_OP ? _has$6(ObjectProto$1$5, key$1) : true)) result.push(AllSymbols$6[key$1]);
		return result;
	};
	if (!USE_NATIVE$1$5) {
		$Symbol$6 = function Symbol$2() {
			if (this instanceof $Symbol$6) throw TypeError("Symbol is not a constructor!");
			var tag = _uid$6(arguments.length > 0 ? arguments[0] : void 0);
			var $set = function(value) {
				if (this === ObjectProto$1$5) $set.call(OPSymbols$6, value);
				if (_has$6(this, HIDDEN$6) && _has$6(this[HIDDEN$6], tag)) this[HIDDEN$6][tag] = false;
				setSymbolDesc$6(this, tag, _propertyDesc$6(1, value));
			};
			if (_descriptors$6 && setter$6) setSymbolDesc$6(ObjectProto$1$5, tag, {
				configurable: true,
				set: $set
			});
			return wrap$9(tag);
		};
		_redefine$6($Symbol$6[PROTOTYPE$2$10], "toString", function toString$11() {
			return this._k;
		});
		_objectGopd$6.f = $getOwnPropertyDescriptor$6;
		_objectDp$6.f = $defineProperty$6;
		_objectGopn$6.f = _objectGopnExt$6.f = $getOwnPropertyNames$6;
		_objectPie$6.f = $propertyIsEnumerable$6;
		_objectGops$6.f = $getOwnPropertySymbols$6;
		if (_descriptors$6 && !_library$6) _redefine$6(ObjectProto$1$5, "propertyIsEnumerable", $propertyIsEnumerable$6, true);
		_wksExt$6.f = function(name) {
			return wrap$9(_wks$6(name));
		};
	}
	_export$6(_export$6.G + _export$6.W + _export$6.F * !USE_NATIVE$1$5, { Symbol: $Symbol$6 });
	for (var es6Symbols$6 = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j$6 = 0; es6Symbols$6.length > j$6;) _wks$6(es6Symbols$6[j$6++]);
	for (var wellKnownSymbols$6 = _objectKeys$6(_wks$6.store), k$6 = 0; wellKnownSymbols$6.length > k$6;) _wksDefine$6(wellKnownSymbols$6[k$6++]);
	_export$6(_export$6.S + _export$6.F * !USE_NATIVE$1$5, "Symbol", {
		"for": function(key$1) {
			return _has$6(SymbolRegistry$6, key$1 += "") ? SymbolRegistry$6[key$1] : SymbolRegistry$6[key$1] = $Symbol$6(key$1);
		},
		keyFor: function keyFor$1(sym) {
			if (!isSymbol$6(sym)) throw TypeError(sym + " is not a symbol!");
			for (var key$1 in SymbolRegistry$6) if (SymbolRegistry$6[key$1] === sym) return key$1;
		},
		useSetter: function() {
			setter$6 = true;
		},
		useSimple: function() {
			setter$6 = false;
		}
	});
	_export$6(_export$6.S + _export$6.F * !USE_NATIVE$1$5, "Object", {
		create: $create$6,
		defineProperty: $defineProperty$6,
		defineProperties: $defineProperties$6,
		getOwnPropertyDescriptor: $getOwnPropertyDescriptor$6,
		getOwnPropertyNames: $getOwnPropertyNames$6,
		getOwnPropertySymbols: $getOwnPropertySymbols$6
	});
	var FAILS_ON_PRIMITIVES$6 = _fails$6(function() {
		_objectGops$6.f(1);
	});
	_export$6(_export$6.S + _export$6.F * FAILS_ON_PRIMITIVES$6, "Object", { getOwnPropertySymbols: function getOwnPropertySymbols$2(it) {
		return _objectGops$6.f(_toObject$6(it));
	} });
	$JSON$6 && _export$6(_export$6.S + _export$6.F * (!USE_NATIVE$1$5 || _fails$6(function() {
		var S = $Symbol$6();
		return _stringify$6([S]) != "[null]" || _stringify$6({ a: S }) != "{}" || _stringify$6(Object(S)) != "{}";
	})), "JSON", { stringify: function stringify$14(it) {
		var args = [it];
		var i$8 = 1;
		var replacer, $replacer;
		while (arguments.length > i$8) args.push(arguments[i$8++]);
		$replacer = replacer = args[1];
		if (!_isObject$6(replacer) && it === void 0 || isSymbol$6(it)) return;
		if (!_isArray$6(replacer)) replacer = function(key$1, value) {
			if (typeof $replacer == "function") value = $replacer.call(this, key$1, value);
			if (!isSymbol$6(value)) return value;
		};
		args[1] = replacer;
		return _stringify$6.apply($JSON$6, args);
	} });
	$Symbol$6[PROTOTYPE$2$10][TO_PRIMITIVE$6] || _hide$6($Symbol$6[PROTOTYPE$2$10], TO_PRIMITIVE$6, $Symbol$6[PROTOTYPE$2$10].valueOf);
	_setToStringTag$6($Symbol$6, "Symbol");
	_setToStringTag$6(Math, "Math", true);
	_setToStringTag$6(_global$6.JSON, "JSON", true);
	var getOwnPropertySymbols$1$6 = _core$6.Object.getOwnPropertySymbols;
	var $getOwnPropertyDescriptor$1$10 = _objectGopd$6.f;
	_objectSap$6("getOwnPropertyDescriptor", function() {
		return function getOwnPropertyDescriptor(it, key$1) {
			return $getOwnPropertyDescriptor$1$10(_toIobject$6(it), key$1);
		};
	});
	var $Object$6 = _core$6.Object;
	var getOwnPropertyDescriptor$1$6 = function getOwnPropertyDescriptor(it, key$1) {
		return $Object$6.getOwnPropertyDescriptor(it, key$1);
	};
	var Reflect$7 = _global$6.Reflect;
	var _ownKeys$6 = Reflect$7 && Reflect$7.ownKeys || function ownKeys$8(it) {
		var keys$6 = _objectGopn$6.f(_anObject$6(it));
		var getSymbols = _objectGops$6.f;
		return getSymbols ? keys$6.concat(getSymbols(it)) : keys$6;
	};
	var _createProperty$6 = function(object, index$1, value) {
		if (index$1 in object) _objectDp$6.f(object, index$1, _propertyDesc$6(0, value));
		else object[index$1] = value;
	};
	_export$6(_export$6.S, "Object", { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
		var O = _toIobject$6(object);
		var getDesc = _objectGopd$6.f;
		var keys$6 = _ownKeys$6(O);
		var result = {};
		var i$8 = 0;
		var key$1, desc$1;
		while (keys$6.length > i$8) {
			desc$1 = getDesc(O, key$1 = keys$6[i$8++]);
			if (desc$1 !== void 0) _createProperty$6(result, key$1, desc$1);
		}
		return result;
	} });
	var getOwnPropertyDescriptors$1$6 = _core$6.Object.getOwnPropertyDescriptors;
	_export$6(_export$6.S + _export$6.F * !_descriptors$6, "Object", { defineProperties: _objectDps$6 });
	var $Object$1$11 = _core$6.Object;
	var defineProperties$1$6 = function defineProperties(T, D) {
		return $Object$1$11.defineProperties(T, D);
	};
	_export$6(_export$6.S + _export$6.F * !_descriptors$6, "Object", { defineProperty: _objectDp$6.f });
	var $Object$2$10 = _core$6.Object;
	var defineProperty$2$10 = function defineProperty$8(it, key$1, desc$1) {
		return $Object$2$10.defineProperty(it, key$1, desc$1);
	};
	var _defineProperty$6 = unwrapExports$6(createCommonjsModule$6(function(module$2) {
		function _defineProperty$7(obj, key$1, value) {
			if (key$1 in obj) defineProperty$2$10(obj, key$1, {
				value,
				enumerable: true,
				configurable: true,
				writable: true
			});
			else obj[key$1] = value;
			return obj;
		}
		module$2.exports = _defineProperty$7;
		module$2.exports["default"] = module$2.exports, module$2.exports.__esModule = true;
	}));
	_wksDefine$6("asyncIterator");
	_wksDefine$6("observable");
	var symbol$1$4 = _core$6.Symbol;
	function ownKeys$6(object, enumerableOnly) {
		var keys$6 = keys$1$6(object);
		if (getOwnPropertySymbols$1$6) {
			var symbols = getOwnPropertySymbols$1$6(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1$6(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$6(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$6(Object(source), true).forEach(function(key$1) {
				_defineProperty$6(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1$6) defineProperties$1$6(target, getOwnPropertyDescriptors$1$6(source));
			else ownKeys$6(Object(source)).forEach(function(key$1) {
				defineProperty$2$10(target, key$1, getOwnPropertyDescriptor$1$6(source, key$1));
			});
		}
		return target;
	}
	const ARRAY_FORMAT = symbol$1$4();
	const INDICES_REGEX = /\[\d+\]$/;
	const BRACKETS_REGEX = /\[\]$/;
	function parseQuery(query$1, options) {
		return qs$2.parse(query$1, _objectSpread$6({
			plainObjects: true,
			ignoreQueryPrefix: true,
			strictNullHandling: true
		}, options));
	}
	function stringifyQuery(obj, options = {}) {
		return qs$2.stringify(obj, _objectSpread$6({
			addQueryPrefix: true,
			strictNullHandling: true
		}, options));
	}
	/**
	* Given a query string, determine the array format used. Returns `undefined`
	* if one cannot be determined.
	*
	* @param {String} query
	* @returns {String | undefined}
	*/
	function arrayFormat(query$1) {
		const keys$6 = (query$1 || "").replace("?", "").split("&").map((str) => decodeURIComponent(str.split("=")[0]));
		for (const key$1 of keys$6) if (INDICES_REGEX.test(key$1)) return "indices";
		else if (BRACKETS_REGEX.test(key$1)) return "brackets";
		if (keys$6.some((key$1, index$1) => keys$6.indexOf(key$1) !== index$1)) return "repeat";
	}
	/**
	* An extended url-parse class that uses `qs` instead of the default
	* `querystringify` to support array and nested object query param strings.
	*/
	var URL$2 = class extends URLParse {
		constructor(url$6, parse$18) {
			super(url$6);
			if (parse$18) this.set("query", this.query || {});
		}
		/**
		* Override set for `query` so we can pass it our custom parser.
		* https://github.com/unshiftio/url-parse/blob/1.4.4/index.js#L314-L316
		*
		* @override
		*/
		set(part, value, fn) {
			if (part === "query") {
				if (value && typeof value === "string") this[ARRAY_FORMAT] = arrayFormat(value) || this[ARRAY_FORMAT];
				return super.set(part, value, parseQuery);
			}
			return super.set(part, value, fn);
		}
		/**
		* Override toString so we can pass it our custom query stringify method.
		* https://github.com/unshiftio/url-parse/blob/1.4.4/index.js#L414
		*
		* @override
		*/
		toString() {
			return super.toString((obj) => stringifyQuery(obj, { arrayFormat: this[ARRAY_FORMAT] }));
		}
	};
	function buildUrl(...paths) {
		const url$6 = new URL$2(paths.map((p) => p && (p + "").trim()).filter(Boolean).join("/"));
		url$6.set("pathname", url$6.pathname.replace(/\/{2,}/g, "/"));
		return url$6.href;
	}
	const supportsBlob = (() => {
		try {
			return !!new Blob();
		} catch (e) {
			return false;
		}
	})();
	function readBlob(blob) {
		return new promise$1$4((resolve$6, reject) => {
			const reader = new FileReader();
			reader.onend = reject;
			reader.onabort = reject;
			reader.onload = () => resolve$6(reader.result);
			reader.readAsDataURL(new Blob([blob], { type: blob.type }));
		});
	}
	async function serialize$1(body$1) {
		if (supportsBlob && body$1 instanceof Blob) return await readBlob(body$1);
		return body$1;
	}
	const supportsFormData = typeof FormData !== "undefined";
	async function serialize$1$1(body$1) {
		if (supportsFormData && body$1 instanceof FormData) {
			const data = [];
			for (const [key$1, value] of body$1.entries()) if (supportsBlob && value instanceof Blob) {
				const blobContent = await readBlob(value);
				data.push(`${key$1}=${blobContent}`);
			} else data.push(`${key$1}=${value}`);
			return data.join("\r\n");
		}
		return body$1;
	}
	_export$6(_export$6.S, "Array", { isArray: _isArray$6 });
	var isArray$1$2 = _core$6.Array.isArray;
	const supportsBuffer = typeof Buffer !== "undefined";
	const supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
	function serialize$2(body$1) {
		if (supportsBuffer && body$1) {
			let buffer$5;
			if (Buffer.isBuffer(body$1)) buffer$5 = body$1;
			else if (isArray$1$2(body$1) && body$1.some((c) => Buffer.isBuffer(c))) {
				const chunks = body$1.map((c) => Buffer.from(c));
				buffer$5 = Buffer.concat(chunks);
			} else if (`${body$1}` === "[object ArrayBuffer]") buffer$5 = Buffer.from(body$1);
			else if (supportsArrayBuffer && ArrayBuffer.isView(body$1)) buffer$5 = Buffer.from(body$1.buffer, body$1.byteOffset, body$1.byteLength);
			if (Buffer.isBuffer(buffer$5)) return buffer$5.toString("base64");
		}
		return body$1;
	}
	var index = {
		blob: serialize$1,
		formData: serialize$1$1,
		buffer: serialize$2
	};
	/**
	* Determine if the given buffer is utf8.
	* @param {Buffer} buffer
	*/
	function isBufferUtf8Representable(buffer$1$1) {
		const utfEncodedBuffer = buffer$1$1.toString("utf8");
		return buffer$4.Buffer.from(utfEncodedBuffer, "utf8").equals(buffer$1$1);
	}
	/**
	* Clone an array buffer
	*
	* @param {ArrayBuffer} arrayBuffer
	*/
	function cloneArrayBuffer$1(arrayBuffer) {
		const clonedArrayBuffer = new ArrayBuffer(arrayBuffer.byteLength);
		new Uint8Array(clonedArrayBuffer).set(new Uint8Array(arrayBuffer));
		return clonedArrayBuffer;
	}
	exports.ACTIONS = actions;
	exports.EXPIRY_STRATEGIES = expiryStrategies;
	exports.HTTP_METHODS = httpMethods;
	exports.HTTP_STATUS_CODES = httpStatusCodes;
	exports.MODES = modes;
	exports.PollyError = PollyError;
	exports.Serializers = index;
	exports.URL = URL$2;
	exports.assert = assert$3;
	exports.buildUrl = buildUrl;
	exports.cloneArrayBuffer = cloneArrayBuffer$1;
	exports.isBufferUtf8Representable = isBufferUtf8Representable;
	exports.timeout = timeout;
	exports.timestamp = timestamp;
}) });

//#endregion
//#region ../../node_modules/.pnpm/loglevel@1.9.2/node_modules/loglevel/lib/loglevel.js
var require_loglevel = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/loglevel@1.9.2/node_modules/loglevel/lib/loglevel.js": ((exports, module) => {
	(function(root$3, definition) {
		if (typeof define === "function" && define.amd) define(definition);
		else if (typeof module === "object" && module.exports) module.exports = definition();
		else root$3.log = definition();
	})(exports, function() {
		var noop$3 = function() {};
		var undefinedType = "undefined";
		var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
		var logMethods = [
			"trace",
			"debug",
			"info",
			"warn",
			"error"
		];
		var _loggersByName = {};
		var defaultLogger = null;
		function bindMethod(obj, methodName) {
			var method$1 = obj[methodName];
			if (typeof method$1.bind === "function") return method$1.bind(obj);
			else try {
				return Function.prototype.bind.call(method$1, obj);
			} catch (e) {
				return function() {
					return Function.prototype.apply.apply(method$1, [obj, arguments]);
				};
			}
		}
		function traceForIE() {
			if (console.log) if (console.log.apply) console.log.apply(console, arguments);
			else Function.prototype.apply.apply(console.log, [console, arguments]);
			if (console.trace) console.trace();
		}
		function realMethod(methodName) {
			if (methodName === "debug") methodName = "log";
			if (typeof console === undefinedType) return false;
			else if (methodName === "trace" && isIE) return traceForIE;
			else if (console[methodName] !== void 0) return bindMethod(console, methodName);
			else if (console.log !== void 0) return bindMethod(console, "log");
			else return noop$3;
		}
		function replaceLoggingMethods() {
			var level = this.getLevel();
			for (var i$8 = 0; i$8 < logMethods.length; i$8++) {
				var methodName = logMethods[i$8];
				this[methodName] = i$8 < level ? noop$3 : this.methodFactory(methodName, level, this.name);
			}
			this.log = this.debug;
			if (typeof console === undefinedType && level < this.levels.SILENT) return "No console available for logging";
		}
		function enableLoggingWhenConsoleArrives(methodName) {
			return function() {
				if (typeof console !== undefinedType) {
					replaceLoggingMethods.call(this);
					this[methodName].apply(this, arguments);
				}
			};
		}
		function defaultMethodFactory(methodName, _level, _loggerName) {
			return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
		}
		function Logger$1(name, factory) {
			var self$1 = this;
			/**
			* The level inherited from a parent logger (or a global default). We
			* cache this here rather than delegating to the parent so that it stays
			* in sync with the actual logging methods that we have installed (the
			* parent could change levels but we might not have rebuilt the loggers
			* in this child yet).
			* @type {number}
			*/
			var inheritedLevel;
			/**
			* The default level for this logger, if any. If set, this overrides
			* `inheritedLevel`.
			* @type {number|null}
			*/
			var defaultLevel;
			/**
			* A user-specific level for this logger. If set, this overrides
			* `defaultLevel`.
			* @type {number|null}
			*/
			var userLevel;
			var storageKey = "loglevel";
			if (typeof name === "string") storageKey += ":" + name;
			else if (typeof name === "symbol") storageKey = void 0;
			function persistLevelIfPossible(levelNum) {
				var levelName = (logMethods[levelNum] || "silent").toUpperCase();
				if (typeof window === undefinedType || !storageKey) return;
				try {
					window.localStorage[storageKey] = levelName;
					return;
				} catch (ignore$1) {}
				try {
					window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
				} catch (ignore$1) {}
			}
			function getPersistedLevel() {
				var storedLevel;
				if (typeof window === undefinedType || !storageKey) return;
				try {
					storedLevel = window.localStorage[storageKey];
				} catch (ignore$1) {}
				if (typeof storedLevel === undefinedType) try {
					var cookie$1 = window.document.cookie;
					var cookieName = encodeURIComponent(storageKey);
					var location = cookie$1.indexOf(cookieName + "=");
					if (location !== -1) storedLevel = /^([^;]+)/.exec(cookie$1.slice(location + cookieName.length + 1))[1];
				} catch (ignore$1) {}
				if (self$1.levels[storedLevel] === void 0) storedLevel = void 0;
				return storedLevel;
			}
			function clearPersistedLevel() {
				if (typeof window === undefinedType || !storageKey) return;
				try {
					window.localStorage.removeItem(storageKey);
				} catch (ignore$1) {}
				try {
					window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
				} catch (ignore$1) {}
			}
			function normalizeLevel(input) {
				var level = input;
				if (typeof level === "string" && self$1.levels[level.toUpperCase()] !== void 0) level = self$1.levels[level.toUpperCase()];
				if (typeof level === "number" && level >= 0 && level <= self$1.levels.SILENT) return level;
				else throw new TypeError("log.setLevel() called with invalid level: " + input);
			}
			self$1.name = name;
			self$1.levels = {
				"TRACE": 0,
				"DEBUG": 1,
				"INFO": 2,
				"WARN": 3,
				"ERROR": 4,
				"SILENT": 5
			};
			self$1.methodFactory = factory || defaultMethodFactory;
			self$1.getLevel = function() {
				if (userLevel != null) return userLevel;
				else if (defaultLevel != null) return defaultLevel;
				else return inheritedLevel;
			};
			self$1.setLevel = function(level, persist) {
				userLevel = normalizeLevel(level);
				if (persist !== false) persistLevelIfPossible(userLevel);
				return replaceLoggingMethods.call(self$1);
			};
			self$1.setDefaultLevel = function(level) {
				defaultLevel = normalizeLevel(level);
				if (!getPersistedLevel()) self$1.setLevel(level, false);
			};
			self$1.resetLevel = function() {
				userLevel = null;
				clearPersistedLevel();
				replaceLoggingMethods.call(self$1);
			};
			self$1.enableAll = function(persist) {
				self$1.setLevel(self$1.levels.TRACE, persist);
			};
			self$1.disableAll = function(persist) {
				self$1.setLevel(self$1.levels.SILENT, persist);
			};
			self$1.rebuild = function() {
				if (defaultLogger !== self$1) inheritedLevel = normalizeLevel(defaultLogger.getLevel());
				replaceLoggingMethods.call(self$1);
				if (defaultLogger === self$1) for (var childName in _loggersByName) _loggersByName[childName].rebuild();
			};
			inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : "WARN");
			var initialLevel = getPersistedLevel();
			if (initialLevel != null) userLevel = normalizeLevel(initialLevel);
			replaceLoggingMethods.call(self$1);
		}
		defaultLogger = new Logger$1();
		defaultLogger.getLogger = function getLogger(name) {
			if (typeof name !== "symbol" && typeof name !== "string" || name === "") throw new TypeError("You must supply a name when creating a logger.");
			var logger = _loggersByName[name];
			if (!logger) logger = _loggersByName[name] = new Logger$1(name, defaultLogger.methodFactory);
			return logger;
		};
		var _log = typeof window !== undefinedType ? window.log : void 0;
		defaultLogger.noConflict = function() {
			if (typeof window !== undefinedType && window.log === defaultLogger) window.log = _log;
			return defaultLogger;
		};
		defaultLogger.getLoggers = function getLoggers() {
			return _loggersByName;
		};
		defaultLogger["default"] = defaultLogger;
		return defaultLogger;
	});
}) });

//#endregion
//#region ../../node_modules/.pnpm/blueimp-md5@2.19.0/node_modules/blueimp-md5/js/md5.js
var require_md5 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/blueimp-md5@2.19.0/node_modules/blueimp-md5/js/md5.js": ((exports, module) => {
	(function($) {
		/**
		* Add integers, wrapping at 2^32.
		* This uses 16-bit operations internally to work around bugs in interpreters.
		*
		* @param {number} x First integer
		* @param {number} y Second integer
		* @returns {number} Sum
		*/
		function safeAdd(x, y$3) {
			var lsw = (x & 65535) + (y$3 & 65535);
			return (x >> 16) + (y$3 >> 16) + (lsw >> 16) << 16 | lsw & 65535;
		}
		/**
		* Bitwise rotate a 32-bit number to the left.
		*
		* @param {number} num 32-bit number
		* @param {number} cnt Rotation count
		* @returns {number} Rotated number
		*/
		function bitRotateLeft(num, cnt) {
			return num << cnt | num >>> 32 - cnt;
		}
		/**
		* Basic operation the algorithm uses.
		*
		* @param {number} q q
		* @param {number} a a
		* @param {number} b b
		* @param {number} x x
		* @param {number} s s
		* @param {number} t t
		* @returns {number} Result
		*/
		function md5cmn(q, a, b, x, s$3, t) {
			return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s$3), b);
		}
		/**
		* Basic operation the algorithm uses.
		*
		* @param {number} a a
		* @param {number} b b
		* @param {number} c c
		* @param {number} d d
		* @param {number} x x
		* @param {number} s s
		* @param {number} t t
		* @returns {number} Result
		*/
		function md5ff(a, b, c, d$3, x, s$3, t) {
			return md5cmn(b & c | ~b & d$3, a, b, x, s$3, t);
		}
		/**
		* Basic operation the algorithm uses.
		*
		* @param {number} a a
		* @param {number} b b
		* @param {number} c c
		* @param {number} d d
		* @param {number} x x
		* @param {number} s s
		* @param {number} t t
		* @returns {number} Result
		*/
		function md5gg(a, b, c, d$3, x, s$3, t) {
			return md5cmn(b & d$3 | c & ~d$3, a, b, x, s$3, t);
		}
		/**
		* Basic operation the algorithm uses.
		*
		* @param {number} a a
		* @param {number} b b
		* @param {number} c c
		* @param {number} d d
		* @param {number} x x
		* @param {number} s s
		* @param {number} t t
		* @returns {number} Result
		*/
		function md5hh(a, b, c, d$3, x, s$3, t) {
			return md5cmn(b ^ c ^ d$3, a, b, x, s$3, t);
		}
		/**
		* Basic operation the algorithm uses.
		*
		* @param {number} a a
		* @param {number} b b
		* @param {number} c c
		* @param {number} d d
		* @param {number} x x
		* @param {number} s s
		* @param {number} t t
		* @returns {number} Result
		*/
		function md5ii(a, b, c, d$3, x, s$3, t) {
			return md5cmn(c ^ (b | ~d$3), a, b, x, s$3, t);
		}
		/**
		* Calculate the MD5 of an array of little-endian words, and a bit length.
		*
		* @param {Array} x Array of little-endian words
		* @param {number} len Bit length
		* @returns {Array<number>} MD5 Array
		*/
		function binlMD5(x, len$1) {
			x[len$1 >> 5] |= 128 << len$1 % 32;
			x[(len$1 + 64 >>> 9 << 4) + 14] = len$1;
			var i$8;
			var olda;
			var oldb;
			var oldc;
			var oldd;
			var a = 1732584193;
			var b = -271733879;
			var c = -1732584194;
			var d$3 = 271733878;
			for (i$8 = 0; i$8 < x.length; i$8 += 16) {
				olda = a;
				oldb = b;
				oldc = c;
				oldd = d$3;
				a = md5ff(a, b, c, d$3, x[i$8], 7, -680876936);
				d$3 = md5ff(d$3, a, b, c, x[i$8 + 1], 12, -389564586);
				c = md5ff(c, d$3, a, b, x[i$8 + 2], 17, 606105819);
				b = md5ff(b, c, d$3, a, x[i$8 + 3], 22, -1044525330);
				a = md5ff(a, b, c, d$3, x[i$8 + 4], 7, -176418897);
				d$3 = md5ff(d$3, a, b, c, x[i$8 + 5], 12, 1200080426);
				c = md5ff(c, d$3, a, b, x[i$8 + 6], 17, -1473231341);
				b = md5ff(b, c, d$3, a, x[i$8 + 7], 22, -45705983);
				a = md5ff(a, b, c, d$3, x[i$8 + 8], 7, 1770035416);
				d$3 = md5ff(d$3, a, b, c, x[i$8 + 9], 12, -1958414417);
				c = md5ff(c, d$3, a, b, x[i$8 + 10], 17, -42063);
				b = md5ff(b, c, d$3, a, x[i$8 + 11], 22, -1990404162);
				a = md5ff(a, b, c, d$3, x[i$8 + 12], 7, 1804603682);
				d$3 = md5ff(d$3, a, b, c, x[i$8 + 13], 12, -40341101);
				c = md5ff(c, d$3, a, b, x[i$8 + 14], 17, -1502002290);
				b = md5ff(b, c, d$3, a, x[i$8 + 15], 22, 1236535329);
				a = md5gg(a, b, c, d$3, x[i$8 + 1], 5, -165796510);
				d$3 = md5gg(d$3, a, b, c, x[i$8 + 6], 9, -1069501632);
				c = md5gg(c, d$3, a, b, x[i$8 + 11], 14, 643717713);
				b = md5gg(b, c, d$3, a, x[i$8], 20, -373897302);
				a = md5gg(a, b, c, d$3, x[i$8 + 5], 5, -701558691);
				d$3 = md5gg(d$3, a, b, c, x[i$8 + 10], 9, 38016083);
				c = md5gg(c, d$3, a, b, x[i$8 + 15], 14, -660478335);
				b = md5gg(b, c, d$3, a, x[i$8 + 4], 20, -405537848);
				a = md5gg(a, b, c, d$3, x[i$8 + 9], 5, 568446438);
				d$3 = md5gg(d$3, a, b, c, x[i$8 + 14], 9, -1019803690);
				c = md5gg(c, d$3, a, b, x[i$8 + 3], 14, -187363961);
				b = md5gg(b, c, d$3, a, x[i$8 + 8], 20, 1163531501);
				a = md5gg(a, b, c, d$3, x[i$8 + 13], 5, -1444681467);
				d$3 = md5gg(d$3, a, b, c, x[i$8 + 2], 9, -51403784);
				c = md5gg(c, d$3, a, b, x[i$8 + 7], 14, 1735328473);
				b = md5gg(b, c, d$3, a, x[i$8 + 12], 20, -1926607734);
				a = md5hh(a, b, c, d$3, x[i$8 + 5], 4, -378558);
				d$3 = md5hh(d$3, a, b, c, x[i$8 + 8], 11, -2022574463);
				c = md5hh(c, d$3, a, b, x[i$8 + 11], 16, 1839030562);
				b = md5hh(b, c, d$3, a, x[i$8 + 14], 23, -35309556);
				a = md5hh(a, b, c, d$3, x[i$8 + 1], 4, -1530992060);
				d$3 = md5hh(d$3, a, b, c, x[i$8 + 4], 11, 1272893353);
				c = md5hh(c, d$3, a, b, x[i$8 + 7], 16, -155497632);
				b = md5hh(b, c, d$3, a, x[i$8 + 10], 23, -1094730640);
				a = md5hh(a, b, c, d$3, x[i$8 + 13], 4, 681279174);
				d$3 = md5hh(d$3, a, b, c, x[i$8], 11, -358537222);
				c = md5hh(c, d$3, a, b, x[i$8 + 3], 16, -722521979);
				b = md5hh(b, c, d$3, a, x[i$8 + 6], 23, 76029189);
				a = md5hh(a, b, c, d$3, x[i$8 + 9], 4, -640364487);
				d$3 = md5hh(d$3, a, b, c, x[i$8 + 12], 11, -421815835);
				c = md5hh(c, d$3, a, b, x[i$8 + 15], 16, 530742520);
				b = md5hh(b, c, d$3, a, x[i$8 + 2], 23, -995338651);
				a = md5ii(a, b, c, d$3, x[i$8], 6, -198630844);
				d$3 = md5ii(d$3, a, b, c, x[i$8 + 7], 10, 1126891415);
				c = md5ii(c, d$3, a, b, x[i$8 + 14], 15, -1416354905);
				b = md5ii(b, c, d$3, a, x[i$8 + 5], 21, -57434055);
				a = md5ii(a, b, c, d$3, x[i$8 + 12], 6, 1700485571);
				d$3 = md5ii(d$3, a, b, c, x[i$8 + 3], 10, -1894986606);
				c = md5ii(c, d$3, a, b, x[i$8 + 10], 15, -1051523);
				b = md5ii(b, c, d$3, a, x[i$8 + 1], 21, -2054922799);
				a = md5ii(a, b, c, d$3, x[i$8 + 8], 6, 1873313359);
				d$3 = md5ii(d$3, a, b, c, x[i$8 + 15], 10, -30611744);
				c = md5ii(c, d$3, a, b, x[i$8 + 6], 15, -1560198380);
				b = md5ii(b, c, d$3, a, x[i$8 + 13], 21, 1309151649);
				a = md5ii(a, b, c, d$3, x[i$8 + 4], 6, -145523070);
				d$3 = md5ii(d$3, a, b, c, x[i$8 + 11], 10, -1120210379);
				c = md5ii(c, d$3, a, b, x[i$8 + 2], 15, 718787259);
				b = md5ii(b, c, d$3, a, x[i$8 + 9], 21, -343485551);
				a = safeAdd(a, olda);
				b = safeAdd(b, oldb);
				c = safeAdd(c, oldc);
				d$3 = safeAdd(d$3, oldd);
			}
			return [
				a,
				b,
				c,
				d$3
			];
		}
		/**
		* Convert an array of little-endian words to a string
		*
		* @param {Array<number>} input MD5 Array
		* @returns {string} MD5 string
		*/
		function binl2rstr(input) {
			var i$8;
			var output = "";
			var length32 = input.length * 32;
			for (i$8 = 0; i$8 < length32; i$8 += 8) output += String.fromCharCode(input[i$8 >> 5] >>> i$8 % 32 & 255);
			return output;
		}
		/**
		* Convert a raw string to an array of little-endian words
		* Characters >255 have their high-byte silently ignored.
		*
		* @param {string} input Raw input string
		* @returns {Array<number>} Array of little-endian words
		*/
		function rstr2binl(input) {
			var i$8;
			var output = [];
			output[(input.length >> 2) - 1] = void 0;
			for (i$8 = 0; i$8 < output.length; i$8 += 1) output[i$8] = 0;
			var length8 = input.length * 8;
			for (i$8 = 0; i$8 < length8; i$8 += 8) output[i$8 >> 5] |= (input.charCodeAt(i$8 / 8) & 255) << i$8 % 32;
			return output;
		}
		/**
		* Calculate the MD5 of a raw string
		*
		* @param {string} s Input string
		* @returns {string} Raw MD5 string
		*/
		function rstrMD5(s$3) {
			return binl2rstr(binlMD5(rstr2binl(s$3), s$3.length * 8));
		}
		/**
		* Calculates the HMAC-MD5 of a key and some data (raw strings)
		*
		* @param {string} key HMAC key
		* @param {string} data Raw input string
		* @returns {string} Raw MD5 string
		*/
		function rstrHMACMD5(key$1, data) {
			var i$8;
			var bkey = rstr2binl(key$1);
			var ipad = [];
			var opad = [];
			var hash;
			ipad[15] = opad[15] = void 0;
			if (bkey.length > 16) bkey = binlMD5(bkey, key$1.length * 8);
			for (i$8 = 0; i$8 < 16; i$8 += 1) {
				ipad[i$8] = bkey[i$8] ^ 909522486;
				opad[i$8] = bkey[i$8] ^ 1549556828;
			}
			hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
			return binl2rstr(binlMD5(opad.concat(hash), 640));
		}
		/**
		* Convert a raw string to a hex string
		*
		* @param {string} input Raw input string
		* @returns {string} Hex encoded string
		*/
		function rstr2hex(input) {
			var hexTab = "0123456789abcdef";
			var output = "";
			var x;
			var i$8;
			for (i$8 = 0; i$8 < input.length; i$8 += 1) {
				x = input.charCodeAt(i$8);
				output += hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15);
			}
			return output;
		}
		/**
		* Encode a string as UTF-8
		*
		* @param {string} input Input string
		* @returns {string} UTF8 string
		*/
		function str2rstrUTF8(input) {
			return unescape(encodeURIComponent(input));
		}
		/**
		* Encodes input string as raw MD5 string
		*
		* @param {string} s Input string
		* @returns {string} Raw MD5 string
		*/
		function rawMD5(s$3) {
			return rstrMD5(str2rstrUTF8(s$3));
		}
		/**
		* Encodes input string as Hex encoded string
		*
		* @param {string} s Input string
		* @returns {string} Hex encoded string
		*/
		function hexMD5(s$3) {
			return rstr2hex(rawMD5(s$3));
		}
		/**
		* Calculates the raw HMAC-MD5 for the given key and data
		*
		* @param {string} k HMAC key
		* @param {string} d Input string
		* @returns {string} Raw MD5 string
		*/
		function rawHMACMD5(k$7, d$3) {
			return rstrHMACMD5(str2rstrUTF8(k$7), str2rstrUTF8(d$3));
		}
		/**
		* Calculates the Hex encoded HMAC-MD5 for the given key and data
		*
		* @param {string} k HMAC key
		* @param {string} d Input string
		* @returns {string} Raw MD5 string
		*/
		function hexHMACMD5(k$7, d$3) {
			return rstr2hex(rawHMACMD5(k$7, d$3));
		}
		/**
		* Calculates MD5 value for a given string.
		* If a key is provided, calculates the HMAC-MD5 value.
		* Returns a Hex encoded string unless the raw argument is given.
		*
		* @param {string} string Input string
		* @param {string} [key] HMAC key
		* @param {boolean} [raw] Raw output switch
		* @returns {string} MD5 output
		*/
		function md5$1(string, key$1, raw$1) {
			if (!key$1) {
				if (!raw$1) return hexMD5(string);
				return rawMD5(string);
			}
			if (!raw$1) return hexHMACMD5(key$1, string);
			return rawHMACMD5(key$1, string);
		}
		if (typeof define === "function" && define.amd) define(function() {
			return md5$1;
		});
		else if (typeof module === "object" && module.exports) module.exports = md5$1;
		else $.md5 = md5$1;
	})(exports);
}) });

//#endregion
//#region ../../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js": ((exports, module) => {
	module.exports = function(data, opts) {
		if (!opts) opts = {};
		if (typeof opts === "function") opts = { cmp: opts };
		var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
		var cmp = opts.cmp && (function(f) {
			return function(node$1) {
				return function(a, b) {
					return f({
						key: a,
						value: node$1[a]
					}, {
						key: b,
						value: node$1[b]
					});
				};
			};
		})(opts.cmp);
		var seen = [];
		return (function stringify$14(node$1) {
			if (node$1 && node$1.toJSON && typeof node$1.toJSON === "function") node$1 = node$1.toJSON();
			if (node$1 === void 0) return;
			if (typeof node$1 == "number") return isFinite(node$1) ? "" + node$1 : "null";
			if (typeof node$1 !== "object") return JSON.stringify(node$1);
			var i$8, out;
			if (Array.isArray(node$1)) {
				out = "[";
				for (i$8 = 0; i$8 < node$1.length; i$8++) {
					if (i$8) out += ",";
					out += stringify$14(node$1[i$8]) || "null";
				}
				return out + "]";
			}
			if (node$1 === null) return "null";
			if (seen.indexOf(node$1) !== -1) {
				if (cycles) return JSON.stringify("__cycle__");
				throw new TypeError("Converting circular structure to JSON");
			}
			var seenIndex = seen.push(node$1) - 1;
			var keys$6 = Object.keys(node$1).sort(cmp && cmp(node$1));
			out = "";
			for (i$8 = 0; i$8 < keys$6.length; i$8++) {
				var key$1 = keys$6[i$8];
				var value = stringify$14(node$1[key$1]);
				if (!value) continue;
				if (out) out += ",";
				out += JSON.stringify(key$1) + ":" + value;
			}
			seen.splice(seenIndex, 1);
			return "{" + out + "}";
		})(data);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/is-absolute-url@3.0.3/node_modules/is-absolute-url/index.js
var require_is_absolute_url = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/is-absolute-url@3.0.3/node_modules/is-absolute-url/index.js": ((exports, module) => {
	module.exports = (url$6) => {
		if (typeof url$6 !== "string") throw new TypeError(`Expected a \`string\`, got \`${typeof url$6}\``);
		if (/^[a-zA-Z]:\\/.test(url$6)) return false;
		return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url$6);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/@sindresorhus+fnv1a@2.0.1/node_modules/@sindresorhus/fnv1a/index.js
var require_fnv1a = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/@sindresorhus+fnv1a@2.0.1/node_modules/@sindresorhus/fnv1a/index.js": ((exports, module) => {
	const FNV_PRIMES = {
		32: 16777619n,
		64: 1099511628211n,
		128: 309485009821345068724781371n,
		256: 374144419156711147060143317175368453031918731002211n,
		512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
		1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
	};
	const FNV_OFFSETS = {
		32: 2166136261n,
		64: 14695981039346656037n,
		128: 144066263297769815596495629667062367629n,
		256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
		512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
		1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
	};
	function fnv1a$1(string) {
		let hash = Number(FNV_OFFSETS[32]);
		let isUnicoded = false;
		for (let i$8 = 0; i$8 < string.length; i$8++) {
			let characterCode = string.charCodeAt(i$8);
			if (characterCode > 127 && !isUnicoded) {
				string = unescape(encodeURIComponent(string));
				characterCode = string.charCodeAt(i$8);
				isUnicoded = true;
			}
			hash ^= characterCode;
			hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
		}
		return hash >>> 0;
	}
	function bigInt(string, { size = 32 } = {}) {
		if (!FNV_PRIMES[size]) throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
		let hash = FNV_OFFSETS[size];
		const fnvPrime = FNV_PRIMES[size];
		let isUnicoded = false;
		for (let i$8 = 0; i$8 < string.length; i$8++) {
			let characterCode = string.charCodeAt(i$8);
			if (characterCode > 127 && !isUnicoded) {
				string = unescape(encodeURIComponent(string));
				characterCode = string.charCodeAt(i$8);
				isUnicoded = true;
			}
			hash ^= BigInt(characterCode);
			hash = BigInt.asUintN(size, hash * fnvPrime);
		}
		return hash;
	}
	module.exports = fnv1a$1;
	module.exports.bigInt = bigInt;
}) });

//#endregion
//#region ../../node_modules/.pnpm/slugify@1.6.6/node_modules/slugify/slugify.js
var require_slugify = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/slugify@1.6.6/node_modules/slugify/slugify.js": ((exports, module) => {
	(function(name, root$3, factory) {
		if (typeof exports === "object") {
			module.exports = factory();
			module.exports["default"] = factory();
		} else if (typeof define === "function" && define.amd) define(factory);
		else root$3[name] = factory();
	})("slugify", exports, function() {
		var charMap = JSON.parse("{\"$\":\"dollar\",\"%\":\"percent\",\"&\":\"and\",\"<\":\"less\",\">\":\"greater\",\"|\":\"or\",\"\":\"cent\",\"\":\"pound\",\"\":\"currency\",\"\":\"yen\",\"\":\"(c)\",\"\":\"a\",\"\":\"(r)\",\"\":\"o\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"A\",\"\":\"AE\",\"\":\"C\",\"\":\"E\",\"\":\"E\",\"\":\"E\",\"\":\"E\",\"\":\"I\",\"\":\"I\",\"\":\"I\",\"\":\"I\",\"\":\"D\",\"\":\"N\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"O\",\"\":\"U\",\"\":\"U\",\"\":\"U\",\"\":\"U\",\"\":\"Y\",\"\":\"TH\",\"\":\"ss\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"a\",\"\":\"ae\",\"\":\"c\",\"\":\"e\",\"\":\"e\",\"\":\"e\",\"\":\"e\",\"\":\"i\",\"\":\"i\",\"\":\"i\",\"\":\"i\",\"\":\"d\",\"\":\"n\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"o\",\"\":\"u\",\"\":\"u\",\"\":\"u\",\"\":\"u\",\"\":\"y\",\"\":\"th\",\"\":\"y\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"C\",\"\":\"c\",\"\":\"C\",\"\":\"c\",\"\":\"D\",\"\":\"d\",\"\":\"DJ\",\"\":\"dj\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"e\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"G\",\"\":\"g\",\"\":\"G\",\"\":\"g\",\"\":\"I\",\"\":\"i\",\"\":\"i\",\"\":\"i\",\"\":\"I\",\"\":\"i\",\"\":\"I\",\"\":\"i\",\"\":\"k\",\"\":\"k\",\"\":\"L\",\"\":\"l\",\"\":\"L\",\"\":\"l\",\"\":\"L\",\"\":\"l\",\"\":\"N\",\"\":\"n\",\"\":\"N\",\"\":\"n\",\"\":\"N\",\"\":\"n\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"OE\",\"\":\"oe\",\"\":\"R\",\"\":\"r\",\"\":\"R\",\"\":\"r\",\"\":\"S\",\"\":\"s\",\"\":\"S\",\"\":\"s\",\"\":\"S\",\"\":\"s\",\"\":\"T\",\"\":\"t\",\"\":\"T\",\"\":\"t\",\"\":\"U\",\"\":\"u\",\"\":\"u\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"W\",\"\":\"w\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"Z\",\"\":\"z\",\"\":\"Z\",\"\":\"z\",\"\":\"Z\",\"\":\"z\",\"\":\"E\",\"\":\"f\",\"\":\"O\",\"\":\"o\",\"\":\"U\",\"\":\"u\",\"\":\"LJ\",\"\":\"lj\",\"\":\"NJ\",\"\":\"nj\",\"\":\"S\",\"\":\"s\",\"\":\"T\",\"\":\"t\",\"\":\"e\",\"\":\"o\",\"\":\"A\",\"\":\"E\",\"\":\"H\",\"\":\"I\",\"\":\"O\",\"\":\"Y\",\"\":\"W\",\"\":\"i\",\"\":\"A\",\"\":\"B\",\"\":\"G\",\"\":\"D\",\"\":\"E\",\"\":\"Z\",\"\":\"H\",\"\":\"8\",\"\":\"I\",\"\":\"K\",\"\":\"L\",\"\":\"M\",\"\":\"N\",\"\":\"3\",\"\":\"O\",\"\":\"P\",\"\":\"R\",\"\":\"S\",\"\":\"T\",\"\":\"Y\",\"\":\"F\",\"\":\"X\",\"\":\"PS\",\"\":\"W\",\"\":\"I\",\"\":\"Y\",\"\":\"a\",\"\":\"e\",\"\":\"h\",\"\":\"i\",\"\":\"y\",\"\":\"a\",\"\":\"b\",\"\":\"g\",\"\":\"d\",\"\":\"e\",\"\":\"z\",\"\":\"h\",\"\":\"8\",\"\":\"i\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"3\",\"\":\"o\",\"\":\"p\",\"\":\"r\",\"\":\"s\",\"\":\"s\",\"\":\"t\",\"\":\"y\",\"\":\"f\",\"\":\"x\",\"\":\"ps\",\"\":\"w\",\"\":\"i\",\"\":\"y\",\"\":\"o\",\"\":\"y\",\"\":\"w\",\"\":\"Yo\",\"\":\"DJ\",\"\":\"Ye\",\"\":\"I\",\"\":\"Yi\",\"\":\"J\",\"\":\"LJ\",\"\":\"NJ\",\"\":\"C\",\"\":\"DZ\",\"\":\"A\",\"\":\"B\",\"\":\"V\",\"\":\"G\",\"\":\"D\",\"\":\"E\",\"\":\"Zh\",\"\":\"Z\",\"\":\"I\",\"\":\"J\",\"\":\"K\",\"\":\"L\",\"\":\"M\",\"\":\"N\",\"\":\"O\",\"\":\"P\",\"\":\"R\",\"\":\"S\",\"\":\"T\",\"\":\"U\",\"\":\"F\",\"\":\"H\",\"\":\"C\",\"\":\"Ch\",\"\":\"Sh\",\"\":\"Sh\",\"\":\"U\",\"\":\"Y\",\"\":\"\",\"\":\"E\",\"\":\"Yu\",\"\":\"Ya\",\"\":\"a\",\"\":\"b\",\"\":\"v\",\"\":\"g\",\"\":\"d\",\"\":\"e\",\"\":\"zh\",\"\":\"z\",\"\":\"i\",\"\":\"j\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"o\",\"\":\"p\",\"\":\"r\",\"\":\"s\",\"\":\"t\",\"\":\"u\",\"\":\"f\",\"\":\"h\",\"\":\"c\",\"\":\"ch\",\"\":\"sh\",\"\":\"sh\",\"\":\"u\",\"\":\"y\",\"\":\"\",\"\":\"e\",\"\":\"yu\",\"\":\"ya\",\"\":\"yo\",\"\":\"dj\",\"\":\"ye\",\"\":\"i\",\"\":\"yi\",\"\":\"j\",\"\":\"lj\",\"\":\"nj\",\"\":\"c\",\"\":\"u\",\"\":\"dz\",\"\":\"G\",\"\":\"g\",\"\":\"GH\",\"\":\"gh\",\"\":\"KH\",\"\":\"kh\",\"\":\"NG\",\"\":\"ng\",\"\":\"UE\",\"\":\"ue\",\"\":\"U\",\"\":\"u\",\"\":\"H\",\"\":\"h\",\"\":\"AE\",\"\":\"ae\",\"\":\"OE\",\"\":\"oe\",\"\":\"A\",\"\":\"B\",\"\":\"G\",\"\":\"D\",\"\":\"E\",\"\":\"Z\",\"\":\"E'\",\"\":\"Y'\",\"\":\"T'\",\"\":\"JH\",\"\":\"I\",\"\":\"L\",\"\":\"X\",\"\":\"C'\",\"\":\"K\",\"\":\"H\",\"\":\"D'\",\"\":\"GH\",\"\":\"TW\",\"\":\"M\",\"\":\"Y\",\"\":\"N\",\"\":\"SH\",\"\":\"CH\",\"\":\"P\",\"\":\"J\",\"\":\"R'\",\"\":\"S\",\"\":\"V\",\"\":\"T\",\"\":\"R\",\"\":\"C\",\"\":\"P'\",\"\":\"Q'\",\"\":\"O''\",\"\":\"F\",\"\":\"EV\",\"\":\"a\",\"\":\"aa\",\"\":\"a\",\"\":\"u\",\"\":\"i\",\"\":\"e\",\"\":\"a\",\"\":\"b\",\"\":\"h\",\"\":\"t\",\"\":\"th\",\"\":\"j\",\"\":\"h\",\"\":\"kh\",\"\":\"d\",\"\":\"th\",\"\":\"r\",\"\":\"z\",\"\":\"s\",\"\":\"sh\",\"\":\"s\",\"\":\"dh\",\"\":\"t\",\"\":\"z\",\"\":\"a\",\"\":\"gh\",\"\":\"f\",\"\":\"q\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"h\",\"\":\"w\",\"\":\"a\",\"\":\"y\",\"\":\"an\",\"\":\"on\",\"\":\"en\",\"\":\"a\",\"\":\"u\",\"\":\"e\",\"\":\"\",\"\":\"0\",\"\":\"1\",\"\":\"2\",\"\":\"3\",\"\":\"4\",\"\":\"5\",\"\":\"6\",\"\":\"7\",\"\":\"8\",\"\":\"9\",\"\":\"p\",\"\":\"ch\",\"\":\"zh\",\"\":\"k\",\"\":\"g\",\"\":\"y\",\"\":\"0\",\"\":\"1\",\"\":\"2\",\"\":\"3\",\"\":\"4\",\"\":\"5\",\"\":\"6\",\"\":\"7\",\"\":\"8\",\"\":\"9\",\"\":\"baht\",\"\":\"a\",\"\":\"b\",\"\":\"g\",\"\":\"d\",\"\":\"e\",\"\":\"v\",\"\":\"z\",\"\":\"t\",\"\":\"i\",\"\":\"k\",\"\":\"l\",\"\":\"m\",\"\":\"n\",\"\":\"o\",\"\":\"p\",\"\":\"zh\",\"\":\"r\",\"\":\"s\",\"\":\"t\",\"\":\"u\",\"\":\"f\",\"\":\"k\",\"\":\"gh\",\"\":\"q\",\"\":\"sh\",\"\":\"ch\",\"\":\"ts\",\"\":\"dz\",\"\":\"ts\",\"\":\"ch\",\"\":\"kh\",\"\":\"j\",\"\":\"h\",\"\":\"S\",\"\":\"s\",\"\":\"W\",\"\":\"w\",\"\":\"W\",\"\":\"w\",\"\":\"W\",\"\":\"w\",\"\":\"SS\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"A\",\"\":\"a\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"E\",\"\":\"e\",\"\":\"I\",\"\":\"i\",\"\":\"I\",\"\":\"i\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"O\",\"\":\"o\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"U\",\"\":\"u\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"-\",\"\":\"'\",\"\":\"'\",\"\":\"\\\"\",\"\":\"\\\"\",\"\":\"\\\"\",\"\":\"+\",\"\":\"*\",\"\":\"...\",\"\":\"ecu\",\"\":\"cruzeiro\",\"\":\"french franc\",\"\":\"lira\",\"\":\"mill\",\"\":\"naira\",\"\":\"peseta\",\"\":\"rupee\",\"\":\"won\",\"\":\"new shequel\",\"\":\"dong\",\"\":\"euro\",\"\":\"kip\",\"\":\"tugrik\",\"\":\"drachma\",\"\":\"penny\",\"\":\"peso\",\"\":\"guarani\",\"\":\"austral\",\"\":\"hryvnia\",\"\":\"cedi\",\"\":\"kazakhstani tenge\",\"\":\"indian rupee\",\"\":\"turkish lira\",\"\":\"russian ruble\",\"\":\"bitcoin\",\"\":\"sm\",\"\":\"tm\",\"\":\"d\",\"\":\"delta\",\"\":\"sum\",\"\":\"infinity\",\"\":\"love\",\"\":\"yuan\",\"\":\"yen\",\"\":\"rial\",\"\":\"laa\",\"\":\"laa\",\"\":\"lai\",\"\":\"la\"}");
		var locales = JSON.parse("{\"bg\":{\"\":\"Y\",\"\":\"Ts\",\"\":\"Sht\",\"\":\"A\",\"\":\"Y\",\"\":\"y\",\"\":\"ts\",\"\":\"sht\",\"\":\"a\",\"\":\"y\"},\"de\":{\"\":\"AE\",\"\":\"ae\",\"\":\"OE\",\"\":\"oe\",\"\":\"UE\",\"\":\"ue\",\"\":\"ss\",\"%\":\"prozent\",\"&\":\"und\",\"|\":\"oder\",\"\":\"summe\",\"\":\"unendlich\",\"\":\"liebe\"},\"es\":{\"%\":\"por ciento\",\"&\":\"y\",\"<\":\"menor que\",\">\":\"mayor que\",\"|\":\"o\",\"\":\"centavos\",\"\":\"libras\",\"\":\"moneda\",\"\":\"francos\",\"\":\"suma\",\"\":\"infinito\",\"\":\"amor\"},\"fr\":{\"%\":\"pourcent\",\"&\":\"et\",\"<\":\"plus petit\",\">\":\"plus grand\",\"|\":\"ou\",\"\":\"centime\",\"\":\"livre\",\"\":\"devise\",\"\":\"franc\",\"\":\"somme\",\"\":\"infini\",\"\":\"amour\"},\"pt\":{\"%\":\"porcento\",\"&\":\"e\",\"<\":\"menor\",\">\":\"maior\",\"|\":\"ou\",\"\":\"centavo\",\"\":\"soma\",\"\":\"libra\",\"\":\"infinito\",\"\":\"amor\"},\"uk\":{\"\":\"Y\",\"\":\"y\",\"\":\"Y\",\"\":\"y\",\"\":\"Ts\",\"\":\"ts\",\"\":\"Kh\",\"\":\"kh\",\"\":\"Shch\",\"\":\"shch\",\"\":\"H\",\"\":\"h\"},\"vi\":{\"\":\"D\",\"\":\"d\"},\"da\":{\"\":\"OE\",\"\":\"oe\",\"\":\"AA\",\"\":\"aa\",\"%\":\"procent\",\"&\":\"og\",\"|\":\"eller\",\"$\":\"dollar\",\"<\":\"mindre end\",\">\":\"strre end\"},\"nb\":{\"&\":\"og\",\"\":\"AA\",\"\":\"AE\",\"\":\"OE\",\"\":\"aa\",\"\":\"ae\",\"\":\"oe\"},\"it\":{\"&\":\"e\"},\"nl\":{\"&\":\"en\"},\"sv\":{\"&\":\"och\",\"\":\"AA\",\"\":\"AE\",\"\":\"OE\",\"\":\"aa\",\"\":\"ae\",\"\":\"oe\"}}");
		function replace$2(string, options) {
			if (typeof string !== "string") throw new Error("slugify: string argument expected");
			options = typeof options === "string" ? { replacement: options } : options || {};
			var locale = locales[options.locale] || {};
			var replacement = options.replacement === void 0 ? "-" : options.replacement;
			var trim$4 = options.trim === void 0 ? true : options.trim;
			var slug = string.normalize().split("").reduce(function(result, ch) {
				var appendChar = locale[ch];
				if (appendChar === void 0) appendChar = charMap[ch];
				if (appendChar === void 0) appendChar = ch;
				if (appendChar === replacement) appendChar = " ";
				return result + appendChar.replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
			}, "");
			if (options.strict) slug = slug.replace(/[^A-Za-z0-9\s]/g, "");
			if (trim$4) slug = slug.trim();
			slug = slug.replace(/\s+/g, replacement);
			if (options.lower) slug = slug.toLowerCase();
			return slug;
		}
		replace$2.extend = function(customMap) {
			Object.assign(charMap, customMap);
		};
		return replace$2;
	});
}) });

//#endregion
//#region ../../node_modules/.pnpm/route-recognizer@0.3.4/node_modules/route-recognizer/dist/route-recognizer.js
var require_route_recognizer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/route-recognizer@0.3.4/node_modules/route-recognizer/dist/route-recognizer.js": ((exports, module) => {
	(function(global$1, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define("route-recognizer", factory) : global$1.RouteRecognizer = factory();
	})(exports, (function() {
		var createObject = Object.create;
		function createMap() {
			var map$3 = createObject(null);
			map$3["__"] = void 0;
			delete map$3["__"];
			return map$3;
		}
		var Target = function Target$1(path$19, matcher, delegate) {
			this.path = path$19;
			this.matcher = matcher;
			this.delegate = delegate;
		};
		Target.prototype.to = function to(target, callback) {
			var delegate = this.delegate;
			if (delegate && delegate.willAddRoute) target = delegate.willAddRoute(this.matcher.target, target);
			this.matcher.add(this.path, target);
			if (callback) {
				if (callback.length === 0) throw new Error("You must have an argument in the function passed to `to`");
				this.matcher.addChild(this.path, target, callback, this.delegate);
			}
		};
		var Matcher = function Matcher$1(target) {
			this.routes = createMap();
			this.children = createMap();
			this.target = target;
		};
		Matcher.prototype.add = function add(path$19, target) {
			this.routes[path$19] = target;
		};
		Matcher.prototype.addChild = function addChild(path$19, target, callback, delegate) {
			var matcher = new Matcher(target);
			this.children[path$19] = matcher;
			var match$1 = generateMatch(path$19, matcher, delegate);
			if (delegate && delegate.contextEntered) delegate.contextEntered(target, match$1);
			callback(match$1);
		};
		function generateMatch(startingPath, matcher, delegate) {
			function match$1(path$19, callback) {
				var fullPath = startingPath + path$19;
				if (callback) callback(generateMatch(fullPath, matcher, delegate));
				else return new Target(fullPath, matcher, delegate);
			}
			return match$1;
		}
		function addRoute(routeArray, path$19, handler) {
			var len$1 = 0;
			for (var i$8 = 0; i$8 < routeArray.length; i$8++) len$1 += routeArray[i$8].path.length;
			path$19 = path$19.substr(len$1);
			var route = {
				path: path$19,
				handler
			};
			routeArray.push(route);
		}
		function eachRoute(baseRoute, matcher, callback, binding) {
			var routes = matcher.routes;
			var paths = Object.keys(routes);
			for (var i$8 = 0; i$8 < paths.length; i$8++) {
				var path$19 = paths[i$8];
				var routeArray = baseRoute.slice();
				addRoute(routeArray, path$19, routes[path$19]);
				var nested = matcher.children[path$19];
				if (nested) eachRoute(routeArray, nested, callback, binding);
				else callback.call(binding, routeArray);
			}
		}
		var map$2 = function(callback, addRouteCallback) {
			var matcher = new Matcher();
			callback(generateMatch("", matcher, this.delegate));
			eachRoute([], matcher, function(routes) {
				if (addRouteCallback) addRouteCallback(this, routes);
				else this.add(routes);
			}, this);
		};
		function normalizePath(path$19) {
			return path$19.split("/").map(normalizeSegment).join("/");
		}
		var SEGMENT_RESERVED_CHARS = /%|\//g;
		function normalizeSegment(segment) {
			if (segment.length < 3 || segment.indexOf("%") === -1) return segment;
			return decodeURIComponent(segment).replace(SEGMENT_RESERVED_CHARS, encodeURIComponent);
		}
		var PATH_SEGMENT_ENCODINGS = /%(?:2(?:4|6|B|C)|3(?:B|D|A)|40)/g;
		function encodePathSegment(str) {
			return encodeURIComponent(str).replace(PATH_SEGMENT_ENCODINGS, decodeURIComponent);
		}
		var escapeRegex = /(\/|\.|\*|\+|\?|\||\(|\)|\[|\]|\{|\}|\\)/g;
		var isArray$11 = Array.isArray;
		var hasOwnProperty$11 = Object.prototype.hasOwnProperty;
		function getParam(params, key$1) {
			if (typeof params !== "object" || params === null) throw new Error("You must pass an object as the second argument to `generate`.");
			if (!hasOwnProperty$11.call(params, key$1)) throw new Error("You must provide param `" + key$1 + "` to `generate`.");
			var value = params[key$1];
			var str = typeof value === "string" ? value : "" + value;
			if (str.length === 0) throw new Error("You must provide a param `" + key$1 + "`.");
			return str;
		}
		var eachChar = [];
		eachChar[0] = function(segment, currentState) {
			var state = currentState;
			var value = segment.value;
			for (var i$8 = 0; i$8 < value.length; i$8++) {
				var ch = value.charCodeAt(i$8);
				state = state.put(ch, false, false);
			}
			return state;
		};
		eachChar[1] = function(_, currentState) {
			return currentState.put(47, true, true);
		};
		eachChar[2] = function(_, currentState) {
			return currentState.put(-1, false, true);
		};
		eachChar[4] = function(_, currentState) {
			return currentState;
		};
		var regex = [];
		regex[0] = function(segment) {
			return segment.value.replace(escapeRegex, "\\$1");
		};
		regex[1] = function() {
			return "([^/]+)";
		};
		regex[2] = function() {
			return "(.+)";
		};
		regex[4] = function() {
			return "";
		};
		var generate = [];
		generate[0] = function(segment) {
			return segment.value;
		};
		generate[1] = function(segment, params) {
			var value = getParam(params, segment.value);
			if (RouteRecognizer$1.ENCODE_AND_DECODE_PATH_SEGMENTS) return encodePathSegment(value);
			else return value;
		};
		generate[2] = function(segment, params) {
			return getParam(params, segment.value);
		};
		generate[4] = function() {
			return "";
		};
		var EmptyObject = Object.freeze({});
		var EmptyArray = Object.freeze([]);
		function parse$18(segments, route, types) {
			if (route.length > 0 && route.charCodeAt(0) === 47) route = route.substr(1);
			var parts = route.split("/");
			var names = void 0;
			var shouldDecodes = void 0;
			for (var i$8 = 0; i$8 < parts.length; i$8++) {
				var part = parts[i$8];
				var flags = 0;
				var type = 0;
				if (part === "") type = 4;
				else if (part.charCodeAt(0) === 58) type = 1;
				else if (part.charCodeAt(0) === 42) type = 2;
				else type = 0;
				flags = 2 << type;
				if (flags & 12) {
					part = part.slice(1);
					names = names || [];
					names.push(part);
					shouldDecodes = shouldDecodes || [];
					shouldDecodes.push((flags & 4) !== 0);
				}
				if (flags & 14) types[type]++;
				segments.push({
					type,
					value: normalizeSegment(part)
				});
			}
			return {
				names: names || EmptyArray,
				shouldDecodes: shouldDecodes || EmptyArray
			};
		}
		function isEqualCharSpec(spec, char, negate) {
			return spec.char === char && spec.negate === negate;
		}
		var State = function State$1(states, id$7, char, negate, repeat) {
			this.states = states;
			this.id = id$7;
			this.char = char;
			this.negate = negate;
			this.nextStates = repeat ? id$7 : null;
			this.pattern = "";
			this._regex = void 0;
			this.handlers = void 0;
			this.types = void 0;
		};
		State.prototype.regex = function regex$1() {
			if (!this._regex) this._regex = new RegExp(this.pattern);
			return this._regex;
		};
		State.prototype.get = function get$1(char, negate) {
			var this$1 = this;
			var nextStates = this.nextStates;
			if (nextStates === null) return;
			if (isArray$11(nextStates)) for (var i$8 = 0; i$8 < nextStates.length; i$8++) {
				var child = this$1.states[nextStates[i$8]];
				if (isEqualCharSpec(child, char, negate)) return child;
			}
			else {
				var child$1 = this.states[nextStates];
				if (isEqualCharSpec(child$1, char, negate)) return child$1;
			}
		};
		State.prototype.put = function put(char, negate, repeat) {
			var state;
			if (state = this.get(char, negate)) return state;
			var states = this.states;
			state = new State(states, states.length, char, negate, repeat);
			states[states.length] = state;
			if (this.nextStates == null) this.nextStates = state.id;
			else if (isArray$11(this.nextStates)) this.nextStates.push(state.id);
			else this.nextStates = [this.nextStates, state.id];
			return state;
		};
		State.prototype.match = function match$1(ch) {
			var this$1 = this;
			var nextStates = this.nextStates;
			if (!nextStates) return [];
			var returned = [];
			if (isArray$11(nextStates)) for (var i$8 = 0; i$8 < nextStates.length; i$8++) {
				var child = this$1.states[nextStates[i$8]];
				if (isMatch(child, ch)) returned.push(child);
			}
			else {
				var child$1 = this.states[nextStates];
				if (isMatch(child$1, ch)) returned.push(child$1);
			}
			return returned;
		};
		function isMatch(spec, char) {
			return spec.negate ? spec.char !== char && spec.char !== -1 : spec.char === char || spec.char === -1;
		}
		function sortSolutions(states) {
			return states.sort(function(a, b) {
				var ref = a.types || [
					0,
					0,
					0
				];
				var astatics = ref[0];
				var adynamics = ref[1];
				var astars = ref[2];
				var ref$1 = b.types || [
					0,
					0,
					0
				];
				var bstatics = ref$1[0];
				var bdynamics = ref$1[1];
				var bstars = ref$1[2];
				if (astars !== bstars) return astars - bstars;
				if (astars) {
					if (astatics !== bstatics) return bstatics - astatics;
					if (adynamics !== bdynamics) return bdynamics - adynamics;
				}
				if (adynamics !== bdynamics) return adynamics - bdynamics;
				if (astatics !== bstatics) return bstatics - astatics;
				return 0;
			});
		}
		function recognizeChar(states, ch) {
			var nextStates = [];
			for (var i$8 = 0, l = states.length; i$8 < l; i$8++) {
				var state = states[i$8];
				nextStates = nextStates.concat(state.match(ch));
			}
			return nextStates;
		}
		var RecognizeResults = function RecognizeResults$1(queryParams) {
			this.length = 0;
			this.queryParams = queryParams || {};
		};
		RecognizeResults.prototype.splice = Array.prototype.splice;
		RecognizeResults.prototype.slice = Array.prototype.slice;
		RecognizeResults.prototype.push = Array.prototype.push;
		function findHandler(state, originalPath, queryParams) {
			var handlers = state.handlers;
			var regex$1 = state.regex();
			if (!regex$1 || !handlers) throw new Error("state not initialized");
			var captures = originalPath.match(regex$1);
			var currentCapture = 1;
			var result = new RecognizeResults(queryParams);
			result.length = handlers.length;
			for (var i$8 = 0; i$8 < handlers.length; i$8++) {
				var handler = handlers[i$8];
				var names = handler.names;
				var shouldDecodes = handler.shouldDecodes;
				var params = EmptyObject;
				var isDynamic = false;
				if (names !== EmptyArray && shouldDecodes !== EmptyArray) for (var j$7 = 0; j$7 < names.length; j$7++) {
					isDynamic = true;
					var name = names[j$7];
					var capture = captures && captures[currentCapture++];
					if (params === EmptyObject) params = {};
					if (RouteRecognizer$1.ENCODE_AND_DECODE_PATH_SEGMENTS && shouldDecodes[j$7]) params[name] = capture && decodeURIComponent(capture);
					else params[name] = capture;
				}
				result[i$8] = {
					handler: handler.handler,
					params,
					isDynamic
				};
			}
			return result;
		}
		function decodeQueryParamPart(part) {
			part = part.replace(/\+/gm, "%20");
			var result;
			try {
				result = decodeURIComponent(part);
			} catch (error) {
				result = "";
			}
			return result;
		}
		var RouteRecognizer$1 = function RouteRecognizer$2() {
			this.names = createMap();
			var states = [];
			var state = new State(states, 0, -1, true, false);
			states[0] = state;
			this.states = states;
			this.rootState = state;
		};
		RouteRecognizer$1.prototype.add = function add(routes, options) {
			var currentState = this.rootState;
			var pattern = "^";
			var types = [
				0,
				0,
				0
			];
			var handlers = new Array(routes.length);
			var allSegments = [];
			var isEmpty = true;
			var j$7 = 0;
			for (var i$8 = 0; i$8 < routes.length; i$8++) {
				var route = routes[i$8];
				var ref = parse$18(allSegments, route.path, types);
				var names = ref.names;
				var shouldDecodes = ref.shouldDecodes;
				for (; j$7 < allSegments.length; j$7++) {
					var segment = allSegments[j$7];
					if (segment.type === 4) continue;
					isEmpty = false;
					currentState = currentState.put(47, false, false);
					pattern += "/";
					currentState = eachChar[segment.type](segment, currentState);
					pattern += regex[segment.type](segment);
				}
				handlers[i$8] = {
					handler: route.handler,
					names,
					shouldDecodes
				};
			}
			if (isEmpty) {
				currentState = currentState.put(47, false, false);
				pattern += "/";
			}
			currentState.handlers = handlers;
			currentState.pattern = pattern + "$";
			currentState.types = types;
			var name;
			if (typeof options === "object" && options !== null && options.as) name = options.as;
			if (name) this.names[name] = {
				segments: allSegments,
				handlers
			};
		};
		RouteRecognizer$1.prototype.handlersFor = function handlersFor(name) {
			var route = this.names[name];
			if (!route) throw new Error("There is no route named " + name);
			var result = new Array(route.handlers.length);
			for (var i$8 = 0; i$8 < route.handlers.length; i$8++) result[i$8] = route.handlers[i$8];
			return result;
		};
		RouteRecognizer$1.prototype.hasRoute = function hasRoute(name) {
			return !!this.names[name];
		};
		RouteRecognizer$1.prototype.generate = function generate$1(name, params) {
			var route = this.names[name];
			var output = "";
			if (!route) throw new Error("There is no route named " + name);
			var segments = route.segments;
			for (var i$8 = 0; i$8 < segments.length; i$8++) {
				var segment = segments[i$8];
				if (segment.type === 4) continue;
				output += "/";
				output += generate[segment.type](segment, params);
			}
			if (output.charAt(0) !== "/") output = "/" + output;
			if (params && params.queryParams) output += this.generateQueryString(params.queryParams);
			return output;
		};
		RouteRecognizer$1.prototype.generateQueryString = function generateQueryString(params) {
			var pairs = [];
			var keys$6 = Object.keys(params);
			keys$6.sort();
			for (var i$8 = 0; i$8 < keys$6.length; i$8++) {
				var key$1 = keys$6[i$8];
				var value = params[key$1];
				if (value == null) continue;
				var pair = encodeURIComponent(key$1);
				if (isArray$11(value)) for (var j$7 = 0; j$7 < value.length; j$7++) {
					var arrayPair = key$1 + "[]=" + encodeURIComponent(value[j$7]);
					pairs.push(arrayPair);
				}
				else {
					pair += "=" + encodeURIComponent(value);
					pairs.push(pair);
				}
			}
			if (pairs.length === 0) return "";
			return "?" + pairs.join("&");
		};
		RouteRecognizer$1.prototype.parseQueryString = function parseQueryString(queryString) {
			var pairs = queryString.split("&");
			var queryParams = {};
			for (var i$8 = 0; i$8 < pairs.length; i$8++) {
				var pair = pairs[i$8].split("="), key$1 = decodeQueryParamPart(pair[0]), keyLength = key$1.length, isArray$12 = false, value = void 0;
				if (pair.length === 1) value = "true";
				else {
					if (keyLength > 2 && key$1.slice(keyLength - 2) === "[]") {
						isArray$12 = true;
						key$1 = key$1.slice(0, keyLength - 2);
						if (!queryParams[key$1]) queryParams[key$1] = [];
					}
					value = pair[1] ? decodeQueryParamPart(pair[1]) : "";
				}
				if (isArray$12) queryParams[key$1].push(value);
				else queryParams[key$1] = value;
			}
			return queryParams;
		};
		RouteRecognizer$1.prototype.recognize = function recognize(path$19) {
			var results;
			var states = [this.rootState];
			var queryParams = {};
			var isSlashDropped = false;
			var hashStart = path$19.indexOf("#");
			if (hashStart !== -1) path$19 = path$19.substr(0, hashStart);
			var queryStart = path$19.indexOf("?");
			if (queryStart !== -1) {
				var queryString = path$19.substr(queryStart + 1, path$19.length);
				path$19 = path$19.substr(0, queryStart);
				queryParams = this.parseQueryString(queryString);
			}
			if (path$19.charAt(0) !== "/") path$19 = "/" + path$19;
			var originalPath = path$19;
			if (RouteRecognizer$1.ENCODE_AND_DECODE_PATH_SEGMENTS) path$19 = normalizePath(path$19);
			else {
				path$19 = decodeURI(path$19);
				originalPath = decodeURI(originalPath);
			}
			var pathLen = path$19.length;
			if (pathLen > 1 && path$19.charAt(pathLen - 1) === "/") {
				path$19 = path$19.substr(0, pathLen - 1);
				originalPath = originalPath.substr(0, originalPath.length - 1);
				isSlashDropped = true;
			}
			for (var i$8 = 0; i$8 < path$19.length; i$8++) {
				states = recognizeChar(states, path$19.charCodeAt(i$8));
				if (!states.length) break;
			}
			var solutions = [];
			for (var i$1$2 = 0; i$1$2 < states.length; i$1$2++) if (states[i$1$2].handlers) solutions.push(states[i$1$2]);
			states = sortSolutions(solutions);
			var state = solutions[0];
			if (state && state.handlers) {
				if (isSlashDropped && state.pattern && state.pattern.slice(-5) === "(.+)$") originalPath = originalPath + "/";
				results = findHandler(state, originalPath, queryParams);
			}
			return results;
		};
		RouteRecognizer$1.VERSION = "0.3.4";
		RouteRecognizer$1.ENCODE_AND_DECODE_PATH_SEGMENTS = true;
		RouteRecognizer$1.Normalizer = {
			normalizeSegment,
			normalizePath,
			encodePathSegment
		};
		RouteRecognizer$1.prototype.map = map$2;
		return RouteRecognizer$1;
	}));
}) });

//#endregion
//#region ../../node_modules/.pnpm/@pollyjs+core@6.0.6/node_modules/@pollyjs/core/dist/cjs/pollyjs-core.js
var require_pollyjs_core = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/@pollyjs+core@6.0.6/node_modules/@pollyjs/core/dist/cjs/pollyjs-core.js": ((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function _interopDefault$5(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var utils$7 = require_pollyjs_utils();
	var logLevel = _interopDefault$5(require_loglevel());
	var md5 = _interopDefault$5(require_md5());
	var stringify$11 = _interopDefault$5(require_fast_json_stable_stringify());
	var isAbsoluteUrl = _interopDefault$5(require_is_absolute_url());
	var fnv1a = _interopDefault$5(require_fnv1a());
	var slugify = _interopDefault$5(require_slugify());
	var RouteRecognizer = _interopDefault$5(require_route_recognizer());
	function unwrapExports$5(x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
	}
	function createCommonjsModule$5(fn, module$2) {
		return module$2 = { exports: {} }, fn(module$2, module$2.exports), module$2.exports;
	}
	function getCjsExportFromNamespace$3(n) {
		return n && n["default"] || n;
	}
	var _global$5 = createCommonjsModule$5(function(module$2) {
		var global$1 = module$2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
		if (typeof __g == "number") __g = global$1;
	});
	var hasOwnProperty$9 = {}.hasOwnProperty;
	var _has$5 = function(it, key$1) {
		return hasOwnProperty$9.call(it, key$1);
	};
	var _fails$5 = function(exec) {
		try {
			return !!exec();
		} catch (e) {
			return true;
		}
	};
	var _descriptors$5 = !_fails$5(function() {
		return Object.defineProperty({}, "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var _core$5 = createCommonjsModule$5(function(module$2) {
		var core = module$2.exports = { version: "2.6.9" };
		if (typeof __e == "number") __e = core;
	});
	_core$5.version;
	var _aFunction$5 = function(it) {
		if (typeof it != "function") throw TypeError(it + " is not a function!");
		return it;
	};
	var _ctx$5 = function(fn, that, length) {
		_aFunction$5(fn);
		if (that === void 0) return fn;
		switch (length) {
			case 1: return function(a) {
				return fn.call(that, a);
			};
			case 2: return function(a, b) {
				return fn.call(that, a, b);
			};
			case 3: return function(a, b, c) {
				return fn.call(that, a, b, c);
			};
		}
		return function() {
			return fn.apply(that, arguments);
		};
	};
	var _isObject$5 = function(it) {
		return typeof it === "object" ? it !== null : typeof it === "function";
	};
	var _anObject$5 = function(it) {
		if (!_isObject$5(it)) throw TypeError(it + " is not an object!");
		return it;
	};
	var document$1$6 = _global$5.document;
	var is$6 = _isObject$5(document$1$6) && _isObject$5(document$1$6.createElement);
	var _domCreate$5 = function(it) {
		return is$6 ? document$1$6.createElement(it) : {};
	};
	var _ie8DomDefine$5 = !_descriptors$5 && !_fails$5(function() {
		return Object.defineProperty(_domCreate$5("div"), "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var _toPrimitive$5 = function(it, S) {
		if (!_isObject$5(it)) return it;
		var fn, val;
		if (S && typeof (fn = it.toString) == "function" && !_isObject$5(val = fn.call(it))) return val;
		if (typeof (fn = it.valueOf) == "function" && !_isObject$5(val = fn.call(it))) return val;
		if (!S && typeof (fn = it.toString) == "function" && !_isObject$5(val = fn.call(it))) return val;
		throw TypeError("Can't convert object to primitive value");
	};
	var dP$5 = Object.defineProperty;
	var _objectDp$5 = { f: _descriptors$5 ? Object.defineProperty : function defineProperty$8(O, P, Attributes) {
		_anObject$5(O);
		P = _toPrimitive$5(P, true);
		_anObject$5(Attributes);
		if (_ie8DomDefine$5) try {
			return dP$5(O, P, Attributes);
		} catch (e) {}
		if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
		if ("value" in Attributes) O[P] = Attributes.value;
		return O;
	} };
	var _propertyDesc$5 = function(bitmap, value) {
		return {
			enumerable: !(bitmap & 1),
			configurable: !(bitmap & 2),
			writable: !(bitmap & 4),
			value
		};
	};
	var _hide$5 = _descriptors$5 ? function(object, key$1, value) {
		return _objectDp$5.f(object, key$1, _propertyDesc$5(1, value));
	} : function(object, key$1, value) {
		object[key$1] = value;
		return object;
	};
	var PROTOTYPE$8 = "prototype";
	var $export$5 = function(type, name, source) {
		var IS_FORCED = type & $export$5.F;
		var IS_GLOBAL = type & $export$5.G;
		var IS_STATIC = type & $export$5.S;
		var IS_PROTO = type & $export$5.P;
		var IS_BIND = type & $export$5.B;
		var IS_WRAP = type & $export$5.W;
		var exports$1 = IS_GLOBAL ? _core$5 : _core$5[name] || (_core$5[name] = {});
		var expProto = exports$1[PROTOTYPE$8];
		var target = IS_GLOBAL ? _global$5 : IS_STATIC ? _global$5[name] : (_global$5[name] || {})[PROTOTYPE$8];
		var key$1, own, out;
		if (IS_GLOBAL) source = name;
		for (key$1 in source) {
			own = !IS_FORCED && target && target[key$1] !== void 0;
			if (own && _has$5(exports$1, key$1)) continue;
			out = own ? target[key$1] : source[key$1];
			exports$1[key$1] = IS_GLOBAL && typeof target[key$1] != "function" ? source[key$1] : IS_BIND && own ? _ctx$5(out, _global$5) : IS_WRAP && target[key$1] == out ? (function(C) {
				var F = function(a, b, c) {
					if (this instanceof C) {
						switch (arguments.length) {
							case 0: return new C();
							case 1: return new C(a);
							case 2: return new C(a, b);
						}
						return new C(a, b, c);
					}
					return C.apply(this, arguments);
				};
				F[PROTOTYPE$8] = C[PROTOTYPE$8];
				return F;
			})(out) : IS_PROTO && typeof out == "function" ? _ctx$5(Function.call, out) : out;
			if (IS_PROTO) {
				(exports$1.virtual || (exports$1.virtual = {}))[key$1] = out;
				if (type & $export$5.R && expProto && !expProto[key$1]) _hide$5(expProto, key$1, out);
			}
		}
	};
	$export$5.F = 1;
	$export$5.G = 2;
	$export$5.S = 4;
	$export$5.P = 8;
	$export$5.B = 16;
	$export$5.W = 32;
	$export$5.U = 64;
	$export$5.R = 128;
	var _export$5 = $export$5;
	var _redefine$5 = _hide$5;
	var id$5 = 0;
	var px$5 = Math.random();
	var _uid$5 = function(key$1) {
		return "Symbol(".concat(key$1 === void 0 ? "" : key$1, ")_", (++id$5 + px$5).toString(36));
	};
	var _meta$5 = createCommonjsModule$5(function(module$2) {
		var META$7 = _uid$5("meta");
		var setDesc = _objectDp$5.f;
		var id$7 = 0;
		var isExtensible = Object.isExtensible || function() {
			return true;
		};
		var FREEZE = !_fails$5(function() {
			return isExtensible(Object.preventExtensions({}));
		});
		var setMeta = function(it) {
			setDesc(it, META$7, { value: {
				i: "O" + ++id$7,
				w: {}
			} });
		};
		var fastKey$2 = function(it, create) {
			if (!_isObject$5(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
			if (!_has$5(it, META$7)) {
				if (!isExtensible(it)) return "F";
				if (!create) return "E";
				setMeta(it);
			}
			return it[META$7].i;
		};
		var getWeak$2 = function(it, create) {
			if (!_has$5(it, META$7)) {
				if (!isExtensible(it)) return true;
				if (!create) return false;
				setMeta(it);
			}
			return it[META$7].w;
		};
		var onFreeze = function(it) {
			if (FREEZE && meta.NEED && isExtensible(it) && !_has$5(it, META$7)) setMeta(it);
			return it;
		};
		var meta = module$2.exports = {
			KEY: META$7,
			NEED: false,
			fastKey: fastKey$2,
			getWeak: getWeak$2,
			onFreeze
		};
	});
	_meta$5.KEY;
	_meta$5.NEED;
	_meta$5.fastKey;
	_meta$5.getWeak;
	_meta$5.onFreeze;
	var _library$5 = true;
	var _shared$5 = createCommonjsModule$5(function(module$2) {
		var SHARED = "__core-js_shared__";
		var store = _global$5[SHARED] || (_global$5[SHARED] = {});
		(module$2.exports = function(key$1, value) {
			return store[key$1] || (store[key$1] = value !== void 0 ? value : {});
		})("versions", []).push({
			version: _core$5.version,
			mode: "pure",
			copyright: " 2019 Denis Pushkarev (zloirock.ru)"
		});
	});
	var _wks$5 = createCommonjsModule$5(function(module$2) {
		var store = _shared$5("wks");
		var Symbol$2 = _global$5.Symbol;
		var USE_SYMBOL = typeof Symbol$2 == "function";
		var $exports = module$2.exports = function(name) {
			return store[name] || (store[name] = USE_SYMBOL && Symbol$2[name] || (USE_SYMBOL ? Symbol$2 : _uid$5)("Symbol." + name));
		};
		$exports.store = store;
	});
	var def$5 = _objectDp$5.f;
	var TAG$5 = _wks$5("toStringTag");
	var _setToStringTag$5 = function(it, tag, stat$4) {
		if (it && !_has$5(it = stat$4 ? it : it.prototype, TAG$5)) def$5(it, TAG$5, {
			configurable: true,
			value: tag
		});
	};
	var _wksExt$5 = { f: _wks$5 };
	var defineProperty$9 = _objectDp$5.f;
	var _wksDefine$5 = function(name) {
		var $Symbol$7 = _core$5.Symbol || (_core$5.Symbol = {});
		if (name.charAt(0) != "_" && !(name in $Symbol$7)) defineProperty$9($Symbol$7, name, { value: _wksExt$5.f(name) });
	};
	var toString$8 = {}.toString;
	var _cof$5 = function(it) {
		return toString$8.call(it).slice(8, -1);
	};
	var _iobject$5 = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
		return _cof$5(it) == "String" ? it.split("") : Object(it);
	};
	var _defined$5 = function(it) {
		if (it == void 0) throw TypeError("Can't call method on  " + it);
		return it;
	};
	var _toIobject$5 = function(it) {
		return _iobject$5(_defined$5(it));
	};
	var ceil$5 = Math.ceil;
	var floor$5 = Math.floor;
	var _toInteger$5 = function(it) {
		return isNaN(it = +it) ? 0 : (it > 0 ? floor$5 : ceil$5)(it);
	};
	var min$5 = Math.min;
	var _toLength$5 = function(it) {
		return it > 0 ? min$5(_toInteger$5(it), 9007199254740991) : 0;
	};
	var max$5 = Math.max;
	var min$1$9 = Math.min;
	var _toAbsoluteIndex$5 = function(index$1, length) {
		index$1 = _toInteger$5(index$1);
		return index$1 < 0 ? max$5(index$1 + length, 0) : min$1$9(index$1, length);
	};
	var _arrayIncludes$5 = function(IS_INCLUDES) {
		return function($this, el, fromIndex) {
			var O = _toIobject$5($this);
			var length = _toLength$5(O.length);
			var index$1 = _toAbsoluteIndex$5(fromIndex, length);
			var value;
			if (IS_INCLUDES && el != el) while (length > index$1) {
				value = O[index$1++];
				if (value != value) return true;
			}
			else for (; length > index$1; index$1++) if (IS_INCLUDES || index$1 in O) {
				if (O[index$1] === el) return IS_INCLUDES || index$1 || 0;
			}
			return !IS_INCLUDES && -1;
		};
	};
	var shared$5 = _shared$5("keys");
	var _sharedKey$5 = function(key$1) {
		return shared$5[key$1] || (shared$5[key$1] = _uid$5(key$1));
	};
	var arrayIndexOf$5 = _arrayIncludes$5(false);
	var IE_PROTO$8 = _sharedKey$5("IE_PROTO");
	var _objectKeysInternal$5 = function(object, names) {
		var O = _toIobject$5(object);
		var i$8 = 0;
		var result = [];
		var key$1;
		for (key$1 in O) if (key$1 != IE_PROTO$8) _has$5(O, key$1) && result.push(key$1);
		while (names.length > i$8) if (_has$5(O, key$1 = names[i$8++])) ~arrayIndexOf$5(result, key$1) || result.push(key$1);
		return result;
	};
	var _enumBugKeys$5 = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
	var _objectKeys$5 = Object.keys || function keys$6(O) {
		return _objectKeysInternal$5(O, _enumBugKeys$5);
	};
	var _objectGops$5 = { f: Object.getOwnPropertySymbols };
	var _objectPie$5 = { f: {}.propertyIsEnumerable };
	var _enumKeys$5 = function(it) {
		var result = _objectKeys$5(it);
		var getSymbols = _objectGops$5.f;
		if (getSymbols) {
			var symbols = getSymbols(it);
			var isEnum$7 = _objectPie$5.f;
			var i$8 = 0;
			var key$1;
			while (symbols.length > i$8) if (isEnum$7.call(it, key$1 = symbols[i$8++])) result.push(key$1);
		}
		return result;
	};
	var _isArray$5 = Array.isArray || function isArray$11(arg) {
		return _cof$5(arg) == "Array";
	};
	var _toObject$5 = function(it) {
		return Object(_defined$5(it));
	};
	var _objectDps$5 = _descriptors$5 ? Object.defineProperties : function defineProperties(O, Properties) {
		_anObject$5(O);
		var keys$6 = _objectKeys$5(Properties);
		var length = keys$6.length;
		var i$8 = 0;
		var P;
		while (length > i$8) _objectDp$5.f(O, P = keys$6[i$8++], Properties[P]);
		return O;
	};
	var document$2$4 = _global$5.document;
	var _html$5 = document$2$4 && document$2$4.documentElement;
	var IE_PROTO$1$9 = _sharedKey$5("IE_PROTO");
	var Empty$5 = function() {};
	var PROTOTYPE$1$10 = "prototype";
	var createDict$5 = function() {
		var iframe = _domCreate$5("iframe");
		var i$8 = _enumBugKeys$5.length;
		var lt = "<";
		var gt = ">";
		var iframeDocument;
		iframe.style.display = "none";
		_html$5.appendChild(iframe);
		iframe.src = "javascript:";
		iframeDocument = iframe.contentWindow.document;
		iframeDocument.open();
		iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
		iframeDocument.close();
		createDict$5 = iframeDocument.F;
		while (i$8--) delete createDict$5[PROTOTYPE$1$10][_enumBugKeys$5[i$8]];
		return createDict$5();
	};
	var _objectCreate$5 = Object.create || function create(O, Properties) {
		var result;
		if (O !== null) {
			Empty$5[PROTOTYPE$1$10] = _anObject$5(O);
			result = new Empty$5();
			Empty$5[PROTOTYPE$1$10] = null;
			result[IE_PROTO$1$9] = O;
		} else result = createDict$5();
		return Properties === void 0 ? result : _objectDps$5(result, Properties);
	};
	var hiddenKeys$5 = _enumBugKeys$5.concat("length", "prototype");
	var _objectGopn$5 = { f: Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		return _objectKeysInternal$5(O, hiddenKeys$5);
	} };
	var gOPN$5 = _objectGopn$5.f;
	var toString$1$12 = {}.toString;
	var windowNames$5 = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
	var getWindowNames$5 = function(it) {
		try {
			return gOPN$5(it);
		} catch (e) {
			return windowNames$5.slice();
		}
	};
	var _objectGopnExt$5 = { f: function getOwnPropertyNames(it) {
		return windowNames$5 && toString$1$12.call(it) == "[object Window]" ? getWindowNames$5(it) : gOPN$5(_toIobject$5(it));
	} };
	var gOPD$5 = Object.getOwnPropertyDescriptor;
	var _objectGopd$5 = { f: _descriptors$5 ? gOPD$5 : function getOwnPropertyDescriptor(O, P) {
		O = _toIobject$5(O);
		P = _toPrimitive$5(P, true);
		if (_ie8DomDefine$5) try {
			return gOPD$5(O, P);
		} catch (e) {}
		if (_has$5(O, P)) return _propertyDesc$5(!_objectPie$5.f.call(O, P), O[P]);
	} };
	var META$5 = _meta$5.KEY;
	var gOPD$1$9 = _objectGopd$5.f;
	var dP$1$10 = _objectDp$5.f;
	var gOPN$1$9 = _objectGopnExt$5.f;
	var $Symbol$5 = _global$5.Symbol;
	var $JSON$5 = _global$5.JSON;
	var _stringify$5 = $JSON$5 && $JSON$5.stringify;
	var PROTOTYPE$2$9 = "prototype";
	var HIDDEN$5 = _wks$5("_hidden");
	var TO_PRIMITIVE$5 = _wks$5("toPrimitive");
	var isEnum$5 = {}.propertyIsEnumerable;
	var SymbolRegistry$5 = _shared$5("symbol-registry");
	var AllSymbols$5 = _shared$5("symbols");
	var OPSymbols$5 = _shared$5("op-symbols");
	var ObjectProto$5 = Object[PROTOTYPE$2$9];
	var USE_NATIVE$5 = typeof $Symbol$5 == "function" && !!_objectGops$5.f;
	var QObject$5 = _global$5.QObject;
	var setter$5 = !QObject$5 || !QObject$5[PROTOTYPE$2$9] || !QObject$5[PROTOTYPE$2$9].findChild;
	var setSymbolDesc$5 = _descriptors$5 && _fails$5(function() {
		return _objectCreate$5(dP$1$10({}, "a", { get: function() {
			return dP$1$10(this, "a", { value: 7 }).a;
		} })).a != 7;
	}) ? function(it, key$1, D) {
		var protoDesc = gOPD$1$9(ObjectProto$5, key$1);
		if (protoDesc) delete ObjectProto$5[key$1];
		dP$1$10(it, key$1, D);
		if (protoDesc && it !== ObjectProto$5) dP$1$10(ObjectProto$5, key$1, protoDesc);
	} : dP$1$10;
	var wrap$8 = function(tag) {
		var sym = AllSymbols$5[tag] = _objectCreate$5($Symbol$5[PROTOTYPE$2$9]);
		sym._k = tag;
		return sym;
	};
	var isSymbol$5 = USE_NATIVE$5 && typeof $Symbol$5.iterator == "symbol" ? function(it) {
		return typeof it == "symbol";
	} : function(it) {
		return it instanceof $Symbol$5;
	};
	var $defineProperty$5 = function defineProperty$8(it, key$1, D) {
		if (it === ObjectProto$5) $defineProperty$5(OPSymbols$5, key$1, D);
		_anObject$5(it);
		key$1 = _toPrimitive$5(key$1, true);
		_anObject$5(D);
		if (_has$5(AllSymbols$5, key$1)) {
			if (!D.enumerable) {
				if (!_has$5(it, HIDDEN$5)) dP$1$10(it, HIDDEN$5, _propertyDesc$5(1, {}));
				it[HIDDEN$5][key$1] = true;
			} else {
				if (_has$5(it, HIDDEN$5) && it[HIDDEN$5][key$1]) it[HIDDEN$5][key$1] = false;
				D = _objectCreate$5(D, { enumerable: _propertyDesc$5(0, false) });
			}
			return setSymbolDesc$5(it, key$1, D);
		}
		return dP$1$10(it, key$1, D);
	};
	var $defineProperties$5 = function defineProperties(it, P) {
		_anObject$5(it);
		var keys$6 = _enumKeys$5(P = _toIobject$5(P));
		var i$8 = 0;
		var l = keys$6.length;
		var key$1;
		while (l > i$8) $defineProperty$5(it, key$1 = keys$6[i$8++], P[key$1]);
		return it;
	};
	var $create$5 = function create(it, P) {
		return P === void 0 ? _objectCreate$5(it) : $defineProperties$5(_objectCreate$5(it), P);
	};
	var $propertyIsEnumerable$5 = function propertyIsEnumerable$1(key$1) {
		var E = isEnum$5.call(this, key$1 = _toPrimitive$5(key$1, true));
		if (this === ObjectProto$5 && _has$5(AllSymbols$5, key$1) && !_has$5(OPSymbols$5, key$1)) return false;
		return E || !_has$5(this, key$1) || !_has$5(AllSymbols$5, key$1) || _has$5(this, HIDDEN$5) && this[HIDDEN$5][key$1] ? E : true;
	};
	var $getOwnPropertyDescriptor$5 = function getOwnPropertyDescriptor(it, key$1) {
		it = _toIobject$5(it);
		key$1 = _toPrimitive$5(key$1, true);
		if (it === ObjectProto$5 && _has$5(AllSymbols$5, key$1) && !_has$5(OPSymbols$5, key$1)) return;
		var D = gOPD$1$9(it, key$1);
		if (D && _has$5(AllSymbols$5, key$1) && !(_has$5(it, HIDDEN$5) && it[HIDDEN$5][key$1])) D.enumerable = true;
		return D;
	};
	var $getOwnPropertyNames$5 = function getOwnPropertyNames(it) {
		var names = gOPN$1$9(_toIobject$5(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (!_has$5(AllSymbols$5, key$1 = names[i$8++]) && key$1 != HIDDEN$5 && key$1 != META$5) result.push(key$1);
		return result;
	};
	var $getOwnPropertySymbols$5 = function getOwnPropertySymbols$2(it) {
		var IS_OP = it === ObjectProto$5;
		var names = gOPN$1$9(IS_OP ? OPSymbols$5 : _toIobject$5(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (_has$5(AllSymbols$5, key$1 = names[i$8++]) && (IS_OP ? _has$5(ObjectProto$5, key$1) : true)) result.push(AllSymbols$5[key$1]);
		return result;
	};
	if (!USE_NATIVE$5) {
		$Symbol$5 = function Symbol$2() {
			if (this instanceof $Symbol$5) throw TypeError("Symbol is not a constructor!");
			var tag = _uid$5(arguments.length > 0 ? arguments[0] : void 0);
			var $set = function(value) {
				if (this === ObjectProto$5) $set.call(OPSymbols$5, value);
				if (_has$5(this, HIDDEN$5) && _has$5(this[HIDDEN$5], tag)) this[HIDDEN$5][tag] = false;
				setSymbolDesc$5(this, tag, _propertyDesc$5(1, value));
			};
			if (_descriptors$5 && setter$5) setSymbolDesc$5(ObjectProto$5, tag, {
				configurable: true,
				set: $set
			});
			return wrap$8(tag);
		};
		_redefine$5($Symbol$5[PROTOTYPE$2$9], "toString", function toString$11() {
			return this._k;
		});
		_objectGopd$5.f = $getOwnPropertyDescriptor$5;
		_objectDp$5.f = $defineProperty$5;
		_objectGopn$5.f = _objectGopnExt$5.f = $getOwnPropertyNames$5;
		_objectPie$5.f = $propertyIsEnumerable$5;
		_objectGops$5.f = $getOwnPropertySymbols$5;
		if (_descriptors$5 && !_library$5) _redefine$5(ObjectProto$5, "propertyIsEnumerable", $propertyIsEnumerable$5, true);
		_wksExt$5.f = function(name) {
			return wrap$8(_wks$5(name));
		};
	}
	_export$5(_export$5.G + _export$5.W + _export$5.F * !USE_NATIVE$5, { Symbol: $Symbol$5 });
	for (var es6Symbols$5 = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j$5 = 0; es6Symbols$5.length > j$5;) _wks$5(es6Symbols$5[j$5++]);
	for (var wellKnownSymbols$5 = _objectKeys$5(_wks$5.store), k$5 = 0; wellKnownSymbols$5.length > k$5;) _wksDefine$5(wellKnownSymbols$5[k$5++]);
	_export$5(_export$5.S + _export$5.F * !USE_NATIVE$5, "Symbol", {
		"for": function(key$1) {
			return _has$5(SymbolRegistry$5, key$1 += "") ? SymbolRegistry$5[key$1] : SymbolRegistry$5[key$1] = $Symbol$5(key$1);
		},
		keyFor: function keyFor$1(sym) {
			if (!isSymbol$5(sym)) throw TypeError(sym + " is not a symbol!");
			for (var key$1 in SymbolRegistry$5) if (SymbolRegistry$5[key$1] === sym) return key$1;
		},
		useSetter: function() {
			setter$5 = true;
		},
		useSimple: function() {
			setter$5 = false;
		}
	});
	_export$5(_export$5.S + _export$5.F * !USE_NATIVE$5, "Object", {
		create: $create$5,
		defineProperty: $defineProperty$5,
		defineProperties: $defineProperties$5,
		getOwnPropertyDescriptor: $getOwnPropertyDescriptor$5,
		getOwnPropertyNames: $getOwnPropertyNames$5,
		getOwnPropertySymbols: $getOwnPropertySymbols$5
	});
	var FAILS_ON_PRIMITIVES$5 = _fails$5(function() {
		_objectGops$5.f(1);
	});
	_export$5(_export$5.S + _export$5.F * FAILS_ON_PRIMITIVES$5, "Object", { getOwnPropertySymbols: function getOwnPropertySymbols$2(it) {
		return _objectGops$5.f(_toObject$5(it));
	} });
	$JSON$5 && _export$5(_export$5.S + _export$5.F * (!USE_NATIVE$5 || _fails$5(function() {
		var S = $Symbol$5();
		return _stringify$5([S]) != "[null]" || _stringify$5({ a: S }) != "{}" || _stringify$5(Object(S)) != "{}";
	})), "JSON", { stringify: function stringify$14(it) {
		var args = [it];
		var i$8 = 1;
		var replacer, $replacer;
		while (arguments.length > i$8) args.push(arguments[i$8++]);
		$replacer = replacer = args[1];
		if (!_isObject$5(replacer) && it === void 0 || isSymbol$5(it)) return;
		if (!_isArray$5(replacer)) replacer = function(key$1, value) {
			if (typeof $replacer == "function") value = $replacer.call(this, key$1, value);
			if (!isSymbol$5(value)) return value;
		};
		args[1] = replacer;
		return _stringify$5.apply($JSON$5, args);
	} });
	$Symbol$5[PROTOTYPE$2$9][TO_PRIMITIVE$5] || _hide$5($Symbol$5[PROTOTYPE$2$9], TO_PRIMITIVE$5, $Symbol$5[PROTOTYPE$2$9].valueOf);
	_setToStringTag$5($Symbol$5, "Symbol");
	_setToStringTag$5(Math, "Math", true);
	_setToStringTag$5(_global$5.JSON, "JSON", true);
	var es6_object_toString$3 = /* @__PURE__ */ Object.freeze({});
	_wksDefine$5("asyncIterator");
	_wksDefine$5("observable");
	getCjsExportFromNamespace$3(es6_object_toString$3);
	var symbol$1$3 = _core$5.Symbol;
	var _iterStep$3 = function(done, value) {
		return {
			value,
			done: !!done
		};
	};
	var _iterators$3 = {};
	var IteratorPrototype$3 = {};
	_hide$5(IteratorPrototype$3, _wks$5("iterator"), function() {
		return this;
	});
	var _iterCreate$3 = function(Constructor, NAME$5, next) {
		Constructor.prototype = _objectCreate$5(IteratorPrototype$3, { next: _propertyDesc$5(1, next) });
		_setToStringTag$5(Constructor, NAME$5 + " Iterator");
	};
	var IE_PROTO$2$6 = _sharedKey$5("IE_PROTO");
	var ObjectProto$1$4 = Object.prototype;
	var _objectGpo$3 = Object.getPrototypeOf || function(O) {
		O = _toObject$5(O);
		if (_has$5(O, IE_PROTO$2$6)) return O[IE_PROTO$2$6];
		if (typeof O.constructor == "function" && O instanceof O.constructor) return O.constructor.prototype;
		return O instanceof Object ? ObjectProto$1$4 : null;
	};
	var ITERATOR$8 = _wks$5("iterator");
	var BUGGY$3 = !([].keys && "next" in [].keys());
	var FF_ITERATOR$3 = "@@iterator";
	var KEYS$3 = "keys";
	var VALUES$3 = "values";
	var returnThis$3 = function() {
		return this;
	};
	var _iterDefine$3 = function(Base, NAME$5, Constructor, next, DEFAULT, IS_SET, FORCED) {
		_iterCreate$3(Constructor, NAME$5, next);
		var getMethod$1 = function(kind) {
			if (!BUGGY$3 && kind in proto$7) return proto$7[kind];
			switch (kind) {
				case KEYS$3: return function keys$6() {
					return new Constructor(this, kind);
				};
				case VALUES$3: return function values() {
					return new Constructor(this, kind);
				};
			}
			return function entries() {
				return new Constructor(this, kind);
			};
		};
		var TAG$7 = NAME$5 + " Iterator";
		var DEF_VALUES = DEFAULT == VALUES$3;
		var VALUES_BUG = false;
		var proto$7 = Base.prototype;
		var $native = proto$7[ITERATOR$8] || proto$7[FF_ITERATOR$3] || DEFAULT && proto$7[DEFAULT];
		var $default = $native || getMethod$1(DEFAULT);
		var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod$1("entries") : void 0;
		var $anyNative = NAME$5 == "Array" ? proto$7.entries || $native : $native;
		var methods$3, key$1, IteratorPrototype$5;
		if ($anyNative) {
			IteratorPrototype$5 = _objectGpo$3($anyNative.call(new Base()));
			if (IteratorPrototype$5 !== Object.prototype && IteratorPrototype$5.next) _setToStringTag$5(IteratorPrototype$5, TAG$7, true);
		}
		if (DEF_VALUES && $native && $native.name !== VALUES$3) {
			VALUES_BUG = true;
			$default = function values() {
				return $native.call(this);
			};
		}
		if (FORCED && (BUGGY$3 || VALUES_BUG || !proto$7[ITERATOR$8])) _hide$5(proto$7, ITERATOR$8, $default);
		_iterators$3[NAME$5] = $default;
		_iterators$3[TAG$7] = returnThis$3;
		if (DEFAULT) {
			methods$3 = {
				values: DEF_VALUES ? $default : getMethod$1(VALUES$3),
				keys: IS_SET ? $default : getMethod$1(KEYS$3),
				entries: $entries
			};
			if (FORCED) {
				for (key$1 in methods$3) if (!(key$1 in proto$7)) _redefine$5(proto$7, key$1, methods$3[key$1]);
			} else _export$5(_export$5.P + _export$5.F * (BUGGY$3 || VALUES_BUG), NAME$5, methods$3);
		}
		return methods$3;
	};
	_iterDefine$3(Array, "Array", function(iterated, kind) {
		this._t = _toIobject$5(iterated);
		this._i = 0;
		this._k = kind;
	}, function() {
		var O = this._t;
		var kind = this._k;
		var index$1 = this._i++;
		if (!O || index$1 >= O.length) {
			this._t = void 0;
			return _iterStep$3(1);
		}
		if (kind == "keys") return _iterStep$3(0, index$1);
		if (kind == "values") return _iterStep$3(0, O[index$1]);
		return _iterStep$3(0, [index$1, O[index$1]]);
	}, "values");
	_iterators$3.Arguments = _iterators$3.Array;
	var TO_STRING_TAG$3 = _wks$5("toStringTag");
	var DOMIterables$3 = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
	for (var i$6 = 0; i$6 < DOMIterables$3.length; i$6++) {
		var NAME$3 = DOMIterables$3[i$6];
		var Collection$3 = _global$5[NAME$3];
		var proto$5 = Collection$3 && Collection$3.prototype;
		if (proto$5 && !proto$5[TO_STRING_TAG$3]) _hide$5(proto$5, TO_STRING_TAG$3, NAME$3);
		_iterators$3[NAME$3] = _iterators$3.Array;
	}
	var SPECIES$7 = _wks$5("species");
	var _arraySpeciesConstructor$2 = function(original) {
		var C;
		if (_isArray$5(original)) {
			C = original.constructor;
			if (typeof C == "function" && (C === Array || _isArray$5(C.prototype))) C = void 0;
			if (_isObject$5(C)) {
				C = C[SPECIES$7];
				if (C === null) C = void 0;
			}
		}
		return C === void 0 ? Array : C;
	};
	var _arraySpeciesCreate$2 = function(original, length) {
		return new (_arraySpeciesConstructor$2(original))(length);
	};
	var _arrayMethods$2 = function(TYPE, $create$7) {
		var IS_MAP = TYPE == 1;
		var IS_FILTER = TYPE == 2;
		var IS_SOME = TYPE == 3;
		var IS_EVERY = TYPE == 4;
		var IS_FIND_INDEX = TYPE == 6;
		var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
		var create = $create$7 || _arraySpeciesCreate$2;
		return function($this, callbackfn, that) {
			var O = _toObject$5($this);
			var self$1 = _iobject$5(O);
			var f = _ctx$5(callbackfn, that, 3);
			var length = _toLength$5(self$1.length);
			var index$1 = 0;
			var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
			var val, res$2;
			for (; length > index$1; index$1++) if (NO_HOLES || index$1 in self$1) {
				val = self$1[index$1];
				res$2 = f(val, index$1, O);
				if (TYPE) {
					if (IS_MAP) result[index$1] = res$2;
					else if (res$2) switch (TYPE) {
						case 3: return true;
						case 5: return val;
						case 6: return index$1;
						case 2: result.push(val);
					}
					else if (IS_EVERY) return false;
				}
			}
			return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
		};
	};
	var $assign$2 = Object.assign;
	var _objectAssign$2 = !$assign$2 || _fails$5(function() {
		var A = {};
		var B = {};
		var S = Symbol();
		var K = "abcdefghijklmnopqrst";
		A[S] = 7;
		K.split("").forEach(function(k$7) {
			B[k$7] = k$7;
		});
		return $assign$2({}, A)[S] != 7 || Object.keys($assign$2({}, B)).join("") != K;
	}) ? function assign$3(target, source) {
		var T = _toObject$5(target);
		var aLen = arguments.length;
		var index$1 = 1;
		var getSymbols = _objectGops$5.f;
		var isEnum$7 = _objectPie$5.f;
		while (aLen > index$1) {
			var S = _iobject$5(arguments[index$1++]);
			var keys$6 = getSymbols ? _objectKeys$5(S).concat(getSymbols(S)) : _objectKeys$5(S);
			var length = keys$6.length;
			var j$7 = 0;
			var key$1;
			while (length > j$7) {
				key$1 = keys$6[j$7++];
				if (!_descriptors$5 || isEnum$7.call(S, key$1)) T[key$1] = S[key$1];
			}
		}
		return T;
	} : $assign$2;
	var _redefineAll$3 = function(target, src$1, safe) {
		for (var key$1 in src$1) if (safe && target[key$1]) target[key$1] = src$1[key$1];
		else _hide$5(target, key$1, src$1[key$1]);
		return target;
	};
	var _anInstance$3 = function(it, Constructor, name, forbiddenField) {
		if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) throw TypeError(name + ": incorrect invocation!");
		return it;
	};
	var _iterCall$3 = function(iterator, fn, value, entries) {
		try {
			return entries ? fn(_anObject$5(value)[0], value[1]) : fn(value);
		} catch (e) {
			var ret = iterator["return"];
			if (ret !== void 0) _anObject$5(ret.call(iterator));
			throw e;
		}
	};
	var ITERATOR$1$9 = _wks$5("iterator");
	var ArrayProto$3 = Array.prototype;
	var _isArrayIter$3 = function(it) {
		return it !== void 0 && (_iterators$3.Array === it || ArrayProto$3[ITERATOR$1$9] === it);
	};
	var TAG$1$4 = _wks$5("toStringTag");
	var ARG$3 = _cof$5(function() {
		return arguments;
	}()) == "Arguments";
	var tryGet$3 = function(it, key$1) {
		try {
			return it[key$1];
		} catch (e) {}
	};
	var _classof$3 = function(it) {
		var O, T, B;
		return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet$3(O = Object(it), TAG$1$4)) == "string" ? T : ARG$3 ? _cof$5(O) : (B = _cof$5(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
	};
	var ITERATOR$2$5 = _wks$5("iterator");
	var core_getIteratorMethod$3 = _core$5.getIteratorMethod = function(it) {
		if (it != void 0) return it[ITERATOR$2$5] || it["@@iterator"] || _iterators$3[_classof$3(it)];
	};
	var _forOf$3 = createCommonjsModule$5(function(module$2) {
		var BREAK = {};
		var RETURN = {};
		var exports$1 = module$2.exports = function(iterable, entries, fn, that, ITERATOR$5) {
			var iterFn = ITERATOR$5 ? function() {
				return iterable;
			} : core_getIteratorMethod$3(iterable);
			var f = _ctx$5(fn, that, entries ? 2 : 1);
			var index$1 = 0;
			var length, step, iterator, result;
			if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
			if (_isArrayIter$3(iterFn)) for (length = _toLength$5(iterable.length); length > index$1; index$1++) {
				result = entries ? f(_anObject$5(step = iterable[index$1])[0], step[1]) : f(iterable[index$1]);
				if (result === BREAK || result === RETURN) return result;
			}
			else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
				result = _iterCall$3(iterator, f, step.value, entries);
				if (result === BREAK || result === RETURN) return result;
			}
		};
		exports$1.BREAK = BREAK;
		exports$1.RETURN = RETURN;
	});
	var _validateCollection$2 = function(it, TYPE) {
		if (!_isObject$5(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
		return it;
	};
	var getWeak$1 = _meta$5.getWeak;
	var arrayFind$1 = _arrayMethods$2(5);
	var arrayFindIndex$1 = _arrayMethods$2(6);
	var id$1$2 = 0;
	var uncaughtFrozenStore$1 = function(that) {
		return that._l || (that._l = new UncaughtFrozenStore$1());
	};
	var UncaughtFrozenStore$1 = function() {
		this.a = [];
	};
	var findUncaughtFrozen$1 = function(store, key$1) {
		return arrayFind$1(store.a, function(it) {
			return it[0] === key$1;
		});
	};
	UncaughtFrozenStore$1.prototype = {
		get: function(key$1) {
			var entry = findUncaughtFrozen$1(this, key$1);
			if (entry) return entry[1];
		},
		has: function(key$1) {
			return !!findUncaughtFrozen$1(this, key$1);
		},
		set: function(key$1, value) {
			var entry = findUncaughtFrozen$1(this, key$1);
			if (entry) entry[1] = value;
			else this.a.push([key$1, value]);
		},
		"delete": function(key$1) {
			var index$1 = arrayFindIndex$1(this.a, function(it) {
				return it[0] === key$1;
			});
			if (~index$1) this.a.splice(index$1, 1);
			return !!~index$1;
		}
	};
	var _collectionWeak$1 = {
		getConstructor: function(wrapper, NAME$5, IS_MAP, ADDER) {
			var C = wrapper(function(that, iterable) {
				_anInstance$3(that, C, NAME$5, "_i");
				that._t = NAME$5;
				that._i = id$1$2++;
				that._l = void 0;
				if (iterable != void 0) _forOf$3(iterable, IS_MAP, that[ADDER], that);
			});
			_redefineAll$3(C.prototype, {
				"delete": function(key$1) {
					if (!_isObject$5(key$1)) return false;
					var data = getWeak$1(key$1);
					if (data === true) return uncaughtFrozenStore$1(_validateCollection$2(this, NAME$5))["delete"](key$1);
					return data && _has$5(data, this._i) && delete data[this._i];
				},
				has: function has$8(key$1) {
					if (!_isObject$5(key$1)) return false;
					var data = getWeak$1(key$1);
					if (data === true) return uncaughtFrozenStore$1(_validateCollection$2(this, NAME$5)).has(key$1);
					return data && _has$5(data, this._i);
				}
			});
			return C;
		},
		def: function(that, key$1, value) {
			var data = getWeak$1(_anObject$5(key$1), true);
			if (data === true) uncaughtFrozenStore$1(that).set(key$1, value);
			else data[that._i] = value;
			return that;
		},
		ufstore: uncaughtFrozenStore$1
	};
	var dP$2$7 = _objectDp$5.f;
	var each$2 = _arrayMethods$2(0);
	var _collection$2 = function(NAME$5, wrapper, methods$3, common$9, IS_MAP, IS_WEAK) {
		var Base = _global$5[NAME$5];
		var C = Base;
		var ADDER = IS_MAP ? "set" : "add";
		var proto$7 = C && C.prototype;
		var O = {};
		if (!_descriptors$5 || typeof C != "function" || !(IS_WEAK || proto$7.forEach && !_fails$5(function() {
			new C().entries().next();
		}))) {
			C = common$9.getConstructor(wrapper, NAME$5, IS_MAP, ADDER);
			_redefineAll$3(C.prototype, methods$3);
			_meta$5.NEED = true;
		} else {
			C = wrapper(function(target, iterable) {
				_anInstance$3(target, C, NAME$5, "_c");
				target._c = new Base();
				if (iterable != void 0) _forOf$3(iterable, IS_MAP, target[ADDER], target);
			});
			each$2("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(KEY) {
				var IS_ADDER = KEY == "add" || KEY == "set";
				if (KEY in proto$7 && !(IS_WEAK && KEY == "clear")) _hide$5(C.prototype, KEY, function(a, b) {
					_anInstance$3(this, C, KEY);
					if (!IS_ADDER && IS_WEAK && !_isObject$5(a)) return KEY == "get" ? void 0 : false;
					var result = this._c[KEY](a === 0 ? 0 : a, b);
					return IS_ADDER ? this : result;
				});
			});
			IS_WEAK || dP$2$7(C.prototype, "size", { get: function() {
				return this._c.size;
			} });
		}
		_setToStringTag$5(C, NAME$5);
		O[NAME$5] = C;
		_export$5(_export$5.G + _export$5.W + _export$5.F, O);
		if (!IS_WEAK) common$9.setStrong(C, NAME$5, IS_MAP);
		return C;
	};
	createCommonjsModule$5(function(module$2) {
		var each$3 = _arrayMethods$2(0);
		var NATIVE_WEAK_MAP = _validateCollection$2;
		var IS_IE11 = !_global$5.ActiveXObject && "ActiveXObject" in _global$5;
		var WEAK_MAP = "WeakMap";
		var getWeak$2 = _meta$5.getWeak;
		var isExtensible = Object.isExtensible;
		var uncaughtFrozenStore$2 = _collectionWeak$1.ufstore;
		var InternalMap;
		var wrapper = function(get$1) {
			return function WeakMap$1() {
				return get$1(this, arguments.length > 0 ? arguments[0] : void 0);
			};
		};
		var methods$3 = {
			get: function get$1(key$1) {
				if (_isObject$5(key$1)) {
					var data = getWeak$2(key$1);
					if (data === true) return uncaughtFrozenStore$2(_validateCollection$2(this, WEAK_MAP)).get(key$1);
					return data ? data[this._i] : void 0;
				}
			},
			set: function set$3(key$1, value) {
				return _collectionWeak$1.def(_validateCollection$2(this, WEAK_MAP), key$1, value);
			}
		};
		var $WeakMap$1 = module$2.exports = _collection$2(WEAK_MAP, wrapper, methods$3, _collectionWeak$1, true, true);
		if (NATIVE_WEAK_MAP && IS_IE11) {
			InternalMap = _collectionWeak$1.getConstructor(wrapper, WEAK_MAP);
			_objectAssign$2(InternalMap.prototype, methods$3);
			_meta$5.NEED = true;
			each$3([
				"delete",
				"has",
				"get",
				"set"
			], function(key$1) {
				var proto$7 = $WeakMap$1.prototype;
				var method$1 = proto$7[key$1];
				_redefine$5(proto$7, key$1, function(a, b) {
					if (_isObject$5(a) && !isExtensible(a)) {
						if (!this._f) this._f = new InternalMap();
						var result = this._f[key$1](a, b);
						return key$1 == "set" ? this : result;
					}
					return method$1.call(this, a, b);
				});
			});
		}
	});
	var _setCollectionOf$2 = function(COLLECTION) {
		_export$5(_export$5.S, COLLECTION, { of: function of() {
			var length = arguments.length;
			var A = new Array(length);
			while (length--) A[length] = arguments[length];
			return new this(A);
		} });
	};
	_setCollectionOf$2("WeakMap");
	var _setCollectionFrom$2 = function(COLLECTION) {
		_export$5(_export$5.S, COLLECTION, { from: function from(source) {
			var mapFn = arguments[1];
			var mapping, A, n, cb;
			_aFunction$5(this);
			mapping = mapFn !== void 0;
			if (mapping) _aFunction$5(mapFn);
			if (source == void 0) return new this();
			A = [];
			if (mapping) {
				n = 0;
				cb = _ctx$5(mapFn, arguments[2], 2);
				_forOf$3(source, false, function(nextItem) {
					A.push(cb(nextItem, n++));
				});
			} else _forOf$3(source, false, A.push, A);
			return new this(A);
		} });
	};
	_setCollectionFrom$2("WeakMap");
	var weakMap$1$1 = _core$5.WeakMap;
	var _stringAt$3 = function(TO_STRING) {
		return function(that, pos) {
			var s$3 = String(_defined$5(that));
			var i$8 = _toInteger$5(pos);
			var l = s$3.length;
			var a, b;
			if (i$8 < 0 || i$8 >= l) return TO_STRING ? "" : void 0;
			a = s$3.charCodeAt(i$8);
			return a < 55296 || a > 56319 || i$8 + 1 === l || (b = s$3.charCodeAt(i$8 + 1)) < 56320 || b > 57343 ? TO_STRING ? s$3.charAt(i$8) : a : TO_STRING ? s$3.slice(i$8, i$8 + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
		};
	};
	var $at$3 = _stringAt$3(true);
	_iterDefine$3(String, "String", function(iterated) {
		this._t = String(iterated);
		this._i = 0;
	}, function() {
		var O = this._t;
		var index$1 = this._i;
		var point;
		if (index$1 >= O.length) return {
			value: void 0,
			done: true
		};
		point = $at$3(O, index$1);
		this._i += point.length;
		return {
			value: point,
			done: false
		};
	});
	var SPECIES$1$8 = _wks$5("species");
	var _setSpecies$3 = function(KEY) {
		var C = typeof _core$5[KEY] == "function" ? _core$5[KEY] : _global$5[KEY];
		if (_descriptors$5 && C && !C[SPECIES$1$8]) _objectDp$5.f(C, SPECIES$1$8, {
			configurable: true,
			get: function() {
				return this;
			}
		});
	};
	var dP$3$3 = _objectDp$5.f;
	var fastKey$1 = _meta$5.fastKey;
	var SIZE$1 = _descriptors$5 ? "_s" : "size";
	var getEntry$1 = function(that, key$1) {
		var index$1 = fastKey$1(key$1);
		var entry;
		if (index$1 !== "F") return that._i[index$1];
		for (entry = that._f; entry; entry = entry.n) if (entry.k == key$1) return entry;
	};
	var _collectionStrong$1 = {
		getConstructor: function(wrapper, NAME$5, IS_MAP, ADDER) {
			var C = wrapper(function(that, iterable) {
				_anInstance$3(that, C, NAME$5, "_i");
				that._t = NAME$5;
				that._i = _objectCreate$5(null);
				that._f = void 0;
				that._l = void 0;
				that[SIZE$1] = 0;
				if (iterable != void 0) _forOf$3(iterable, IS_MAP, that[ADDER], that);
			});
			_redefineAll$3(C.prototype, {
				clear: function clear$1() {
					for (var that = _validateCollection$2(this, NAME$5), data = that._i, entry = that._f; entry; entry = entry.n) {
						entry.r = true;
						if (entry.p) entry.p = entry.p.n = void 0;
						delete data[entry.i];
					}
					that._f = that._l = void 0;
					that[SIZE$1] = 0;
				},
				"delete": function(key$1) {
					var that = _validateCollection$2(this, NAME$5);
					var entry = getEntry$1(that, key$1);
					if (entry) {
						var next = entry.n;
						var prev = entry.p;
						delete that._i[entry.i];
						entry.r = true;
						if (prev) prev.n = next;
						if (next) next.p = prev;
						if (that._f == entry) that._f = next;
						if (that._l == entry) that._l = prev;
						that[SIZE$1]--;
					}
					return !!entry;
				},
				forEach: function forEach(callbackfn) {
					_validateCollection$2(this, NAME$5);
					var f = _ctx$5(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
					var entry;
					while (entry = entry ? entry.n : this._f) {
						f(entry.v, entry.k, this);
						while (entry && entry.r) entry = entry.p;
					}
				},
				has: function has$8(key$1) {
					return !!getEntry$1(_validateCollection$2(this, NAME$5), key$1);
				}
			});
			if (_descriptors$5) dP$3$3(C.prototype, "size", { get: function() {
				return _validateCollection$2(this, NAME$5)[SIZE$1];
			} });
			return C;
		},
		def: function(that, key$1, value) {
			var entry = getEntry$1(that, key$1);
			var prev, index$1;
			if (entry) entry.v = value;
			else {
				that._l = entry = {
					i: index$1 = fastKey$1(key$1, true),
					k: key$1,
					v: value,
					p: prev = that._l,
					n: void 0,
					r: false
				};
				if (!that._f) that._f = entry;
				if (prev) prev.n = entry;
				that[SIZE$1]++;
				if (index$1 !== "F") that._i[index$1] = entry;
			}
			return that;
		},
		getEntry: getEntry$1,
		setStrong: function(C, NAME$5, IS_MAP) {
			_iterDefine$3(C, NAME$5, function(iterated, kind) {
				this._t = _validateCollection$2(iterated, NAME$5);
				this._k = kind;
				this._l = void 0;
			}, function() {
				var that = this;
				var kind = that._k;
				var entry = that._l;
				while (entry && entry.r) entry = entry.p;
				if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
					that._t = void 0;
					return _iterStep$3(1);
				}
				if (kind == "keys") return _iterStep$3(0, entry.k);
				if (kind == "values") return _iterStep$3(0, entry.v);
				return _iterStep$3(0, [entry.k, entry.v]);
			}, IS_MAP ? "entries" : "values", !IS_MAP, true);
			_setSpecies$3(NAME$5);
		}
	};
	var MAP$1 = "Map";
	_collection$2(MAP$1, function(get$1) {
		return function Map$4() {
			return get$1(this, arguments.length > 0 ? arguments[0] : void 0);
		};
	}, {
		get: function get$1(key$1) {
			var entry = _collectionStrong$1.getEntry(_validateCollection$2(this, MAP$1), key$1);
			return entry && entry.v;
		},
		set: function set$3(key$1, value) {
			return _collectionStrong$1.def(_validateCollection$2(this, MAP$1), key$1 === 0 ? 0 : key$1, value);
		}
	}, _collectionStrong$1, true);
	var _arrayFromIterable$1 = function(iter, ITERATOR$5) {
		var result = [];
		_forOf$3(iter, false, result.push, result, ITERATOR$5);
		return result;
	};
	var _collectionToJson$1 = function(NAME$5) {
		return function toJSON$1() {
			if (_classof$3(this) != NAME$5) throw TypeError(NAME$5 + "#toJSON isn't generic");
			return _arrayFromIterable$1(this);
		};
	};
	_export$5(_export$5.P + _export$5.R, "Map", { toJSON: _collectionToJson$1("Map") });
	_setCollectionOf$2("Map");
	_setCollectionFrom$2("Map");
	var map$1$1 = _core$5.Map;
	var isEnum$1$1 = _objectPie$5.f;
	var _objectToArray = function(isEntries) {
		return function(it) {
			var O = _toIobject$5(it);
			var keys$6 = _objectKeys$5(O);
			var length = keys$6.length;
			var i$8 = 0;
			var result = [];
			var key$1;
			while (length > i$8) {
				key$1 = keys$6[i$8++];
				if (!_descriptors$5 || isEnum$1$1.call(O, key$1)) result.push(isEntries ? [key$1, O[key$1]] : O[key$1]);
			}
			return result;
		};
	};
	var $values = _objectToArray(false);
	_export$5(_export$5.S, "Object", { values: function values(it) {
		return $values(it);
	} });
	var values$1 = _core$5.Object.values;
	var SPECIES$2$6 = _wks$5("species");
	var _speciesConstructor$3 = function(O, D) {
		var C = _anObject$5(O).constructor;
		var S;
		return C === void 0 || (S = _anObject$5(C)[SPECIES$2$6]) == void 0 ? D : _aFunction$5(S);
	};
	var _invoke$3 = function(fn, args, that) {
		var un = that === void 0;
		switch (args.length) {
			case 0: return un ? fn() : fn.call(that);
			case 1: return un ? fn(args[0]) : fn.call(that, args[0]);
			case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
			case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
			case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
		}
		return fn.apply(that, args);
	};
	var process$6 = _global$5.process;
	var setTask$3 = _global$5.setImmediate;
	var clearTask$3 = _global$5.clearImmediate;
	var MessageChannel$3 = _global$5.MessageChannel;
	var Dispatch$3 = _global$5.Dispatch;
	var counter$3 = 0;
	var queue$3 = {};
	var ONREADYSTATECHANGE$3 = "onreadystatechange";
	var defer$6, channel$3, port$3;
	var run$3 = function() {
		var id$7 = +this;
		if (queue$3.hasOwnProperty(id$7)) {
			var fn = queue$3[id$7];
			delete queue$3[id$7];
			fn();
		}
	};
	var listener$4 = function(event) {
		run$3.call(event.data);
	};
	if (!setTask$3 || !clearTask$3) {
		setTask$3 = function setImmediate$3(fn) {
			var args = [];
			var i$8 = 1;
			while (arguments.length > i$8) args.push(arguments[i$8++]);
			queue$3[++counter$3] = function() {
				_invoke$3(typeof fn == "function" ? fn : Function(fn), args);
			};
			defer$6(counter$3);
			return counter$3;
		};
		clearTask$3 = function clearImmediate$1(id$7) {
			delete queue$3[id$7];
		};
		if (_cof$5(process$6) == "process") defer$6 = function(id$7) {
			process$6.nextTick(_ctx$5(run$3, id$7, 1));
		};
		else if (Dispatch$3 && Dispatch$3.now) defer$6 = function(id$7) {
			Dispatch$3.now(_ctx$5(run$3, id$7, 1));
		};
		else if (MessageChannel$3) {
			channel$3 = new MessageChannel$3();
			port$3 = channel$3.port2;
			channel$3.port1.onmessage = listener$4;
			defer$6 = _ctx$5(port$3.postMessage, port$3, 1);
		} else if (_global$5.addEventListener && typeof postMessage == "function" && !_global$5.importScripts) {
			defer$6 = function(id$7) {
				_global$5.postMessage(id$7 + "", "*");
			};
			_global$5.addEventListener("message", listener$4, false);
		} else if (ONREADYSTATECHANGE$3 in _domCreate$5("script")) defer$6 = function(id$7) {
			_html$5.appendChild(_domCreate$5("script"))[ONREADYSTATECHANGE$3] = function() {
				_html$5.removeChild(this);
				run$3.call(id$7);
			};
		};
		else defer$6 = function(id$7) {
			setTimeout(_ctx$5(run$3, id$7, 1), 0);
		};
	}
	var _task$3 = {
		set: setTask$3,
		clear: clearTask$3
	};
	var macrotask$3 = _task$3.set;
	var Observer$3 = _global$5.MutationObserver || _global$5.WebKitMutationObserver;
	var process$1$5 = _global$5.process;
	var Promise$4 = _global$5.Promise;
	var isNode$3 = _cof$5(process$1$5) == "process";
	var _microtask$3 = function() {
		var head, last, notify$6;
		var flush = function() {
			var parent, fn;
			if (isNode$3 && (parent = process$1$5.domain)) parent.exit();
			while (head) {
				fn = head.fn;
				head = head.next;
				try {
					fn();
				} catch (e) {
					if (head) notify$6();
					else last = void 0;
					throw e;
				}
			}
			last = void 0;
			if (parent) parent.enter();
		};
		if (isNode$3) notify$6 = function() {
			process$1$5.nextTick(flush);
		};
		else if (Observer$3 && !(_global$5.navigator && _global$5.navigator.standalone)) {
			var toggle = true;
			var node$1 = document.createTextNode("");
			new Observer$3(flush).observe(node$1, { characterData: true });
			notify$6 = function() {
				node$1.data = toggle = !toggle;
			};
		} else if (Promise$4 && Promise$4.resolve) {
			var promise = Promise$4.resolve(void 0);
			notify$6 = function() {
				promise.then(flush);
			};
		} else notify$6 = function() {
			macrotask$3.call(_global$5, flush);
		};
		return function(fn) {
			var task$5 = {
				fn,
				next: void 0
			};
			if (last) last.next = task$5;
			if (!head) {
				head = task$5;
				notify$6();
			}
			last = task$5;
		};
	};
	function PromiseCapability$3(C) {
		var resolve$6, reject;
		this.promise = new C(function($$resolve, $$reject) {
			if (resolve$6 !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
			resolve$6 = $$resolve;
			reject = $$reject;
		});
		this.resolve = _aFunction$5(resolve$6);
		this.reject = _aFunction$5(reject);
	}
	var f$7$3 = function(C) {
		return new PromiseCapability$3(C);
	};
	var _newPromiseCapability$3 = { f: f$7$3 };
	var _perform$3 = function(exec) {
		try {
			return {
				e: false,
				v: exec()
			};
		} catch (e) {
			return {
				e: true,
				v: e
			};
		}
	};
	var navigator$3 = _global$5.navigator;
	var _userAgent$3 = navigator$3 && navigator$3.userAgent || "";
	var _promiseResolve$3 = function(C, x) {
		_anObject$5(C);
		if (_isObject$5(x) && x.constructor === C) return x;
		var promiseCapability = _newPromiseCapability$3.f(C);
		var resolve$6 = promiseCapability.resolve;
		resolve$6(x);
		return promiseCapability.promise;
	};
	var ITERATOR$3$7 = _wks$5("iterator");
	var SAFE_CLOSING$3 = false;
	try {
		var riter$3 = [7][ITERATOR$3$7]();
		riter$3["return"] = function() {
			SAFE_CLOSING$3 = true;
		};
		Array.from(riter$3, function() {
			throw 2;
		});
	} catch (e) {}
	var _iterDetect$3 = function(exec, skipClosing) {
		if (!skipClosing && !SAFE_CLOSING$3) return false;
		var safe = false;
		try {
			var arr = [7];
			var iter = arr[ITERATOR$3$7]();
			iter.next = function() {
				return { done: safe = true };
			};
			arr[ITERATOR$3$7] = function() {
				return iter;
			};
			exec(arr);
		} catch (e) {}
		return safe;
	};
	var task$3 = _task$3.set;
	var microtask$3 = _microtask$3();
	var PROMISE$3 = "Promise";
	var TypeError$1$3 = _global$5.TypeError;
	var process$2$7 = _global$5.process;
	var versions$3 = process$2$7 && process$2$7.versions;
	var v8$3 = versions$3 && versions$3.v8 || "";
	var $Promise$3 = _global$5[PROMISE$3];
	var isNode$1$6 = _classof$3(process$2$7) == "process";
	var empty$3 = function() {};
	var Internal$3, newGenericPromiseCapability$3, OwnPromiseCapability$3, Wrapper$3;
	var newPromiseCapability$3 = newGenericPromiseCapability$3 = _newPromiseCapability$3.f;
	var USE_NATIVE$1$4 = !!function() {
		try {
			var promise = $Promise$3.resolve(1);
			var FakePromise = (promise.constructor = {})[_wks$5("species")] = function(exec) {
				exec(empty$3, empty$3);
			};
			return (isNode$1$6 || typeof PromiseRejectionEvent == "function") && promise.then(empty$3) instanceof FakePromise && v8$3.indexOf("6.6") !== 0 && _userAgent$3.indexOf("Chrome/66") === -1;
		} catch (e) {}
	}();
	var isThenable$3 = function(it) {
		var then;
		return _isObject$5(it) && typeof (then = it.then) == "function" ? then : false;
	};
	var notify$3 = function(promise, isReject) {
		if (promise._n) return;
		promise._n = true;
		var chain = promise._c;
		microtask$3(function() {
			var value = promise._v;
			var ok = promise._s == 1;
			var i$8 = 0;
			var run$5 = function(reaction) {
				var handler = ok ? reaction.ok : reaction.fail;
				var resolve$6 = reaction.resolve;
				var reject = reaction.reject;
				var domain = reaction.domain;
				var result, then, exited;
				try {
					if (handler) {
						if (!ok) {
							if (promise._h == 2) onHandleUnhandled$3(promise);
							promise._h = 1;
						}
						if (handler === true) result = value;
						else {
							if (domain) domain.enter();
							result = handler(value);
							if (domain) {
								domain.exit();
								exited = true;
							}
						}
						if (result === reaction.promise) reject(TypeError$1$3("Promise-chain cycle"));
						else if (then = isThenable$3(result)) then.call(result, resolve$6, reject);
						else resolve$6(result);
					} else reject(value);
				} catch (e) {
					if (domain && !exited) domain.exit();
					reject(e);
				}
			};
			while (chain.length > i$8) run$5(chain[i$8++]);
			promise._c = [];
			promise._n = false;
			if (isReject && !promise._h) onUnhandled$3(promise);
		});
	};
	var onUnhandled$3 = function(promise) {
		task$3.call(_global$5, function() {
			var value = promise._v;
			var unhandled = isUnhandled$3(promise);
			var result, handler, console$1;
			if (unhandled) {
				result = _perform$3(function() {
					if (isNode$1$6) process$2$7.emit("unhandledRejection", value, promise);
					else if (handler = _global$5.onunhandledrejection) handler({
						promise,
						reason: value
					});
					else if ((console$1 = _global$5.console) && console$1.error) console$1.error("Unhandled promise rejection", value);
				});
				promise._h = isNode$1$6 || isUnhandled$3(promise) ? 2 : 1;
			}
			promise._a = void 0;
			if (unhandled && result.e) throw result.v;
		});
	};
	var isUnhandled$3 = function(promise) {
		return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled$3 = function(promise) {
		task$3.call(_global$5, function() {
			var handler;
			if (isNode$1$6) process$2$7.emit("rejectionHandled", promise);
			else if (handler = _global$5.onrejectionhandled) handler({
				promise,
				reason: promise._v
			});
		});
	};
	var $reject$3 = function(value) {
		var promise = this;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		promise._v = value;
		promise._s = 2;
		if (!promise._a) promise._a = promise._c.slice();
		notify$3(promise, true);
	};
	var $resolve$3 = function(value) {
		var promise = this;
		var then;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		try {
			if (promise === value) throw TypeError$1$3("Promise can't be resolved itself");
			if (then = isThenable$3(value)) microtask$3(function() {
				var wrapper = {
					_w: promise,
					_d: false
				};
				try {
					then.call(value, _ctx$5($resolve$3, wrapper, 1), _ctx$5($reject$3, wrapper, 1));
				} catch (e) {
					$reject$3.call(wrapper, e);
				}
			});
			else {
				promise._v = value;
				promise._s = 1;
				notify$3(promise, false);
			}
		} catch (e) {
			$reject$3.call({
				_w: promise,
				_d: false
			}, e);
		}
	};
	if (!USE_NATIVE$1$4) {
		$Promise$3 = function Promise$6(executor) {
			_anInstance$3(this, $Promise$3, PROMISE$3, "_h");
			_aFunction$5(executor);
			Internal$3.call(this);
			try {
				executor(_ctx$5($resolve$3, this, 1), _ctx$5($reject$3, this, 1));
			} catch (err) {
				$reject$3.call(this, err);
			}
		};
		Internal$3 = function Promise$6(executor) {
			this._c = [];
			this._a = void 0;
			this._s = 0;
			this._d = false;
			this._v = void 0;
			this._h = 0;
			this._n = false;
		};
		Internal$3.prototype = _redefineAll$3($Promise$3.prototype, {
			then: function then(onFulfilled, onRejected) {
				var reaction = newPromiseCapability$3(_speciesConstructor$3(this, $Promise$3));
				reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
				reaction.fail = typeof onRejected == "function" && onRejected;
				reaction.domain = isNode$1$6 ? process$2$7.domain : void 0;
				this._c.push(reaction);
				if (this._a) this._a.push(reaction);
				if (this._s) notify$3(this, false);
				return reaction.promise;
			},
			"catch": function(onRejected) {
				return this.then(void 0, onRejected);
			}
		});
		OwnPromiseCapability$3 = function() {
			var promise = new Internal$3();
			this.promise = promise;
			this.resolve = _ctx$5($resolve$3, promise, 1);
			this.reject = _ctx$5($reject$3, promise, 1);
		};
		_newPromiseCapability$3.f = newPromiseCapability$3 = function(C) {
			return C === $Promise$3 || C === Wrapper$3 ? new OwnPromiseCapability$3(C) : newGenericPromiseCapability$3(C);
		};
	}
	_export$5(_export$5.G + _export$5.W + _export$5.F * !USE_NATIVE$1$4, { Promise: $Promise$3 });
	_setToStringTag$5($Promise$3, PROMISE$3);
	_setSpecies$3(PROMISE$3);
	Wrapper$3 = _core$5[PROMISE$3];
	_export$5(_export$5.S + _export$5.F * !USE_NATIVE$1$4, PROMISE$3, { reject: function reject(r) {
		var capability = newPromiseCapability$3(this);
		var $$reject = capability.reject;
		$$reject(r);
		return capability.promise;
	} });
	_export$5(_export$5.S + _export$5.F * _library$5, PROMISE$3, { resolve: function resolve$6(x) {
		return _promiseResolve$3(this === Wrapper$3 ? $Promise$3 : this, x);
	} });
	_export$5(_export$5.S + _export$5.F * !(USE_NATIVE$1$4 && _iterDetect$3(function(iter) {
		$Promise$3.all(iter)["catch"](empty$3);
	})), PROMISE$3, {
		all: function all(iterable) {
			var C = this;
			var capability = newPromiseCapability$3(C);
			var resolve$6 = capability.resolve;
			var reject = capability.reject;
			var result = _perform$3(function() {
				var values = [];
				var index$1 = 0;
				var remaining = 1;
				_forOf$3(iterable, false, function(promise) {
					var $index = index$1++;
					var alreadyCalled = false;
					values.push(void 0);
					remaining++;
					C.resolve(promise).then(function(value) {
						if (alreadyCalled) return;
						alreadyCalled = true;
						values[$index] = value;
						--remaining || resolve$6(values);
					}, reject);
				});
				--remaining || resolve$6(values);
			});
			if (result.e) reject(result.v);
			return capability.promise;
		},
		race: function race(iterable) {
			var C = this;
			var capability = newPromiseCapability$3(C);
			var reject = capability.reject;
			var result = _perform$3(function() {
				_forOf$3(iterable, false, function(promise) {
					C.resolve(promise).then(capability.resolve, reject);
				});
			});
			if (result.e) reject(result.v);
			return capability.promise;
		}
	});
	_export$5(_export$5.P + _export$5.R, "Promise", { "finally": function(onFinally) {
		var C = _speciesConstructor$3(this, _core$5.Promise || _global$5.Promise);
		var isFunction$3 = typeof onFinally == "function";
		return this.then(isFunction$3 ? function(x) {
			return _promiseResolve$3(C, onFinally()).then(function() {
				return x;
			});
		} : onFinally, isFunction$3 ? function(e) {
			return _promiseResolve$3(C, onFinally()).then(function() {
				throw e;
			});
		} : onFinally);
	} });
	_export$5(_export$5.S, "Promise", { "try": function(callbackfn) {
		var promiseCapability = _newPromiseCapability$3.f(this);
		var result = _perform$3(callbackfn);
		(result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
		return promiseCapability.promise;
	} });
	var promise$1$3 = _core$5.Promise;
	var version = "6.0.6";
	const FORMATTED_ACTIONS = {
		[utils$7.ACTIONS.RECORD]: "Recorded",
		[utils$7.ACTIONS.REPLAY]: "Replayed",
		[utils$7.ACTIONS.INTERCEPT]: "Intercepted",
		[utils$7.ACTIONS.PASSTHROUGH]: "Passthrough"
	};
	var Logger = class {
		constructor(polly) {
			this.polly = polly;
			this.log = logLevel.getLogger(`@pollyjs/core:${this.polly.recordingName}`);
			this.log.setLevel(polly.config.logLevel);
		}
		connect() {
			this._middleware = this.polly.server.any().on("error", (...args) => this.logRequestError(...args)).on("request", (...args) => this.logRequest(...args)).on("response", (...args) => this.logRequestResponse(...args));
		}
		disconnect() {
			this._middleware.off("error");
			this._middleware.off("response");
		}
		logRequest(request) {
			const { log: log$4 } = request;
			const debug$23 = log$4.getLevel() <= log$4.levels.DEBUG;
			log$4.info(`Request: ${request.method} ${request.url}`, ...debug$23 ? [{ request }] : []);
		}
		logRequestResponse(request, response) {
			const { log: log$4 } = request;
			const debug$23 = log$4.getLevel() <= log$4.levels.DEBUG;
			log$4.info(`Response: ${FORMATTED_ACTIONS[request.action]}  ${request.method} ${request.url} ${response.statusCode}  ${request.responseTime}ms`, ...debug$23 ? [{
				request,
				response
			}] : []);
		}
		logRequestError(request, error) {
			const { log: log$4 } = request;
			const debug$23 = log$4.getLevel() <= log$4.levels.DEBUG;
			log$4.error(`Errored  ${request.method} ${request.url}`, error, ...debug$23 ? [{ request }] : []);
		}
	};
	function keyFor(Factory) {
		return `${Factory.type}:${Factory.id}`;
	}
	var Container = class {
		constructor() {
			this._registry = new map$1$1();
		}
		/**
		* Register a factory onto the container.
		*
		* @param {Function} Factory
		*/
		register(Factory) {
			utils$7.assert(`Attempted to register ${Factory} but invalid factory provided. Expected function, received: "${typeof Factory}"`, typeof Factory === "function");
			const { type } = Factory;
			const name = Factory.id;
			utils$7.assert(`Invalid registration id provided. Expected string, received: "${typeof name}"`, typeof name === "string");
			utils$7.assert(`Invalid registration type provided. Expected string, received: "${typeof type}"`, typeof type === "string");
			this._registry.set(keyFor(Factory), Factory);
		}
		/**
		* Unregister a factory from the container via a key (e.g. `adapter:fetch`)
		* or Factory class.
		*
		* @param {String|Function} keyOrFactory
		*/
		unregister(keyOrFactory) {
			const { _registry: registry } = this;
			const key$1 = typeof keyOrFactory === "function" ? keyFor(keyOrFactory) : keyOrFactory;
			registry.delete(key$1);
		}
		/**
		* Lookup a factory by the given key (e.g. `adapter:fetch`)
		*
		* @param {String} key
		* @returns {Function}
		*/
		lookup(key$1) {
			return this._registry.get(key$1) || null;
		}
		/**
		* Check if a factory has been registered via a key (e.g. `adapter:fetch`)
		* or Factory class.
		*
		* @param {String|Function} keyOrFactory
		* @returns {Boolean}
		*/
		has(keyOrFactory) {
			const { _registry: registry } = this;
			const key$1 = typeof keyOrFactory === "function" ? keyFor(keyOrFactory) : keyOrFactory;
			return registry.has(key$1);
		}
	};
	var Timing = {
		fixed(ms$2) {
			return () => utils$7.timeout(ms$2);
		},
		relative(ratio) {
			return (ms$2) => utils$7.timeout(ratio * ms$2);
		}
	};
	var DefaultConfig$1 = {
		mode: utils$7.MODES.REPLAY,
		adapters: [],
		adapterOptions: {},
		persister: null,
		persisterOptions: {
			keepUnusedRequests: false,
			disableSortingHarEntries: false
		},
		logLevel: logLevel.levels.WARN,
		flushRequestsOnStop: false,
		recordIfMissing: true,
		recordFailedRequests: false,
		expiresIn: null,
		expiryStrategy: utils$7.EXPIRY_STRATEGIES.WARN,
		timing: Timing.fixed(0),
		matchRequestsBy: {
			method: true,
			headers: true,
			body: true,
			order: true,
			url: {
				protocol: true,
				username: true,
				password: true,
				hostname: true,
				port: true,
				pathname: true,
				query: true,
				hash: false
			}
		}
	};
	/**
	* Checks if `value` is object-like. A value is object-like if it's not `null`
	* and has a `typeof` result of "object".
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	* @example
	*
	* _.isObjectLike({});
	* // => true
	*
	* _.isObjectLike([1, 2, 3]);
	* // => true
	*
	* _.isObjectLike(_.noop);
	* // => false
	*
	* _.isObjectLike(null);
	* // => false
	*/
	function isObjectLike$1(value) {
		return value != null && typeof value == "object";
	}
	/**
	* Remove the host, protocol, and slashes from a URL instance.
	*
	* @param {URL} url
	*/
	function removeHostFromUrl(url$6) {
		url$6.set("protocol", "");
		url$6.set("host", "");
		url$6.set("slashes", false);
		return url$6;
	}
	/**
	* Creates an exact representation of the passed url string with url-parse.
	*
	* @param {String} url
	* @param {...args} args Arguments to pass through to the URL constructor
	* @returns {URL} A url-parse URL instance
	*/
	function parseUrl$4(url$6, ...args) {
		const parsedUrl = new utils$7.URL(url$6, ...args);
		if (!isAbsoluteUrl(url$6)) if (url$6.startsWith("//")) parsedUrl.set("protocol", "");
		else removeHostFromUrl(parsedUrl);
		return parsedUrl;
	}
	const { keys } = Object;
	const HANDLER = {
		get(obj, prop) {
			return obj[typeof prop === "string" ? prop.toLowerCase() : prop];
		},
		set(obj, prop, value) {
			if (typeof prop !== "string") return false;
			if (value === null || typeof value === "undefined") delete obj[prop.toLowerCase()];
			else obj[prop.toLowerCase()] = value;
			return true;
		},
		deleteProperty(obj, prop) {
			if (typeof prop !== "string") return false;
			delete obj[prop.toLowerCase()];
			return true;
		}
	};
	function HTTPHeaders(headers$1) {
		const proxy = new Proxy({}, HANDLER);
		if (isObjectLike$1(headers$1)) keys(headers$1).forEach((h$3) => proxy[h$3] = headers$1[h$3]);
		return proxy;
	}
	const { keys: keys$1$5 } = Object;
	const { isArray: isArray$6 } = Array;
	const { parse: parse$16 } = JSON;
	function isFunction$2(fn) {
		return typeof fn === "function";
	}
	function method(method$1, config, req$2) {
		return isFunction$2(config) ? config(method$1, req$2) : method$1.toUpperCase();
	}
	function url$5(url$6, config, req$2) {
		let parsedUrl = parseUrl$4(url$6, true);
		if (isFunction$2(config)) parsedUrl = parseUrl$4(config(url$6, req$2), true);
		else keys$1$5(config || {}).forEach((key$1) => {
			if (isFunction$2(config[key$1])) parsedUrl.set(key$1, config[key$1](parsedUrl[key$1], req$2));
			else if (!config[key$1]) parsedUrl.set(key$1, "");
		});
		if (isObjectLike$1(parsedUrl.query)) parsedUrl.set("query", parse$16(stringify$11(parsedUrl.query)));
		return parsedUrl.href;
	}
	function headers(headers$1, config, req$2) {
		const normalizedHeaders = new HTTPHeaders(headers$1);
		if (isFunction$2(config)) return config(normalizedHeaders, req$2);
		if (isObjectLike$1(config) && isArray$6(config.exclude)) config.exclude.forEach((header) => delete normalizedHeaders[header]);
		return normalizedHeaders;
	}
	function body(body$1, config, req$2) {
		return isFunction$2(config) ? config(body$1, req$2) : body$1;
	}
	var NormalizeRequest = {
		headers,
		method,
		body,
		url: url$5
	};
	function sanitize(str) {
		return str.replace(/\W/g, "-");
	}
	function guidFor(str) {
		const hash = fnv1a(str).toString();
		let slug = slugify(sanitize(str));
		slug = slug.substring(0, 100 - hash.length - 1);
		return `${slug}_${hash}`;
	}
	function guidForRecording(recording) {
		return (recording || "").split("/").map(guidFor).join("/");
	}
	_export$5(_export$5.S, "Array", { isArray: _isArray$5 });
	var isArray$2$1 = _core$5.Array.isArray;
	/**
	* Removes all key-value entries from the list cache.
	*
	* @private
	* @name clear
	* @memberOf ListCache
	*/
	function listCacheClear$2() {
		this.__data__ = [];
		this.size = 0;
	}
	/**
	* Performs a
	* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	* comparison between two values to determine if they are equivalent.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to compare.
	* @param {*} other The other value to compare.
	* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	* @example
	*
	* var object = { 'a': 1 };
	* var other = { 'a': 1 };
	*
	* _.eq(object, object);
	* // => true
	*
	* _.eq(object, other);
	* // => false
	*
	* _.eq('a', 'a');
	* // => true
	*
	* _.eq('a', Object('a'));
	* // => false
	*
	* _.eq(NaN, NaN);
	* // => true
	*/
	function eq$2(value, other) {
		return value === other || value !== value && other !== other;
	}
	/**
	* Gets the index at which the `key` is found in `array` of key-value pairs.
	*
	* @private
	* @param {Array} array The array to inspect.
	* @param {*} key The key to search for.
	* @returns {number} Returns the index of the matched value, else `-1`.
	*/
	function assocIndexOf$2(array, key$1) {
		var length = array.length;
		while (length--) if (eq$2(array[length][0], key$1)) return length;
		return -1;
	}
	/** Built-in value references. */
	var splice$2 = Array.prototype.splice;
	/**
	* Removes `key` and its value from the list cache.
	*
	* @private
	* @name delete
	* @memberOf ListCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function listCacheDelete$2(key$1) {
		var data = this.__data__, index$1 = assocIndexOf$2(data, key$1);
		if (index$1 < 0) return false;
		if (index$1 == data.length - 1) data.pop();
		else splice$2.call(data, index$1, 1);
		--this.size;
		return true;
	}
	/**
	* Gets the list cache value for `key`.
	*
	* @private
	* @name get
	* @memberOf ListCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function listCacheGet$2(key$1) {
		var data = this.__data__, index$1 = assocIndexOf$2(data, key$1);
		return index$1 < 0 ? void 0 : data[index$1][1];
	}
	/**
	* Checks if a list cache value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf ListCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function listCacheHas$2(key$1) {
		return assocIndexOf$2(this.__data__, key$1) > -1;
	}
	/**
	* Sets the list cache `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf ListCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the list cache instance.
	*/
	function listCacheSet$2(key$1, value) {
		var data = this.__data__, index$1 = assocIndexOf$2(data, key$1);
		if (index$1 < 0) {
			++this.size;
			data.push([key$1, value]);
		} else data[index$1][1] = value;
		return this;
	}
	/**
	* Creates an list cache object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function ListCache$2(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	ListCache$2.prototype.clear = listCacheClear$2;
	ListCache$2.prototype["delete"] = listCacheDelete$2;
	ListCache$2.prototype.get = listCacheGet$2;
	ListCache$2.prototype.has = listCacheHas$2;
	ListCache$2.prototype.set = listCacheSet$2;
	/**
	* Removes all key-value entries from the stack.
	*
	* @private
	* @name clear
	* @memberOf Stack
	*/
	function stackClear() {
		this.__data__ = new ListCache$2();
		this.size = 0;
	}
	/**
	* Removes `key` and its value from the stack.
	*
	* @private
	* @name delete
	* @memberOf Stack
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function stackDelete(key$1) {
		var data = this.__data__, result = data["delete"](key$1);
		this.size = data.size;
		return result;
	}
	/**
	* Gets the stack value for `key`.
	*
	* @private
	* @name get
	* @memberOf Stack
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function stackGet(key$1) {
		return this.__data__.get(key$1);
	}
	/**
	* Checks if a stack value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf Stack
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function stackHas(key$1) {
		return this.__data__.has(key$1);
	}
	/** Detect free variable `global` from Node.js. */
	var freeGlobal$2 = typeof global == "object" && global && global.Object === Object && global;
	/** Detect free variable `self`. */
	var freeSelf$2 = typeof self == "object" && self && self.Object === Object && self;
	/** Used as a reference to the global object. */
	var root$2 = freeGlobal$2 || freeSelf$2 || Function("return this")();
	/** Built-in value references. */
	var Symbol$1$2 = root$2.Symbol;
	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;
	/** Used to check objects for own properties. */
	var hasOwnProperty$1$3 = objectProto$3.hasOwnProperty;
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var nativeObjectToString$2 = objectProto$3.toString;
	/** Built-in value references. */
	var symToStringTag$2 = Symbol$1$2 ? Symbol$1$2.toStringTag : void 0;
	/**
	* A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the raw `toStringTag`.
	*/
	function getRawTag$1(value) {
		var isOwn = hasOwnProperty$1$3.call(value, symToStringTag$2), tag = value[symToStringTag$2];
		try {
			value[symToStringTag$2] = void 0;
			var unmasked = true;
		} catch (e) {}
		var result = nativeObjectToString$2.call(value);
		if (unmasked) if (isOwn) value[symToStringTag$2] = tag;
		else delete value[symToStringTag$2];
		return result;
	}
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var nativeObjectToString$1$3 = Object.prototype.toString;
	/**
	* Converts `value` to a string using `Object.prototype.toString`.
	*
	* @private
	* @param {*} value The value to convert.
	* @returns {string} Returns the converted string.
	*/
	function objectToString$2(value) {
		return nativeObjectToString$1$3.call(value);
	}
	/** `Object#toString` result references. */
	var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
	/** Built-in value references. */
	var symToStringTag$1$3 = Symbol$1$2 ? Symbol$1$2.toStringTag : void 0;
	/**
	* The base implementation of `getTag` without fallbacks for buggy environments.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the `toStringTag`.
	*/
	function baseGetTag$1(value) {
		if (value == null) return value === void 0 ? undefinedTag$1 : nullTag$1;
		return symToStringTag$1$3 && symToStringTag$1$3 in Object(value) ? getRawTag$1(value) : objectToString$2(value);
	}
	/**
	* Checks if `value` is the
	* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an object, else `false`.
	* @example
	*
	* _.isObject({});
	* // => true
	*
	* _.isObject([1, 2, 3]);
	* // => true
	*
	* _.isObject(_.noop);
	* // => true
	*
	* _.isObject(null);
	* // => false
	*/
	function isObject$2(value) {
		var type = typeof value;
		return value != null && (type == "object" || type == "function");
	}
	/** `Object#toString` result references. */
	var asyncTag$1 = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
	/**
	* Checks if `value` is classified as a `Function` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a function, else `false`.
	* @example
	*
	* _.isFunction(_);
	* // => true
	*
	* _.isFunction(/abc/);
	* // => false
	*/
	function isFunction$1$1(value) {
		if (!isObject$2(value)) return false;
		var tag = baseGetTag$1(value);
		return tag == funcTag$2 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
	}
	/** Used to detect overreaching core-js shims. */
	var coreJsData$2 = root$2["__core-js_shared__"];
	/** Used to detect methods masquerading as native. */
	var maskSrcKey$2 = function() {
		var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
		return uid ? "Symbol(src)_1." + uid : "";
	}();
	/**
	* Checks if `func` has its source masked.
	*
	* @private
	* @param {Function} func The function to check.
	* @returns {boolean} Returns `true` if `func` is masked, else `false`.
	*/
	function isMasked$2(func) {
		return !!maskSrcKey$2 && maskSrcKey$2 in func;
	}
	/** Used to resolve the decompiled source of functions. */
	var funcToString$3 = Function.prototype.toString;
	/**
	* Converts `func` to its source code.
	*
	* @private
	* @param {Function} func The function to convert.
	* @returns {string} Returns the source code.
	*/
	function toSource$2(func) {
		if (func != null) {
			try {
				return funcToString$3.call(func);
			} catch (e) {}
			try {
				return func + "";
			} catch (e) {}
		}
		return "";
	}
	/**
	* Used to match `RegExp`
	* [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	*/
	var reRegExpChar$2 = /[\\^$.*+?()[\]{}|]/g;
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor$2 = /^\[object .+?Constructor\]$/;
	/** Used for built-in method references. */
	var funcProto$1$1 = Function.prototype, objectProto$2$4 = Object.prototype;
	/** Used to resolve the decompiled source of functions. */
	var funcToString$1$4 = funcProto$1$1.toString;
	/** Used to check objects for own properties. */
	var hasOwnProperty$2$2 = objectProto$2$4.hasOwnProperty;
	/** Used to detect if a method is native. */
	var reIsNative$2 = RegExp("^" + funcToString$1$4.call(hasOwnProperty$2$2).replace(reRegExpChar$2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	/**
	* The base implementation of `_.isNative` without bad shim checks.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a native function,
	*  else `false`.
	*/
	function baseIsNative$2(value) {
		if (!isObject$2(value) || isMasked$2(value)) return false;
		return (isFunction$1$1(value) ? reIsNative$2 : reIsHostCtor$2).test(toSource$2(value));
	}
	/**
	* Gets the value at `key` of `object`.
	*
	* @private
	* @param {Object} [object] The object to query.
	* @param {string} key The key of the property to get.
	* @returns {*} Returns the property value.
	*/
	function getValue$2(object, key$1) {
		return object == null ? void 0 : object[key$1];
	}
	/**
	* Gets the native function at `key` of `object`.
	*
	* @private
	* @param {Object} object The object to query.
	* @param {string} key The key of the method to get.
	* @returns {*} Returns the function if it's native, else `undefined`.
	*/
	function getNative$2(object, key$1) {
		var value = getValue$2(object, key$1);
		return baseIsNative$2(value) ? value : void 0;
	}
	var Map$3 = getNative$2(root$2, "Map");
	var nativeCreate$2 = getNative$2(Object, "create");
	/**
	* Removes all key-value entries from the hash.
	*
	* @private
	* @name clear
	* @memberOf Hash
	*/
	function hashClear$2() {
		this.__data__ = nativeCreate$2 ? nativeCreate$2(null) : {};
		this.size = 0;
	}
	/**
	* Removes `key` and its value from the hash.
	*
	* @private
	* @name delete
	* @memberOf Hash
	* @param {Object} hash The hash to modify.
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function hashDelete$2(key$1) {
		var result = this.has(key$1) && delete this.__data__[key$1];
		this.size -= result ? 1 : 0;
		return result;
	}
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
	/** Used to check objects for own properties. */
	var hasOwnProperty$3$2 = Object.prototype.hasOwnProperty;
	/**
	* Gets the hash value for `key`.
	*
	* @private
	* @name get
	* @memberOf Hash
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function hashGet$2(key$1) {
		var data = this.__data__;
		if (nativeCreate$2) {
			var result = data[key$1];
			return result === HASH_UNDEFINED$4 ? void 0 : result;
		}
		return hasOwnProperty$3$2.call(data, key$1) ? data[key$1] : void 0;
	}
	/** Used to check objects for own properties. */
	var hasOwnProperty$4$2 = Object.prototype.hasOwnProperty;
	/**
	* Checks if a hash value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf Hash
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function hashHas$2(key$1) {
		var data = this.__data__;
		return nativeCreate$2 ? data[key$1] !== void 0 : hasOwnProperty$4$2.call(data, key$1);
	}
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1$5 = "__lodash_hash_undefined__";
	/**
	* Sets the hash `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf Hash
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the hash instance.
	*/
	function hashSet$2(key$1, value) {
		var data = this.__data__;
		this.size += this.has(key$1) ? 0 : 1;
		data[key$1] = nativeCreate$2 && value === void 0 ? HASH_UNDEFINED$1$5 : value;
		return this;
	}
	/**
	* Creates a hash object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function Hash$2(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	Hash$2.prototype.clear = hashClear$2;
	Hash$2.prototype["delete"] = hashDelete$2;
	Hash$2.prototype.get = hashGet$2;
	Hash$2.prototype.has = hashHas$2;
	Hash$2.prototype.set = hashSet$2;
	/**
	* Removes all key-value entries from the map.
	*
	* @private
	* @name clear
	* @memberOf MapCache
	*/
	function mapCacheClear$2() {
		this.size = 0;
		this.__data__ = {
			"hash": new Hash$2(),
			"map": new (Map$3 || ListCache$2)(),
			"string": new Hash$2()
		};
	}
	/**
	* Checks if `value` is suitable for use as unique object key.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	*/
	function isKeyable$2(value) {
		var type = typeof value;
		return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
	}
	/**
	* Gets the data for `map`.
	*
	* @private
	* @param {Object} map The map to query.
	* @param {string} key The reference key.
	* @returns {*} Returns the map data.
	*/
	function getMapData$2(map$2, key$1) {
		var data = map$2.__data__;
		return isKeyable$2(key$1) ? data[typeof key$1 == "string" ? "string" : "hash"] : data.map;
	}
	/**
	* Removes `key` and its value from the map.
	*
	* @private
	* @name delete
	* @memberOf MapCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function mapCacheDelete$2(key$1) {
		var result = getMapData$2(this, key$1)["delete"](key$1);
		this.size -= result ? 1 : 0;
		return result;
	}
	/**
	* Gets the map value for `key`.
	*
	* @private
	* @name get
	* @memberOf MapCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function mapCacheGet$2(key$1) {
		return getMapData$2(this, key$1).get(key$1);
	}
	/**
	* Checks if a map value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf MapCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function mapCacheHas$2(key$1) {
		return getMapData$2(this, key$1).has(key$1);
	}
	/**
	* Sets the map `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf MapCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the map cache instance.
	*/
	function mapCacheSet$2(key$1, value) {
		var data = getMapData$2(this, key$1), size = data.size;
		data.set(key$1, value);
		this.size += data.size == size ? 0 : 1;
		return this;
	}
	/**
	* Creates a map cache object to store key-value pairs.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function MapCache$2(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	MapCache$2.prototype.clear = mapCacheClear$2;
	MapCache$2.prototype["delete"] = mapCacheDelete$2;
	MapCache$2.prototype.get = mapCacheGet$2;
	MapCache$2.prototype.has = mapCacheHas$2;
	MapCache$2.prototype.set = mapCacheSet$2;
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE$1 = 200;
	/**
	* Sets the stack `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf Stack
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the stack cache instance.
	*/
	function stackSet(key$1, value) {
		var data = this.__data__;
		if (data instanceof ListCache$2) {
			var pairs = data.__data__;
			if (!Map$3 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
				pairs.push([key$1, value]);
				this.size = ++data.size;
				return this;
			}
			data = this.__data__ = new MapCache$2(pairs);
		}
		data.set(key$1, value);
		this.size = data.size;
		return this;
	}
	/**
	* Creates a stack cache object to store key-value pairs.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function Stack(entries) {
		this.size = (this.__data__ = new ListCache$2(entries)).size;
	}
	Stack.prototype.clear = stackClear;
	Stack.prototype["delete"] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	var defineProperty$1$5 = function() {
		try {
			var func = getNative$2(Object, "defineProperty");
			func({}, "", {});
			return func;
		} catch (e) {}
	}();
	/**
	* The base implementation of `assignValue` and `assignMergeValue` without
	* value checks.
	*
	* @private
	* @param {Object} object The object to modify.
	* @param {string} key The key of the property to assign.
	* @param {*} value The value to assign.
	*/
	function baseAssignValue(object, key$1, value) {
		if (key$1 == "__proto__" && defineProperty$1$5) defineProperty$1$5(object, key$1, {
			"configurable": true,
			"enumerable": true,
			"value": value,
			"writable": true
		});
		else object[key$1] = value;
	}
	/**
	* This function is like `assignValue` except that it doesn't assign
	* `undefined` values.
	*
	* @private
	* @param {Object} object The object to modify.
	* @param {string} key The key of the property to assign.
	* @param {*} value The value to assign.
	*/
	function assignMergeValue(object, key$1, value) {
		if (value !== void 0 && !eq$2(object[key$1], value) || value === void 0 && !(key$1 in object)) baseAssignValue(object, key$1, value);
	}
	/**
	* Creates a base function for methods like `_.forIn` and `_.forOwn`.
	*
	* @private
	* @param {boolean} [fromRight] Specify iterating from right to left.
	* @returns {Function} Returns the new base function.
	*/
	function createBaseFor(fromRight) {
		return function(object, iteratee, keysFunc) {
			var index$1 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
			while (length--) {
				var key$1 = props[fromRight ? length : ++index$1];
				if (iteratee(iterable[key$1], key$1, iterable) === false) break;
			}
			return object;
		};
	}
	/**
	* The base implementation of `baseForOwn` which iterates over `object`
	* properties returned by `keysFunc` and invokes `iteratee` for each property.
	* Iteratee functions may exit iteration early by explicitly returning `false`.
	*
	* @private
	* @param {Object} object The object to iterate over.
	* @param {Function} iteratee The function invoked per iteration.
	* @param {Function} keysFunc The function to get the keys of `object`.
	* @returns {Object} Returns `object`.
	*/
	var baseFor = createBaseFor();
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
	/** Built-in value references. */
	var Buffer$17 = freeModule && freeModule.exports === freeExports ? root$2.Buffer : void 0, allocUnsafe = Buffer$17 ? Buffer$17.allocUnsafe : void 0;
	/**
	* Creates a clone of  `buffer`.
	*
	* @private
	* @param {Buffer} buffer The buffer to clone.
	* @param {boolean} [isDeep] Specify a deep clone.
	* @returns {Buffer} Returns the cloned buffer.
	*/
	function cloneBuffer(buffer$5, isDeep) {
		if (isDeep) return buffer$5.slice();
		var length = buffer$5.length, result = allocUnsafe ? allocUnsafe(length) : new buffer$5.constructor(length);
		buffer$5.copy(result);
		return result;
	}
	/** Built-in value references. */
	var Uint8Array$1 = root$2.Uint8Array;
	/**
	* Creates a clone of `arrayBuffer`.
	*
	* @private
	* @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	* @returns {ArrayBuffer} Returns the cloned array buffer.
	*/
	function cloneArrayBuffer(arrayBuffer) {
		var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
		new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
		return result;
	}
	/**
	* Creates a clone of `typedArray`.
	*
	* @private
	* @param {Object} typedArray The typed array to clone.
	* @param {boolean} [isDeep] Specify a deep clone.
	* @returns {Object} Returns the cloned typed array.
	*/
	function cloneTypedArray(typedArray, isDeep) {
		var buffer$5 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
		return new typedArray.constructor(buffer$5, typedArray.byteOffset, typedArray.length);
	}
	/**
	* Copies the values of `source` to `array`.
	*
	* @private
	* @param {Array} source The array to copy values from.
	* @param {Array} [array=[]] The array to copy values to.
	* @returns {Array} Returns `array`.
	*/
	function copyArray(source, array) {
		var index$1 = -1, length = source.length;
		array || (array = Array(length));
		while (++index$1 < length) array[index$1] = source[index$1];
		return array;
	}
	/** Built-in value references. */
	var objectCreate = Object.create;
	/**
	* The base implementation of `_.create` without support for assigning
	* properties to the created object.
	*
	* @private
	* @param {Object} proto The object to inherit from.
	* @returns {Object} Returns the new object.
	*/
	var baseCreate = function() {
		function object() {}
		return function(proto$7) {
			if (!isObject$2(proto$7)) return {};
			if (objectCreate) return objectCreate(proto$7);
			object.prototype = proto$7;
			var result = new object();
			object.prototype = void 0;
			return result;
		};
	}();
	/**
	* Creates a unary function that invokes `func` with its argument transformed.
	*
	* @private
	* @param {Function} func The function to wrap.
	* @param {Function} transform The argument transform.
	* @returns {Function} Returns the new function.
	*/
	function overArg(func, transform) {
		return function(arg) {
			return func(transform(arg));
		};
	}
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;
	/**
	* Checks if `value` is likely a prototype object.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	*/
	function isPrototype(value) {
		var Ctor = value && value.constructor;
		return value === (typeof Ctor == "function" && Ctor.prototype || objectProto$5);
	}
	/**
	* Initializes an object clone.
	*
	* @private
	* @param {Object} object The object to clone.
	* @returns {Object} Returns the initialized clone.
	*/
	function initCloneObject(object) {
		return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
	}
	/** `Object#toString` result references. */
	var argsTag = "[object Arguments]";
	/**
	* The base implementation of `_.isArguments`.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an `arguments` object,
	*/
	function baseIsArguments(value) {
		return isObjectLike$1(value) && baseGetTag$1(value) == argsTag;
	}
	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;
	/** Used to check objects for own properties. */
	var hasOwnProperty$5$1 = objectProto$6.hasOwnProperty;
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
	/**
	* Checks if `value` is likely an `arguments` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an `arguments` object,
	*  else `false`.
	* @example
	*
	* _.isArguments(function() { return arguments; }());
	* // => true
	*
	* _.isArguments([1, 2, 3]);
	* // => false
	*/
	var isArguments = baseIsArguments(function() {
		return arguments;
	}()) ? baseIsArguments : function(value) {
		return isObjectLike$1(value) && hasOwnProperty$5$1.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
	};
	/**
	* Checks if `value` is classified as an `Array` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an array, else `false`.
	* @example
	*
	* _.isArray([1, 2, 3]);
	* // => true
	*
	* _.isArray(document.body.children);
	* // => false
	*
	* _.isArray('abc');
	* // => false
	*
	* _.isArray(_.noop);
	* // => false
	*/
	var isArray$3$1 = Array.isArray;
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;
	/**
	* Checks if `value` is a valid array-like length.
	*
	* **Note:** This method is loosely based on
	* [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	* @example
	*
	* _.isLength(3);
	* // => true
	*
	* _.isLength(Number.MIN_VALUE);
	* // => false
	*
	* _.isLength(Infinity);
	* // => false
	*
	* _.isLength('3');
	* // => false
	*/
	function isLength(value) {
		return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}
	/**
	* Checks if `value` is array-like. A value is considered array-like if it's
	* not a function and has a `value.length` that's an integer greater than or
	* equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	* @example
	*
	* _.isArrayLike([1, 2, 3]);
	* // => true
	*
	* _.isArrayLike(document.body.children);
	* // => true
	*
	* _.isArrayLike('abc');
	* // => true
	*
	* _.isArrayLike(_.noop);
	* // => false
	*/
	function isArrayLike(value) {
		return value != null && isLength(value.length) && !isFunction$1$1(value);
	}
	/**
	* This method is like `_.isArrayLike` except that it also checks if `value`
	* is an object.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an array-like object,
	*  else `false`.
	* @example
	*
	* _.isArrayLikeObject([1, 2, 3]);
	* // => true
	*
	* _.isArrayLikeObject(document.body.children);
	* // => true
	*
	* _.isArrayLikeObject('abc');
	* // => false
	*
	* _.isArrayLikeObject(_.noop);
	* // => false
	*/
	function isArrayLikeObject(value) {
		return isObjectLike$1(value) && isArrayLike(value);
	}
	/**
	* This method returns `false`.
	*
	* @static
	* @memberOf _
	* @since 4.13.0
	* @category Util
	* @returns {boolean} Returns `false`.
	* @example
	*
	* _.times(2, _.stubFalse);
	* // => [false, false]
	*/
	function stubFalse() {
		return false;
	}
	/** Detect free variable `exports`. */
	var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
	/** Detect free variable `module`. */
	var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
	/** Built-in value references. */
	var Buffer$1$1 = freeModule$1 && freeModule$1.exports === freeExports$1 ? root$2.Buffer : void 0;
	/**
	* Checks if `value` is a buffer.
	*
	* @static
	* @memberOf _
	* @since 4.3.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	* @example
	*
	* _.isBuffer(new Buffer(2));
	* // => true
	*
	* _.isBuffer(new Uint8Array(2));
	* // => false
	*/
	var isBuffer$1 = (Buffer$1$1 ? Buffer$1$1.isBuffer : void 0) || stubFalse;
	/** `Object#toString` result references. */
	var objectTag = "[object Object]";
	/** Used for built-in method references. */
	var funcProto$2 = Function.prototype, objectProto$7 = Object.prototype;
	/** Used to resolve the decompiled source of functions. */
	var funcToString$2$2 = funcProto$2.toString;
	/** Used to check objects for own properties. */
	var hasOwnProperty$6$1 = objectProto$7.hasOwnProperty;
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString$2$2.call(Object);
	/**
	* Checks if `value` is a plain object, that is, an object created by the
	* `Object` constructor or one with a `[[Prototype]]` of `null`.
	*
	* @static
	* @memberOf _
	* @since 0.8.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	* @example
	*
	* function Foo() {
	*   this.a = 1;
	* }
	*
	* _.isPlainObject(new Foo);
	* // => false
	*
	* _.isPlainObject([1, 2, 3]);
	* // => false
	*
	* _.isPlainObject({ 'x': 0, 'y': 0 });
	* // => true
	*
	* _.isPlainObject(Object.create(null));
	* // => true
	*/
	function isPlainObject$2(value) {
		if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag) return false;
		var proto$7 = getPrototype(value);
		if (proto$7 === null) return true;
		var Ctor = hasOwnProperty$6$1.call(proto$7, "constructor") && proto$7.constructor;
		return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2$2.call(Ctor) == objectCtorString;
	}
	/** `Object#toString` result references. */
	var argsTag$1 = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag$1$1 = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
	var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	/**
	* The base implementation of `_.isTypedArray` without Node.js optimizations.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	*/
	function baseIsTypedArray(value) {
		return isObjectLike$1(value) && isLength(value.length) && !!typedArrayTags[baseGetTag$1(value)];
	}
	/**
	* The base implementation of `_.unary` without support for storing metadata.
	*
	* @private
	* @param {Function} func The function to cap arguments for.
	* @returns {Function} Returns the new capped function.
	*/
	function baseUnary(func) {
		return function(value) {
			return func(value);
		};
	}
	/** Detect free variable `exports`. */
	var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
	/** Detect free variable `module`. */
	var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
	/** Detect free variable `process` from Node.js. */
	var freeProcess = freeModule$2 && freeModule$2.exports === freeExports$2 && freeGlobal$2.process;
	/** Used to access faster Node.js helpers. */
	var nodeUtil = function() {
		try {
			var types = freeModule$2 && freeModule$2.require && freeModule$2.require("util").types;
			if (types) return types;
			return freeProcess && freeProcess.binding && freeProcess.binding("util");
		} catch (e) {}
	}();
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	/**
	* Checks if `value` is classified as a typed array.
	*
	* @static
	* @memberOf _
	* @since 3.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	* @example
	*
	* _.isTypedArray(new Uint8Array);
	* // => true
	*
	* _.isTypedArray([]);
	* // => false
	*/
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	/**
	* Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	*
	* @private
	* @param {Object} object The object to query.
	* @param {string} key The key of the property to get.
	* @returns {*} Returns the property value.
	*/
	function safeGet(object, key$1) {
		if (key$1 === "constructor" && typeof object[key$1] === "function") return;
		if (key$1 == "__proto__") return;
		return object[key$1];
	}
	/** Used to check objects for own properties. */
	var hasOwnProperty$7$1 = Object.prototype.hasOwnProperty;
	/**
	* Assigns `value` to `key` of `object` if the existing value is not equivalent
	* using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	* for equality comparisons.
	*
	* @private
	* @param {Object} object The object to modify.
	* @param {string} key The key of the property to assign.
	* @param {*} value The value to assign.
	*/
	function assignValue$1(object, key$1, value) {
		var objValue = object[key$1];
		if (!(hasOwnProperty$7$1.call(object, key$1) && eq$2(objValue, value)) || value === void 0 && !(key$1 in object)) baseAssignValue(object, key$1, value);
	}
	/**
	* Copies properties of `source` to `object`.
	*
	* @private
	* @param {Object} source The object to copy properties from.
	* @param {Array} props The property identifiers to copy.
	* @param {Object} [object={}] The object to copy properties to.
	* @param {Function} [customizer] The function to customize copied values.
	* @returns {Object} Returns `object`.
	*/
	function copyObject(source, props, object, customizer$1) {
		var isNew = !object;
		object || (object = {});
		var index$1 = -1, length = props.length;
		while (++index$1 < length) {
			var key$1 = props[index$1];
			var newValue = customizer$1 ? customizer$1(object[key$1], source[key$1], key$1, object, source) : void 0;
			if (newValue === void 0) newValue = source[key$1];
			if (isNew) baseAssignValue(object, key$1, newValue);
			else assignValue$1(object, key$1, newValue);
		}
		return object;
	}
	/**
	* The base implementation of `_.times` without support for iteratee shorthands
	* or max array length checks.
	*
	* @private
	* @param {number} n The number of times to invoke `iteratee`.
	* @param {Function} iteratee The function invoked per iteration.
	* @returns {Array} Returns the array of results.
	*/
	function baseTimes(n, iteratee) {
		var index$1 = -1, result = Array(n);
		while (++index$1 < n) result[index$1] = iteratee(index$1);
		return result;
	}
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1$1 = 9007199254740991;
	/** Used to detect unsigned integer values. */
	var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
	/**
	* Checks if `value` is a valid array-like index.
	*
	* @private
	* @param {*} value The value to check.
	* @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	* @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	*/
	function isIndex$1(value, length) {
		var type = typeof value;
		length = length == null ? MAX_SAFE_INTEGER$1$1 : length;
		return !!length && (type == "number" || type != "symbol" && reIsUint$1.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}
	/** Used to check objects for own properties. */
	var hasOwnProperty$8$1 = Object.prototype.hasOwnProperty;
	/**
	* Creates an array of the enumerable property names of the array-like `value`.
	*
	* @private
	* @param {*} value The value to query.
	* @param {boolean} inherited Specify returning inherited property names.
	* @returns {Array} Returns the array of property names.
	*/
	function arrayLikeKeys(value, inherited) {
		var isArr = isArray$3$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
		for (var key$1 in value) if ((inherited || hasOwnProperty$8$1.call(value, key$1)) && !(skipIndexes && (key$1 == "length" || isBuff && (key$1 == "offset" || key$1 == "parent") || isType && (key$1 == "buffer" || key$1 == "byteLength" || key$1 == "byteOffset") || isIndex$1(key$1, length)))) result.push(key$1);
		return result;
	}
	/**
	* This function is like
	* [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	* except that it includes inherited enumerable properties.
	*
	* @private
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of property names.
	*/
	function nativeKeysIn(object) {
		var result = [];
		if (object != null) for (var key$1 in Object(object)) result.push(key$1);
		return result;
	}
	/** Used to check objects for own properties. */
	var hasOwnProperty$9$1 = Object.prototype.hasOwnProperty;
	/**
	* The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	*
	* @private
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of property names.
	*/
	function baseKeysIn(object) {
		if (!isObject$2(object)) return nativeKeysIn(object);
		var isProto = isPrototype(object), result = [];
		for (var key$1 in object) if (!(key$1 == "constructor" && (isProto || !hasOwnProperty$9$1.call(object, key$1)))) result.push(key$1);
		return result;
	}
	/**
	* Creates an array of the own and inherited enumerable property names of `object`.
	*
	* **Note:** Non-object values are coerced to objects.
	*
	* @static
	* @memberOf _
	* @since 3.0.0
	* @category Object
	* @param {Object} object The object to query.
	* @returns {Array} Returns the array of property names.
	* @example
	*
	* function Foo() {
	*   this.a = 1;
	*   this.b = 2;
	* }
	*
	* Foo.prototype.c = 3;
	*
	* _.keysIn(new Foo);
	* // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	*/
	function keysIn(object) {
		return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}
	/**
	* Converts `value` to a plain object flattening inherited enumerable string
	* keyed properties of `value` to own properties of the plain object.
	*
	* @static
	* @memberOf _
	* @since 3.0.0
	* @category Lang
	* @param {*} value The value to convert.
	* @returns {Object} Returns the converted plain object.
	* @example
	*
	* function Foo() {
	*   this.b = 2;
	* }
	*
	* Foo.prototype.c = 3;
	*
	* _.assign({ 'a': 1 }, new Foo);
	* // => { 'a': 1, 'b': 2 }
	*
	* _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	* // => { 'a': 1, 'b': 2, 'c': 3 }
	*/
	function toPlainObject(value) {
		return copyObject(value, keysIn(value));
	}
	/**
	* A specialized version of `baseMerge` for arrays and objects which performs
	* deep merges and tracks traversed objects enabling objects with circular
	* references to be merged.
	*
	* @private
	* @param {Object} object The destination object.
	* @param {Object} source The source object.
	* @param {string} key The key of the value to merge.
	* @param {number} srcIndex The index of `source`.
	* @param {Function} mergeFunc The function to merge values.
	* @param {Function} [customizer] The function to customize assigned values.
	* @param {Object} [stack] Tracks traversed source values and their merged
	*  counterparts.
	*/
	function baseMergeDeep(object, source, key$1, srcIndex, mergeFunc, customizer$1, stack) {
		var objValue = safeGet(object, key$1), srcValue = safeGet(source, key$1), stacked = stack.get(srcValue);
		if (stacked) {
			assignMergeValue(object, key$1, stacked);
			return;
		}
		var newValue = customizer$1 ? customizer$1(objValue, srcValue, key$1 + "", object, source, stack) : void 0;
		var isCommon = newValue === void 0;
		if (isCommon) {
			var isArr = isArray$3$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
			newValue = srcValue;
			if (isArr || isBuff || isTyped) if (isArray$3$1(objValue)) newValue = objValue;
			else if (isArrayLikeObject(objValue)) newValue = copyArray(objValue);
			else if (isBuff) {
				isCommon = false;
				newValue = cloneBuffer(srcValue, true);
			} else if (isTyped) {
				isCommon = false;
				newValue = cloneTypedArray(srcValue, true);
			} else newValue = [];
			else if (isPlainObject$2(srcValue) || isArguments(srcValue)) {
				newValue = objValue;
				if (isArguments(objValue)) newValue = toPlainObject(objValue);
				else if (!isObject$2(objValue) || isFunction$1$1(objValue)) newValue = initCloneObject(srcValue);
			} else isCommon = false;
		}
		if (isCommon) {
			stack.set(srcValue, newValue);
			mergeFunc(newValue, srcValue, srcIndex, customizer$1, stack);
			stack["delete"](srcValue);
		}
		assignMergeValue(object, key$1, newValue);
	}
	/**
	* The base implementation of `_.merge` without support for multiple sources.
	*
	* @private
	* @param {Object} object The destination object.
	* @param {Object} source The source object.
	* @param {number} srcIndex The index of `source`.
	* @param {Function} [customizer] The function to customize merged values.
	* @param {Object} [stack] Tracks traversed source values and their merged
	*  counterparts.
	*/
	function baseMerge(object, source, srcIndex, customizer$1, stack) {
		if (object === source) return;
		baseFor(source, function(srcValue, key$1) {
			stack || (stack = new Stack());
			if (isObject$2(srcValue)) baseMergeDeep(object, source, key$1, srcIndex, baseMerge, customizer$1, stack);
			else {
				var newValue = customizer$1 ? customizer$1(safeGet(object, key$1), srcValue, key$1 + "", object, source, stack) : void 0;
				if (newValue === void 0) newValue = srcValue;
				assignMergeValue(object, key$1, newValue);
			}
		}, keysIn);
	}
	/**
	* This method returns the first argument it receives.
	*
	* @static
	* @since 0.1.0
	* @memberOf _
	* @category Util
	* @param {*} value Any value.
	* @returns {*} Returns `value`.
	* @example
	*
	* var object = { 'a': 1 };
	*
	* console.log(_.identity(object) === object);
	* // => true
	*/
	function identity(value) {
		return value;
	}
	/**
	* A faster alternative to `Function#apply`, this function invokes `func`
	* with the `this` binding of `thisArg` and the arguments of `args`.
	*
	* @private
	* @param {Function} func The function to invoke.
	* @param {*} thisArg The `this` binding of `func`.
	* @param {Array} args The arguments to invoke `func` with.
	* @returns {*} Returns the result of `func`.
	*/
	function apply(func, thisArg, args) {
		switch (args.length) {
			case 0: return func.call(thisArg);
			case 1: return func.call(thisArg, args[0]);
			case 2: return func.call(thisArg, args[0], args[1]);
			case 3: return func.call(thisArg, args[0], args[1], args[2]);
		}
		return func.apply(thisArg, args);
	}
	var nativeMax = Math.max;
	/**
	* A specialized version of `baseRest` which transforms the rest array.
	*
	* @private
	* @param {Function} func The function to apply a rest parameter to.
	* @param {number} [start=func.length-1] The start position of the rest parameter.
	* @param {Function} transform The rest array transform.
	* @returns {Function} Returns the new function.
	*/
	function overRest(func, start, transform) {
		start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
		return function() {
			var args = arguments, index$1 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
			while (++index$1 < length) array[index$1] = args[start + index$1];
			index$1 = -1;
			var otherArgs = Array(start + 1);
			while (++index$1 < start) otherArgs[index$1] = args[index$1];
			otherArgs[start] = transform(array);
			return apply(func, this, otherArgs);
		};
	}
	/**
	* Creates a function that returns `value`.
	*
	* @static
	* @memberOf _
	* @since 2.4.0
	* @category Util
	* @param {*} value The value to return from the new function.
	* @returns {Function} Returns the new constant function.
	* @example
	*
	* var objects = _.times(2, _.constant({ 'a': 1 }));
	*
	* console.log(objects);
	* // => [{ 'a': 1 }, { 'a': 1 }]
	*
	* console.log(objects[0] === objects[1]);
	* // => true
	*/
	function constant(value) {
		return function() {
			return value;
		};
	}
	/**
	* The base implementation of `setToString` without support for hot loop shorting.
	*
	* @private
	* @param {Function} func The function to modify.
	* @param {Function} string The `toString` result.
	* @returns {Function} Returns `func`.
	*/
	var baseSetToString = !defineProperty$1$5 ? identity : function(func, string) {
		return defineProperty$1$5(func, "toString", {
			"configurable": true,
			"enumerable": false,
			"value": constant(string),
			"writable": true
		});
	};
	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800, HOT_SPAN = 16;
	var nativeNow = Date.now;
	/**
	* Creates a function that'll short out and invoke `identity` instead
	* of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	* milliseconds.
	*
	* @private
	* @param {Function} func The function to restrict.
	* @returns {Function} Returns the new shortable function.
	*/
	function shortOut(func) {
		var count = 0, lastCalled = 0;
		return function() {
			var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
			lastCalled = stamp;
			if (remaining > 0) {
				if (++count >= HOT_COUNT) return arguments[0];
			} else count = 0;
			return func.apply(void 0, arguments);
		};
	}
	/**
	* Sets the `toString` method of `func` to return `string`.
	*
	* @private
	* @param {Function} func The function to modify.
	* @param {Function} string The `toString` result.
	* @returns {Function} Returns `func`.
	*/
	var setToString = shortOut(baseSetToString);
	/**
	* The base implementation of `_.rest` which doesn't validate or coerce arguments.
	*
	* @private
	* @param {Function} func The function to apply a rest parameter to.
	* @param {number} [start=func.length-1] The start position of the rest parameter.
	* @returns {Function} Returns the new function.
	*/
	function baseRest(func, start) {
		return setToString(overRest(func, start, identity), func + "");
	}
	/**
	* Checks if the given arguments are from an iteratee call.
	*
	* @private
	* @param {*} value The potential iteratee value argument.
	* @param {*} index The potential iteratee index or key argument.
	* @param {*} object The potential iteratee object argument.
	* @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	*  else `false`.
	*/
	function isIterateeCall(value, index$1, object) {
		if (!isObject$2(object)) return false;
		var type = typeof index$1;
		if (type == "number" ? isArrayLike(object) && isIndex$1(index$1, object.length) : type == "string" && index$1 in object) return eq$2(object[index$1], value);
		return false;
	}
	/**
	* Creates a function like `_.assign`.
	*
	* @private
	* @param {Function} assigner The function to assign values.
	* @returns {Function} Returns the new assigner function.
	*/
	function createAssigner(assigner) {
		return baseRest(function(object, sources) {
			var index$1 = -1, length = sources.length, customizer$1 = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
			customizer$1 = assigner.length > 3 && typeof customizer$1 == "function" ? (length--, customizer$1) : void 0;
			if (guard && isIterateeCall(sources[0], sources[1], guard)) {
				customizer$1 = length < 3 ? void 0 : customizer$1;
				length = 1;
			}
			object = Object(object);
			while (++index$1 < length) {
				var source = sources[index$1];
				if (source) assigner(object, source, index$1, customizer$1);
			}
			return object;
		});
	}
	/**
	* This method is like `_.merge` except that it accepts `customizer` which
	* is invoked to produce the merged values of the destination and source
	* properties. If `customizer` returns `undefined`, merging is handled by the
	* method instead. The `customizer` is invoked with six arguments:
	* (objValue, srcValue, key, object, source, stack).
	*
	* **Note:** This method mutates `object`.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Object
	* @param {Object} object The destination object.
	* @param {...Object} sources The source objects.
	* @param {Function} customizer The function to customize assigned values.
	* @returns {Object} Returns `object`.
	* @example
	*
	* function customizer(objValue, srcValue) {
	*   if (_.isArray(objValue)) {
	*     return objValue.concat(srcValue);
	*   }
	* }
	*
	* var object = { 'a': [1], 'b': [2] };
	* var other = { 'a': [3], 'b': [4] };
	*
	* _.mergeWith(object, other, customizer);
	* // => { 'a': [1, 3], 'b': [2, 4] }
	*/
	var mergeWith = createAssigner(function(object, source, srcIndex, customizer$1) {
		baseMerge(object, source, srcIndex, customizer$1);
	});
	function customizer(objValue, srcValue, key$1) {
		if (isArray$2$1(objValue) || ["context"].includes(key$1)) return srcValue;
	}
	function mergeConfigs(...configs) {
		return mergeWith({}, ...configs, customizer);
	}
	/**
	* Create a deferred promise with `resolve` and `reject` methods.
	*/
	function defer$1$1() {
		let _resolve;
		let _reject;
		const promise = new promise$1$3((resolve$6, reject) => {
			_resolve = resolve$6;
			_reject = reject;
		});
		promise.catch(() => {});
		promise.resolve = _resolve;
		promise.reject = _reject;
		return promise;
	}
	function validateRecordingName(name) {
		utils$7.assert(`Invalid recording name provided. Expected string, received: "${typeof name}".`, typeof name === "string");
		utils$7.assert(`Invalid recording name provided. Received An empty or blank string.`, name.trim().length > 0);
	}
	function validateRequestConfig(config) {
		utils$7.assert(`Invalid config provided. Expected object, received: "${typeof config}".`, isObjectLike$1(config) && !isArray$2$1(config));
		[
			"mode",
			"adapters",
			"adapterOptions",
			"persister",
			"persisterOptions"
		].forEach((key$1) => utils$7.assert(`Invalid configuration option provided. The "${key$1}" option cannot be overridden using the server configuration API.`, !(key$1 in config)));
	}
	function validateTimesOption(times) {
		utils$7.assert(`Invalid number provided. Expected number, received: "${typeof times}".`, typeof times === "number");
		utils$7.assert(`Invalid number provided. The number must be greater than 0, received "${typeof times}".`, times > 0);
	}
	const { freeze } = Object;
	const { parse: parse$1$1 } = JSON;
	var HTTPBase = class {
		constructor() {
			this.headers = new HTTPHeaders();
		}
		getHeader(name) {
			return this.headers[name];
		}
		setHeader(name, value) {
			this.headers[name] = value;
			return this;
		}
		setHeaders(headers$1 = {}) {
			for (const name in headers$1) this.setHeader(name, headers$1[name]);
			return this;
		}
		removeHeader(name) {
			this.setHeader(name, null);
			return this;
		}
		removeHeaders(headers$1 = []) {
			for (const name of headers$1) this.removeHeader(name);
			return this;
		}
		hasHeader(name) {
			return !!this.getHeader(name);
		}
		type(type) {
			return this.setHeader("Content-Type", type);
		}
		send(data) {
			let body$1 = data;
			switch (typeof body$1) {
				case "string":
					if (!this.hasHeader("Content-Type")) this.type("text/html");
					break;
				case "boolean":
				case "number":
				case "object":
					if (body$1 === null) body$1 = "";
					else return this.json(body$1);
					break;
			}
			if (typeof body$1 === "string") {
				const contentType$5 = this.getHeader("Content-Type");
				if (contentType$5 && !contentType$5.includes("charset")) this.type(`${contentType$5}; charset=utf-8`);
			}
			this.body = body$1;
			return this;
		}
		json(obj) {
			if (!this.hasHeader("Content-Type")) this.type("application/json");
			return this.send(stringify$11(obj));
		}
		jsonBody() {
			return parse$1$1(this.body);
		}
		end() {
			freeze(this);
			freeze(this.headers);
			return this;
		}
	};
	var _stringWs$2 = "	\n\v\f\r \xA0\u2028\u2029";
	var space$2 = "[" + _stringWs$2 + "]";
	var non$2 = "";
	var ltrim$2 = RegExp("^" + space$2 + space$2 + "*");
	var rtrim$2 = RegExp(space$2 + space$2 + "*$");
	var exporter$2 = function(KEY, exec, ALIAS) {
		var exp = {};
		var FORCE = _fails$5(function() {
			return !!_stringWs$2[KEY]() || non$2[KEY]() != non$2;
		});
		var fn = exp[KEY] = FORCE ? exec(trim$2) : _stringWs$2[KEY];
		if (ALIAS) exp[ALIAS] = fn;
		_export$5(_export$5.P + _export$5.F * FORCE, "String", exp);
	};
	var trim$2 = exporter$2.trim = function(string, TYPE) {
		string = String(_defined$5(string));
		if (TYPE & 1) string = string.replace(ltrim$2, "");
		if (TYPE & 2) string = string.replace(rtrim$2, "");
		return string;
	};
	var _stringTrim$2 = exporter$2;
	var $parseInt$1 = _global$5.parseInt;
	var $trim$2 = _stringTrim$2.trim;
	var hex$1 = /^[-+]?0[xX]/;
	var _parseInt$1 = $parseInt$1(_stringWs$2 + "08") !== 8 || $parseInt$1(_stringWs$2 + "0x16") !== 22 ? function parseInt$1(str, radix) {
		var string = $trim$2(String(str), 3);
		return $parseInt$1(string, radix >>> 0 || (hex$1.test(string) ? 16 : 10));
	} : $parseInt$1;
	_export$5(_export$5.G + _export$5.F * (parseInt != _parseInt$1), { parseInt: _parseInt$1 });
	var _parseInt$2$1 = _core$5.parseInt;
	const DEFAULT_STATUS_CODE = 200;
	var PollyResponse = class extends HTTPBase {
		constructor(statusCode, headers$1, body$1, encoding) {
			super();
			this.status(statusCode || DEFAULT_STATUS_CODE);
			this.setHeaders(headers$1);
			this.body = body$1;
			this.encoding = encoding;
		}
		get ok() {
			return this.statusCode && this.statusCode >= 200 && this.statusCode < 300;
		}
		get statusText() {
			return utils$7.HTTP_STATUS_CODES[this.statusCode] || utils$7.HTTP_STATUS_CODES[DEFAULT_STATUS_CODE];
		}
		status(statusCode) {
			const status$1 = _parseInt$2$1(statusCode, 10);
			utils$7.assert(`[Response] Invalid status code: ${status$1}`, status$1 >= 100 && status$1 < 600);
			this.statusCode = status$1;
			return this;
		}
		sendStatus(status$1) {
			this.status(status$1);
			this.type("text/plain");
			return this.send(this.statusText);
		}
	};
	var _objectSap$5 = function(KEY, exec) {
		var fn = (_core$5.Object || {})[KEY] || Object[KEY];
		var exp = {};
		exp[KEY] = exec(fn);
		_export$5(_export$5.S + _export$5.F * _fails$5(function() {
			fn(1);
		}), "Object", exp);
	};
	_objectSap$5("keys", function() {
		return function keys$6(it) {
			return _objectKeys$5(_toObject$5(it));
		};
	});
	var keys$3$1 = _core$5.Object.keys;
	var getOwnPropertySymbols$1$5 = _core$5.Object.getOwnPropertySymbols;
	var $getOwnPropertyDescriptor$1$9 = _objectGopd$5.f;
	_objectSap$5("getOwnPropertyDescriptor", function() {
		return function getOwnPropertyDescriptor(it, key$1) {
			return $getOwnPropertyDescriptor$1$9(_toIobject$5(it), key$1);
		};
	});
	var $Object$8 = _core$5.Object;
	var getOwnPropertyDescriptor$1$5 = function getOwnPropertyDescriptor(it, key$1) {
		return $Object$8.getOwnPropertyDescriptor(it, key$1);
	};
	var Reflect$6 = _global$5.Reflect;
	var _ownKeys$5 = Reflect$6 && Reflect$6.ownKeys || function ownKeys$8(it) {
		var keys$6 = _objectGopn$5.f(_anObject$5(it));
		var getSymbols = _objectGops$5.f;
		return getSymbols ? keys$6.concat(getSymbols(it)) : keys$6;
	};
	var _createProperty$5 = function(object, index$1, value) {
		if (index$1 in object) _objectDp$5.f(object, index$1, _propertyDesc$5(0, value));
		else object[index$1] = value;
	};
	_export$5(_export$5.S, "Object", { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
		var O = _toIobject$5(object);
		var getDesc = _objectGopd$5.f;
		var keys$6 = _ownKeys$5(O);
		var result = {};
		var i$8 = 0;
		var key$1, desc$1;
		while (keys$6.length > i$8) {
			desc$1 = getDesc(O, key$1 = keys$6[i$8++]);
			if (desc$1 !== void 0) _createProperty$5(result, key$1, desc$1);
		}
		return result;
	} });
	var getOwnPropertyDescriptors$1$5 = _core$5.Object.getOwnPropertyDescriptors;
	_export$5(_export$5.S + _export$5.F * !_descriptors$5, "Object", { defineProperties: _objectDps$5 });
	var $Object$1$10 = _core$5.Object;
	var defineProperties$1$5 = function defineProperties(T, D) {
		return $Object$1$10.defineProperties(T, D);
	};
	_export$5(_export$5.S + _export$5.F * !_descriptors$5, "Object", { defineProperty: _objectDp$5.f });
	var $Object$2$9 = _core$5.Object;
	var defineProperty$3$3 = function defineProperty$8(it, key$1, desc$1) {
		return $Object$2$9.defineProperty(it, key$1, desc$1);
	};
	var _defineProperty$5 = unwrapExports$5(createCommonjsModule$5(function(module$2) {
		function _defineProperty$7(obj, key$1, value) {
			if (key$1 in obj) defineProperty$3$3(obj, key$1, {
				value,
				enumerable: true,
				configurable: true,
				writable: true
			});
			else obj[key$1] = value;
			return obj;
		}
		module$2.exports = _defineProperty$7;
		module$2.exports["default"] = module$2.exports, module$2.exports.__esModule = true;
	}));
	var SET = "Set";
	_collection$2(SET, function(get$1) {
		return function Set$2() {
			return get$1(this, arguments.length > 0 ? arguments[0] : void 0);
		};
	}, { add: function add(value) {
		return _collectionStrong$1.def(_validateCollection$2(this, SET), value = value === 0 ? 0 : value, value);
	} }, _collectionStrong$1);
	_export$5(_export$5.P + _export$5.R, "Set", { toJSON: _collectionToJson$1("Set") });
	_setCollectionOf$2("Set");
	_setCollectionFrom$2("Set");
	var set$1 = _core$5.Set;
	/**
	* Create a function that will execute the given fn and call the cancel
	* callback after being called n times.
	*
	* @export
	* @param {Function} fn
	* @param {Number} nTimes
	* @param {Function} cancel
	* @returns
	*/
	function cancelFnAfterNTimes(fn, nTimes, cancel) {
		let callCount = 0;
		return function(...args) {
			if (++callCount >= nTimes) cancel();
			return fn(...args);
		};
	}
	_export$5(_export$5.S + _export$5.F, "Object", { assign: _objectAssign$2 });
	var assign$1$1 = _core$5.Object.assign;
	const STOP_PROPAGATION = symbol$1$3();
	var Event = class {
		constructor(type, props) {
			utils$7.assert(`Invalid type provided. Expected a non-empty string, received: "${typeof type}".`, type && typeof type === "string");
			defineProperty$3$3(this, "type", { value: type });
			assign$1$1(this, props || {});
			this[STOP_PROPAGATION] = false;
		}
		stopPropagation() {
			this[STOP_PROPAGATION] = true;
		}
		get shouldStopPropagating() {
			return this[STOP_PROPAGATION];
		}
	};
	function ownKeys$7(object, enumerableOnly) {
		var keys$6 = keys$3$1(object);
		if (getOwnPropertySymbols$1$5) {
			var symbols = getOwnPropertySymbols$1$5(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1$5(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$7(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$7(Object(source), true).forEach(function(key$1) {
				_defineProperty$5(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1$5) defineProperties$1$5(target, getOwnPropertyDescriptors$1$5(source));
			else ownKeys$7(Object(source)).forEach(function(key$1) {
				defineProperty$3$3(target, key$1, getOwnPropertyDescriptor$1$5(source, key$1));
			});
		}
		return target;
	}
	const EVENTS = symbol$1$3();
	const EVENT_NAMES = symbol$1$3();
	function assertEventName(eventName, eventNames) {
		utils$7.assert(`Invalid event name provided. Expected string, received: "${typeof eventName}".`, typeof eventName === "string");
		utils$7.assert(`Invalid event name provided: "${eventName}". Possible events: ${[...eventNames].join(", ")}.`, eventNames.has(eventName));
	}
	function assertListener(listener$6) {
		utils$7.assert(`Invalid listener provided. Expected function, received: "${typeof listener$6}".`, typeof listener$6 === "function");
	}
	var EventEmitter$5 = class {
		/**
		* @constructor
		* @param {Object} options
		* @param {String[]} options.eventNames - Supported events
		*/
		constructor(options = {}) {
			const { eventNames } = options;
			utils$7.assert("An array of supported events must be provided via the `eventNames` option.", isArray$2$1(eventNames) && eventNames.length > 0);
			this[EVENTS] = new map$1$1();
			this[EVENT_NAMES] = new set$1(eventNames);
		}
		/**
		* Returns an array listing the events for which the emitter has
		* registered listeners
		*
		* @returns {String[]}
		*/
		eventNames() {
			const eventNames = [];
			this[EVENTS].forEach((_, eventName) => this.hasListeners(eventName) && eventNames.push(eventName));
			return eventNames;
		}
		/**
		* Adds the `listener` function to the end of the listeners array for the
		* event named `eventName`
		*
		* @param {String} eventName - The name of the event
		* @param {Function} listener - The callback function
		* @param {Object} [options={}]
		* @param {Number} options.times - listener will be cancelled after this many times
		* @returns {EventEmitter}
		*/
		on(eventName, listener$6, options = {}) {
			assertEventName(eventName, this[EVENT_NAMES]);
			assertListener(listener$6);
			const events = this[EVENTS];
			const { times } = options;
			if (!events.has(eventName)) events.set(eventName, new set$1());
			if (times) {
				validateTimesOption(times);
				const tempListener = cancelFnAfterNTimes(listener$6, times, () => this.off(eventName, tempListener));
				this.off(eventName, listener$6);
				tempListener.listener = listener$6;
				listener$6 = tempListener;
			}
			events.get(eventName).add(listener$6);
			return this;
		}
		/**
		* Adds a one-time `listener` function for the event named `eventName`.
		* The next time `eventName` is triggered, this listener is removed and
		* then invoked.
		*
		* @param {String} eventName - The name of the event
		* @param {Function} listener - The callback function
		* @param {Object} [options={}]
		* @returns {EventEmitter}
		*/
		once(eventName, listener$6, options = {}) {
			this.on(eventName, listener$6, _objectSpread$7(_objectSpread$7({}, options), {}, { times: 1 }));
			return this;
		}
		/**
		* Removes the specified `listener` from the listener array for
		* the event named `eventName`. If `listener` is not provided then it removes
		* all listeners, or those of the specified `eventName`.
		*
		* @param {String} eventName - The name of the event
		* @param {Function} [listener] - The callback function
		* @returns {EventEmitter}
		*/
		off(eventName, listener$6) {
			assertEventName(eventName, this[EVENT_NAMES]);
			const events = this[EVENTS];
			if (this.hasListeners(eventName)) if (typeof listener$6 === "function") {
				events.get(eventName).delete(listener$6);
				this.listeners(eventName).forEach((l) => {
					if (l.listener === listener$6) events.get(eventName).delete(l);
				});
			} else events.get(eventName).clear(eventName);
			return this;
		}
		/**
		* Returns a copy of the array of listeners for the event named `eventName`.
		*
		* @param {String} eventName - The name of the event
		* @returns {Function[]}
		*/
		listeners(eventName) {
			assertEventName(eventName, this[EVENT_NAMES]);
			return this.hasListeners(eventName) ? [...this[EVENTS].get(eventName)] : [];
		}
		/**
		* Returns `true` if there are any listeners for the event named `eventName`
		* or `false` otherwise.
		*
		* @param {String} eventName - The name of the event
		* @returns {Boolean}
		*/
		hasListeners(eventName) {
			assertEventName(eventName, this[EVENT_NAMES]);
			const events = this[EVENTS];
			return events.has(eventName) && events.get(eventName).size > 0;
		}
		/**
		* Asynchronously calls each of the `listeners` registered for the event named
		* `eventName`, in the order they were registered, passing the supplied
		* arguments to each.
		*
		* Returns a promise that will resolve to `false` if a listener stopped
		* propagation, `true` otherwise.
		*
		* @async
		* @param {String} eventName - The name of the event
		* @param {any} ...args - The arguments to pass to the listeners
		* @returns {Promise<Boolean>}
		*/
		async emit(eventName, ...args) {
			assertEventName(eventName, this[EVENT_NAMES]);
			const event = new Event(eventName);
			for (const listener$6 of this.listeners(eventName)) {
				await listener$6(...args, event);
				if (event.shouldStopPropagating) return false;
			}
			return true;
		}
		/**
		* Asynchronously and concurrently calls each of the `listeners` registered
		* for the event named `eventName`, in the order they were registered,
		* passing the supplied arguments to each.
		*
		* Returns a promise that will resolve to `false` if a listener stopped
		* propagation, `true` otherwise.
		*
		* @async
		* @param {String} eventName - The name of the event
		* @param {any} ...args - The arguments to pass to the listeners
		* @returns {Promise<Boolean>}
		*/
		async emitParallel(eventName, ...args) {
			assertEventName(eventName, this[EVENT_NAMES]);
			const event = new Event(eventName);
			await promise$1$3.all(this.listeners(eventName).map((listener$6) => listener$6(...args, event)));
			if (event.shouldStopPropagating) return false;
			return true;
		}
		/**
		* Synchronously calls each of the `listeners` registered for the event named
		* `eventName`, in the order they were registered, passing the supplied
		* arguments to each.
		*
		* Throws if a listener's return value is promise-like.
		*
		* Returns`false` if a listener stopped propagation, `true` otherwise.
		*
		* @param {String} eventName - The name of the event
		* @param {any} ...args - The arguments to pass to the listeners
		* @returns {Boolean}
		*/
		emitSync(eventName, ...args) {
			assertEventName(eventName, this[EVENT_NAMES]);
			const event = new Event(eventName);
			for (const listener$6 of this.listeners(eventName)) {
				const returnValue = listener$6(...args, event);
				utils$7.assert(`Attempted to emit a synchronous event "${eventName}" but an asynchronous listener was called.`, !(isObjectLike$1(returnValue) && typeof returnValue.then === "function"));
				if (event.shouldStopPropagating) return false;
			}
			return true;
		}
	};
	const ABORT = symbol$1$3();
	const PASSTHROUGH = symbol$1$3();
	function setDefaults(interceptor) {
		interceptor[ABORT] = false;
		interceptor[PASSTHROUGH] = false;
	}
	var Interceptor$1 = class extends Event {
		constructor() {
			super("intercept");
			setDefaults(this);
		}
		abort() {
			setDefaults(this);
			this[ABORT] = true;
		}
		passthrough() {
			setDefaults(this);
			this[PASSTHROUGH] = true;
		}
		get shouldAbort() {
			return this[ABORT];
		}
		get shouldPassthrough() {
			return this[PASSTHROUGH];
		}
		get shouldIntercept() {
			return !this.shouldAbort && !this.shouldPassthrough;
		}
	};
	const { keys: keys$4, freeze: freeze$1 } = Object;
	const ROUTE = symbol$1$3();
	const POLLY = symbol$1$3();
	const PARSED_URL = symbol$1$3();
	const EVENT_EMITTER = symbol$1$3();
	const SUPPORTED_EVENTS = ["identify"];
	var PollyRequest = class extends HTTPBase {
		constructor(polly, request) {
			super();
			utils$7.assert("Url is required.", request.url);
			utils$7.assert("Method is required.", request.method && typeof request.method === "string");
			this.didRespond = false;
			this.aborted = false;
			this.url = request.url;
			this.method = request.method.toUpperCase();
			this.body = request.body;
			this.setHeaders(request.headers);
			this.recordingName = polly.recordingName;
			this.recordingId = polly.recordingId;
			this.requestArguments = freeze$1(request.requestArguments);
			this.promise = defer$1$1();
			this[POLLY] = polly;
			this[EVENT_EMITTER] = new EventEmitter$5({ eventNames: SUPPORTED_EVENTS });
			this.action = null;
			this._interceptor = new Interceptor$1();
			this[ROUTE] = polly.server.lookup(this.method, this.url);
			this[ROUTE].applyFiltersWithArgs(this);
			this.configure(this[ROUTE].config());
			const recordingName = this[ROUTE].recordingName();
			if (recordingName) this.overrideRecordingName(recordingName);
		}
		get url() {
			return this[PARSED_URL].toString();
		}
		set url(value) {
			this[PARSED_URL] = parseUrl$4(`${value}`, true);
		}
		get absoluteUrl() {
			const { url: url$6 } = this;
			return isAbsoluteUrl(url$6) ? url$6 : new utils$7.URL(url$6).href;
		}
		get protocol() {
			return this[PARSED_URL].protocol;
		}
		get hostname() {
			return this[PARSED_URL].hostname;
		}
		get port() {
			return this[PARSED_URL].port;
		}
		get origin() {
			return this[PARSED_URL].origin;
		}
		get pathname() {
			return this[PARSED_URL].pathname;
		}
		get query() {
			return this[PARSED_URL].query;
		}
		set query(value) {
			this[PARSED_URL].set("query", value);
		}
		get hash() {
			return this[PARSED_URL].hash;
		}
		set hash(value) {
			this[PARSED_URL].set("hash", value);
		}
		get shouldPassthrough() {
			return this[ROUTE].shouldPassthrough();
		}
		get shouldIntercept() {
			return this[ROUTE].shouldIntercept();
		}
		get log() {
			if (this.id) {
				const log$4 = logLevel.getLogger(`@pollyjs/core:${this.recordingName}:${this.id}`);
				log$4.setLevel(this.config.logLevel);
				return log$4;
			} else return this[POLLY].logger.log;
		}
		on(eventName, listener$6) {
			this[EVENT_EMITTER].on(eventName, listener$6);
			return this;
		}
		once(eventName, listener$6) {
			this[EVENT_EMITTER].once(eventName, listener$6);
			return this;
		}
		off(eventName, listener$6) {
			this[EVENT_EMITTER].off(eventName, listener$6);
			return this;
		}
		async init() {
			await this._emit("request");
			this.response = new PollyResponse();
			this.didRespond = false;
			await this._identify();
			this.timestamp = utils$7.timestamp();
		}
		async respond(response) {
			const { statusCode, headers: headers$1, body: body$1, encoding } = response || {};
			utils$7.assert("Cannot respond to a request that already has a response.", !this.didRespond);
			if (this.aborted) return;
			this.response.timestamp = utils$7.timestamp();
			this.response.status(statusCode);
			this.response.setHeaders(headers$1);
			this.response.body = body$1;
			this.response.encoding = encoding;
			await this._emit("beforeResponse", this.response);
			this.response.end();
			this.responseTime = new Date(this.response.timestamp).getTime() - new Date(this.timestamp).getTime();
			this.didRespond = true;
			this.end();
			await this._emit("response", this.response);
		}
		abort() {
			this.aborted = true;
		}
		overrideRecordingName(recordingName) {
			validateRecordingName(recordingName);
			this.recordingName = recordingName;
			this.recordingId = guidForRecording(recordingName);
		}
		configure(config) {
			validateRequestConfig(config);
			this.config = mergeConfigs(this[POLLY].config, this.config || {}, config);
		}
		_intercept() {
			return this[ROUTE].intercept(this, this.response, ...arguments);
		}
		_emit(eventName, ...args) {
			return this[ROUTE].emit(eventName, this, ...args);
		}
		async _identify() {
			const { _requests: requests } = this[POLLY];
			const { matchRequestsBy } = this.config;
			this.identifiers = {};
			keys$4(NormalizeRequest).forEach((key$1) => {
				if (this[key$1] && matchRequestsBy[key$1]) this.identifiers[key$1] = NormalizeRequest[key$1](this[key$1], matchRequestsBy[key$1], this);
			});
			await this[EVENT_EMITTER].emit("identify", this);
			freeze$1(this.identifiers);
			this.id = md5(stringify$11(this.identifiers));
			this.order = matchRequestsBy.order && !this.shouldPassthrough && !this.shouldIntercept ? requests.slice(0, requests.indexOf(this)).filter((r) => r.id === this.id && r.recordingId === this.recordingId).length : 0;
			this.log.debug("Request Identified:", {
				id: this.id,
				order: this.order,
				identifiers: this.identifiers,
				request: this
			});
		}
	};
	/**
	* Casts `value` as an array if it's not one.
	*
	* @static
	* @memberOf _
	* @since 4.4.0
	* @category Lang
	* @param {*} value The value to inspect.
	* @returns {Array} Returns the cast array.
	* @example
	*
	* _.castArray(1);
	* // => [1]
	*
	* _.castArray({ 'a': 1 });
	* // => [{ 'a': 1 }]
	*
	* _.castArray('abc');
	* // => ['abc']
	*
	* _.castArray(null);
	* // => [null]
	*
	* _.castArray(undefined);
	* // => [undefined]
	*
	* _.castArray();
	* // => []
	*
	* var array = [1, 2, 3];
	* console.log(_.castArray(array) === array);
	* // => true
	*/
	function castArray() {
		if (!arguments.length) return [];
		var value = arguments[0];
		return isArray$3$1(value) ? value : [value];
	}
	function get(target, propertyKey) {
		var receiver = arguments.length < 3 ? target : arguments[2];
		var desc$1, proto$7;
		if (_anObject$5(target) === receiver) return target[propertyKey];
		if (desc$1 = _objectGopd$5.f(target, propertyKey)) return _has$5(desc$1, "value") ? desc$1.value : desc$1.get !== void 0 ? desc$1.get.call(receiver) : void 0;
		if (_isObject$5(proto$7 = _objectGpo$3(target))) return get(proto$7, propertyKey, receiver);
	}
	_export$5(_export$5.S, "Reflect", { get });
	var get$2 = _core$5.Reflect.get;
	function ownKeys$1$8(object, enumerableOnly) {
		var keys$6 = keys$3$1(object);
		if (getOwnPropertySymbols$1$5) {
			var symbols = getOwnPropertySymbols$1$5(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1$5(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$1$8(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$1$8(Object(source), true).forEach(function(key$1) {
				_defineProperty$5(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1$5) defineProperties$1$5(target, getOwnPropertyDescriptors$1$5(source));
			else ownKeys$1$8(Object(source)).forEach(function(key$1) {
				defineProperty$3$3(target, key$1, getOwnPropertyDescriptor$1$5(source, key$1));
			});
		}
		return target;
	}
	const HANDLERS = symbol$1$3();
	function requestWithParams(req$2, { params }) {
		return new Proxy(req$2, {
			set(source, prop, value) {
				source[prop] = value;
				return true;
			},
			get(source, prop) {
				if (prop === "params") return _objectSpread$1$8({}, params);
				return get$2(source, prop);
			}
		});
	}
	var Route$3 = class {
		/**
		*
		* @param {RecognizeResults} recognizeResults
		* @param {Array<Route>} middleware
		*/
		constructor(recognizeResults, middleware$1) {
			const result = recognizeResults && recognizeResults[0];
			this.params = {};
			this.queryParams = {};
			this.handlers = [];
			this.middleware = middleware$1 || [];
			if (result) {
				this.handlers = result.handler;
				this.params = _objectSpread$1$8({}, result.params);
				this.queryParams = recognizeResults.queryParams;
			}
			this[HANDLERS] = this._orderedHandlers();
		}
		shouldPassthrough() {
			return Boolean(this._valueFor("passthrough"));
		}
		shouldIntercept() {
			return Boolean(this._valueFor("intercept"));
		}
		recordingName() {
			return this._valueFor("recordingName") || null;
		}
		config() {
			return mergeConfigs(...this[HANDLERS].map(({ handler }) => handler.get("config")));
		}
		applyFiltersWithArgs(req$2, ...args) {
			this[HANDLERS] = this[HANDLERS].filter(({ route, handler }) => [...handler.get("filters")].every((fn) => fn(requestWithParams(req$2, route), ...args)));
		}
		/**
		* Invokes the intercept handlers defined on the routes + middleware.
		* @param {PollyRequest} req
		* @param {PollyResponse} res
		* @param {Interceptor} interceptor
		*/
		async intercept(req$2, res$2, interceptor) {
			for (const { route, handler } of this[HANDLERS]) {
				if (!interceptor.shouldIntercept || interceptor.shouldStopPropagating) return;
				if (handler.has("intercept")) await handler.get("intercept")(requestWithParams(req$2, route), res$2, interceptor);
			}
		}
		/**
		* Emit an event registered on the handler + all middleware handler events
		* @param {String} eventName
		* @param {PollyRequest} req
		* @param {...args} ...args
		*/
		async emit(eventName, req$2, ...args) {
			for (const { route, handler } of this[HANDLERS]) if (!await handler._eventEmitter.emit(eventName, requestWithParams(req$2, route), ...args)) return;
		}
		_orderedHandlers() {
			return [...this.middleware, this].reduce((handlers, route) => {
				handlers.push(...route.handlers.map((handler) => ({
					route,
					handler
				})));
				return handlers;
			}, []);
		}
		_valueFor(key$1) {
			let value;
			for (const { handler } of this[HANDLERS]) if (handler.has(key$1)) value = handler.get(key$1);
			return value;
		}
	};
	function ownKeys$2$2(object, enumerableOnly) {
		var keys$6 = keys$3$1(object);
		if (getOwnPropertySymbols$1$5) {
			var symbols = getOwnPropertySymbols$1$5(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1$5(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$2$2(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$2$2(Object(source), true).forEach(function(key$1) {
				_defineProperty$5(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1$5) defineProperties$1$5(target, getOwnPropertyDescriptors$1$5(source));
			else ownKeys$2$2(Object(source)).forEach(function(key$1) {
				defineProperty$3$3(target, key$1, getOwnPropertyDescriptor$1$5(source, key$1));
			});
		}
		return target;
	}
	var Handler = class extends map$1$1 {
		constructor() {
			super();
			this.set("config", {});
			this.set("defaultOptions", {});
			this.set("filters", new set$1());
			this._eventEmitter = new EventEmitter$5({ eventNames: [
				"error",
				"abort",
				"request",
				"beforeReplay",
				"beforePersist",
				"beforeResponse",
				"response"
			] });
		}
		on(eventName, listener$6, options = {}) {
			this._eventEmitter.on(eventName, listener$6, _objectSpread$2$2(_objectSpread$2$2({}, this.get("defaultOptions")), options));
			return this;
		}
		once(eventName, listener$6) {
			this._eventEmitter.once(eventName, listener$6);
			return this;
		}
		off(eventName, listener$6) {
			this._eventEmitter.off(eventName, listener$6);
			return this;
		}
		passthrough(value = true) {
			this.set("passthrough", Boolean(value));
			if (this.get("passthrough")) this.delete("intercept");
			return this;
		}
		intercept(fn, options = {}) {
			utils$7.assert(`Invalid intercept handler provided. Expected function, received: "${typeof fn}".`, typeof fn === "function");
			options = _objectSpread$2$2(_objectSpread$2$2({}, this.get("defaultOptions")), options);
			if ("times" in options) {
				validateTimesOption(options.times);
				fn = cancelFnAfterNTimes(fn, options.times, () => this.delete("intercept"));
			}
			this.set("intercept", fn);
			this.passthrough(false);
			return this;
		}
		recordingName(recordingName) {
			if (recordingName) validateRecordingName(recordingName);
			this.set("recordingName", recordingName);
			return this;
		}
		configure(config) {
			validateRequestConfig(config);
			this.set("config", config);
			return this;
		}
		filter(fn) {
			utils$7.assert(`Invalid filter callback provided. Expected function, received: "${typeof fn}".`, typeof fn === "function");
			this.get("filters").add(fn);
			return this;
		}
		times(n) {
			if (!n && typeof n !== "number") delete this.get("defaultOptions").times;
			else {
				validateTimesOption(n);
				this.get("defaultOptions").times = n;
			}
			return this;
		}
	};
	const GLOBAL = "__GLOBAL__";
	var Middleware = class {
		constructor({ host, paths, global: global$1, handler }) {
			this.global = Boolean(global$1);
			this.handler = handler;
			this.host = host;
			this.paths = this.global ? [GLOBAL] : paths;
			this._routeRecognizer = new RouteRecognizer();
			this.paths.forEach((path$19) => this._routeRecognizer.add([{
				path: path$19,
				handler: [handler]
			}]));
		}
		match(host, path$19) {
			if (this.global) return new Route$3(this._routeRecognizer.recognize(GLOBAL));
			if (this.host === host) {
				const recognizeResult = this._routeRecognizer.recognize(path$19);
				return recognizeResult && new Route$3(recognizeResult);
			}
		}
	};
	const HOST = symbol$1$3();
	const NAMESPACES = symbol$1$3();
	const REGISTRY = symbol$1$3();
	const MIDDLEWARE = symbol$1$3();
	const HANDLERS$1 = symbol$1$3();
	const CHARS = {
		SLASH: "/",
		STAR: "*",
		COLON: ":"
	};
	const { keys: keys$5 } = Object;
	function parseUrl$1$1(url$6) {
		const parsedUrl = new utils$7.URL(url$6);
		return {
			host: parsedUrl.host ? parsedUrl.origin : CHARS.SLASH,
			path: parsedUrl.pathname || CHARS.SLASH
		};
	}
	var Server$1 = class {
		constructor() {
			this[HOST] = "";
			this[REGISTRY] = {};
			this[NAMESPACES] = [];
			this[MIDDLEWARE] = [];
		}
		host(path$19, callback) {
			const host = this[HOST];
			utils$7.assert(`[Server] A host cannot be specified within another host.`, !host);
			this[HOST] = path$19;
			callback(this);
			this[HOST] = host;
		}
		namespace(path$19, callback) {
			const namespaces = this[NAMESPACES];
			this[NAMESPACES] = [...namespaces, path$19];
			callback(this);
			this[NAMESPACES] = namespaces;
		}
		timeout() {
			return utils$7.timeout(...arguments);
		}
		get() {
			return this._register("GET", ...arguments);
		}
		put() {
			return this._register("PUT", ...arguments);
		}
		post() {
			return this._register("POST", ...arguments);
		}
		delete() {
			return this._register("DELETE", ...arguments);
		}
		patch() {
			return this._register("PATCH", ...arguments);
		}
		merge() {
			return this._register("MERGE", ...arguments);
		}
		head() {
			return this._register("HEAD", ...arguments);
		}
		options() {
			return this._register("OPTIONS", ...arguments);
		}
		any() {
			return this._registerMiddleware(...arguments);
		}
		lookup(method$1, url$6) {
			return new Route$3(this._recognize(method$1, url$6), this._lookupMiddleware(url$6));
		}
		_lookupMiddleware(url$6) {
			const { host, path: path$19 } = parseUrl$1$1(url$6);
			return this[MIDDLEWARE].map((m$3) => m$3.match(host, path$19)).filter(Boolean);
		}
		_register(method$1, routes) {
			const handler = new Handler();
			castArray(routes).forEach((route) => {
				const { host, path: path$19 } = parseUrl$1$1(this._buildUrl(route));
				const registry = this._registryForHost(host);
				const name = this._nameForPath(path$19);
				const router = registry[method$1.toUpperCase()];
				if (router[HANDLERS$1].has(name)) router[HANDLERS$1].get(name).push(handler);
				else {
					router[HANDLERS$1].set(name, [handler]);
					router.add([{
						path: path$19,
						handler: router[HANDLERS$1].get(name)
					}]);
				}
			});
			return handler;
		}
		_registerMiddleware(routes) {
			const handler = new Handler();
			const pathsByHost = {};
			castArray(routes).forEach((route) => {
				if ((!route || route === CHARS.STAR) && !this[HOST] && this[NAMESPACES].length === 0) this[MIDDLEWARE].push(new Middleware({
					global: true,
					handler
				}));
				else {
					const { host, path: path$19 } = parseUrl$1$1(this._buildUrl(route));
					pathsByHost[host] = pathsByHost[host] || [];
					pathsByHost[host].push(path$19);
				}
			});
			keys$5(pathsByHost).forEach((host) => {
				this[MIDDLEWARE].push(new Middleware({
					host,
					paths: pathsByHost[host],
					handler
				}));
			});
			return handler;
		}
		_recognize(method$1, url$6) {
			const { host, path: path$19 } = parseUrl$1$1(url$6);
			return this._registryForHost(host)[method$1.toUpperCase()].recognize(path$19);
		}
		_buildUrl(path$19) {
			return utils$7.buildUrl(this[HOST], ...this[NAMESPACES], path$19);
		}
		/**
		* Converts a url path into a name used to combine route handlers by
		* normalizing dynamic and star segments
		* @param {String} path
		* @returns {String}
		*/
		_nameForPath(path$19 = "") {
			return path$19.split(CHARS.SLASH).map((segment) => {
				switch (segment.charAt(0)) {
					case CHARS.COLON: return CHARS.COLON;
					case CHARS.STAR: return CHARS.STAR;
					default: return segment;
				}
			}).join(CHARS.SLASH).replace(/\/$/, "") || CHARS.SLASH;
		}
		_registryForHost(host) {
			if (!this[REGISTRY][host]) this[REGISTRY][host] = utils$7.HTTP_METHODS.reduce((acc, method$1) => {
				acc[method$1] = new RouteRecognizer();
				acc[method$1][HANDLERS$1] = new map$1$1();
				return acc;
			}, {});
			return this[REGISTRY][host];
		}
	};
	const RECORDING_NAME = symbol$1$3();
	const RECORDING_ID = symbol$1$3();
	const PAUSED_ADAPTERS = symbol$1$3();
	const FACTORY_REGISTRATION = new weakMap$1$1();
	const EVENT_EMITTER$1 = new EventEmitter$5({ eventNames: [
		"register",
		"create",
		"stop"
	] });
	/**
	* @export
	* @class Polly
	*/
	var Polly$1 = class {
		constructor(recordingName, config) {
			this.recordingName = recordingName;
			this.server = new Server$1();
			this.config = {};
			this.container = new Container();
			EVENT_EMITTER$1.emitSync("register", this.container);
			this.adapters = new map$1$1();
			this.persister = null;
			this._requests = [];
			EVENT_EMITTER$1.emitSync("create", this);
			this.configure(config);
		}
		/**
		* Package version.
		*
		* @readonly
		* @public
		* @memberof Polly
		*/
		static get VERSION() {
			return version;
		}
		/**
		* @public
		* @memberof Polly
		*/
		get recordingName() {
			return this[RECORDING_NAME];
		}
		set recordingName(name) {
			validateRecordingName(name);
			this[RECORDING_NAME] = name;
			this[RECORDING_ID] = guidForRecording(name);
		}
		/**
		* @readonly
		* @public
		* @memberof Polly
		*/
		get recordingId() {
			return this[RECORDING_ID];
		}
		get mode() {
			return this.config.mode;
		}
		set mode(mode) {
			const possibleModes = values$1(utils$7.MODES);
			utils$7.assert(`Invalid mode provided: "${mode}". Possible modes: ${possibleModes.join(", ")}.`, possibleModes.includes(mode));
			this.config.mode = mode;
		}
		static on(eventName, listener$6) {
			EVENT_EMITTER$1.on(eventName, listener$6);
			return this;
		}
		static once(eventName, listener$6) {
			EVENT_EMITTER$1.once(eventName, listener$6);
			return this;
		}
		static off(eventName, listener$6) {
			EVENT_EMITTER$1.off(eventName, listener$6);
			return this;
		}
		static register(Factory) {
			if (!FACTORY_REGISTRATION.has(Factory)) FACTORY_REGISTRATION.set(Factory, (container) => container.register(Factory));
			this.on("register", FACTORY_REGISTRATION.get(Factory));
			return this;
		}
		static unregister(Factory) {
			if (FACTORY_REGISTRATION.has(Factory)) this.off("register", FACTORY_REGISTRATION.get(Factory));
			return this;
		}
		/**
		* @param {Object} [config={}]
		* @public
		* @memberof Polly
		*/
		configure(config = {}) {
			const { container } = this;
			utils$7.assert("Cannot call `configure` once requests have been handled.", this._requests.length === 0);
			utils$7.assert("Cannot call `configure` on an instance of Polly that is not running.", this.mode !== utils$7.MODES.STOPPED);
			this.disconnect();
			if (this.logger) this.logger.disconnect();
			this.config = mergeConfigs(DefaultConfig$1, this.config, config);
			this.logger = new Logger(this);
			this.logger.connect();
			this.config.adapters.forEach((adapter) => this.connectTo(adapter));
			let { persister } = this.config;
			if (persister) {
				if (typeof persister === "function") {
					container.register(persister);
					persister = persister.id;
				}
				utils$7.assert(`Persister matching the name \`${persister}\` was not registered.`, container.has(`persister:${persister}`));
				this.persister = new (container.lookup(`persister:${persister}`))(this);
			}
			this.logger.log.debug("Polly instance configured.", { config: this.config });
		}
		/**
		* @public
		* @memberof Polly
		*/
		record() {
			this.mode = utils$7.MODES.RECORD;
		}
		/**
		* @public
		* @memberof Polly
		*/
		replay() {
			this.mode = utils$7.MODES.REPLAY;
		}
		/**
		* @public
		* @memberof Polly
		*/
		passthrough() {
			this.mode = utils$7.MODES.PASSTHROUGH;
		}
		/**
		* @public
		* @memberof Polly
		*/
		pause() {
			this[PAUSED_ADAPTERS] = [...this.adapters.keys()];
			this.disconnect();
		}
		/**
		* @public
		* @memberof Polly
		*/
		play() {
			if (this[PAUSED_ADAPTERS]) {
				this[PAUSED_ADAPTERS].forEach((adapterId) => this.connectTo(adapterId));
				delete this[PAUSED_ADAPTERS];
			}
		}
		/**
		* @public
		* @memberof Polly
		*/
		async stop() {
			if (this.mode !== utils$7.MODES.STOPPED) {
				if (this.config.flushRequestsOnStop) await this.flush();
				this.disconnect();
				await (this.persister && this.persister.persist());
				this.mode = utils$7.MODES.STOPPED;
				await EVENT_EMITTER$1.emit("stop", this);
				this.logger.log.debug("Polly instance stopped.", { recordingName: this.recordingName });
				this.logger.disconnect();
			}
		}
		async flush() {
			const NOOP = () => {};
			await promise$1$3.all(this._requests.map((r) => promise$1$3.resolve(r.promise).then(NOOP, NOOP)));
		}
		/**
		* @param {String|Function} idOrFactory
		* @public
		* @memberof Polly
		*/
		connectTo(idOrAdapter) {
			const { container, adapters } = this;
			let adapterId = idOrAdapter;
			if (typeof idOrAdapter === "function") {
				container.register(idOrAdapter);
				adapterId = idOrAdapter.id;
			}
			utils$7.assert(`Adapter matching the name \`${adapterId}\` was not registered.`, container.has(`adapter:${adapterId}`));
			this.disconnectFrom(adapterId);
			const adapter = new (container.lookup(`adapter:${adapterId}`))(this);
			adapter.connect();
			adapters.set(adapterId, adapter);
		}
		/**
		* @param {String|Function} idOrAdapter
		* @public
		* @memberof Polly
		*/
		disconnectFrom(idOrAdapter) {
			const { adapters } = this;
			let adapterId = idOrAdapter;
			if (typeof idOrAdapter === "function") adapterId = idOrAdapter.id;
			if (adapters.has(adapterId)) {
				adapters.get(adapterId).disconnect();
				adapters.delete(adapterId);
			}
		}
		/**
		* @public
		* @memberof Polly
		*/
		disconnect() {
			for (const adapterId of this.adapters.keys()) this.disconnectFrom(adapterId);
		}
		/**
		* @param {Object} [request={}]
		* @returns {PollyRequest}
		* @private
		* @memberof Polly
		*/
		registerRequest(request = {}) {
			const pollyRequest = new PollyRequest(this, request);
			this._requests.push(pollyRequest);
			return pollyRequest;
		}
	};
	const { defineProperty: defineProperty$5$2 } = Object;
	function beforeEach(context, recordingName, defaults$5) {
		defineProperty$5$2(context, "polly", {
			writable: true,
			enumerable: true,
			configurable: true,
			value: new Polly$1(recordingName, defaults$5)
		});
	}
	async function afterEach(context, framework) {
		await context.polly.stop();
		defineProperty$5$2(context, "polly", {
			enumerable: true,
			configurable: true,
			get() {
				throw new utils$7.PollyError(`You are trying to access an instance of Polly that is no longer available.\nSee: https://netflix.github.io/pollyjs/#/test-frameworks/${framework}?id=test-hook-ordering`);
			}
		});
	}
	function generateRecordingName(assert$4) {
		return assert$4.test.testReport.fullName.join("/");
	}
	function setupQunit(hooks, defaults$5 = {}) {
		setupQunit.beforeEach(hooks, defaults$5);
		setupQunit.afterEach(hooks);
	}
	setupQunit.beforeEach = function setupQunitBeforeEach(hooks, defaults$5 = {}) {
		hooks.beforeEach(function() {
			return beforeEach(this, generateRecordingName(...arguments), defaults$5);
		});
	};
	setupQunit.afterEach = function setupQunitAfterEach(hooks) {
		hooks.afterEach(function() {
			return afterEach(this, "qunit");
		});
	};
	function generateRecordingName$1(context) {
		const { currentTest } = context;
		const parts = [currentTest.title];
		let parent = currentTest.parent;
		while (parent && parent.title) {
			parts.push(parent.title);
			parent = parent.parent;
		}
		return parts.reverse().join("/");
	}
	function setupMocha(defaults$5 = {}, ctx = global) {
		setupMocha.beforeEach(defaults$5, ctx);
		setupMocha.afterEach(ctx);
	}
	setupMocha.beforeEach = function setupMochaBeforeEach(defaults$5, ctx = global) {
		ctx.beforeEach(function() {
			return beforeEach(this, generateRecordingName$1(this), defaults$5);
		});
	};
	setupMocha.afterEach = function setupMochaAfterEach(ctx = global) {
		ctx.afterEach(function() {
			return afterEach(this, "mocha");
		});
	};
	exports.Polly = Polly$1;
	exports.Timing = Timing;
	exports.setupMocha = setupMocha;
	exports.setupQunit = setupQunit;
}) });

//#endregion
//#region ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js": ((exports, module) => {
	/**
	* Helpers.
	*/
	var s$2 = 1e3;
	var m$2 = s$2 * 60;
	var h$2 = m$2 * 60;
	var d$2 = h$2 * 24;
	var w$1 = d$2 * 7;
	var y$2 = d$2 * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$15(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong$2(val) : fmtShort$2(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$15(str) {
		str = String(str);
		if (str.length > 100) return;
		var match$1 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match$1) return;
		var n = parseFloat(match$1[1]);
		switch ((match$1[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y$2;
			case "weeks":
			case "week":
			case "w": return n * w$1;
			case "days":
			case "day":
			case "d": return n * d$2;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h$2;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m$2;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s$2;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort$2(ms$2) {
		var msAbs = Math.abs(ms$2);
		if (msAbs >= d$2) return Math.round(ms$2 / d$2) + "d";
		if (msAbs >= h$2) return Math.round(ms$2 / h$2) + "h";
		if (msAbs >= m$2) return Math.round(ms$2 / m$2) + "m";
		if (msAbs >= s$2) return Math.round(ms$2 / s$2) + "s";
		return ms$2 + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong$2(ms$2) {
		var msAbs = Math.abs(ms$2);
		if (msAbs >= d$2) return plural$2(ms$2, msAbs, d$2, "day");
		if (msAbs >= h$2) return plural$2(ms$2, msAbs, h$2, "hour");
		if (msAbs >= m$2) return plural$2(ms$2, msAbs, m$2, "minute");
		if (msAbs >= s$2) return plural$2(ms$2, msAbs, s$2, "second");
		return ms$2 + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural$2(ms$2, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms$2 / n) + " " + name + (isPlural ? "s" : "");
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js
var require_common$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js": ((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup$1(env$2) {
		createDebug$1.debug = createDebug$1;
		createDebug$1.default = createDebug$1;
		createDebug$1.coerce = coerce$1;
		createDebug$1.disable = disable$1;
		createDebug$1.enable = enable$1;
		createDebug$1.enabled = enabled$1;
		createDebug$1.humanize = require_ms$1();
		createDebug$1.destroy = destroy$3;
		Object.keys(env$2).forEach((key$1) => {
			createDebug$1[key$1] = env$2[key$1];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug$1.names = [];
		createDebug$1.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug$1.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor$1(namespace) {
			let hash = 0;
			for (let i$8 = 0; i$8 < namespace.length; i$8++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i$8);
				hash |= 0;
			}
			return createDebug$1.colors[Math.abs(hash) % createDebug$1.colors.length];
		}
		createDebug$1.selectColor = selectColor$1;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug$1(namespace) {
			let prevTime$1;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$23(...args) {
				if (!debug$23.enabled) return;
				const self$1 = debug$23;
				const curr = Number(/* @__PURE__ */ new Date());
				self$1.diff = curr - (prevTime$1 || curr);
				self$1.prev = prevTime$1;
				self$1.curr = curr;
				prevTime$1 = curr;
				args[0] = createDebug$1.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index$1 = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match$1, format$6) => {
					if (match$1 === "%%") return "%";
					index$1++;
					const formatter = createDebug$1.formatters[format$6];
					if (typeof formatter === "function") {
						const val = args[index$1];
						match$1 = formatter.call(self$1, val);
						args.splice(index$1, 1);
						index$1--;
					}
					return match$1;
				});
				createDebug$1.formatArgs.call(self$1, args);
				(self$1.log || createDebug$1.log).apply(self$1, args);
			}
			debug$23.namespace = namespace;
			debug$23.useColors = createDebug$1.useColors();
			debug$23.color = createDebug$1.selectColor(namespace);
			debug$23.extend = extend;
			debug$23.destroy = createDebug$1.destroy;
			Object.defineProperty(debug$23, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug$1.namespaces) {
						namespacesCache = createDebug$1.namespaces;
						enabledCache = createDebug$1.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug$1.init === "function") createDebug$1.init(debug$23);
			return debug$23;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug$1(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable$1(namespaces) {
			createDebug$1.save(namespaces);
			createDebug$1.namespaces = namespaces;
			createDebug$1.names = [];
			createDebug$1.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug$1.skips.push(ns.slice(1));
			else createDebug$1.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable$1() {
			const namespaces = [...createDebug$1.names, ...createDebug$1.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug$1.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled$1(name) {
			for (const skip of createDebug$1.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug$1.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce$1(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy$3() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug$1.enable(createDebug$1.load());
		return createDebug$1;
	}
	module.exports = setup$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js
var require_browser$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js": ((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*/
	exports.formatArgs = formatArgs$3;
	exports.save = save$3;
	exports.load = load$6;
	exports.useColors = useColors$3;
	exports.storage = localstorage$1();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
			}
		};
	})();
	/**
	* Colors.
	*/
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors$3() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		let m$3;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$3 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$3[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs$3(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index$1 = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match$1) => {
			if (match$1 === "%%") return;
			index$1++;
			if (match$1 === "%c") lastC = index$1;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.debug()` when available.
	* No-op when `console.debug` is not a "function".
	* If `console.debug` is not available, falls back
	* to `console.log`.
	*
	* @api public
	*/
	exports.log = console.debug || console.log || (() => {});
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save$3(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load$6() {
		let r;
		try {
			r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
		} catch (error) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage$1() {
		try {
			return localStorage;
		} catch (error) {}
	}
	module.exports = require_common$1()(exports);
	const { formatters: formatters$1 } = module.exports;
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	formatters$1.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js": ((exports, module) => {
	module.exports = (flag, argv = process.argv) => {
		const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf("--");
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js": ((exports, module) => {
	const os$1 = __require("os");
	const tty$3 = __require("tty");
	const hasFlag$1 = require_has_flag();
	const { env: env$1 } = process;
	let forceColor$1;
	if (hasFlag$1("no-color") || hasFlag$1("no-colors") || hasFlag$1("color=false") || hasFlag$1("color=never")) forceColor$1 = 0;
	else if (hasFlag$1("color") || hasFlag$1("colors") || hasFlag$1("color=true") || hasFlag$1("color=always")) forceColor$1 = 1;
	if ("FORCE_COLOR" in env$1) if (env$1.FORCE_COLOR === "true") forceColor$1 = 1;
	else if (env$1.FORCE_COLOR === "false") forceColor$1 = 0;
	else forceColor$1 = env$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env$1.FORCE_COLOR, 10), 3);
	function translateLevel$1(level) {
		if (level === 0) return false;
		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}
	function supportsColor$1(haveStream, streamIsTTY) {
		if (forceColor$1 === 0) return 0;
		if (hasFlag$1("color=16m") || hasFlag$1("color=full") || hasFlag$1("color=truecolor")) return 3;
		if (hasFlag$1("color=256")) return 2;
		if (haveStream && !streamIsTTY && forceColor$1 === void 0) return 0;
		const min$8 = forceColor$1 || 0;
		if (env$1.TERM === "dumb") return min$8;
		if (process.platform === "win32") {
			const osRelease = os$1.release().split(".");
			if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
			return 1;
		}
		if ("CI" in env$1) {
			if ([
				"TRAVIS",
				"CIRCLECI",
				"APPVEYOR",
				"GITLAB_CI",
				"GITHUB_ACTIONS",
				"BUILDKITE"
			].some((sign$2) => sign$2 in env$1) || env$1.CI_NAME === "codeship") return 1;
			return min$8;
		}
		if ("TEAMCITY_VERSION" in env$1) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;
		if (env$1.COLORTERM === "truecolor") return 3;
		if ("TERM_PROGRAM" in env$1) {
			const version$1 = parseInt((env$1.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
			switch (env$1.TERM_PROGRAM) {
				case "iTerm.app": return version$1 >= 3 ? 3 : 2;
				case "Apple_Terminal": return 2;
			}
		}
		if (/-256(color)?$/i.test(env$1.TERM)) return 2;
		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) return 1;
		if ("COLORTERM" in env$1) return 1;
		return min$8;
	}
	function getSupportLevel$1(stream$3) {
		return translateLevel$1(supportsColor$1(stream$3, stream$3 && stream$3.isTTY));
	}
	module.exports = {
		supportsColor: getSupportLevel$1,
		stdout: translateLevel$1(supportsColor$1(true, tty$3.isatty(1))),
		stderr: translateLevel$1(supportsColor$1(true, tty$3.isatty(2)))
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js
var require_node$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	const tty$2 = __require("tty");
	const util$8 = __require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*/
	exports.init = init$1;
	exports.log = log$3;
	exports.formatArgs = formatArgs$2;
	exports.save = save$2;
	exports.load = load$5;
	exports.useColors = useColors$2;
	exports.destroy = util$8.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		const supportsColor$2 = require_supports_color();
		if (supportsColor$2 && (supportsColor$2.stderr || supportsColor$2).level >= 2) exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	} catch (error) {}
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter((key$1) => {
		return /^debug_/i.test(key$1);
	}).reduce((obj, key$1) => {
		const prop = key$1.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k$7) => {
			return k$7.toUpperCase();
		});
		let val = process.env[key$1];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors$2() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty$2.isatty(process.stderr.fd);
	}
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs$2(args) {
		const { namespace: name, useColors: useColors$4 } = this;
		if (useColors$4) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name + " " + args[0];
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) return "";
		return (/* @__PURE__ */ new Date()).toISOString() + " ";
	}
	/**
	* Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	*/
	function log$3(...args) {
		return process.stderr.write(util$8.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save$2(namespaces) {
		if (namespaces) process.env.DEBUG = namespaces;
		else delete process.env.DEBUG;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load$5() {
		return process.env.DEBUG;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init$1(debug$23) {
		debug$23.inspectOpts = {};
		const keys$6 = Object.keys(exports.inspectOpts);
		for (let i$8 = 0; i$8 < keys$6.length; i$8++) debug$23.inspectOpts[keys$6[i$8]] = exports.inspectOpts[keys$6[i$8]];
	}
	module.exports = require_common$1()(exports);
	const { formatters } = module.exports;
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$8.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	};
	/**
	* Map %O to `util.inspect()`, allowing multiple lines if needed.
	*/
	formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$8.inspect(v, this.inspectOpts);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js
var require_src$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js": ((exports, module) => {
	/**
	* Detect Electron renderer / nwjs process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) module.exports = require_browser$1();
	else module.exports = require_node$1();
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/common.js
var require_common = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/common.js": ((exports, module) => {
	const debug$22 = require_src$1()("nock.common");
	const timers$1 = __require("timers");
	const url$4 = __require("url");
	const util$7 = __require("util");
	/**
	* Normalizes the request options so that it always has `host` property.
	*
	* @param  {Object} options - a parsed options object of the request
	*/
	function normalizeRequestOptions$1(options) {
		options.proto = options.proto || "http";
		options.port = options.port || (options.proto === "http" ? 80 : 443);
		if (options.host) {
			debug$22("options.host:", options.host);
			if (!options.hostname) if (options.host.split(":").length === 2) options.hostname = options.host.split(":")[0];
			else options.hostname = options.host;
		}
		debug$22("options.hostname in the end: %j", options.hostname);
		options.host = `${options.hostname || "localhost"}:${options.port}`;
		debug$22("options.host in the end: %j", options.host);
		["hostname", "host"].forEach(function(attr) {
			if (options[attr]) options[attr] = options[attr].toLowerCase();
		});
		return options;
	}
	/**
	* Returns true if the data contained in buffer can be reconstructed
	* from its utf8 representation.
	*
	* @param  {Object} buffer - a Buffer object
	* @returns {boolean}
	*/
	function isUtf8Representable$1(buffer$5) {
		const utfEncodedBuffer = buffer$5.toString("utf8");
		return Buffer.from(utfEncodedBuffer, "utf8").equals(buffer$5);
	}
	let requestOverrides$1 = {};
	/**
	* Overrides the current `request` function of `http` and `https` modules with
	* our own version which intercepts issues HTTP/HTTPS requests and forwards them
	* to the given `newRequest` function.
	*
	* @param  {Function} newRequest - a function handling requests; it accepts four arguments:
	*   - proto - a string with the overridden module's protocol name (either `http` or `https`)
	*   - overriddenRequest - the overridden module's request function already bound to module's object
	*   - options - the options of the issued request
	*   - callback - the callback of the issued request
	*/
	function overrideRequests$1(newRequest) {
		debug$22("overriding requests");
		["http", "https"].forEach(function(proto$7) {
			debug$22("- overriding request for", proto$7);
			const moduleName = proto$7;
			const module$2 = __require(proto$7);
			const overriddenRequest = module$2.request;
			const overriddenGet = module$2.get;
			if (requestOverrides$1[moduleName]) throw new Error(`Module's request already overridden for ${moduleName} protocol.`);
			requestOverrides$1[moduleName] = {
				module: module$2,
				request: overriddenRequest,
				get: overriddenGet
			};
			module$2.request = function(input, options, callback) {
				return newRequest(proto$7, overriddenRequest.bind(module$2), [
					input,
					options,
					callback
				]);
			};
			module$2.get = function(input, options, callback) {
				const req$2 = newRequest(proto$7, overriddenGet.bind(module$2), [
					input,
					options,
					callback
				]);
				req$2.end();
				return req$2;
			};
			debug$22("- overridden request for", proto$7);
		});
	}
	/**
	* Restores `request` function of `http` and `https` modules to values they
	* held before they were overridden by us.
	*/
	function restoreOverriddenRequests$1() {
		debug$22("restoring requests");
		Object.entries(requestOverrides$1).forEach(([proto$7, { module: module$2, request, get: get$1 }]) => {
			debug$22("- restoring request for", proto$7);
			module$2.request = request;
			module$2.get = get$1;
			debug$22("- restored request for", proto$7);
		});
		requestOverrides$1 = {};
	}
	/**
	* In WHATWG URL vernacular, this returns the origin portion of a URL.
	* However, the port is not included if it's standard and not already present on the host.
	*/
	function normalizeOrigin$1(proto$7, host, port$6) {
		return `${proto$7}://${host}${host.includes(":") || proto$7 === "http" && (port$6 === 80 || port$6 === "80") || proto$7 === "https" && (port$6 === 443 || port$6 === "443") ? "" : `:${port$6}`}`;
	}
	/**
	* Get high level information about request as string
	* @param  {Object} options
	* @param  {string} options.method
	* @param  {number|string} options.port
	* @param  {string} options.proto Set internally. always http or https
	* @param  {string} options.hostname
	* @param  {string} options.path
	* @param  {Object} options.headers
	* @param  {string} body
	* @return {string}
	*/
	function stringifyRequest$2(options, body$1) {
		const { method: method$1 = "GET", path: path$19 = "", port: port$6 } = options;
		const log$4 = {
			method: method$1,
			url: `${normalizeOrigin$1(options.proto, options.hostname, port$6)}${path$19}`,
			headers: options.headers
		};
		if (body$1) log$4.body = body$1;
		return JSON.stringify(log$4, null, 2);
	}
	function isContentEncoded$1(headers$1) {
		const contentEncoding$2 = headers$1["content-encoding"];
		return typeof contentEncoding$2 === "string" && contentEncoding$2 !== "";
	}
	function contentEncoding$1(headers$1, encoder) {
		const contentEncoding$2 = headers$1["content-encoding"];
		return contentEncoding$2 !== void 0 && contentEncoding$2.toString() === encoder;
	}
	function isJSONContent$1(headers$1) {
		return String(headers$1["content-type"] || "").toLowerCase().startsWith("application/json");
	}
	/**
	* Return a new object with all field names of the headers lower-cased.
	*
	* Duplicates throw an error.
	*/
	function headersFieldNamesToLowerCase$1(headers$1, throwOnDuplicate) {
		if (!isPlainObject$1(headers$1)) throw Error("Headers must be provided as an object");
		const lowerCaseHeaders = {};
		Object.entries(headers$1).forEach(([fieldName, fieldValue]) => {
			const key$1 = fieldName.toLowerCase();
			if (lowerCaseHeaders[key$1] !== void 0) if (throwOnDuplicate) throw Error(`Failed to convert header keys to lower case due to field name conflict: ${key$1}`);
			else debug$22(`Duplicate header provided in request: ${key$1}. Only the last value can be matched.`);
			lowerCaseHeaders[key$1] = fieldValue;
		});
		return lowerCaseHeaders;
	}
	const headersFieldsArrayToLowerCase$1 = (headers$1) => [...new Set(headers$1.map((fieldName) => fieldName.toLowerCase()))];
	/**
	* Converts the various accepted formats of headers into a flat array representing "raw headers".
	*
	* Nock allows headers to be provided as a raw array, a plain object, or a Map.
	*
	* While all the header names are expected to be strings, the values are left intact as they can
	* be functions, strings, or arrays of strings.
	*
	*  https://nodejs.org/api/http.html#http_message_rawheaders
	*/
	function headersInputToRawArray$1(headers$1) {
		if (headers$1 === void 0) return [];
		if (Array.isArray(headers$1)) {
			if (headers$1.length % 2) throw new Error(`Raw headers must be provided as an array with an even number of items. [fieldName, value, ...]`);
			return [...headers$1];
		}
		if (util$7.types.isMap(headers$1)) return [].concat(...Array.from(headers$1, ([k$7, v]) => [k$7.toString(), v]));
		if (isPlainObject$1(headers$1)) return [].concat(...Object.entries(headers$1));
		throw new Error(`Headers must be provided as an array of raw values, a Map, or a plain Object. ${headers$1}`);
	}
	/**
	* Converts an array of raw headers to an object, using the same rules as Nodes `http.IncomingMessage.headers`.
	*
	* Header names/keys are lower-cased.
	*/
	function headersArrayToObject$1(rawHeaders) {
		if (!Array.isArray(rawHeaders)) throw Error("Expected a header array");
		const accumulator = {};
		forEachHeader$1(rawHeaders, (value, fieldName) => {
			addHeaderLine$1(accumulator, fieldName, value);
		});
		return accumulator;
	}
	const noDuplicatesHeaders$1 = new Set([
		"age",
		"authorization",
		"content-length",
		"content-type",
		"etag",
		"expires",
		"from",
		"host",
		"if-modified-since",
		"if-unmodified-since",
		"last-modified",
		"location",
		"max-forwards",
		"proxy-authorization",
		"referer",
		"retry-after",
		"user-agent"
	]);
	/**
	* Set key/value data in accordance with Node's logic for folding duplicate headers.
	*
	* The `value` param should be a function, string, or array of strings.
	*
	* Node's docs and source:
	* https://nodejs.org/api/http.html#http_message_headers
	* https://github.com/nodejs/node/blob/908292cf1f551c614a733d858528ffb13fb3a524/lib/_http_incoming.js#L245
	*
	* Header names are lower-cased.
	* Duplicates in raw headers are handled in the following ways, depending on the header name:
	* - Duplicates of field names listed in `noDuplicatesHeaders` (above) are discarded.
	* - `set-cookie` is always an array. Duplicates are added to the array.
	* - For duplicate `cookie` headers, the values are joined together with '; '.
	* - For all other headers, the values are joined together with ', '.
	*
	* Node's implementation is larger because it highly optimizes for not having to call `toLowerCase()`.
	* We've opted to always call `toLowerCase` in exchange for a more concise function.
	*
	* While Node has the luxury of knowing `value` is always a string, we do an extra step of coercion at the top.
	*/
	function addHeaderLine$1(headers$1, name, value) {
		let values;
		if (typeof value === "function") values = [value.name];
		else if (Array.isArray(value)) values = value.map(String);
		else values = [String(value)];
		const key$1 = name.toLowerCase();
		if (key$1 === "set-cookie") if (headers$1["set-cookie"] === void 0) headers$1["set-cookie"] = values;
		else headers$1["set-cookie"].push(...values);
		else if (noDuplicatesHeaders$1.has(key$1)) {
			if (headers$1[key$1] === void 0) headers$1[key$1] = values[0];
		} else {
			if (headers$1[key$1] !== void 0) values = [headers$1[key$1], ...values];
			const separator = key$1 === "cookie" ? "; " : ", ";
			headers$1[key$1] = values.join(separator);
		}
	}
	/**
	* Deletes the given `fieldName` property from `headers` object by performing
	* case-insensitive search through keys.
	*
	* @headers   {Object} headers - object of header field names and values
	* @fieldName {String} field name - string with the case-insensitive field name
	*/
	function deleteHeadersField$1(headers$1, fieldNameToDelete) {
		if (!isPlainObject$1(headers$1)) throw Error("headers must be an object");
		if (typeof fieldNameToDelete !== "string") throw Error("field name must be a string");
		const lowerCaseFieldNameToDelete = fieldNameToDelete.toLowerCase();
		Object.keys(headers$1).filter((fieldName) => fieldName.toLowerCase() === lowerCaseFieldNameToDelete).forEach((fieldName) => delete headers$1[fieldName]);
	}
	/**
	* Utility for iterating over a raw headers array.
	*
	* The callback is called with:
	*  - The header value. string, array of strings, or a function
	*  - The header field name. string
	*  - Index of the header field in the raw header array.
	*/
	function forEachHeader$1(rawHeaders, callback) {
		for (let i$8 = 0; i$8 < rawHeaders.length; i$8 += 2) callback(rawHeaders[i$8 + 1], rawHeaders[i$8], i$8);
	}
	function percentDecode$1(str) {
		try {
			return decodeURIComponent(str.replace(/\+/g, " "));
		} catch (e) {
			return str;
		}
	}
	/**
	* URI encode the provided string, stringently adhering to RFC 3986.
	*
	* RFC 3986 reserves !, ', (, ), and * but encodeURIComponent does not encode them so we do it manually.
	*
	* https://tools.ietf.org/html/rfc3986
	* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
	*/
	function percentEncode$1(str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
			return `%${c.charCodeAt(0).toString(16).toUpperCase()}`;
		});
	}
	function matchStringOrRegexp$1(target, pattern) {
		const targetStr = target === void 0 || target === null ? "" : String(target);
		if (pattern instanceof RegExp) {
			pattern.lastIndex = 0;
			return pattern.test(targetStr);
		}
		return targetStr === String(pattern);
	}
	/**
	* Formats a query parameter.
	*
	* @param key                The key of the query parameter to format.
	* @param value              The value of the query parameter to format.
	* @param stringFormattingFn The function used to format string values. Can
	*                           be used to encode or decode the query value.
	*
	* @returns *[] the formatted [key, value] pair.
	*/
	function formatQueryValue$1(key$1, value, stringFormattingFn) {
		switch (true) {
			case typeof value === "number":
			case typeof value === "boolean":
				value = value.toString();
				break;
			case value === null:
			case value === void 0:
				value = "";
				break;
			case typeof value === "string":
				if (stringFormattingFn) value = stringFormattingFn(value);
				break;
			case value instanceof RegExp: break;
			case Array.isArray(value):
				value = value.map(function(val, idx) {
					return formatQueryValue$1(idx, val, stringFormattingFn)[1];
				});
				break;
			case typeof value === "object":
				value = Object.entries(value).reduce(function(acc, [subKey, subVal]) {
					const subPair = formatQueryValue$1(subKey, subVal, stringFormattingFn);
					acc[subPair[0]] = subPair[1];
					return acc;
				}, {});
				break;
		}
		if (stringFormattingFn) key$1 = stringFormattingFn(key$1);
		return [key$1, value];
	}
	function isStream$1(obj) {
		return obj && typeof obj !== "string" && !Buffer.isBuffer(obj) && typeof obj.setEncoding === "function";
	}
	/**
	* Converts the arguments from the various signatures of http[s].request into a standard
	* options object and an optional callback function.
	*
	* https://nodejs.org/api/http.html#http_http_request_url_options_callback
	*
	* Taken from the beginning of the native `ClientRequest`.
	* https://github.com/nodejs/node/blob/908292cf1f551c614a733d858528ffb13fb3a524/lib/_http_client.js#L68
	*/
	function normalizeClientRequestArgs$1(input, options, cb) {
		if (typeof input === "string") input = urlToOptions$2(new url$4.URL(input));
		else if (input instanceof url$4.URL) input = urlToOptions$2(input);
		else {
			cb = options;
			options = input;
			input = null;
		}
		if (typeof options === "function") {
			cb = options;
			options = input || {};
		} else options = Object.assign(input || {}, options);
		return {
			options,
			callback: cb
		};
	}
	/**
	* Utility function that converts a URL object into an ordinary
	* options object as expected by the http.request and https.request APIs.
	*
	* This was copied from Node's source
	* https://github.com/nodejs/node/blob/908292cf1f551c614a733d858528ffb13fb3a524/lib/internal/url.js#L1257
	*/
	function urlToOptions$2(url$6) {
		const options = {
			protocol: url$6.protocol,
			hostname: typeof url$6.hostname === "string" && url$6.hostname.startsWith("[") ? url$6.hostname.slice(1, -1) : url$6.hostname,
			hash: url$6.hash,
			search: url$6.search,
			pathname: url$6.pathname,
			path: `${url$6.pathname}${url$6.search || ""}`,
			href: url$6.href
		};
		if (url$6.port !== "") options.port = Number(url$6.port);
		if (url$6.username || url$6.password) options.auth = `${url$6.username}:${url$6.password}`;
		return options;
	}
	/**
	* Determines if request data matches the expected schema.
	*
	* Used for comparing decoded search parameters, request body JSON objects,
	* and URL decoded request form bodies.
	*
	* Performs a general recursive strict comparison with two caveats:
	*  - The expected data can use regexp to compare values
	*  - JSON path notation and nested objects are considered equal
	*/
	const dataEqual$1 = (expected, actual) => {
		if (isPlainObject$1(expected)) expected = expand$1(expected);
		if (isPlainObject$1(actual)) actual = expand$1(actual);
		return deepEqual$1(expected, actual);
	};
	/**
	* Performs a recursive strict comparison between two values.
	*
	* Expected values or leaf nodes of expected object values that are RegExp use test() for comparison.
	*/
	function deepEqual$1(expected, actual) {
		debug$22("deepEqual comparing", typeof expected, expected, typeof actual, actual);
		if (expected instanceof RegExp) return expected.test(actual);
		if (Array.isArray(expected) && Array.isArray(actual)) {
			if (expected.length !== actual.length) return false;
			return expected.every((expVal, idx) => deepEqual$1(expVal, actual[idx]));
		}
		if (isPlainObject$1(expected) && isPlainObject$1(actual)) return Array.from(new Set(Object.keys(expected).concat(Object.keys(actual)))).every((key$1) => deepEqual$1(expected[key$1], actual[key$1]));
		return expected === actual;
	}
	const timeouts$1 = /* @__PURE__ */ new Set();
	const immediates$1 = /* @__PURE__ */ new Set();
	const wrapTimer$1 = (timer, ids) => (callback, ...timerArgs) => {
		const cb = (...callbackArgs) => {
			try {
				callback(...callbackArgs);
			} finally {
				ids.delete(id$7);
			}
		};
		const id$7 = timer(cb, ...timerArgs);
		ids.add(id$7);
		return id$7;
	};
	const setTimeout$2 = wrapTimer$1(timers$1.setTimeout, timeouts$1);
	const setImmediate$2 = wrapTimer$1(timers$1.setImmediate, immediates$1);
	function clearTimer$1(clear$1, ids) {
		ids.forEach(clear$1);
		ids.clear();
	}
	function removeAllTimers$1() {
		clearTimer$1(clearTimeout, timeouts$1);
		clearTimer$1(clearImmediate, immediates$1);
	}
	/**
	* Check if the Client Request has been cancelled.
	*
	* Until Node 14 is the minimum, we need to look at both flags to see if the request has been cancelled.
	* The two flags have the same purpose, but the Node maintainers are migrating from `abort(ed)` to
	* `destroy(ed)` terminology, to be more consistent with `stream.Writable`.
	* In Node 14.x+, Calling `abort()` will set both `aborted` and `destroyed` to true, however,
	* calling `destroy()` will only set `destroyed` to true.
	* Falling back on checking if the socket is destroyed to cover the case of Node <14.x where
	* `destroy()` is called, but `destroyed` is undefined.
	*
	* Node Client Request history:
	* - `request.abort()`: Added in: v0.3.8, Deprecated since: v14.1.0, v13.14.0
	* - `request.aborted`: Added in: v0.11.14, Became a boolean instead of a timestamp: v11.0.0, Not deprecated (yet)
	* - `request.destroy()`: Added in: v0.3.0
	* - `request.destroyed`: Added in: v14.1.0, v13.14.0
	*
	* @param {ClientRequest} req
	* @returns {boolean}
	*/
	function isRequestDestroyed$1(req$2) {
		return !!(req$2.destroyed === true || req$2.aborted || req$2.socket && req$2.socket.destroyed);
	}
	/**
	* Returns true if the given value is a plain object and not an Array.
	* @param {*} value
	* @returns {boolean}
	*/
	function isPlainObject$1(value) {
		if (typeof value !== "object" || value === null) return false;
		if (Object.prototype.toString.call(value) !== "[object Object]") return false;
		const proto$7 = Object.getPrototypeOf(value);
		if (proto$7 === null) return true;
		const Ctor = Object.prototype.hasOwnProperty.call(proto$7, "constructor") && proto$7.constructor;
		return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
	}
	const prototypePollutionBlockList = [
		"__proto__",
		"prototype",
		"constructor"
	];
	const blocklistFilter = function(part) {
		return prototypePollutionBlockList.indexOf(part) === -1;
	};
	/**
	* Converts flat objects whose keys use JSON path notation to nested objects.
	*
	* The input object is not mutated.
	*
	* @example
	* { 'foo[bar][0]': 'baz' } -> { foo: { bar: [ 'baz' ] } }
	*/
	const expand$1 = (input) => {
		if (input === void 0 || input === null) return input;
		const keys$6 = Object.keys(input);
		const result = {};
		let resultPtr = result;
		for (let path$19 of keys$6) {
			const originalPath = path$19;
			if (path$19.indexOf("[") >= 0) path$19 = path$19.replace(/\[/g, ".").replace(/]/g, "");
			const parts = path$19.split(".");
			if (parts.filter(blocklistFilter).length !== parts.length) return;
			resultPtr = result;
			const lastIndex = parts.length - 1;
			for (let i$8 = 0; i$8 < parts.length; ++i$8) {
				const part = parts[i$8];
				if (i$8 === lastIndex) if (Array.isArray(resultPtr)) resultPtr[+part] = input[originalPath];
				else resultPtr[part] = input[originalPath];
				else {
					if (resultPtr[part] === void 0 || resultPtr[part] === null) {
						const nextPart = parts[i$8 + 1];
						if (/^\d+$/.test(nextPart)) resultPtr[part] = [];
						else resultPtr[part] = {};
					}
					resultPtr = resultPtr[part];
				}
			}
		}
		return result;
	};
	module.exports = {
		contentEncoding: contentEncoding$1,
		dataEqual: dataEqual$1,
		deleteHeadersField: deleteHeadersField$1,
		expand: expand$1,
		forEachHeader: forEachHeader$1,
		formatQueryValue: formatQueryValue$1,
		headersArrayToObject: headersArrayToObject$1,
		headersFieldNamesToLowerCase: headersFieldNamesToLowerCase$1,
		headersFieldsArrayToLowerCase: headersFieldsArrayToLowerCase$1,
		headersInputToRawArray: headersInputToRawArray$1,
		isContentEncoded: isContentEncoded$1,
		isJSONContent: isJSONContent$1,
		isPlainObject: isPlainObject$1,
		isRequestDestroyed: isRequestDestroyed$1,
		isStream: isStream$1,
		isUtf8Representable: isUtf8Representable$1,
		matchStringOrRegexp: matchStringOrRegexp$1,
		normalizeClientRequestArgs: normalizeClientRequestArgs$1,
		normalizeOrigin: normalizeOrigin$1,
		normalizeRequestOptions: normalizeRequestOptions$1,
		overrideRequests: overrideRequests$1,
		percentDecode: percentDecode$1,
		percentEncode: percentEncode$1,
		removeAllTimers: removeAllTimers$1,
		restoreOverriddenRequests: restoreOverriddenRequests$1,
		setImmediate: setImmediate$2,
		setTimeout: setTimeout$2,
		stringifyRequest: stringifyRequest$2
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/propagate@2.0.1/node_modules/propagate/index.js
var require_propagate = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/propagate@2.0.1/node_modules/propagate/index.js": ((exports, module) => {
	function propagate$1(events, source, dest) {
		if (arguments.length < 3) {
			dest = source;
			source = events;
			events = void 0;
		}
		const eventsIsObject = typeof events === "object";
		if (events && !eventsIsObject) events = [events];
		if (eventsIsObject) return explicitPropagate(events, source, dest);
		const shouldPropagate = (eventName) => events === void 0 || events.includes(eventName);
		const oldEmit = source.emit;
		source.emit = (eventName, ...args) => {
			const oldEmitHadListeners = oldEmit.call(source, eventName, ...args);
			let destEmitHadListeners = false;
			if (shouldPropagate(eventName)) destEmitHadListeners = dest.emit(eventName, ...args);
			return oldEmitHadListeners || destEmitHadListeners;
		};
		function end() {
			source.emit = oldEmit;
		}
		return { end };
	}
	module.exports = propagate$1;
	function explicitPropagate(events, source, dest) {
		let eventsIn;
		let eventsOut;
		if (Array.isArray(events)) {
			eventsIn = events;
			eventsOut = events;
		} else {
			eventsIn = Object.keys(events);
			eventsOut = eventsIn.map(function(key$1) {
				return events[key$1];
			});
		}
		const listeners = eventsOut.map(function(event) {
			return function() {
				const args = Array.prototype.slice.call(arguments);
				args.unshift(event);
				dest.emit.apply(dest, args);
			};
		});
		listeners.forEach(register);
		return { end };
		function register(listener$6, i$8) {
			source.on(eventsIn[i$8], listener$6);
		}
		function unregister(listener$6, i$8) {
			source.removeListener(eventsIn[i$8], listener$6);
		}
		function end() {
			listeners.forEach(unregister);
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/global_emitter.js
var require_global_emitter = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/global_emitter.js": ((exports, module) => {
	const { EventEmitter: EventEmitter$4 } = __require("events");
	module.exports = new EventEmitter$4();
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/socket.js
var require_socket = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/socket.js": ((exports, module) => {
	const { EventEmitter: EventEmitter$3 } = __require("events");
	const debug$21 = require_src$1()("nock.socket");
	module.exports = class Socket$1 extends EventEmitter$3 {
		constructor(options) {
			super();
			if (options.proto === "https") {
				this.authorized = true;
				this.encrypted = true;
			}
			this.bufferSize = 0;
			this.writableLength = 0;
			this.writable = true;
			this.readable = true;
			this.pending = false;
			this.destroyed = false;
			this.connecting = true;
			this._hadError = false;
			this.timeout = 0;
			const ipv6 = options.family === 6;
			this.remoteFamily = ipv6 ? "IPv6" : "IPv4";
			this.localAddress = this.remoteAddress = ipv6 ? "::1" : "127.0.0.1";
			this.localPort = this.remotePort = parseInt(options.port);
		}
		setNoDelay() {}
		setKeepAlive() {}
		resume() {}
		ref() {}
		unref() {}
		write() {}
		address() {
			return {
				port: this.remotePort,
				family: this.remoteFamily,
				address: this.remoteAddress
			};
		}
		setTimeout(timeoutMs, fn) {
			this.timeout = timeoutMs;
			if (fn) this.once("timeout", fn);
			return this;
		}
		/**
		* Artificial delay that will trip socket timeouts when appropriate.
		*
		* Doesn't actually wait for time to pass.
		* Timeout events don't necessarily end the request.
		* While many clients choose to abort the request upon a timeout, Node itself does not.
		*/
		applyDelay(delayMs) {
			if (this.timeout && delayMs > this.timeout) {
				debug$21("socket timeout");
				this.emit("timeout");
			}
		}
		getPeerCertificate() {
			return Buffer.from((Math.random() * 1e4 + Date.now()).toString()).toString("base64");
		}
		/**
		* Denotes that no more I/O activity should happen on this socket.
		*
		* The implementation in Node if far more complex as it juggles underlying async streams.
		* For the purposes of Nock, we just need it to set some flags and on the first call
		* emit a 'close' and optional 'error' event. Both events propagate through the request object.
		*/
		destroy(err) {
			if (this.destroyed) return this;
			debug$21("socket destroy");
			this.destroyed = true;
			this.readable = this.writable = false;
			this.readableEnded = this.writableFinished = true;
			process.nextTick(() => {
				if (err) {
					this._hadError = true;
					this.emit("error", err);
				}
				this.emit("close");
			});
			return this;
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/playback_interceptor.js
var require_playback_interceptor = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/playback_interceptor.js": ((exports, module) => {
	const stream$2 = __require("stream");
	const util$6 = __require("util");
	const zlib$1 = __require("zlib");
	const debug$20 = require_src$1()("nock.playback_interceptor");
	const common$8 = require_common();
	function parseJSONRequestBody(req$2, requestBody) {
		if (!requestBody || !common$8.isJSONContent(req$2.headers)) return requestBody;
		if (common$8.contentEncoding(req$2.headers, "gzip")) requestBody = String(zlib$1.gunzipSync(Buffer.from(requestBody, "hex")));
		else if (common$8.contentEncoding(req$2.headers, "deflate")) requestBody = String(zlib$1.inflateSync(Buffer.from(requestBody, "hex")));
		return JSON.parse(requestBody);
	}
	function parseFullReplyResult(response, fullReplyResult) {
		debug$20("full response from callback result: %j", fullReplyResult);
		if (!Array.isArray(fullReplyResult)) throw Error("A single function provided to .reply MUST return an array");
		if (fullReplyResult.length > 3) throw Error("The array returned from the .reply callback contains too many values");
		const [status$1, body$1 = "", headers$1] = fullReplyResult;
		if (!Number.isInteger(status$1)) throw new Error(`Invalid ${typeof status$1} value for status code`);
		response.statusCode = status$1;
		response.rawHeaders.push(...common$8.headersInputToRawArray(headers$1));
		debug$20("response.rawHeaders after reply: %j", response.rawHeaders);
		return body$1;
	}
	/**
	* Determine which of the default headers should be added to the response.
	*
	* Don't include any defaults whose case-insensitive keys are already on the response.
	*/
	function selectDefaultHeaders(existingHeaders, defaultHeaders) {
		if (!defaultHeaders.length) return [];
		const definedHeaders = /* @__PURE__ */ new Set();
		const result = [];
		common$8.forEachHeader(existingHeaders, (_, fieldName) => {
			definedHeaders.add(fieldName.toLowerCase());
		});
		common$8.forEachHeader(defaultHeaders, (value, fieldName) => {
			if (!definedHeaders.has(fieldName.toLowerCase())) result.push(fieldName, value);
		});
		return result;
	}
	var ReadableBuffers = class extends stream$2.Readable {
		constructor(buffers, opts = {}) {
			super(opts);
			this.buffers = buffers;
		}
		_read(_size) {
			while (this.buffers.length) if (!this.push(this.buffers.shift())) return;
			this.push(null);
		}
	};
	function convertBodyToStream(body$1) {
		if (common$8.isStream(body$1)) return body$1;
		if (body$1 === void 0) return new ReadableBuffers([]);
		if (Buffer.isBuffer(body$1)) return new ReadableBuffers([body$1]);
		if (typeof body$1 !== "string") body$1 = JSON.stringify(body$1);
		return new ReadableBuffers([Buffer.from(body$1)]);
	}
	/**
	* Play back an interceptor using the given request and mock response.
	*/
	function playbackInterceptor$1({ req: req$2, socket, options, requestBodyString, requestBodyIsUtf8Representable, response, interceptor }) {
		const { logger } = interceptor.scope;
		function start() {
			req$2.headers = req$2.getHeaders();
			interceptor.scope.emit("request", req$2, interceptor, requestBodyString);
			if (typeof interceptor.errorMessage !== "undefined") {
				let error;
				if (typeof interceptor.errorMessage === "object") error = interceptor.errorMessage;
				else error = new Error(interceptor.errorMessage);
				const delay = interceptor.delayBodyInMs + interceptor.delayConnectionInMs;
				common$8.setTimeout(() => req$2.destroy(error), delay);
				return;
			}
			response.statusCode = interceptor.statusCode;
			response.rawHeaders = [...interceptor.rawHeaders];
			logger("response.rawHeaders:", response.rawHeaders);
			interceptor.req = req$2;
			if (interceptor.replyFunction) {
				const parsedRequestBody = parseJSONRequestBody(req$2, requestBodyString);
				let fn = interceptor.replyFunction;
				if (fn.length === 3) fn = util$6.promisify(fn);
				Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody)).then(continueWithResponseBody).catch((err) => req$2.destroy(err));
				return;
			}
			if (interceptor.fullReplyFunction) {
				const parsedRequestBody = parseJSONRequestBody(req$2, requestBodyString);
				let fn = interceptor.fullReplyFunction;
				if (fn.length === 3) fn = util$6.promisify(fn);
				Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody)).then(continueWithFullResponse).catch((err) => req$2.destroy(err));
				return;
			}
			if (common$8.isContentEncoded(interceptor.headers) && !common$8.isStream(interceptor.body)) {
				continueWithResponseBody(new ReadableBuffers((Array.isArray(interceptor.body) ? interceptor.body : [interceptor.body]).map((data) => Buffer.from(data, "hex"))));
				return;
			}
			let responseBody = interceptor.body;
			if (!requestBodyIsUtf8Representable && typeof responseBody === "string") {
				responseBody = Buffer.from(responseBody, "hex");
				if (!responseBody || interceptor.body.length > 0 && responseBody.length === 0) responseBody = Buffer.from(interceptor.body, "utf8");
			}
			return continueWithResponseBody(responseBody);
		}
		function continueWithFullResponse(fullReplyResult) {
			let responseBody;
			try {
				responseBody = parseFullReplyResult(response, fullReplyResult);
			} catch (err) {
				req$2.destroy(err);
				return;
			}
			continueWithResponseBody(responseBody);
		}
		function prepareResponseHeaders(body$1) {
			const defaultHeaders = [...interceptor.scope._defaultReplyHeaders];
			if (body$1 !== void 0 && typeof body$1 !== "string" && !Buffer.isBuffer(body$1) && !common$8.isStream(body$1)) defaultHeaders.push("Content-Type", "application/json");
			response.rawHeaders.push(...selectDefaultHeaders(response.rawHeaders, defaultHeaders));
			common$8.forEachHeader(response.rawHeaders, (value, fieldName, i$8) => {
				if (typeof value === "function") response.rawHeaders[i$8 + 1] = value(req$2, response, body$1);
			});
			response.headers = common$8.headersArrayToObject(response.rawHeaders);
		}
		function continueWithResponseBody(rawBody) {
			prepareResponseHeaders(rawBody);
			const bodyAsStream = convertBodyToStream(rawBody);
			bodyAsStream.pause();
			bodyAsStream.on("data", function(chunk) {
				response.push(chunk);
			});
			bodyAsStream.on("end", function() {
				response.complete = true;
				response.push(null);
				interceptor.scope.emit("replied", req$2, interceptor);
			});
			bodyAsStream.on("error", function(err) {
				response.emit("error", err);
			});
			const { delayBodyInMs, delayConnectionInMs } = interceptor;
			function respond() {
				if (common$8.isRequestDestroyed(req$2)) return;
				req$2.res = response;
				response.req = req$2;
				logger("emitting response");
				req$2.emit("response", response);
				common$8.setTimeout(() => bodyAsStream.resume(), delayBodyInMs);
			}
			socket.applyDelay(delayConnectionInMs);
			common$8.setTimeout(respond, delayConnectionInMs);
		}
		common$8.setImmediate(() => {
			if (!common$8.isRequestDestroyed(req$2)) start();
		});
	}
	module.exports = { playbackInterceptor: playbackInterceptor$1 };
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/intercepted_request_router.js
var require_intercepted_request_router = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/intercepted_request_router.js": ((exports, module) => {
	const debug$19 = require_src$1()("nock.request_overrider");
	const { IncomingMessage, ClientRequest, request: originalHttpRequest } = __require("http");
	const { request: originalHttpsRequest } = __require("https");
	const propagate = require_propagate();
	const common$7 = require_common();
	const globalEmitter$1 = require_global_emitter();
	const Socket = require_socket();
	const { playbackInterceptor } = require_playback_interceptor();
	function socketOnClose(req$2) {
		debug$19("socket close");
		if (!req$2.res && !req$2.socket._hadError) {
			req$2.socket._hadError = true;
			const err = /* @__PURE__ */ new Error("socket hang up");
			err.code = "ECONNRESET";
			req$2.emit("error", err);
		}
		req$2.emit("close");
	}
	/**
	* Given a group of interceptors, appropriately route an outgoing request.
	* Identify which interceptor ought to respond, if any, then delegate to
	* `playbackInterceptor()` to consume the request itself.
	*/
	var InterceptedRequestRouter$1 = class {
		constructor({ req: req$2, options, interceptors }) {
			this.req = req$2;
			this.options = {
				...options,
				headers: common$7.headersFieldNamesToLowerCase(options.headers || {}, false)
			};
			this.interceptors = interceptors;
			this.socket = new Socket(options);
			const timeout$1 = options.timeout || options.agent && options.agent.options && options.agent.options.timeout;
			if (timeout$1) this.socket.setTimeout(timeout$1);
			this.response = new IncomingMessage(this.socket);
			this.requestBodyBuffers = [];
			this.playbackStarted = false;
			this.readyToStartPlaybackOnSocketEvent = false;
			this.attachToReq();
			process.nextTick(() => this.connectSocket());
		}
		attachToReq() {
			const { req: req$2, options } = this;
			for (const [name, val] of Object.entries(options.headers)) req$2.setHeader(name.toLowerCase(), val);
			if (options.auth && !options.headers.authorization) req$2.setHeader("authorization", `Basic ${Buffer.from(options.auth).toString("base64")}`);
			req$2.path = options.path;
			req$2.method = options.method;
			req$2.write = (...args) => this.handleWrite(...args);
			req$2.end = (...args) => this.handleEnd(...args);
			req$2.flushHeaders = (...args) => this.handleFlushHeaders(...args);
			if (options.headers.expect === "100-continue") common$7.setImmediate(() => {
				debug$19("continue");
				req$2.emit("continue");
			});
		}
		connectSocket() {
			const { req: req$2, socket } = this;
			if (common$7.isRequestDestroyed(req$2)) return;
			req$2.socket = req$2.connection = socket;
			propagate(["error", "timeout"], socket, req$2);
			socket.on("close", () => socketOnClose(req$2));
			socket.connecting = false;
			req$2.emit("socket", socket);
			socket.emit("connect");
			if (socket.authorized) socket.emit("secureConnect");
			if (this.readyToStartPlaybackOnSocketEvent) this.maybeStartPlayback();
		}
		handleWrite(...args) {
			debug$19("request write");
			let [buffer$5, encoding] = args;
			const { req: req$2 } = this;
			if (req$2.finished) {
				const err = /* @__PURE__ */ new Error("write after end");
				err.code = "ERR_STREAM_WRITE_AFTER_END";
				process.nextTick(() => req$2.emit("error", err));
				return true;
			}
			if (req$2.socket && req$2.socket.destroyed) return false;
			if (!buffer$5) return true;
			if (!Buffer.isBuffer(buffer$5)) buffer$5 = Buffer.from(buffer$5, encoding);
			this.requestBodyBuffers.push(buffer$5);
			const callback = args.length > 1 ? args[args.length - 1] : void 0;
			if (typeof callback === "function") callback();
			common$7.setImmediate(function() {
				req$2.emit("drain");
			});
			return false;
		}
		handleEnd(chunk, encoding, callback) {
			debug$19("request end");
			const { req: req$2 } = this;
			if (typeof chunk === "function") {
				callback = chunk;
				chunk = null;
			} else if (typeof encoding === "function") {
				callback = encoding;
				encoding = null;
			}
			if (typeof callback === "function") req$2.once("finish", callback);
			if (chunk) req$2.write(chunk, encoding);
			req$2.finished = true;
			this.maybeStartPlayback();
			return req$2;
		}
		handleFlushHeaders() {
			debug$19("request flushHeaders");
			this.maybeStartPlayback();
		}
		/**
		* Set request headers of the given request. This is needed both during the
		* routing phase, in case header filters were specified, and during the
		* interceptor-playback phase, to correctly pass mocked request headers.
		* TODO There are some problems with this; see https://github.com/nock/nock/issues/1718
		*/
		setHostHeaderUsingInterceptor(interceptor) {
			const { req: req$2, options } = this;
			const HOST_HEADER = "host";
			if (interceptor.__nock_filteredScope && interceptor.__nock_scopeHost) {
				options.headers[HOST_HEADER] = interceptor.__nock_scopeHost;
				req$2.setHeader(HOST_HEADER, interceptor.__nock_scopeHost);
			} else if (options.host && !req$2.getHeader(HOST_HEADER)) {
				let hostHeader = options.host;
				if (options.port === 80 || options.port === 443) hostHeader = hostHeader.split(":")[0];
				req$2.setHeader(HOST_HEADER, hostHeader);
			}
		}
		maybeStartPlayback() {
			const { req: req$2, socket, playbackStarted } = this;
			if (socket.connecting) {
				this.readyToStartPlaybackOnSocketEvent = true;
				return;
			}
			if (!common$7.isRequestDestroyed(req$2) && !playbackStarted) this.startPlayback();
		}
		startPlayback() {
			debug$19("ending");
			this.playbackStarted = true;
			const { req: req$2, response, socket, options, interceptors } = this;
			Object.assign(options, {
				path: req$2.path,
				headers: req$2.getHeaders(),
				protocol: `${options.proto}:`
			});
			interceptors.forEach((interceptor) => {
				this.setHostHeaderUsingInterceptor(interceptor);
			});
			const requestBodyBuffer = Buffer.concat(this.requestBodyBuffers);
			const requestBodyIsUtf8Representable = common$7.isUtf8Representable(requestBodyBuffer);
			const requestBodyString = requestBodyBuffer.toString(requestBodyIsUtf8Representable ? "utf8" : "hex");
			const matchedInterceptor = interceptors.find((i$8) => i$8.match(req$2, options, requestBodyString));
			if (matchedInterceptor) {
				matchedInterceptor.scope.logger("interceptor identified, starting mocking");
				matchedInterceptor.markConsumed();
				req$2.emit("finish");
				playbackInterceptor({
					req: req$2,
					socket,
					options,
					requestBodyString,
					requestBodyIsUtf8Representable,
					response,
					interceptor: matchedInterceptor
				});
			} else {
				globalEmitter$1.emit("no match", req$2, options, requestBodyString);
				if (interceptors.some((i$8) => i$8.matchHostName(options) && i$8.options.allowUnmocked) && req$2 instanceof ClientRequest) {
					const newReq = options.proto === "https" ? originalHttpsRequest(options) : originalHttpRequest(options);
					propagate(newReq, req$2);
					newReq.end(requestBodyBuffer);
				} else {
					const reqStr = common$7.stringifyRequest(options, requestBodyString);
					const err = /* @__PURE__ */ new Error(`Nock: No match for request ${reqStr}`);
					err.code = "ERR_NOCK_NO_MATCH";
					err.statusCode = err.status = 404;
					req$2.destroy(err);
				}
			}
		}
	};
	module.exports = { InterceptedRequestRouter: InterceptedRequestRouter$1 };
}) });

//#endregion
//#region ../../node_modules/.pnpm/json-stringify-safe@5.0.1/node_modules/json-stringify-safe/stringify.js
var require_stringify$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/json-stringify-safe@5.0.1/node_modules/json-stringify-safe/stringify.js": ((exports, module) => {
	exports = module.exports = stringify$10;
	exports.getSerialize = serializer;
	function stringify$10(obj, replacer, spaces, cycleReplacer) {
		return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
	}
	function serializer(replacer, cycleReplacer) {
		var stack = [], keys$6 = [];
		if (cycleReplacer == null) cycleReplacer = function(key$1, value) {
			if (stack[0] === value) return "[Circular ~]";
			return "[Circular ~." + keys$6.slice(0, stack.indexOf(value)).join(".") + "]";
		};
		return function(key$1, value) {
			if (stack.length > 0) {
				var thisPos = stack.indexOf(this);
				~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
				~thisPos ? keys$6.splice(thisPos, Infinity, key$1) : keys$6.push(key$1);
				if (~stack.indexOf(value)) value = cycleReplacer.call(this, key$1, value);
			} else stack.push(value);
			return replacer == null ? value : replacer.call(this, key$1, value);
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/match_body.js
var require_match_body = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/match_body.js": ((exports, module) => {
	const querystring$3 = __require("querystring");
	const common$6 = require_common();
	module.exports = function matchBody$1(options, spec, body$1) {
		if (spec instanceof RegExp) return spec.test(body$1);
		if (Buffer.isBuffer(spec)) {
			const encoding = common$6.isUtf8Representable(spec) ? "utf8" : "hex";
			spec = spec.toString(encoding);
		}
		const contentType$5 = (options.headers && (options.headers["Content-Type"] || options.headers["content-type"]) || "").toString();
		const isMultipart = contentType$5.includes("multipart");
		const isUrlencoded = contentType$5.includes("application/x-www-form-urlencoded");
		let json$1;
		if (typeof spec === "object" || typeof spec === "function") {
			try {
				json$1 = JSON.parse(body$1);
			} catch (err) {}
			if (json$1 !== void 0) body$1 = json$1;
			else if (isUrlencoded) body$1 = querystring$3.parse(body$1);
		}
		if (typeof spec === "function") return spec.call(options, body$1);
		if (!isMultipart && typeof body$1 === "string") body$1 = body$1.replace(/\r?\n|\r/g, "");
		if (!isMultipart && typeof spec === "string") spec = spec.replace(/\r?\n|\r/g, "");
		if (isUrlencoded) spec = mapValuesDeep(spec, (val) => val instanceof RegExp ? val : `${val}`);
		return common$6.dataEqual(spec, body$1);
	};
	function mapValues(object, cb) {
		const keys$6 = Object.keys(object);
		for (const key$1 of keys$6) object[key$1] = cb(object[key$1], key$1, object);
		return object;
	}
	/**
	* Based on lodash issue discussion
	* https://github.com/lodash/lodash/issues/1244
	*/
	function mapValuesDeep(obj, cb) {
		if (Array.isArray(obj)) return obj.map((v) => mapValuesDeep(v, cb));
		if (common$6.isPlainObject(obj)) return mapValues(obj, (v) => mapValuesDeep(v, cb));
		return cb(obj);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/interceptor.js
var require_interceptor = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/interceptor.js": ((exports, module) => {
	const stringify$9 = require_stringify$1();
	const querystring$2 = __require("querystring");
	const { URL: URL$1, URLSearchParams } = __require("url");
	const common$5 = require_common();
	const { remove: remove$4 } = require_intercept();
	const matchBody = require_match_body();
	let fs$25;
	try {
		fs$25 = __require("fs");
	} catch (err) {}
	module.exports = class Interceptor$2 {
		/**
		*
		* Valid argument types for `uri`:
		*  - A string used for strict comparisons with pathname.
		*    The search portion of the URI may also be postfixed, in which case the search params
		*    are striped and added via the `query` method.
		*  - A RegExp instance that tests against only the pathname of requests.
		*  - A synchronous function bound to this Interceptor instance. It's provided the pathname
		*    of requests and must return a boolean denoting if the request is considered a match.
		*/
		constructor(scope, uri, method$1, requestBody, interceptorOptions) {
			const uriIsStr = typeof uri === "string";
			if (uriIsStr && !scope.scopeOptions.filteringScope && !scope.basePathname && !uri.startsWith("/") && !uri.startsWith("*")) throw Error(`Non-wildcard URL path strings must begin with a slash (otherwise they won't match anything) (got: ${uri})`);
			if (!method$1) throw new Error("The \"method\" parameter is required for an intercept call.");
			this.scope = scope;
			this.interceptorMatchHeaders = [];
			this.method = method$1.toUpperCase();
			this.uri = uri;
			this._key = `${this.method} ${scope.basePath}${scope.basePathname}${uriIsStr ? "" : "/"}${uri}`;
			this.basePath = this.scope.basePath;
			this.path = uriIsStr ? scope.basePathname + uri : uri;
			this.queries = null;
			this.options = interceptorOptions || {};
			this.counter = 1;
			this._requestBody = requestBody;
			this.reqheaders = common$5.headersFieldNamesToLowerCase(scope.scopeOptions.reqheaders || {}, true);
			this.badheaders = common$5.headersFieldsArrayToLowerCase(scope.scopeOptions.badheaders || []);
			this.delayBodyInMs = 0;
			this.delayConnectionInMs = 0;
			this.optional = false;
			if (uriIsStr && uri.includes("?")) {
				const parsedURL = new URL$1(this.path, "http://localhost");
				this.path = parsedURL.pathname;
				this.query(parsedURL.searchParams);
				this._key = `${this.method} ${scope.basePath}${this.path}`;
			}
		}
		optionally(flag = true) {
			if (typeof flag !== "boolean") throw new Error("Invalid arguments: argument should be a boolean");
			this.optional = flag;
			return this;
		}
		replyWithError(errorMessage) {
			this.errorMessage = errorMessage;
			this.options = {
				...this.scope.scopeOptions,
				...this.options
			};
			this.scope.add(this._key, this);
			return this.scope;
		}
		reply(statusCode, body$1, rawHeaders) {
			if (typeof statusCode === "function") {
				if (arguments.length > 1) throw Error("Invalid arguments. When providing a function for the first argument, .reply does not accept other arguments.");
				this.statusCode = null;
				this.fullReplyFunction = statusCode;
			} else {
				if (statusCode !== void 0 && !Number.isInteger(statusCode)) throw new Error(`Invalid ${typeof statusCode} value for status code`);
				this.statusCode = statusCode || 200;
				if (typeof body$1 === "function") {
					this.replyFunction = body$1;
					body$1 = null;
				}
			}
			this.options = {
				...this.scope.scopeOptions,
				...this.options
			};
			this.rawHeaders = common$5.headersInputToRawArray(rawHeaders);
			if (this.scope.date) this.rawHeaders.push("Date", this.scope.date.toUTCString());
			this.headers = common$5.headersArrayToObject(this.rawHeaders.concat(this.scope._defaultReplyHeaders));
			if (body$1 && typeof body$1 !== "string" && !Buffer.isBuffer(body$1) && !common$5.isStream(body$1) && !common$5.isContentEncoded(this.headers)) {
				try {
					body$1 = stringify$9(body$1);
				} catch (err) {
					throw new Error("Error encoding response body into JSON");
				}
				if (!this.headers["content-type"]) this.rawHeaders.push("Content-Type", "application/json");
			}
			if (this.scope.contentLen) {
				if (typeof body$1 === "string") this.rawHeaders.push("Content-Length", body$1.length);
				else if (Buffer.isBuffer(body$1)) this.rawHeaders.push("Content-Length", body$1.byteLength);
			}
			this.scope.logger("reply.headers:", this.headers);
			this.scope.logger("reply.rawHeaders:", this.rawHeaders);
			this.body = body$1;
			this.scope.add(this._key, this);
			return this.scope;
		}
		replyWithFile(statusCode, filePath, headers$1) {
			if (!fs$25) throw new Error("No fs");
			this.filePath = filePath;
			return this.reply(statusCode, () => {
				const readStream$1 = fs$25.createReadStream(filePath);
				readStream$1.pause();
				return readStream$1;
			}, headers$1);
		}
		reqheaderMatches(options, key$1) {
			const reqHeader = this.reqheaders[key$1];
			let header = options.headers[key$1];
			if (header && typeof header !== "string" && header.toString) header = header.toString();
			if (key$1 === "host" && (header === void 0 || reqHeader === void 0)) return true;
			if (reqHeader !== void 0 && header !== void 0) {
				if (typeof reqHeader === "function") return reqHeader(header);
				else if (common$5.matchStringOrRegexp(header, reqHeader)) return true;
			}
			this.scope.logger("request header field doesn't match:", key$1, header, reqHeader);
			return false;
		}
		match(req$2, options, body$1) {
			if (this.scope.logger.enabled) this.scope.logger("attempting match %s, body = %s", stringify$9(options), stringify$9(body$1));
			const method$1 = (options.method || "GET").toUpperCase();
			let { path: path$19 = "/" } = options;
			let matches;
			let matchKey;
			const { proto: proto$7 } = options;
			if (this.method !== method$1) {
				this.scope.logger(`Method did not match. Request ${method$1} Interceptor ${this.method}`);
				return false;
			}
			if (this.scope.transformPathFunction) path$19 = this.scope.transformPathFunction(path$19);
			const requestMatchesFilter = ({ name, value: predicate }) => {
				const headerValue = req$2.getHeader(name);
				if (typeof predicate === "function") return predicate(headerValue);
				else return common$5.matchStringOrRegexp(headerValue, predicate);
			};
			if (!this.scope.matchHeaders.every(requestMatchesFilter) || !this.interceptorMatchHeaders.every(requestMatchesFilter)) {
				this.scope.logger("headers don't match");
				return false;
			}
			if (!Object.keys(this.reqheaders).every((key$1) => this.reqheaderMatches(options, key$1))) {
				this.scope.logger("headers don't match");
				return false;
			}
			if (this.scope.scopeOptions.conditionally && !this.scope.scopeOptions.conditionally()) {
				this.scope.logger("matching failed because Scope.conditionally() did not validate");
				return false;
			}
			const badHeaders = this.badheaders.filter((header) => header in options.headers);
			if (badHeaders.length) {
				this.scope.logger("request contains bad headers", ...badHeaders);
				return false;
			}
			if (this.queries === null) this.scope.logger("query matching skipped");
			else {
				const [pathname, search] = path$19.split("?");
				const matchQueries = this.matchQuery({ search });
				this.scope.logger(matchQueries ? "query matching succeeded" : "query matching failed");
				if (!matchQueries) return false;
				path$19 = pathname;
			}
			if (this.__nock_filteredScope) matchKey = this.__nock_filteredScope;
			else matchKey = common$5.normalizeOrigin(proto$7, options.host, options.port);
			if (typeof this.uri === "function") matches = common$5.matchStringOrRegexp(matchKey, this.basePath) && this.uri.call(this, path$19);
			else matches = common$5.matchStringOrRegexp(matchKey, this.basePath) && common$5.matchStringOrRegexp(path$19, this.path);
			this.scope.logger(`matching ${matchKey}${path$19} to ${this._key}: ${matches}`);
			if (matches && this._requestBody !== void 0) {
				if (this.scope.transformRequestBodyFunction) body$1 = this.scope.transformRequestBodyFunction(body$1, this._requestBody);
				matches = matchBody(options, this._requestBody, body$1);
				if (!matches) this.scope.logger("bodies don't match: \n", this._requestBody, "\n", body$1);
			}
			return matches;
		}
		/**
		* Return true when the interceptor's method, protocol, host, port, and path
		* match the provided options.
		*/
		matchOrigin(options) {
			const isPathFn = typeof this.path === "function";
			const isRegex = this.path instanceof RegExp;
			const isRegexBasePath = this.scope.basePath instanceof RegExp;
			const method$1 = (options.method || "GET").toUpperCase();
			let { path: path$19 } = options;
			const { proto: proto$7 } = options;
			if (!isRegex) path$19 = path$19 ? path$19.split("?")[0] : "";
			if (this.scope.transformPathFunction) path$19 = this.scope.transformPathFunction(path$19);
			const comparisonKey = isPathFn || isRegex ? this.__nock_scopeKey : this._key;
			const matchKey = `${method$1} ${proto$7}://${options.host}${path$19}`;
			if (isPathFn) return !!(matchKey.match(comparisonKey) && this.path(path$19));
			if (isRegex && !isRegexBasePath) return !!matchKey.match(comparisonKey) && this.path.test(path$19);
			if (isRegexBasePath) return this.scope.basePath.test(matchKey) && !!path$19.match(this.path);
			return comparisonKey === matchKey;
		}
		matchHostName(options) {
			const { basePath: basePath$1 } = this.scope;
			if (basePath$1 instanceof RegExp) return basePath$1.test(options.hostname);
			return options.hostname === this.scope.urlParts.hostname;
		}
		matchQuery(options) {
			if (this.queries === true) return true;
			const reqQueries = querystring$2.parse(options.search);
			this.scope.logger("Interceptor queries: %j", this.queries);
			this.scope.logger("    Request queries: %j", reqQueries);
			if (typeof this.queries === "function") return this.queries(reqQueries);
			return common$5.dataEqual(this.queries, reqQueries);
		}
		filteringPath(...args) {
			this.scope.filteringPath(...args);
			return this;
		}
		markConsumed() {
			this.interceptionCounter++;
			remove$4(this);
			if (!this.scope.shouldPersist() && this.counter < 1) this.scope.remove(this._key, this);
		}
		matchHeader(name, value) {
			this.interceptorMatchHeaders.push({
				name,
				value
			});
			return this;
		}
		basicAuth({ user, pass = "" }) {
			const encoded = Buffer.from(`${user}:${pass}`).toString("base64");
			this.matchHeader("authorization", `Basic ${encoded}`);
			return this;
		}
		/**
		* Set query strings for the interceptor
		* @name query
		* @param queries Object of query string name,values (accepts regexp values)
		* @public
		* @example
		* // Will match 'http://zombo.com/?q=t'
		* nock('http://zombo.com').get('/').query({q: 't'});
		*/
		query(queries) {
			if (this.queries !== null) throw Error(`Query parameters have already been defined`);
			if (queries === true) {
				this.queries = queries;
				return this;
			}
			if (typeof queries === "function") {
				this.queries = queries;
				return this;
			}
			let strFormattingFn;
			if (this.scope.scopeOptions.encodedQueryParams) strFormattingFn = common$5.percentDecode;
			if (queries instanceof URLSearchParams || typeof queries === "string") queries = querystring$2.parse(queries.toString());
			else if (!common$5.isPlainObject(queries)) throw Error(`Argument Error: ${queries}`);
			this.queries = {};
			for (const [key$1, value] of Object.entries(queries)) {
				const [formattedKey, formattedValue] = common$5.formatQueryValue(key$1, value, strFormattingFn);
				this.queries[formattedKey] = formattedValue;
			}
			return this;
		}
		/**
		* Set number of times will repeat the interceptor
		* @name times
		* @param newCounter Number of times to repeat (should be > 0)
		* @public
		* @example
		* // Will repeat mock 5 times for same king of request
		* nock('http://zombo.com).get('/').times(5).reply(200, 'Ok');
		*/
		times(newCounter) {
			if (newCounter < 1) return this;
			this.counter = newCounter;
			return this;
		}
		/**
		* An sugar syntax for times(1)
		* @name once
		* @see {@link times}
		* @public
		* @example
		* nock('http://zombo.com).get('/').once().reply(200, 'Ok');
		*/
		once() {
			return this.times(1);
		}
		/**
		* An sugar syntax for times(2)
		* @name twice
		* @see {@link times}
		* @public
		* @example
		* nock('http://zombo.com).get('/').twice().reply(200, 'Ok');
		*/
		twice() {
			return this.times(2);
		}
		/**
		* An sugar syntax for times(3).
		* @name thrice
		* @see {@link times}
		* @public
		* @example
		* nock('http://zombo.com).get('/').thrice().reply(200, 'Ok');
		*/
		thrice() {
			return this.times(3);
		}
		/**
		* Delay the response by a certain number of ms.
		*
		* @param {(integer|object)} opts - Number of milliseconds to wait, or an object
		* @param {integer} [opts.head] - Number of milliseconds to wait before response is sent
		* @param {integer} [opts.body] - Number of milliseconds to wait before response body is sent
		* @return {Interceptor} - the current interceptor for chaining
		*/
		delay(opts) {
			let headDelay;
			let bodyDelay;
			if (typeof opts === "number") {
				headDelay = opts;
				bodyDelay = 0;
			} else if (typeof opts === "object") {
				headDelay = opts.head || 0;
				bodyDelay = opts.body || 0;
			} else throw new Error(`Unexpected input opts ${opts}`);
			return this.delayConnection(headDelay).delayBody(bodyDelay);
		}
		/**
		* Delay the response body by a certain number of ms.
		*
		* @param {integer} ms - Number of milliseconds to wait before response is sent
		* @return {Interceptor} - the current interceptor for chaining
		*/
		delayBody(ms$2) {
			this.delayBodyInMs = ms$2;
			return this;
		}
		/**
		* Delay the connection by a certain number of ms.
		*
		* @param  {integer} ms - Number of milliseconds to wait
		* @return {Interceptor} - the current interceptor for chaining
		*/
		delayConnection(ms$2) {
			this.delayConnectionInMs = ms$2;
			return this;
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/intercept.js
var require_intercept = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/intercept.js": ((exports, module) => {
	/**
	* @module nock/intercept
	*/
	const { InterceptedRequestRouter } = require_intercepted_request_router();
	const common$4 = require_common();
	const { inherits: inherits$1 } = __require("util");
	const http$6 = __require("http");
	const debug$18 = require_src$1()("nock.intercept");
	const globalEmitter = require_global_emitter();
	/**
	* @name NetConnectNotAllowedError
	* @private
	* @desc Error trying to make a connection when disabled external access.
	* @class
	* @example
	* nock.disableNetConnect();
	* http.get('http://zombo.com');
	* // throw NetConnectNotAllowedError
	*/
	function NetConnectNotAllowedError(host, path$19) {
		Error.call(this);
		this.name = "NetConnectNotAllowedError";
		this.code = "ENETUNREACH";
		this.message = `Nock: Disallowed net connect for "${host}${path$19}"`;
		Error.captureStackTrace(this, this.constructor);
	}
	inherits$1(NetConnectNotAllowedError, Error);
	let allInterceptors = {};
	let allowNetConnect;
	/**
	* Enabled real request.
	* @public
	* @param {String|RegExp} matcher=RegExp.new('.*') Expression to match
	* @example
	* // Enables all real requests
	* nock.enableNetConnect();
	* @example
	* // Enables real requests for url that matches google
	* nock.enableNetConnect('google');
	* @example
	* // Enables real requests for url that matches google and amazon
	* nock.enableNetConnect(/(google|amazon)/);
	* @example
	* // Enables real requests for url that includes google
	* nock.enableNetConnect(host => host.includes('google'));
	*/
	function enableNetConnect$2(matcher) {
		if (typeof matcher === "string") allowNetConnect = new RegExp(matcher);
		else if (matcher instanceof RegExp) allowNetConnect = matcher;
		else if (typeof matcher === "function") allowNetConnect = { test: matcher };
		else allowNetConnect = /.*/;
	}
	function isEnabledForNetConnect(options) {
		common$4.normalizeRequestOptions(options);
		const enabled$1 = allowNetConnect && allowNetConnect.test(options.host);
		debug$18("Net connect", enabled$1 ? "" : "not", "enabled for", options.host);
		return enabled$1;
	}
	/**
	* Disable all real requests.
	* @public
	* @example
	* nock.disableNetConnect();
	*/
	function disableNetConnect$2() {
		allowNetConnect = void 0;
	}
	function isOn$2() {
		return !isOff();
	}
	function isOff() {
		return process.env.NOCK_OFF === "true";
	}
	function addInterceptor$1(key$1, interceptor, scope, scopeOptions, host) {
		if (!(key$1 in allInterceptors)) allInterceptors[key$1] = {
			key: key$1,
			interceptors: []
		};
		interceptor.__nock_scope = scope;
		interceptor.__nock_scopeKey = key$1;
		interceptor.__nock_scopeOptions = scopeOptions;
		interceptor.__nock_scopeHost = host;
		interceptor.interceptionCounter = 0;
		if (scopeOptions.allowUnmocked) allInterceptors[key$1].allowUnmocked = true;
		allInterceptors[key$1].interceptors.push(interceptor);
	}
	function remove$3(interceptor) {
		if (interceptor.__nock_scope.shouldPersist() || --interceptor.counter > 0) return;
		const { basePath: basePath$1 } = interceptor;
		const interceptors = allInterceptors[basePath$1] && allInterceptors[basePath$1].interceptors || [];
		interceptors.some(function(thisInterceptor, i$8) {
			return thisInterceptor === interceptor ? interceptors.splice(i$8, 1) : false;
		});
	}
	function removeAll$1() {
		Object.keys(allInterceptors).forEach(function(key$1) {
			allInterceptors[key$1].interceptors.forEach(function(interceptor) {
				interceptor.scope.keyedInterceptors = {};
			});
		});
		allInterceptors = {};
	}
	/**
	* Return all the Interceptors whose Scopes match against the base path of the provided options.
	*
	* @returns {Interceptor[]}
	*/
	function interceptorsFor(options) {
		common$4.normalizeRequestOptions(options);
		debug$18("interceptors for %j", options.host);
		const basePath$1 = `${options.proto}://${options.host}`;
		debug$18("filtering interceptors for basepath", basePath$1);
		for (const { key: key$1, interceptors, allowUnmocked } of Object.values(allInterceptors)) {
			for (const interceptor of interceptors) {
				const { filteringScope } = interceptor.__nock_scopeOptions;
				if (filteringScope && filteringScope(basePath$1)) {
					interceptor.scope.logger("found matching scope interceptor");
					interceptors.forEach((ic) => {
						ic.__nock_filteredScope = ic.__nock_scopeKey;
					});
					return interceptors;
				}
			}
			if (common$4.matchStringOrRegexp(basePath$1, key$1)) if (allowUnmocked && interceptors.length === 0) {
				debug$18("matched base path with allowUnmocked (no matching interceptors)");
				return [{
					options: { allowUnmocked: true },
					matchOrigin() {
						return false;
					}
				}];
			} else {
				debug$18(`matched base path (${interceptors.length} interceptor${interceptors.length > 1 ? "s" : ""})`);
				return interceptors;
			}
		}
	}
	function removeInterceptor$1(options) {
		const Interceptor$2 = require_interceptor();
		let baseUrl, key$1, method$1, proto$7;
		if (options instanceof Interceptor$2) {
			baseUrl = options.basePath;
			key$1 = options._key;
		} else {
			proto$7 = options.proto ? options.proto : "http";
			common$4.normalizeRequestOptions(options);
			baseUrl = `${proto$7}://${options.host}`;
			method$1 = options.method && options.method.toUpperCase() || "GET";
			key$1 = `${method$1} ${baseUrl}${options.path || "/"}`;
		}
		if (allInterceptors[baseUrl] && allInterceptors[baseUrl].interceptors.length > 0) {
			for (let i$8 = 0; i$8 < allInterceptors[baseUrl].interceptors.length; i$8++) {
				const interceptor = allInterceptors[baseUrl].interceptors[i$8];
				if (options instanceof Interceptor$2 ? interceptor === options : interceptor._key === key$1) {
					allInterceptors[baseUrl].interceptors.splice(i$8, 1);
					interceptor.scope.remove(key$1, interceptor);
					break;
				}
			}
			return true;
		}
		return false;
	}
	let originalClientRequest;
	function ErroringClientRequest(error) {
		http$6.OutgoingMessage.call(this);
		process.nextTick(function() {
			this.emit("error", error);
		}.bind(this));
	}
	inherits$1(ErroringClientRequest, http$6.ClientRequest);
	function overrideClientRequest() {
		debug$18("Overriding ClientRequest");
		function OverriddenClientRequest(...args) {
			const { options, callback } = common$4.normalizeClientRequestArgs(...args);
			if (Object.keys(options).length === 0) throw Error("Creating a ClientRequest with empty `options` is not supported in Nock");
			http$6.OutgoingMessage.call(this);
			const interceptors = interceptorsFor(options);
			if (isOn$2() && interceptors) {
				debug$18("using", interceptors.length, "interceptors");
				const overrider = new InterceptedRequestRouter({
					req: this,
					options,
					interceptors
				});
				Object.assign(this, overrider);
				if (callback) this.once("response", callback);
			} else {
				debug$18("falling back to original ClientRequest");
				if (isOff() || isEnabledForNetConnect(options)) originalClientRequest.apply(this, arguments);
				else common$4.setImmediate(function() {
					const error = new NetConnectNotAllowedError(options.host, options.path);
					this.emit("error", error);
				}.bind(this));
			}
		}
		inherits$1(OverriddenClientRequest, http$6.ClientRequest);
		originalClientRequest = http$6.ClientRequest;
		http$6.ClientRequest = OverriddenClientRequest;
		debug$18("ClientRequest overridden");
	}
	function restoreOverriddenClientRequest$1() {
		debug$18("restoring overridden ClientRequest");
		if (!originalClientRequest) debug$18("- ClientRequest was not overridden");
		else {
			http$6.ClientRequest = originalClientRequest;
			originalClientRequest = void 0;
			debug$18("- ClientRequest restored");
		}
	}
	function isActive$1() {
		return originalClientRequest !== void 0;
	}
	function interceptorScopes() {
		const nestedInterceptors = Object.values(allInterceptors).map((i$8) => i$8.interceptors);
		return [...new Set([].concat(...nestedInterceptors).map((i$8) => i$8.scope))];
	}
	function isDone$1() {
		return interceptorScopes().every((scope) => scope.isDone());
	}
	function pendingMocks$1() {
		return [].concat(...interceptorScopes().map((scope) => scope.pendingMocks()));
	}
	function activeMocks$1() {
		return [].concat(...interceptorScopes().map((scope) => scope.activeMocks()));
	}
	function activate$2() {
		if (originalClientRequest) throw new Error("Nock already active");
		common$4.overrideRequests(function(proto$7, overriddenRequest, args) {
			const { options, callback } = common$4.normalizeClientRequestArgs(...args);
			if (Object.keys(options).length === 0) throw Error("Making a request with empty `options` is not supported in Nock");
			options.proto = proto$7;
			const interceptors = interceptorsFor(options);
			if (isOn$2() && interceptors) {
				const matches = interceptors.some((interceptor) => interceptor.matchOrigin(options));
				const allowUnmocked = interceptors.some((interceptor) => interceptor.options.allowUnmocked);
				if (!matches && allowUnmocked) {
					let req$2;
					if (proto$7 === "https") {
						const { ClientRequest: ClientRequest$1 } = http$6;
						http$6.ClientRequest = originalClientRequest;
						req$2 = overriddenRequest(options, callback);
						http$6.ClientRequest = ClientRequest$1;
					} else req$2 = overriddenRequest(options, callback);
					globalEmitter.emit("no match", req$2);
					return req$2;
				}
				return new http$6.ClientRequest(options, callback);
			} else {
				globalEmitter.emit("no match", options);
				if (isOff() || isEnabledForNetConnect(options)) return overriddenRequest(options, callback);
				else return new ErroringClientRequest(new NetConnectNotAllowedError(options.host, options.path));
			}
		});
		overrideClientRequest();
	}
	module.exports = {
		addInterceptor: addInterceptor$1,
		remove: remove$3,
		removeAll: removeAll$1,
		removeInterceptor: removeInterceptor$1,
		isOn: isOn$2,
		activate: activate$2,
		isActive: isActive$1,
		isDone: isDone$1,
		pendingMocks: pendingMocks$1,
		activeMocks: activeMocks$1,
		enableNetConnect: enableNetConnect$2,
		disableNetConnect: disableNetConnect$2,
		restoreOverriddenClientRequest: restoreOverriddenClientRequest$1,
		abortPendingRequests: common$4.removeAllTimers
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/recorder.js
var require_recorder = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/recorder.js": ((exports, module) => {
	const debug$17 = require_src$1()("nock.recorder");
	const querystring$1 = __require("querystring");
	const { inspect } = __require("util");
	const common$3 = require_common();
	const { restoreOverriddenClientRequest } = require_intercept();
	const SEPARATOR = "\n<<<<<<-- cut here -->>>>>>\n";
	let recordingInProgress = false;
	let outputs = [];
	function getScope(options) {
		const { proto: proto$7, host, port: port$6 } = common$3.normalizeRequestOptions(options);
		return common$3.normalizeOrigin(proto$7, host, port$6);
	}
	function getMethod(options) {
		return options.method || "GET";
	}
	function getBodyFromChunks(chunks, headers$1) {
		if (headers$1 && common$3.isContentEncoded(headers$1)) return { body: chunks.map((chunk) => chunk.toString("hex")) };
		const mergedBuffer = Buffer.concat(chunks);
		const isUtf8Representable$2 = common$3.isUtf8Representable(mergedBuffer);
		if (isUtf8Representable$2) {
			const maybeStringifiedJson = mergedBuffer.toString("utf8");
			try {
				return {
					isUtf8Representable: isUtf8Representable$2,
					body: JSON.parse(maybeStringifiedJson)
				};
			} catch (err) {
				return {
					isUtf8Representable: isUtf8Representable$2,
					body: maybeStringifiedJson
				};
			}
		} else return {
			isUtf8Representable: isUtf8Representable$2,
			body: mergedBuffer.toString("hex")
		};
	}
	function generateRequestAndResponseObject({ req: req$2, bodyChunks, options, res: res$2, dataChunks, reqheaders }) {
		const { body: body$1, isUtf8Representable: isUtf8Representable$2 } = getBodyFromChunks(dataChunks, res$2.headers);
		options.path = req$2.path;
		return {
			scope: getScope(options),
			method: getMethod(options),
			path: options.path,
			body: getBodyFromChunks(bodyChunks).body,
			status: res$2.statusCode,
			response: body$1,
			rawHeaders: res$2.rawHeaders,
			reqheaders: reqheaders || void 0,
			responseIsBinary: isUtf8Representable$2 === false
		};
	}
	function generateRequestAndResponse({ req: req$2, bodyChunks, options, res: res$2, dataChunks, reqheaders }) {
		const requestBody = getBodyFromChunks(bodyChunks).body;
		const responseBody = getBodyFromChunks(dataChunks, res$2.headers).body;
		let { path: path$19 } = options;
		const queryIndex = req$2.path.indexOf("?");
		let queryObj = {};
		if (queryIndex !== -1) {
			path$19 = path$19.substring(0, queryIndex);
			const queryStr = req$2.path.slice(queryIndex + 1);
			queryObj = querystring$1.parse(queryStr);
		}
		path$19 = path$19.replace(/'/g, `\\'`);
		const encodedQueryObj = {};
		for (const key$1 in queryObj) {
			const formattedPair = common$3.formatQueryValue(key$1, queryObj[key$1], common$3.percentEncode);
			encodedQueryObj[formattedPair[0]] = formattedPair[1];
		}
		const lines = [];
		lines.push("");
		const scope = getScope(options);
		lines.push(`nock('${scope}', {"encodedQueryParams":true})`);
		const methodName = getMethod(options).toLowerCase();
		if (requestBody) lines.push(`  .${methodName}('${path$19}', ${JSON.stringify(requestBody)})`);
		else lines.push(`  .${methodName}('${path$19}')`);
		Object.entries(reqheaders || {}).forEach(([fieldName, fieldValue]) => {
			const safeName = JSON.stringify(fieldName);
			const safeValue = JSON.stringify(fieldValue);
			lines.push(`  .matchHeader(${safeName}, ${safeValue})`);
		});
		if (queryIndex !== -1) lines.push(`  .query(${JSON.stringify(encodedQueryObj)})`);
		const statusCode = res$2.statusCode.toString();
		const stringifiedResponseBody = JSON.stringify(responseBody);
		const headers$1 = inspect(res$2.rawHeaders);
		lines.push(`  .reply(${statusCode}, ${stringifiedResponseBody}, ${headers$1});`);
		return lines.join("\n");
	}
	let currentRecordingId = 0;
	const defaultRecordOptions = {
		dont_print: false,
		enable_reqheaders_recording: false,
		logging: console.log,
		output_objects: false,
		use_separator: true
	};
	function record$1(recOptions) {
		if (recordingInProgress) throw new Error("Nock recording already in progress");
		recordingInProgress = true;
		currentRecordingId = currentRecordingId + 1;
		const thisRecordingId = currentRecordingId;
		if (typeof recOptions === "boolean") recOptions = { dont_print: recOptions };
		recOptions = {
			...defaultRecordOptions,
			...recOptions
		};
		debug$17("start recording", thisRecordingId, recOptions);
		const { dont_print: dontPrint, enable_reqheaders_recording: enableReqHeadersRecording, logging, output_objects: outputObjects, use_separator: useSeparator } = recOptions;
		debug$17(thisRecordingId, "restoring overridden requests before new overrides");
		common$3.restoreOverriddenRequests();
		restoreOverriddenClientRequest();
		common$3.overrideRequests(function(proto$7, overriddenRequest, rawArgs) {
			const { options, callback } = common$3.normalizeClientRequestArgs(...rawArgs);
			const bodyChunks = [];
			/* istanbul ignore if */
			if (options._recording) return overriddenRequest(options, callback);
			options._recording = true;
			const req$2 = overriddenRequest(options, function(res$2) {
				debug$17(thisRecordingId, "intercepting", proto$7, "request to record");
				res$2.once("end", function() {
					debug$17(thisRecordingId, proto$7, "intercepted request ended");
					let reqheaders;
					if (enableReqHeadersRecording) {
						reqheaders = req$2.getHeaders();
						common$3.deleteHeadersField(reqheaders, "user-agent");
					}
					let out = (outputObjects ? generateRequestAndResponseObject : generateRequestAndResponse)({
						req: req$2,
						bodyChunks,
						options,
						res: res$2,
						dataChunks,
						reqheaders
					});
					debug$17("out:", out);
					if (thisRecordingId !== currentRecordingId) {
						debug$17("skipping recording of an out-of-order request", out);
						return;
					}
					outputs.push(out);
					if (!dontPrint) if (useSeparator) {
						if (typeof out !== "string") out = JSON.stringify(out, null, 2);
						logging(SEPARATOR + out + SEPARATOR);
					} else logging(out);
				});
				let encoding;
				const { setEncoding } = res$2;
				res$2.setEncoding = function(newEncoding) {
					encoding = newEncoding;
					return setEncoding.apply(this, arguments);
				};
				const dataChunks = [];
				const origResPush = res$2.push;
				res$2.push = function(data) {
					if (data) {
						if (encoding) data = Buffer.from(data, encoding);
						dataChunks.push(data);
					}
					return origResPush.call(res$2, data);
				};
				if (callback) callback(res$2, options, callback);
				debug$17("finished setting up intercepting");
				if (proto$7 === "https") options.proto = "https";
			});
			const recordChunk = (chunk, encoding) => {
				debug$17(thisRecordingId, "new", proto$7, "body chunk");
				if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, encoding);
				bodyChunks.push(chunk);
			};
			const oldWrite = req$2.write;
			req$2.write = function(chunk, encoding) {
				if (typeof chunk !== "undefined") {
					recordChunk(chunk, encoding);
					oldWrite.apply(req$2, arguments);
				} else throw new Error("Data was undefined.");
			};
			const oldEnd = req$2.end;
			req$2.end = function(chunk, encoding, callback$1) {
				debug$17("req.end");
				if (typeof chunk === "function") {
					callback$1 = chunk;
					chunk = null;
				} else if (typeof encoding === "function") {
					callback$1 = encoding;
					encoding = null;
				}
				if (chunk) recordChunk(chunk, encoding);
				oldEnd.call(req$2, chunk, encoding, callback$1);
			};
			return req$2;
		});
	}
	function restore$1() {
		debug$17(currentRecordingId, "restoring all the overridden http/https properties");
		common$3.restoreOverriddenRequests();
		restoreOverriddenClientRequest();
		recordingInProgress = false;
	}
	function clear() {
		outputs = [];
	}
	module.exports = {
		record: record$1,
		outputs: () => outputs,
		restore: restore$1,
		clear
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/scope.js
var require_scope = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/scope.js": ((exports, module) => {
	/**
	* @module nock/scope
	*/
	const { addInterceptor, isOn: isOn$1 } = require_intercept();
	const common$2 = require_common();
	const assert$2 = __require("assert");
	const url$3 = __require("url");
	const debug$16 = require_src$1()("nock.scope");
	const { EventEmitter: EventEmitter$2 } = __require("events");
	const Interceptor = require_interceptor();
	const { URL, Url: LegacyUrl } = url$3;
	let fs$24;
	try {
		fs$24 = __require("fs");
	} catch (err) {}
	/**
	* Normalizes the passed url for consistent internal processing
	* @param {string|LegacyUrl|URL} u
	*/
	function normalizeUrl(u$12) {
		if (!(u$12 instanceof URL)) {
			if (u$12 instanceof LegacyUrl) return normalizeUrl(new URL(url$3.format(u$12)));
			return normalizeUrl(new URL(u$12));
		}
		if (!/https?:/.test(u$12.protocol)) throw new TypeError(`Protocol '${u$12.protocol}' not recognized. This commonly occurs when a hostname and port are included without a protocol, producing a URL that is valid but confusing, and probably not what you want.`);
		return {
			href: u$12.href,
			origin: u$12.origin,
			protocol: u$12.protocol,
			username: u$12.username,
			password: u$12.password,
			host: u$12.host,
			hostname: typeof u$12.hostname === "string" && u$12.hostname.startsWith("[") ? u$12.hostname.slice(1, -1) : u$12.hostname,
			port: u$12.port || (u$12.protocol === "http:" ? 80 : 443),
			pathname: u$12.pathname,
			search: u$12.search,
			searchParams: u$12.searchParams,
			hash: u$12.hash
		};
	}
	/**
	* @param  {string|RegExp|LegacyUrl|URL} basePath
	* @param  {Object}   options
	* @param  {boolean}  options.allowUnmocked
	* @param  {string[]} options.badheaders
	* @param  {function} options.conditionally
	* @param  {boolean}  options.encodedQueryParams
	* @param  {function} options.filteringScope
	* @param  {Object}   options.reqheaders
	* @constructor
	*/
	var Scope$1 = class Scope$1 extends EventEmitter$2 {
		constructor(basePath$1, options) {
			super();
			this.keyedInterceptors = {};
			this.interceptors = [];
			this.transformPathFunction = null;
			this.transformRequestBodyFunction = null;
			this.matchHeaders = [];
			this.scopeOptions = options || {};
			this.urlParts = {};
			this._persist = false;
			this.contentLen = false;
			this.date = null;
			this.basePath = basePath$1;
			this.basePathname = "";
			this.port = null;
			this._defaultReplyHeaders = [];
			let logNamespace = String(basePath$1);
			if (!(basePath$1 instanceof RegExp)) {
				this.urlParts = normalizeUrl(basePath$1);
				this.port = this.urlParts.port;
				this.basePathname = this.urlParts.pathname.replace(/\/$/, "");
				this.basePath = `${this.urlParts.protocol}//${this.urlParts.hostname}:${this.port}`;
				logNamespace = this.urlParts.host;
			}
			this.logger = debug$16.extend(logNamespace);
		}
		add(key$1, interceptor) {
			if (!(key$1 in this.keyedInterceptors)) this.keyedInterceptors[key$1] = [];
			this.keyedInterceptors[key$1].push(interceptor);
			addInterceptor(this.basePath, interceptor, this, this.scopeOptions, this.urlParts.hostname);
		}
		remove(key$1, interceptor) {
			if (this._persist) return;
			const arr = this.keyedInterceptors[key$1];
			if (arr) {
				arr.splice(arr.indexOf(interceptor), 1);
				if (arr.length === 0) delete this.keyedInterceptors[key$1];
			}
		}
		intercept(uri, method$1, requestBody, interceptorOptions) {
			const ic = new Interceptor(this, uri, method$1, requestBody, interceptorOptions);
			this.interceptors.push(ic);
			return ic;
		}
		get(uri, requestBody, options) {
			return this.intercept(uri, "GET", requestBody, options);
		}
		post(uri, requestBody, options) {
			return this.intercept(uri, "POST", requestBody, options);
		}
		put(uri, requestBody, options) {
			return this.intercept(uri, "PUT", requestBody, options);
		}
		head(uri, requestBody, options) {
			return this.intercept(uri, "HEAD", requestBody, options);
		}
		patch(uri, requestBody, options) {
			return this.intercept(uri, "PATCH", requestBody, options);
		}
		merge(uri, requestBody, options) {
			return this.intercept(uri, "MERGE", requestBody, options);
		}
		delete(uri, requestBody, options) {
			return this.intercept(uri, "DELETE", requestBody, options);
		}
		options(uri, requestBody, options) {
			return this.intercept(uri, "OPTIONS", requestBody, options);
		}
		pendingMocks() {
			return this.activeMocks().filter((key$1) => this.keyedInterceptors[key$1].some(({ interceptionCounter, optional }) => {
				return !(this._persist && interceptionCounter > 0) && !optional;
			}));
		}
		activeMocks() {
			return Object.keys(this.keyedInterceptors);
		}
		isDone() {
			if (!isOn$1()) return true;
			return this.pendingMocks().length === 0;
		}
		done() {
			assert$2.ok(this.isDone(), `Mocks not yet satisfied:\n${this.pendingMocks().join("\n")}`);
		}
		buildFilter() {
			const filteringArguments = arguments;
			if (arguments[0] instanceof RegExp) return function(candidate) {
				/* istanbul ignore if */
				if (typeof candidate !== "string") throw Error(`Nock internal assertion failed: typeof candidate is ${typeof candidate}. If you encounter this error, please report it as a bug.`);
				return candidate.replace(filteringArguments[0], filteringArguments[1]);
			};
			else if (typeof arguments[0] === "function") return arguments[0];
		}
		filteringPath() {
			this.transformPathFunction = this.buildFilter.apply(this, arguments);
			if (!this.transformPathFunction) throw new Error("Invalid arguments: filtering path should be a function or a regular expression");
			return this;
		}
		filteringRequestBody() {
			this.transformRequestBodyFunction = this.buildFilter.apply(this, arguments);
			if (!this.transformRequestBodyFunction) throw new Error("Invalid arguments: filtering request body should be a function or a regular expression");
			return this;
		}
		matchHeader(name, value) {
			this.matchHeaders.push({
				name: name.toLowerCase(),
				value
			});
			return this;
		}
		defaultReplyHeaders(headers$1) {
			this._defaultReplyHeaders = common$2.headersInputToRawArray(headers$1);
			return this;
		}
		persist(flag = true) {
			if (typeof flag !== "boolean") throw new Error("Invalid arguments: argument should be a boolean");
			this._persist = flag;
			return this;
		}
		/**
		* @private
		* @returns {boolean}
		*/
		shouldPersist() {
			return this._persist;
		}
		replyContentLength() {
			this.contentLen = true;
			return this;
		}
		replyDate(d$3) {
			this.date = d$3 || /* @__PURE__ */ new Date();
			return this;
		}
		clone() {
			return new Scope$1(this.basePath, this.scopeOptions);
		}
	};
	function loadDefs$2(path$19) {
		if (!fs$24) throw new Error("No fs");
		const contents = fs$24.readFileSync(path$19);
		return JSON.parse(contents);
	}
	function load$4(path$19) {
		return define$3(loadDefs$2(path$19));
	}
	function getStatusFromDefinition(nockDef) {
		if (nockDef.reply !== void 0) {
			const parsedReply = parseInt(nockDef.reply, 10);
			if (isNaN(parsedReply)) throw Error("`reply`, when present, must be a numeric string");
			return parsedReply;
		}
		return nockDef.status || 200;
	}
	function getScopeFromDefinition(nockDef) {
		if (nockDef.port !== void 0) {
			const options = url$3.parse(nockDef.scope);
			if (options.port === null) return `${nockDef.scope}:${nockDef.port}`;
			else if (parseInt(options.port) !== parseInt(nockDef.port)) throw new Error("Mismatched port numbers in scope and port properties of nock definition.");
		}
		return nockDef.scope;
	}
	function tryJsonParse(string) {
		try {
			return JSON.parse(string);
		} catch (err) {
			return string;
		}
	}
	function define$3(nockDefs) {
		const scopes = [];
		nockDefs.forEach(function(nockDef) {
			const nscope = getScopeFromDefinition(nockDef);
			const npath = nockDef.path;
			if (!nockDef.method) throw Error("Method is required");
			const method$1 = nockDef.method.toLowerCase();
			const status$1 = getStatusFromDefinition(nockDef);
			const rawHeaders = nockDef.rawHeaders || [];
			const reqheaders = nockDef.reqheaders || {};
			const badheaders = nockDef.badheaders || [];
			const options = { ...nockDef.options };
			options.reqheaders = reqheaders;
			options.badheaders = badheaders;
			let response;
			if (!nockDef.response) response = "";
			else if (nockDef.responseIsBinary) response = Buffer.from(nockDef.response, "hex");
			else response = typeof nockDef.response === "string" ? tryJsonParse(nockDef.response) : nockDef.response;
			const scope = new Scope$1(nscope, options);
			Object.entries(reqheaders).forEach(([fieldName, value]) => {
				scope.matchHeader(fieldName, value);
			});
			["filteringRequestBody", "filteringPath"].forEach((filter) => {
				if (nockDef[filter]) scope[filter](nockDef[filter]);
			});
			scope.intercept(npath, method$1, nockDef.body).reply(status$1, response, rawHeaders);
			scopes.push(scope);
		});
		return scopes;
	}
	module.exports = {
		Scope: Scope$1,
		load: load$4,
		loadDefs: loadDefs$2,
		define: define$3
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/back.js
var require_back = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/lib/back.js": ((exports, module) => {
	const assert$1 = __require("assert");
	const recorder$1 = require_recorder();
	const { activate: activate$1, disableNetConnect: disableNetConnect$1, enableNetConnect: enableNetConnect$1, removeAll: cleanAll } = require_intercept();
	const { loadDefs: loadDefs$1, define: define$2 } = require_scope();
	const { format: format$5 } = __require("util");
	const path$18 = __require("path");
	const debug$15 = require_src$1()("nock.back");
	let _mode = null;
	let fs$23;
	try {
		fs$23 = __require("fs");
	} catch (err) {}
	/**
	* nock the current function with the fixture given
	*
	* @param {string}   fixtureName  - the name of the fixture, e.x. 'foo.json'
	* @param {object}   options      - [optional] extra options for nock with, e.x. `{ assert: true }`
	* @param {function} nockedFn     - [optional] callback function to be executed with the given fixture being loaded;
	*                                  if defined the function will be called with context `{ scopes: loaded_nocks || [] }`
	*                                  set as `this` and `nockDone` callback function as first and only parameter;
	*                                  if not defined a promise resolving to `{nockDone, context}` where `context` is
	*                                  aforementioned `{ scopes: loaded_nocks || [] }`
	*
	* List of options:
	*
	* @param {function} before       - a preprocessing function, gets called before nock.define
	* @param {function} after        - a postprocessing function, gets called after nock.define
	* @param {function} afterRecord  - a postprocessing function, gets called after recording. Is passed the array
	*                                  of scopes recorded and should return the array scopes to save to the fixture
	* @param {function} recorder     - custom options to pass to the recorder
	*
	*/
	function Back(fixtureName, options, nockedFn) {
		if (!Back.fixtures) throw new Error("Back requires nock.back.fixtures to be set\nEx:\n	require(nock).back.fixtures = '/path/to/fixtures/'");
		if (typeof fixtureName !== "string") throw new Error("Parameter fixtureName must be a string");
		if (arguments.length === 1) options = {};
		else if (arguments.length === 2) {
			if (typeof options === "function") {
				nockedFn = options;
				options = {};
			}
		}
		_mode.setup();
		const fixture = path$18.join(Back.fixtures, fixtureName);
		const context = _mode.start(fixture, options);
		const nockDone = function() {
			_mode.finish(fixture, options, context);
		};
		debug$15("context:", context);
		if (typeof nockedFn === "function") nockedFn.call(context, nockDone);
		else return Promise.resolve({
			nockDone,
			context
		});
	}
	/*******************************************************************************
	*                                    Modes                                     *
	*******************************************************************************/
	const wild = {
		setup: function() {
			cleanAll();
			recorder$1.restore();
			activate$1();
			enableNetConnect$1();
		},
		start: function() {
			return load$3();
		},
		finish: function() {}
	};
	const dryrun = {
		setup: function() {
			recorder$1.restore();
			cleanAll();
			activate$1();
			enableNetConnect$1();
		},
		start: function(fixture, options) {
			const contexts = load$3(fixture, options);
			enableNetConnect$1();
			return contexts;
		},
		finish: function() {}
	};
	const record = {
		setup: function() {
			recorder$1.restore();
			recorder$1.clear();
			cleanAll();
			activate$1();
			disableNetConnect$1();
		},
		start: function(fixture, options) {
			if (!fs$23) throw new Error("no fs");
			const context = load$3(fixture, options);
			if (!context.isLoaded) {
				recorder$1.record({
					dont_print: true,
					output_objects: true,
					...options.recorder
				});
				context.isRecording = true;
			}
			return context;
		},
		finish: function(fixture, options, context) {
			if (context.isRecording) {
				let outputs$1 = recorder$1.outputs();
				if (typeof options.afterRecord === "function") outputs$1 = options.afterRecord(outputs$1);
				outputs$1 = typeof outputs$1 === "string" ? outputs$1 : JSON.stringify(outputs$1, null, 4);
				debug$15("recorder outputs:", outputs$1);
				fs$23.mkdirSync(path$18.dirname(fixture), { recursive: true });
				fs$23.writeFileSync(fixture, outputs$1);
			}
		}
	};
	const update = {
		setup: function() {
			recorder$1.restore();
			recorder$1.clear();
			cleanAll();
			activate$1();
			disableNetConnect$1();
		},
		start: function(fixture, options) {
			if (!fs$23) throw new Error("no fs");
			const context = removeFixture(fixture);
			recorder$1.record({
				dont_print: true,
				output_objects: true,
				...options.recorder
			});
			context.isRecording = true;
			return context;
		},
		finish: function(fixture, options, context) {
			let outputs$1 = recorder$1.outputs();
			if (typeof options.afterRecord === "function") outputs$1 = options.afterRecord(outputs$1);
			outputs$1 = typeof outputs$1 === "string" ? outputs$1 : JSON.stringify(outputs$1, null, 4);
			debug$15("recorder outputs:", outputs$1);
			fs$23.mkdirSync(path$18.dirname(fixture), { recursive: true });
			fs$23.writeFileSync(fixture, outputs$1);
		}
	};
	const lockdown = {
		setup: function() {
			recorder$1.restore();
			recorder$1.clear();
			cleanAll();
			activate$1();
			disableNetConnect$1();
		},
		start: function(fixture, options) {
			return load$3(fixture, options);
		},
		finish: function() {}
	};
	function load$3(fixture, options) {
		const context = {
			scopes: [],
			assertScopesFinished: function() {
				assertScopes(this.scopes, fixture);
			},
			query: function() {
				const nested = this.scopes.map((scope) => scope.interceptors.map((interceptor) => ({
					method: interceptor.method,
					uri: interceptor.uri,
					basePath: interceptor.basePath,
					path: interceptor.path,
					queries: interceptor.queries,
					counter: interceptor.counter,
					body: interceptor.body,
					statusCode: interceptor.statusCode,
					optional: interceptor.optional
				})));
				return [].concat.apply([], nested);
			}
		};
		if (fixture && fixtureExists(fixture)) {
			let scopes = loadDefs$1(fixture);
			applyHook(scopes, options.before);
			scopes = define$2(scopes);
			applyHook(scopes, options.after);
			context.scopes = scopes;
			context.isLoaded = true;
		}
		return context;
	}
	function removeFixture(fixture, options) {
		const context = {
			scopes: [],
			assertScopesFinished: function() {}
		};
		if (fixture && fixtureExists(fixture))
 /* istanbul ignore next - fs.unlinkSync is for node 10 support */
		fs$23.rmSync ? fs$23.rmSync(fixture) : fs$23.unlinkSync(fixture);
		context.isLoaded = false;
		return context;
	}
	function applyHook(scopes, fn) {
		if (!fn) return;
		if (typeof fn !== "function") throw new Error("processing hooks must be a function");
		scopes.forEach(fn);
	}
	function fixtureExists(fixture) {
		if (!fs$23) throw new Error("no fs");
		return fs$23.existsSync(fixture);
	}
	function assertScopes(scopes, fixture) {
		const pending = scopes.filter((scope) => !scope.isDone()).map((scope) => scope.pendingMocks());
		if (pending.length) assert$1.fail(format$5("%j was not used, consider removing %s to rerecord fixture", [].concat(...pending), fixture));
	}
	const Modes = {
		wild,
		dryrun,
		record,
		update,
		lockdown
	};
	Back.setMode = function(mode) {
		if (!(mode in Modes)) throw new Error(`Unknown mode: ${mode}`);
		Back.currentMode = mode;
		debug$15("New nock back mode:", Back.currentMode);
		_mode = Modes[mode];
		_mode.setup();
	};
	Back.fixtures = null;
	Back.currentMode = null;
	module.exports = Back;
}) });

//#endregion
//#region ../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/index.js
var require_nock = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nock@13.5.6/node_modules/nock/index.js": ((exports, module) => {
	const back = require_back();
	const emitter = require_global_emitter();
	const { activate, isActive, isDone, isOn, pendingMocks, activeMocks, removeInterceptor, disableNetConnect, enableNetConnect, removeAll, abortPendingRequests } = require_intercept();
	const recorder = require_recorder();
	const { Scope, load: load$2, loadDefs, define: define$1 } = require_scope();
	module.exports = (basePath$1, options) => new Scope(basePath$1, options);
	Object.assign(module.exports, {
		activate,
		isActive,
		isDone,
		pendingMocks,
		activeMocks,
		removeInterceptor,
		disableNetConnect,
		enableNetConnect,
		cleanAll: removeAll,
		abortPendingRequests,
		load: load$2,
		loadDefs,
		define: define$1,
		emitter,
		recorder: {
			rec: recorder.record,
			clear: recorder.clear,
			play: recorder.outputs
		},
		restore: recorder.restore,
		back
	});
	if (isOn()) back.setMode(process.env.NOCK_BACK_MODE || "dryrun");
}) });

//#endregion
//#region ../../node_modules/.pnpm/@pollyjs+adapter@6.0.6/node_modules/@pollyjs/adapter/dist/cjs/pollyjs-adapter.js
var require_pollyjs_adapter = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/@pollyjs+adapter@6.0.6/node_modules/@pollyjs/adapter/dist/cjs/pollyjs-adapter.js": ((exports, module) => {
	var utils$6 = require_pollyjs_utils();
	var _defined$4 = function(it) {
		if (it == void 0) throw TypeError("Can't call method on  " + it);
		return it;
	};
	var _toObject$4 = function(it) {
		return Object(_defined$4(it));
	};
	var hasOwnProperty$8 = {}.hasOwnProperty;
	var _has$4 = function(it, key$1) {
		return hasOwnProperty$8.call(it, key$1);
	};
	var toString$10 = {}.toString;
	var _cof$4 = function(it) {
		return toString$10.call(it).slice(8, -1);
	};
	var _iobject$4 = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
		return _cof$4(it) == "String" ? it.split("") : Object(it);
	};
	var _toIobject$4 = function(it) {
		return _iobject$4(_defined$4(it));
	};
	var ceil$4 = Math.ceil;
	var floor$4 = Math.floor;
	var _toInteger$4 = function(it) {
		return isNaN(it = +it) ? 0 : (it > 0 ? floor$4 : ceil$4)(it);
	};
	var min$7 = Math.min;
	var _toLength$4 = function(it) {
		return it > 0 ? min$7(_toInteger$4(it), 9007199254740991) : 0;
	};
	var max$4 = Math.max;
	var min$1$8 = Math.min;
	var _toAbsoluteIndex$4 = function(index$1, length) {
		index$1 = _toInteger$4(index$1);
		return index$1 < 0 ? max$4(index$1 + length, 0) : min$1$8(index$1, length);
	};
	var _arrayIncludes$4 = function(IS_INCLUDES) {
		return function($this, el, fromIndex) {
			var O = _toIobject$4($this);
			var length = _toLength$4(O.length);
			var index$1 = _toAbsoluteIndex$4(fromIndex, length);
			var value;
			if (IS_INCLUDES && el != el) while (length > index$1) {
				value = O[index$1++];
				if (value != value) return true;
			}
			else for (; length > index$1; index$1++) if (IS_INCLUDES || index$1 in O) {
				if (O[index$1] === el) return IS_INCLUDES || index$1 || 0;
			}
			return !IS_INCLUDES && -1;
		};
	};
	function unwrapExports$4(x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
	}
	function createCommonjsModule$4(fn, module$2) {
		return module$2 = { exports: {} }, fn(module$2, module$2.exports), module$2.exports;
	}
	function getCjsExportFromNamespace$2(n) {
		return n && n["default"] || n;
	}
	var _core$4 = createCommonjsModule$4(function(module$2) {
		var core = module$2.exports = { version: "2.6.9" };
		if (typeof __e == "number") __e = core;
	});
	_core$4.version;
	var _global$4 = createCommonjsModule$4(function(module$2) {
		var global$1 = module$2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
		if (typeof __g == "number") __g = global$1;
	});
	var _library$4 = true;
	var _shared$4 = createCommonjsModule$4(function(module$2) {
		var SHARED = "__core-js_shared__";
		var store = _global$4[SHARED] || (_global$4[SHARED] = {});
		(module$2.exports = function(key$1, value) {
			return store[key$1] || (store[key$1] = value !== void 0 ? value : {});
		})("versions", []).push({
			version: _core$4.version,
			mode: "pure",
			copyright: " 2019 Denis Pushkarev (zloirock.ru)"
		});
	});
	var id$4 = 0;
	var px$4 = Math.random();
	var _uid$4 = function(key$1) {
		return "Symbol(".concat(key$1 === void 0 ? "" : key$1, ")_", (++id$4 + px$4).toString(36));
	};
	var shared$4 = _shared$4("keys");
	var _sharedKey$4 = function(key$1) {
		return shared$4[key$1] || (shared$4[key$1] = _uid$4(key$1));
	};
	var arrayIndexOf$4 = _arrayIncludes$4(false);
	var IE_PROTO$4 = _sharedKey$4("IE_PROTO");
	var _objectKeysInternal$4 = function(object, names) {
		var O = _toIobject$4(object);
		var i$8 = 0;
		var result = [];
		var key$1;
		for (key$1 in O) if (key$1 != IE_PROTO$4) _has$4(O, key$1) && result.push(key$1);
		while (names.length > i$8) if (_has$4(O, key$1 = names[i$8++])) ~arrayIndexOf$4(result, key$1) || result.push(key$1);
		return result;
	};
	var _enumBugKeys$4 = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
	var _objectKeys$4 = Object.keys || function keys$6(O) {
		return _objectKeysInternal$4(O, _enumBugKeys$4);
	};
	var _aFunction$4 = function(it) {
		if (typeof it != "function") throw TypeError(it + " is not a function!");
		return it;
	};
	var _ctx$4 = function(fn, that, length) {
		_aFunction$4(fn);
		if (that === void 0) return fn;
		switch (length) {
			case 1: return function(a) {
				return fn.call(that, a);
			};
			case 2: return function(a, b) {
				return fn.call(that, a, b);
			};
			case 3: return function(a, b, c) {
				return fn.call(that, a, b, c);
			};
		}
		return function() {
			return fn.apply(that, arguments);
		};
	};
	var _isObject$4 = function(it) {
		return typeof it === "object" ? it !== null : typeof it === "function";
	};
	var _anObject$4 = function(it) {
		if (!_isObject$4(it)) throw TypeError(it + " is not an object!");
		return it;
	};
	var _fails$4 = function(exec) {
		try {
			return !!exec();
		} catch (e) {
			return true;
		}
	};
	var _descriptors$4 = !_fails$4(function() {
		return Object.defineProperty({}, "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var document$3 = _global$4.document;
	var is$5 = _isObject$4(document$3) && _isObject$4(document$3.createElement);
	var _domCreate$4 = function(it) {
		return is$5 ? document$3.createElement(it) : {};
	};
	var _ie8DomDefine$4 = !_descriptors$4 && !_fails$4(function() {
		return Object.defineProperty(_domCreate$4("div"), "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var _toPrimitive$4 = function(it, S) {
		if (!_isObject$4(it)) return it;
		var fn, val;
		if (S && typeof (fn = it.toString) == "function" && !_isObject$4(val = fn.call(it))) return val;
		if (typeof (fn = it.valueOf) == "function" && !_isObject$4(val = fn.call(it))) return val;
		if (!S && typeof (fn = it.toString) == "function" && !_isObject$4(val = fn.call(it))) return val;
		throw TypeError("Can't convert object to primitive value");
	};
	var dP$8 = Object.defineProperty;
	var _objectDp$4 = { f: _descriptors$4 ? Object.defineProperty : function defineProperty$8(O, P, Attributes) {
		_anObject$4(O);
		P = _toPrimitive$4(P, true);
		_anObject$4(Attributes);
		if (_ie8DomDefine$4) try {
			return dP$8(O, P, Attributes);
		} catch (e) {}
		if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
		if ("value" in Attributes) O[P] = Attributes.value;
		return O;
	} };
	var _propertyDesc$4 = function(bitmap, value) {
		return {
			enumerable: !(bitmap & 1),
			configurable: !(bitmap & 2),
			writable: !(bitmap & 4),
			value
		};
	};
	var _hide$4 = _descriptors$4 ? function(object, key$1, value) {
		return _objectDp$4.f(object, key$1, _propertyDesc$4(1, value));
	} : function(object, key$1, value) {
		object[key$1] = value;
		return object;
	};
	var PROTOTYPE$4 = "prototype";
	var $export$4 = function(type, name, source) {
		var IS_FORCED = type & $export$4.F;
		var IS_GLOBAL = type & $export$4.G;
		var IS_STATIC = type & $export$4.S;
		var IS_PROTO = type & $export$4.P;
		var IS_BIND = type & $export$4.B;
		var IS_WRAP = type & $export$4.W;
		var exports$1 = IS_GLOBAL ? _core$4 : _core$4[name] || (_core$4[name] = {});
		var expProto = exports$1[PROTOTYPE$4];
		var target = IS_GLOBAL ? _global$4 : IS_STATIC ? _global$4[name] : (_global$4[name] || {})[PROTOTYPE$4];
		var key$1, own, out;
		if (IS_GLOBAL) source = name;
		for (key$1 in source) {
			own = !IS_FORCED && target && target[key$1] !== void 0;
			if (own && _has$4(exports$1, key$1)) continue;
			out = own ? target[key$1] : source[key$1];
			exports$1[key$1] = IS_GLOBAL && typeof target[key$1] != "function" ? source[key$1] : IS_BIND && own ? _ctx$4(out, _global$4) : IS_WRAP && target[key$1] == out ? (function(C) {
				var F = function(a, b, c) {
					if (this instanceof C) {
						switch (arguments.length) {
							case 0: return new C();
							case 1: return new C(a);
							case 2: return new C(a, b);
						}
						return new C(a, b, c);
					}
					return C.apply(this, arguments);
				};
				F[PROTOTYPE$4] = C[PROTOTYPE$4];
				return F;
			})(out) : IS_PROTO && typeof out == "function" ? _ctx$4(Function.call, out) : out;
			if (IS_PROTO) {
				(exports$1.virtual || (exports$1.virtual = {}))[key$1] = out;
				if (type & $export$4.R && expProto && !expProto[key$1]) _hide$4(expProto, key$1, out);
			}
		}
	};
	$export$4.F = 1;
	$export$4.G = 2;
	$export$4.S = 4;
	$export$4.P = 8;
	$export$4.B = 16;
	$export$4.W = 32;
	$export$4.U = 64;
	$export$4.R = 128;
	var _export$4 = $export$4;
	var _objectSap$4 = function(KEY, exec) {
		var fn = (_core$4.Object || {})[KEY] || Object[KEY];
		var exp = {};
		exp[KEY] = exec(fn);
		_export$4(_export$4.S + _export$4.F * _fails$4(function() {
			fn(1);
		}), "Object", exp);
	};
	_objectSap$4("keys", function() {
		return function keys$6(it) {
			return _objectKeys$4(_toObject$4(it));
		};
	});
	var keys$1$4 = _core$4.Object.keys;
	var _redefine$4 = _hide$4;
	var _meta$4 = createCommonjsModule$4(function(module$2) {
		var META$7 = _uid$4("meta");
		var setDesc = _objectDp$4.f;
		var id$7 = 0;
		var isExtensible = Object.isExtensible || function() {
			return true;
		};
		var FREEZE = !_fails$4(function() {
			return isExtensible(Object.preventExtensions({}));
		});
		var setMeta = function(it) {
			setDesc(it, META$7, { value: {
				i: "O" + ++id$7,
				w: {}
			} });
		};
		var fastKey$2 = function(it, create) {
			if (!_isObject$4(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
			if (!_has$4(it, META$7)) {
				if (!isExtensible(it)) return "F";
				if (!create) return "E";
				setMeta(it);
			}
			return it[META$7].i;
		};
		var getWeak$2 = function(it, create) {
			if (!_has$4(it, META$7)) {
				if (!isExtensible(it)) return true;
				if (!create) return false;
				setMeta(it);
			}
			return it[META$7].w;
		};
		var onFreeze = function(it) {
			if (FREEZE && meta.NEED && isExtensible(it) && !_has$4(it, META$7)) setMeta(it);
			return it;
		};
		var meta = module$2.exports = {
			KEY: META$7,
			NEED: false,
			fastKey: fastKey$2,
			getWeak: getWeak$2,
			onFreeze
		};
	});
	_meta$4.KEY;
	_meta$4.NEED;
	_meta$4.fastKey;
	_meta$4.getWeak;
	_meta$4.onFreeze;
	var _wks$4 = createCommonjsModule$4(function(module$2) {
		var store = _shared$4("wks");
		var Symbol$2 = _global$4.Symbol;
		var USE_SYMBOL = typeof Symbol$2 == "function";
		var $exports = module$2.exports = function(name) {
			return store[name] || (store[name] = USE_SYMBOL && Symbol$2[name] || (USE_SYMBOL ? Symbol$2 : _uid$4)("Symbol." + name));
		};
		$exports.store = store;
	});
	var def$4 = _objectDp$4.f;
	var TAG$4 = _wks$4("toStringTag");
	var _setToStringTag$4 = function(it, tag, stat$4) {
		if (it && !_has$4(it = stat$4 ? it : it.prototype, TAG$4)) def$4(it, TAG$4, {
			configurable: true,
			value: tag
		});
	};
	var _wksExt$4 = { f: _wks$4 };
	var defineProperty$7 = _objectDp$4.f;
	var _wksDefine$4 = function(name) {
		var $Symbol$7 = _core$4.Symbol || (_core$4.Symbol = {});
		if (name.charAt(0) != "_" && !(name in $Symbol$7)) defineProperty$7($Symbol$7, name, { value: _wksExt$4.f(name) });
	};
	var _objectGops$4 = { f: Object.getOwnPropertySymbols };
	var _objectPie$4 = { f: {}.propertyIsEnumerable };
	var _enumKeys$4 = function(it) {
		var result = _objectKeys$4(it);
		var getSymbols = _objectGops$4.f;
		if (getSymbols) {
			var symbols = getSymbols(it);
			var isEnum$7 = _objectPie$4.f;
			var i$8 = 0;
			var key$1;
			while (symbols.length > i$8) if (isEnum$7.call(it, key$1 = symbols[i$8++])) result.push(key$1);
		}
		return result;
	};
	var _isArray$4 = Array.isArray || function isArray$11(arg) {
		return _cof$4(arg) == "Array";
	};
	var _objectDps$4 = _descriptors$4 ? Object.defineProperties : function defineProperties(O, Properties) {
		_anObject$4(O);
		var keys$6 = _objectKeys$4(Properties);
		var length = keys$6.length;
		var i$8 = 0;
		var P;
		while (length > i$8) _objectDp$4.f(O, P = keys$6[i$8++], Properties[P]);
		return O;
	};
	var document$1$5 = _global$4.document;
	var _html$4 = document$1$5 && document$1$5.documentElement;
	var IE_PROTO$1$7 = _sharedKey$4("IE_PROTO");
	var Empty$4 = function() {};
	var PROTOTYPE$1$9 = "prototype";
	var createDict$4 = function() {
		var iframe = _domCreate$4("iframe");
		var i$8 = _enumBugKeys$4.length;
		var lt = "<";
		var gt = ">";
		var iframeDocument;
		iframe.style.display = "none";
		_html$4.appendChild(iframe);
		iframe.src = "javascript:";
		iframeDocument = iframe.contentWindow.document;
		iframeDocument.open();
		iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
		iframeDocument.close();
		createDict$4 = iframeDocument.F;
		while (i$8--) delete createDict$4[PROTOTYPE$1$9][_enumBugKeys$4[i$8]];
		return createDict$4();
	};
	var _objectCreate$4 = Object.create || function create(O, Properties) {
		var result;
		if (O !== null) {
			Empty$4[PROTOTYPE$1$9] = _anObject$4(O);
			result = new Empty$4();
			Empty$4[PROTOTYPE$1$9] = null;
			result[IE_PROTO$1$7] = O;
		} else result = createDict$4();
		return Properties === void 0 ? result : _objectDps$4(result, Properties);
	};
	var hiddenKeys$4 = _enumBugKeys$4.concat("length", "prototype");
	var _objectGopn$4 = { f: Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		return _objectKeysInternal$4(O, hiddenKeys$4);
	} };
	var gOPN$7 = _objectGopn$4.f;
	var toString$1$11 = {}.toString;
	var windowNames$4 = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
	var getWindowNames$4 = function(it) {
		try {
			return gOPN$7(it);
		} catch (e) {
			return windowNames$4.slice();
		}
	};
	var _objectGopnExt$4 = { f: function getOwnPropertyNames(it) {
		return windowNames$4 && toString$1$11.call(it) == "[object Window]" ? getWindowNames$4(it) : gOPN$7(_toIobject$4(it));
	} };
	var gOPD$7 = Object.getOwnPropertyDescriptor;
	var _objectGopd$4 = { f: _descriptors$4 ? gOPD$7 : function getOwnPropertyDescriptor(O, P) {
		O = _toIobject$4(O);
		P = _toPrimitive$4(P, true);
		if (_ie8DomDefine$4) try {
			return gOPD$7(O, P);
		} catch (e) {}
		if (_has$4(O, P)) return _propertyDesc$4(!_objectPie$4.f.call(O, P), O[P]);
	} };
	var META$4 = _meta$4.KEY;
	var gOPD$1$8 = _objectGopd$4.f;
	var dP$1$9 = _objectDp$4.f;
	var gOPN$1$8 = _objectGopnExt$4.f;
	var $Symbol$4 = _global$4.Symbol;
	var $JSON$4 = _global$4.JSON;
	var _stringify$4 = $JSON$4 && $JSON$4.stringify;
	var PROTOTYPE$2$7 = "prototype";
	var HIDDEN$4 = _wks$4("_hidden");
	var TO_PRIMITIVE$4 = _wks$4("toPrimitive");
	var isEnum$4 = {}.propertyIsEnumerable;
	var SymbolRegistry$4 = _shared$4("symbol-registry");
	var AllSymbols$4 = _shared$4("symbols");
	var OPSymbols$4 = _shared$4("op-symbols");
	var ObjectProto$4 = Object[PROTOTYPE$2$7];
	var USE_NATIVE$4 = typeof $Symbol$4 == "function" && !!_objectGops$4.f;
	var QObject$4 = _global$4.QObject;
	var setter$4 = !QObject$4 || !QObject$4[PROTOTYPE$2$7] || !QObject$4[PROTOTYPE$2$7].findChild;
	var setSymbolDesc$4 = _descriptors$4 && _fails$4(function() {
		return _objectCreate$4(dP$1$9({}, "a", { get: function() {
			return dP$1$9(this, "a", { value: 7 }).a;
		} })).a != 7;
	}) ? function(it, key$1, D) {
		var protoDesc = gOPD$1$8(ObjectProto$4, key$1);
		if (protoDesc) delete ObjectProto$4[key$1];
		dP$1$9(it, key$1, D);
		if (protoDesc && it !== ObjectProto$4) dP$1$9(ObjectProto$4, key$1, protoDesc);
	} : dP$1$9;
	var wrap$7 = function(tag) {
		var sym = AllSymbols$4[tag] = _objectCreate$4($Symbol$4[PROTOTYPE$2$7]);
		sym._k = tag;
		return sym;
	};
	var isSymbol$4 = USE_NATIVE$4 && typeof $Symbol$4.iterator == "symbol" ? function(it) {
		return typeof it == "symbol";
	} : function(it) {
		return it instanceof $Symbol$4;
	};
	var $defineProperty$4 = function defineProperty$8(it, key$1, D) {
		if (it === ObjectProto$4) $defineProperty$4(OPSymbols$4, key$1, D);
		_anObject$4(it);
		key$1 = _toPrimitive$4(key$1, true);
		_anObject$4(D);
		if (_has$4(AllSymbols$4, key$1)) {
			if (!D.enumerable) {
				if (!_has$4(it, HIDDEN$4)) dP$1$9(it, HIDDEN$4, _propertyDesc$4(1, {}));
				it[HIDDEN$4][key$1] = true;
			} else {
				if (_has$4(it, HIDDEN$4) && it[HIDDEN$4][key$1]) it[HIDDEN$4][key$1] = false;
				D = _objectCreate$4(D, { enumerable: _propertyDesc$4(0, false) });
			}
			return setSymbolDesc$4(it, key$1, D);
		}
		return dP$1$9(it, key$1, D);
	};
	var $defineProperties$4 = function defineProperties(it, P) {
		_anObject$4(it);
		var keys$6 = _enumKeys$4(P = _toIobject$4(P));
		var i$8 = 0;
		var l = keys$6.length;
		var key$1;
		while (l > i$8) $defineProperty$4(it, key$1 = keys$6[i$8++], P[key$1]);
		return it;
	};
	var $create$4 = function create(it, P) {
		return P === void 0 ? _objectCreate$4(it) : $defineProperties$4(_objectCreate$4(it), P);
	};
	var $propertyIsEnumerable$4 = function propertyIsEnumerable$1(key$1) {
		var E = isEnum$4.call(this, key$1 = _toPrimitive$4(key$1, true));
		if (this === ObjectProto$4 && _has$4(AllSymbols$4, key$1) && !_has$4(OPSymbols$4, key$1)) return false;
		return E || !_has$4(this, key$1) || !_has$4(AllSymbols$4, key$1) || _has$4(this, HIDDEN$4) && this[HIDDEN$4][key$1] ? E : true;
	};
	var $getOwnPropertyDescriptor$7 = function getOwnPropertyDescriptor(it, key$1) {
		it = _toIobject$4(it);
		key$1 = _toPrimitive$4(key$1, true);
		if (it === ObjectProto$4 && _has$4(AllSymbols$4, key$1) && !_has$4(OPSymbols$4, key$1)) return;
		var D = gOPD$1$8(it, key$1);
		if (D && _has$4(AllSymbols$4, key$1) && !(_has$4(it, HIDDEN$4) && it[HIDDEN$4][key$1])) D.enumerable = true;
		return D;
	};
	var $getOwnPropertyNames$4 = function getOwnPropertyNames(it) {
		var names = gOPN$1$8(_toIobject$4(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (!_has$4(AllSymbols$4, key$1 = names[i$8++]) && key$1 != HIDDEN$4 && key$1 != META$4) result.push(key$1);
		return result;
	};
	var $getOwnPropertySymbols$4 = function getOwnPropertySymbols$2(it) {
		var IS_OP = it === ObjectProto$4;
		var names = gOPN$1$8(IS_OP ? OPSymbols$4 : _toIobject$4(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (_has$4(AllSymbols$4, key$1 = names[i$8++]) && (IS_OP ? _has$4(ObjectProto$4, key$1) : true)) result.push(AllSymbols$4[key$1]);
		return result;
	};
	if (!USE_NATIVE$4) {
		$Symbol$4 = function Symbol$2() {
			if (this instanceof $Symbol$4) throw TypeError("Symbol is not a constructor!");
			var tag = _uid$4(arguments.length > 0 ? arguments[0] : void 0);
			var $set = function(value) {
				if (this === ObjectProto$4) $set.call(OPSymbols$4, value);
				if (_has$4(this, HIDDEN$4) && _has$4(this[HIDDEN$4], tag)) this[HIDDEN$4][tag] = false;
				setSymbolDesc$4(this, tag, _propertyDesc$4(1, value));
			};
			if (_descriptors$4 && setter$4) setSymbolDesc$4(ObjectProto$4, tag, {
				configurable: true,
				set: $set
			});
			return wrap$7(tag);
		};
		_redefine$4($Symbol$4[PROTOTYPE$2$7], "toString", function toString$11() {
			return this._k;
		});
		_objectGopd$4.f = $getOwnPropertyDescriptor$7;
		_objectDp$4.f = $defineProperty$4;
		_objectGopn$4.f = _objectGopnExt$4.f = $getOwnPropertyNames$4;
		_objectPie$4.f = $propertyIsEnumerable$4;
		_objectGops$4.f = $getOwnPropertySymbols$4;
		if (_descriptors$4 && !_library$4) _redefine$4(ObjectProto$4, "propertyIsEnumerable", $propertyIsEnumerable$4, true);
		_wksExt$4.f = function(name) {
			return wrap$7(_wks$4(name));
		};
	}
	_export$4(_export$4.G + _export$4.W + _export$4.F * !USE_NATIVE$4, { Symbol: $Symbol$4 });
	for (var es6Symbols$4 = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j$4 = 0; es6Symbols$4.length > j$4;) _wks$4(es6Symbols$4[j$4++]);
	for (var wellKnownSymbols$4 = _objectKeys$4(_wks$4.store), k$4 = 0; wellKnownSymbols$4.length > k$4;) _wksDefine$4(wellKnownSymbols$4[k$4++]);
	_export$4(_export$4.S + _export$4.F * !USE_NATIVE$4, "Symbol", {
		"for": function(key$1) {
			return _has$4(SymbolRegistry$4, key$1 += "") ? SymbolRegistry$4[key$1] : SymbolRegistry$4[key$1] = $Symbol$4(key$1);
		},
		keyFor: function keyFor$1(sym) {
			if (!isSymbol$4(sym)) throw TypeError(sym + " is not a symbol!");
			for (var key$1 in SymbolRegistry$4) if (SymbolRegistry$4[key$1] === sym) return key$1;
		},
		useSetter: function() {
			setter$4 = true;
		},
		useSimple: function() {
			setter$4 = false;
		}
	});
	_export$4(_export$4.S + _export$4.F * !USE_NATIVE$4, "Object", {
		create: $create$4,
		defineProperty: $defineProperty$4,
		defineProperties: $defineProperties$4,
		getOwnPropertyDescriptor: $getOwnPropertyDescriptor$7,
		getOwnPropertyNames: $getOwnPropertyNames$4,
		getOwnPropertySymbols: $getOwnPropertySymbols$4
	});
	var FAILS_ON_PRIMITIVES$4 = _fails$4(function() {
		_objectGops$4.f(1);
	});
	_export$4(_export$4.S + _export$4.F * FAILS_ON_PRIMITIVES$4, "Object", { getOwnPropertySymbols: function getOwnPropertySymbols$2(it) {
		return _objectGops$4.f(_toObject$4(it));
	} });
	$JSON$4 && _export$4(_export$4.S + _export$4.F * (!USE_NATIVE$4 || _fails$4(function() {
		var S = $Symbol$4();
		return _stringify$4([S]) != "[null]" || _stringify$4({ a: S }) != "{}" || _stringify$4(Object(S)) != "{}";
	})), "JSON", { stringify: function stringify$14(it) {
		var args = [it];
		var i$8 = 1;
		var replacer, $replacer;
		while (arguments.length > i$8) args.push(arguments[i$8++]);
		$replacer = replacer = args[1];
		if (!_isObject$4(replacer) && it === void 0 || isSymbol$4(it)) return;
		if (!_isArray$4(replacer)) replacer = function(key$1, value) {
			if (typeof $replacer == "function") value = $replacer.call(this, key$1, value);
			if (!isSymbol$4(value)) return value;
		};
		args[1] = replacer;
		return _stringify$4.apply($JSON$4, args);
	} });
	$Symbol$4[PROTOTYPE$2$7][TO_PRIMITIVE$4] || _hide$4($Symbol$4[PROTOTYPE$2$7], TO_PRIMITIVE$4, $Symbol$4[PROTOTYPE$2$7].valueOf);
	_setToStringTag$4($Symbol$4, "Symbol");
	_setToStringTag$4(Math, "Math", true);
	_setToStringTag$4(_global$4.JSON, "JSON", true);
	var getOwnPropertySymbols$1$4 = _core$4.Object.getOwnPropertySymbols;
	var $getOwnPropertyDescriptor$1$8 = _objectGopd$4.f;
	_objectSap$4("getOwnPropertyDescriptor", function() {
		return function getOwnPropertyDescriptor(it, key$1) {
			return $getOwnPropertyDescriptor$1$8(_toIobject$4(it), key$1);
		};
	});
	var $Object$4 = _core$4.Object;
	var getOwnPropertyDescriptor$1$4 = function getOwnPropertyDescriptor(it, key$1) {
		return $Object$4.getOwnPropertyDescriptor(it, key$1);
	};
	var Reflect$5 = _global$4.Reflect;
	var _ownKeys$4 = Reflect$5 && Reflect$5.ownKeys || function ownKeys$8(it) {
		var keys$6 = _objectGopn$4.f(_anObject$4(it));
		var getSymbols = _objectGops$4.f;
		return getSymbols ? keys$6.concat(getSymbols(it)) : keys$6;
	};
	var _createProperty$4 = function(object, index$1, value) {
		if (index$1 in object) _objectDp$4.f(object, index$1, _propertyDesc$4(0, value));
		else object[index$1] = value;
	};
	_export$4(_export$4.S, "Object", { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
		var O = _toIobject$4(object);
		var getDesc = _objectGopd$4.f;
		var keys$6 = _ownKeys$4(O);
		var result = {};
		var i$8 = 0;
		var key$1, desc$1;
		while (keys$6.length > i$8) {
			desc$1 = getDesc(O, key$1 = keys$6[i$8++]);
			if (desc$1 !== void 0) _createProperty$4(result, key$1, desc$1);
		}
		return result;
	} });
	var getOwnPropertyDescriptors$1$4 = _core$4.Object.getOwnPropertyDescriptors;
	_export$4(_export$4.S + _export$4.F * !_descriptors$4, "Object", { defineProperties: _objectDps$4 });
	var $Object$1$9 = _core$4.Object;
	var defineProperties$1$4 = function defineProperties(T, D) {
		return $Object$1$9.defineProperties(T, D);
	};
	_export$4(_export$4.S + _export$4.F * !_descriptors$4, "Object", { defineProperty: _objectDp$4.f });
	var $Object$2$7 = _core$4.Object;
	var defineProperty$2$8 = function defineProperty$8(it, key$1, desc$1) {
		return $Object$2$7.defineProperty(it, key$1, desc$1);
	};
	var _defineProperty$4 = unwrapExports$4(createCommonjsModule$4(function(module$2) {
		function _defineProperty$7(obj, key$1, value) {
			if (key$1 in obj) defineProperty$2$8(obj, key$1, {
				value,
				enumerable: true,
				configurable: true,
				writable: true
			});
			else obj[key$1] = value;
			return obj;
		}
		module$2.exports = _defineProperty$7;
		module$2.exports["default"] = module$2.exports, module$2.exports.__esModule = true;
	}));
	var es6_object_toString$2 = /* @__PURE__ */ Object.freeze({});
	_wksDefine$4("asyncIterator");
	_wksDefine$4("observable");
	getCjsExportFromNamespace$2(es6_object_toString$2);
	var symbol$1$2 = _core$4.Symbol;
	var $JSON$1$2 = _core$4.JSON || (_core$4.JSON = { stringify: JSON.stringify });
	var stringify$1$2 = function stringify$14(it) {
		return $JSON$1$2.stringify.apply($JSON$1$2, arguments);
	};
	var _stringWs$1 = "	\n\v\f\r \xA0\u2028\u2029";
	var space$1 = "[" + _stringWs$1 + "]";
	var non$1 = "";
	var ltrim$1 = RegExp("^" + space$1 + space$1 + "*");
	var rtrim$1 = RegExp(space$1 + space$1 + "*$");
	var exporter$1 = function(KEY, exec, ALIAS) {
		var exp = {};
		var FORCE = _fails$4(function() {
			return !!_stringWs$1[KEY]() || non$1[KEY]() != non$1;
		});
		var fn = exp[KEY] = FORCE ? exec(trim$1) : _stringWs$1[KEY];
		if (ALIAS) exp[ALIAS] = fn;
		_export$4(_export$4.P + _export$4.F * FORCE, "String", exp);
	};
	var trim$1 = exporter$1.trim = function(string, TYPE) {
		string = String(_defined$4(string));
		if (TYPE & 1) string = string.replace(ltrim$1, "");
		if (TYPE & 2) string = string.replace(rtrim$1, "");
		return string;
	};
	var _stringTrim$1 = exporter$1;
	var $parseFloat = _global$4.parseFloat;
	var $trim$1 = _stringTrim$1.trim;
	var _parseFloat = 1 / $parseFloat(_stringWs$1 + "-0") !== -Infinity ? function parseFloat$1(str) {
		var string = $trim$1(String(str), 3);
		var result = $parseFloat(string);
		return result === 0 && string.charAt(0) == "-" ? -0 : result;
	} : $parseFloat;
	_export$4(_export$4.G + _export$4.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });
	var _parseFloat$2 = _core$4.parseFloat;
	const ALPHA_NUMERIC_DOT = /([0-9.]+)([a-zA-Z]+)/g;
	const TIMES = {
		ms: 1,
		millisecond: 1,
		milliseconds: 1,
		s: 1e3,
		sec: 1e3,
		secs: 1e3,
		second: 1e3,
		seconds: 1e3,
		m: 6e4,
		min: 6e4,
		mins: 6e4,
		minute: 6e4,
		minutes: 6e4,
		h: 36e5,
		hr: 36e5,
		hrs: 36e5,
		hour: 36e5,
		hours: 36e5,
		d: 864e5,
		day: 864e5,
		days: 864e5,
		w: 6048e5,
		wk: 6048e5,
		wks: 6048e5,
		week: 6048e5,
		weeks: 6048e5,
		y: 31536e6,
		yr: 31536e6,
		yrs: 31536e6,
		year: 31536e6,
		years: 31536e6
	};
	function dehumanizeTime(input) {
		if (typeof input !== "string") return NaN;
		return input.replace(/ /g, "").match(ALPHA_NUMERIC_DOT).map((part) => part.split(ALPHA_NUMERIC_DOT).filter((o) => o)).reduce((accum, [number, unit]) => {
			return accum + _parseFloat$2(number) * TIMES[unit];
		}, 0);
	}
	function isExpired(recordedOn, expiresIn) {
		if (recordedOn && expiresIn) return /* @__PURE__ */ new Date() > new Date(new Date(recordedOn).getTime() + dehumanizeTime(expiresIn));
		return false;
	}
	function ownKeys$5(object, enumerableOnly) {
		var keys$6 = keys$1$4(object);
		if (getOwnPropertySymbols$1$4) {
			var symbols = getOwnPropertySymbols$1$4(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1$4(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$5(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$5(Object(source), true).forEach(function(key$1) {
				_defineProperty$4(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1$4) defineProperties$1$4(target, getOwnPropertyDescriptors$1$4(source));
			else ownKeys$5(Object(source)).forEach(function(key$1) {
				defineProperty$2$8(target, key$1, getOwnPropertyDescriptor$1$4(source, key$1));
			});
		}
		return target;
	}
	function stringifyRequest$1(req$2, ...args) {
		const config = _objectSpread$5({}, req$2.config);
		[
			"adapter",
			"adapterOptions",
			"persister",
			"persisterOptions"
		].forEach((k$7) => delete config[k$7]);
		return stringify$1$2({
			url: req$2.url,
			method: req$2.method,
			headers: req$2.headers,
			body: req$2.body,
			recordingName: req$2.recordingName,
			id: req$2.id,
			order: req$2.order,
			identifiers: req$2.identifiers,
			config
		}, ...args);
	}
	const { isArray: isArray$5 } = Array;
	function normalizeRecordedResponse(response) {
		const { status: status$1, statusText, headers: headers$1, content } = response;
		return {
			statusText,
			statusCode: status$1,
			headers: normalizeHeaders(headers$1),
			body: content && content.text,
			encoding: content && content.encoding
		};
	}
	function normalizeHeaders(headers$1) {
		return (headers$1 || []).reduce((accum, { name, value, _fromType }) => {
			const existingValue = accum[name];
			if (existingValue) {
				if (!isArray$5(existingValue)) accum[name] = [existingValue];
				accum[name].push(value);
			} else accum[name] = _fromType === "array" ? [value] : value;
			return accum;
		}, {});
	}
	function ownKeys$1$6(object, enumerableOnly) {
		var keys$6 = keys$1$4(object);
		if (getOwnPropertySymbols$1$4) {
			var symbols = getOwnPropertySymbols$1$4(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1$4(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$1$6(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$1$6(Object(source), true).forEach(function(key$1) {
				_defineProperty$4(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1$4) defineProperties$1$4(target, getOwnPropertyDescriptors$1$4(source));
			else ownKeys$1$6(Object(source)).forEach(function(key$1) {
				defineProperty$2$8(target, key$1, getOwnPropertyDescriptor$1$4(source, key$1));
			});
		}
		return target;
	}
	const REQUEST_HANDLER = symbol$1$2();
	var Adapter$2 = class {
		constructor(polly) {
			this.polly = polly;
			this.isConnected = false;
		}
		static get type() {
			return "adapter";
		}
		static get id() {
			utils$6.assert("Must override the static `id` getter.");
		}
		get defaultOptions() {
			return {};
		}
		get options() {
			return _objectSpread$1$6(_objectSpread$1$6({}, this.defaultOptions || {}), (this.polly.config.adapterOptions || {})[this.constructor.id] || {});
		}
		get persister() {
			return this.polly.persister;
		}
		connect() {
			if (!this.isConnected) {
				this.onConnect();
				this.isConnected = true;
				this.polly.logger.log.debug(`Connected to ${this.constructor.id} adapter.`);
			}
		}
		onConnect() {
			this.assert("Must implement the `onConnect` hook.");
		}
		disconnect() {
			if (this.isConnected) {
				this.onDisconnect();
				this.isConnected = false;
				this.polly.logger.log.debug(`Disconnected from ${this.constructor.id} adapter.`);
			}
		}
		onDisconnect() {
			this.assert("Must implement the `onDisconnect` hook.");
		}
		timeout(pollyRequest, { time }) {
			const { timing } = pollyRequest.config;
			if (typeof timing === "function") return timing(time);
		}
		async handleRequest(request) {
			const pollyRequest = this.polly.registerRequest(request);
			try {
				pollyRequest.on("identify", (...args) => this.onIdentifyRequest(...args));
				await this.onRequest(pollyRequest);
				await pollyRequest.init();
				await this[REQUEST_HANDLER](pollyRequest);
				if (pollyRequest.aborted) throw new utils$6.PollyError("Request aborted.");
				await this.onRequestFinished(pollyRequest);
			} catch (error) {
				await this.onRequestFailed(pollyRequest, error);
			}
			return pollyRequest;
		}
		async [REQUEST_HANDLER](pollyRequest) {
			const { mode } = this.polly;
			const { _interceptor: interceptor } = pollyRequest;
			if (pollyRequest.aborted) return;
			if (pollyRequest.shouldIntercept) {
				await this.intercept(pollyRequest, interceptor);
				if (interceptor.shouldIntercept) return;
			}
			if (mode === utils$6.MODES.PASSTHROUGH || pollyRequest.shouldPassthrough || interceptor.shouldPassthrough) return this.passthrough(pollyRequest);
			this.assert("A persister must be configured in order to record and replay requests.", !!this.persister);
			if (mode === utils$6.MODES.RECORD) return this.record(pollyRequest);
			if (mode === utils$6.MODES.REPLAY) return this.replay(pollyRequest);
			this.assert("Unhandled request: \n" + stringifyRequest$1(pollyRequest, null, 2));
		}
		async passthrough(pollyRequest) {
			pollyRequest.action = utils$6.ACTIONS.PASSTHROUGH;
			return this.onPassthrough(pollyRequest);
		}
		/**
		* @param {PollyRequest} pollyRequest
		*/
		async onPassthrough(pollyRequest) {
			const response = await this.onFetchResponse(pollyRequest);
			await pollyRequest.respond(response);
		}
		async intercept(pollyRequest, interceptor) {
			pollyRequest.action = utils$6.ACTIONS.INTERCEPT;
			await pollyRequest._intercept(interceptor);
			if (interceptor.shouldIntercept) return this.onIntercept(pollyRequest, pollyRequest.response);
		}
		/**
		* @param {PollyRequest} pollyRequest
		* @param {PollyResponse} pollyResponse
		*/
		async onIntercept(pollyRequest, pollyResponse) {
			await pollyRequest.respond(pollyResponse);
		}
		async record(pollyRequest) {
			pollyRequest.action = utils$6.ACTIONS.RECORD;
			if ("navigator" in global && !navigator.onLine) pollyRequest.log.warn(`[Polly] Recording may fail because the browser is offline.
${stringifyRequest$1(pollyRequest)}`);
			return this.onRecord(pollyRequest);
		}
		/**
		* @param {PollyRequest} pollyRequest
		*/
		async onRecord(pollyRequest) {
			await this.onPassthrough(pollyRequest);
			if (!pollyRequest.aborted) await this.persister.recordRequest(pollyRequest);
		}
		async replay(pollyRequest) {
			const { config } = pollyRequest;
			const recordingEntry = await this.persister.findEntry(pollyRequest);
			if (recordingEntry) {
				const clonedRecordingEntry = JSON.parse(stringify$1$2(recordingEntry));
				await pollyRequest._emit("beforeReplay", clonedRecordingEntry);
				if (isExpired(clonedRecordingEntry.startedDateTime, config.expiresIn)) {
					const message = `Recording for the following request has expired.
${stringifyRequest$1(pollyRequest, null, 2)}`;
					switch (config.expiryStrategy) {
						case utils$6.EXPIRY_STRATEGIES.RECORD: return this.record(pollyRequest);
						case utils$6.EXPIRY_STRATEGIES.ERROR:
							this.assert(message);
							break;
						case utils$6.EXPIRY_STRATEGIES.WARN:
							pollyRequest.log.warn(`[Polly] ${message}`);
							break;
						default:
							this.assert(`Invalid config option passed for "expiryStrategy": "${config.expiryStrategy}"`);
							break;
					}
				}
				await this.timeout(pollyRequest, clonedRecordingEntry);
				pollyRequest.action = utils$6.ACTIONS.REPLAY;
				return this.onReplay(pollyRequest, normalizeRecordedResponse(clonedRecordingEntry.response), clonedRecordingEntry);
			}
			if (config.recordIfMissing) return this.record(pollyRequest);
			this.assert("Recording for the following request is not found and `recordIfMissing` is `false`.\n" + stringifyRequest$1(pollyRequest, null, 2));
		}
		/**
		* @param {PollyRequest} pollyRequest
		* @param {Object} normalizedResponse The normalized response generated from the recording entry
		* @param {Object} recordingEntry The entire recording entry
		*/
		async onReplay(pollyRequest, normalizedResponse) {
			await pollyRequest.respond(normalizedResponse);
		}
		assert(message, ...args) {
			utils$6.assert(`[${this.constructor.type}:${this.constructor.id}] ${message}`, ...args);
		}
		/**
		* @param {PollyRequest} pollyRequest
		*/
		onRequest() {}
		/**
		* @param {PollyRequest} pollyRequest
		*/
		async onIdentifyRequest(pollyRequest) {
			const { identifiers } = pollyRequest;
			for (const type of [
				"blob",
				"formData",
				"buffer"
			]) identifiers.body = await utils$6.Serializers[type](identifiers.body);
		}
		/**
		* @param {PollyRequest} pollyRequest
		*/
		async onRequestFinished(pollyRequest) {
			await this.onRespond(pollyRequest);
			pollyRequest.promise.resolve();
		}
		/**
		* @param {PollyRequest} pollyRequest
		* @param {Error} [error]
		*/
		async onRequestFailed(pollyRequest, error) {
			const { aborted } = pollyRequest;
			error = error || new utils$6.PollyError("Request failed due to an unknown error.");
			try {
				if (aborted) await pollyRequest._emit("abort");
				else await pollyRequest._emit("error", error);
				await this.onRespond(pollyRequest, error);
			} finally {
				pollyRequest.promise.reject(error);
			}
		}
		/**
		* Make sure the response from a Polly request is delivered to the
		* user through the adapter interface.
		*
		* Calling `pollyjs.flush()` will await this method.
		*
		* @param {PollyRequest} pollyRequest
		* @param {Error} [error]
		*/
		async onRespond() {}
		/**
		* @param {PollyRequest} pollyRequest
		* @returns {Object({ statusCode: number, headers: Object, body: string })}
		*/
		async onFetchResponse() {
			this.assert("Must implement the `onFetchResponse` hook.");
		}
	};
	module.exports = Adapter$2;
}) });

//#endregion
//#region ../../node_modules/.pnpm/@pollyjs+adapter-node-http@6.0.6/node_modules/@pollyjs/adapter-node-http/dist/cjs/pollyjs-adapter-node-http.js
var require_pollyjs_adapter_node_http = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/@pollyjs+adapter-node-http@6.0.6/node_modules/@pollyjs/adapter-node-http/dist/cjs/pollyjs-adapter-node-http.js": ((exports, module) => {
	function _interopDefault$4(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var http$5 = _interopDefault$4(__require("http"));
	var https = _interopDefault$4(__require("https"));
	var url$2 = __require("url");
	var url__default = _interopDefault$4(url$2);
	var stream$1 = __require("stream");
	var nock = _interopDefault$4(require_nock());
	var tty$1 = _interopDefault$4(__require("tty"));
	var util$5 = _interopDefault$4(__require("util"));
	var os = _interopDefault$4(__require("os"));
	var timers = _interopDefault$4(__require("timers"));
	var Adapter$1 = _interopDefault$4(require_pollyjs_adapter());
	var utils$5 = require_pollyjs_utils();
	var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
	function unwrapExports$3(x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
	}
	function createCommonjsModule$3(fn, module$2) {
		return module$2 = { exports: {} }, fn(module$2, module$2.exports), module$2.exports;
	}
	var _global$3 = createCommonjsModule$3(function(module$2) {
		var global$1 = module$2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
		if (typeof __g == "number") __g = global$1;
	});
	var hasOwnProperty$7 = {}.hasOwnProperty;
	var _has$3 = function(it, key$1) {
		return hasOwnProperty$7.call(it, key$1);
	};
	var _fails$3 = function(exec) {
		try {
			return !!exec();
		} catch (e) {
			return true;
		}
	};
	var _descriptors$3 = !_fails$3(function() {
		return Object.defineProperty({}, "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var _core$3 = createCommonjsModule$3(function(module$2) {
		var core = module$2.exports = { version: "2.6.9" };
		if (typeof __e == "number") __e = core;
	});
	_core$3.version;
	var _aFunction$3 = function(it) {
		if (typeof it != "function") throw TypeError(it + " is not a function!");
		return it;
	};
	var _ctx$3 = function(fn, that, length) {
		_aFunction$3(fn);
		if (that === void 0) return fn;
		switch (length) {
			case 1: return function(a) {
				return fn.call(that, a);
			};
			case 2: return function(a, b) {
				return fn.call(that, a, b);
			};
			case 3: return function(a, b, c) {
				return fn.call(that, a, b, c);
			};
		}
		return function() {
			return fn.apply(that, arguments);
		};
	};
	var _isObject$3 = function(it) {
		return typeof it === "object" ? it !== null : typeof it === "function";
	};
	var _anObject$3 = function(it) {
		if (!_isObject$3(it)) throw TypeError(it + " is not an object!");
		return it;
	};
	var document$1$4 = _global$3.document;
	var is$4 = _isObject$3(document$1$4) && _isObject$3(document$1$4.createElement);
	var _domCreate$3 = function(it) {
		return is$4 ? document$1$4.createElement(it) : {};
	};
	var _ie8DomDefine$3 = !_descriptors$3 && !_fails$3(function() {
		return Object.defineProperty(_domCreate$3("div"), "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var _toPrimitive$3 = function(it, S) {
		if (!_isObject$3(it)) return it;
		var fn, val;
		if (S && typeof (fn = it.toString) == "function" && !_isObject$3(val = fn.call(it))) return val;
		if (typeof (fn = it.valueOf) == "function" && !_isObject$3(val = fn.call(it))) return val;
		if (!S && typeof (fn = it.toString) == "function" && !_isObject$3(val = fn.call(it))) return val;
		throw TypeError("Can't convert object to primitive value");
	};
	var dP$6 = Object.defineProperty;
	var _objectDp$3 = { f: _descriptors$3 ? Object.defineProperty : function defineProperty$8(O, P, Attributes) {
		_anObject$3(O);
		P = _toPrimitive$3(P, true);
		_anObject$3(Attributes);
		if (_ie8DomDefine$3) try {
			return dP$6(O, P, Attributes);
		} catch (e) {}
		if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
		if ("value" in Attributes) O[P] = Attributes.value;
		return O;
	} };
	var _propertyDesc$3 = function(bitmap, value) {
		return {
			enumerable: !(bitmap & 1),
			configurable: !(bitmap & 2),
			writable: !(bitmap & 4),
			value
		};
	};
	var _hide$3 = _descriptors$3 ? function(object, key$1, value) {
		return _objectDp$3.f(object, key$1, _propertyDesc$3(1, value));
	} : function(object, key$1, value) {
		object[key$1] = value;
		return object;
	};
	var PROTOTYPE$7 = "prototype";
	var $export$3 = function(type, name, source) {
		var IS_FORCED = type & $export$3.F;
		var IS_GLOBAL = type & $export$3.G;
		var IS_STATIC = type & $export$3.S;
		var IS_PROTO = type & $export$3.P;
		var IS_BIND = type & $export$3.B;
		var IS_WRAP = type & $export$3.W;
		var exports$1 = IS_GLOBAL ? _core$3 : _core$3[name] || (_core$3[name] = {});
		var expProto = exports$1[PROTOTYPE$7];
		var target = IS_GLOBAL ? _global$3 : IS_STATIC ? _global$3[name] : (_global$3[name] || {})[PROTOTYPE$7];
		var key$1, own, out;
		if (IS_GLOBAL) source = name;
		for (key$1 in source) {
			own = !IS_FORCED && target && target[key$1] !== void 0;
			if (own && _has$3(exports$1, key$1)) continue;
			out = own ? target[key$1] : source[key$1];
			exports$1[key$1] = IS_GLOBAL && typeof target[key$1] != "function" ? source[key$1] : IS_BIND && own ? _ctx$3(out, _global$3) : IS_WRAP && target[key$1] == out ? (function(C) {
				var F = function(a, b, c) {
					if (this instanceof C) {
						switch (arguments.length) {
							case 0: return new C();
							case 1: return new C(a);
							case 2: return new C(a, b);
						}
						return new C(a, b, c);
					}
					return C.apply(this, arguments);
				};
				F[PROTOTYPE$7] = C[PROTOTYPE$7];
				return F;
			})(out) : IS_PROTO && typeof out == "function" ? _ctx$3(Function.call, out) : out;
			if (IS_PROTO) {
				(exports$1.virtual || (exports$1.virtual = {}))[key$1] = out;
				if (type & $export$3.R && expProto && !expProto[key$1]) _hide$3(expProto, key$1, out);
			}
		}
	};
	$export$3.F = 1;
	$export$3.G = 2;
	$export$3.S = 4;
	$export$3.P = 8;
	$export$3.B = 16;
	$export$3.W = 32;
	$export$3.U = 64;
	$export$3.R = 128;
	var _export$3 = $export$3;
	var _redefine$3 = _hide$3;
	var id$3 = 0;
	var px$3 = Math.random();
	var _uid$3 = function(key$1) {
		return "Symbol(".concat(key$1 === void 0 ? "" : key$1, ")_", (++id$3 + px$3).toString(36));
	};
	var _meta$3 = createCommonjsModule$3(function(module$2) {
		var META$7 = _uid$3("meta");
		var setDesc = _objectDp$3.f;
		var id$7 = 0;
		var isExtensible = Object.isExtensible || function() {
			return true;
		};
		var FREEZE = !_fails$3(function() {
			return isExtensible(Object.preventExtensions({}));
		});
		var setMeta = function(it) {
			setDesc(it, META$7, { value: {
				i: "O" + ++id$7,
				w: {}
			} });
		};
		var fastKey$2 = function(it, create) {
			if (!_isObject$3(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
			if (!_has$3(it, META$7)) {
				if (!isExtensible(it)) return "F";
				if (!create) return "E";
				setMeta(it);
			}
			return it[META$7].i;
		};
		var getWeak$2 = function(it, create) {
			if (!_has$3(it, META$7)) {
				if (!isExtensible(it)) return true;
				if (!create) return false;
				setMeta(it);
			}
			return it[META$7].w;
		};
		var onFreeze = function(it) {
			if (FREEZE && meta.NEED && isExtensible(it) && !_has$3(it, META$7)) setMeta(it);
			return it;
		};
		var meta = module$2.exports = {
			KEY: META$7,
			NEED: false,
			fastKey: fastKey$2,
			getWeak: getWeak$2,
			onFreeze
		};
	});
	_meta$3.KEY;
	_meta$3.NEED;
	_meta$3.fastKey;
	_meta$3.getWeak;
	_meta$3.onFreeze;
	var _library$3 = true;
	var _shared$3 = createCommonjsModule$3(function(module$2) {
		var SHARED = "__core-js_shared__";
		var store = _global$3[SHARED] || (_global$3[SHARED] = {});
		(module$2.exports = function(key$1, value) {
			return store[key$1] || (store[key$1] = value !== void 0 ? value : {});
		})("versions", []).push({
			version: _core$3.version,
			mode: "pure",
			copyright: " 2019 Denis Pushkarev (zloirock.ru)"
		});
	});
	var _wks$3 = createCommonjsModule$3(function(module$2) {
		var store = _shared$3("wks");
		var Symbol$2 = _global$3.Symbol;
		var USE_SYMBOL = typeof Symbol$2 == "function";
		var $exports = module$2.exports = function(name) {
			return store[name] || (store[name] = USE_SYMBOL && Symbol$2[name] || (USE_SYMBOL ? Symbol$2 : _uid$3)("Symbol." + name));
		};
		$exports.store = store;
	});
	var def$3 = _objectDp$3.f;
	var TAG$3 = _wks$3("toStringTag");
	var _setToStringTag$3 = function(it, tag, stat$4) {
		if (it && !_has$3(it = stat$4 ? it : it.prototype, TAG$3)) def$3(it, TAG$3, {
			configurable: true,
			value: tag
		});
	};
	var _wksExt$3 = { f: _wks$3 };
	var defineProperty$5 = _objectDp$3.f;
	var _wksDefine$3 = function(name) {
		var $Symbol$7 = _core$3.Symbol || (_core$3.Symbol = {});
		if (name.charAt(0) != "_" && !(name in $Symbol$7)) defineProperty$5($Symbol$7, name, { value: _wksExt$3.f(name) });
	};
	var toString$6 = {}.toString;
	var _cof$3 = function(it) {
		return toString$6.call(it).slice(8, -1);
	};
	var _iobject$3 = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
		return _cof$3(it) == "String" ? it.split("") : Object(it);
	};
	var _defined$3 = function(it) {
		if (it == void 0) throw TypeError("Can't call method on  " + it);
		return it;
	};
	var _toIobject$3 = function(it) {
		return _iobject$3(_defined$3(it));
	};
	var ceil$3 = Math.ceil;
	var floor$3 = Math.floor;
	var _toInteger$3 = function(it) {
		return isNaN(it = +it) ? 0 : (it > 0 ? floor$3 : ceil$3)(it);
	};
	var min$3 = Math.min;
	var _toLength$3 = function(it) {
		return it > 0 ? min$3(_toInteger$3(it), 9007199254740991) : 0;
	};
	var max$3 = Math.max;
	var min$1$6 = Math.min;
	var _toAbsoluteIndex$3 = function(index$1, length) {
		index$1 = _toInteger$3(index$1);
		return index$1 < 0 ? max$3(index$1 + length, 0) : min$1$6(index$1, length);
	};
	var _arrayIncludes$3 = function(IS_INCLUDES) {
		return function($this, el, fromIndex) {
			var O = _toIobject$3($this);
			var length = _toLength$3(O.length);
			var index$1 = _toAbsoluteIndex$3(fromIndex, length);
			var value;
			if (IS_INCLUDES && el != el) while (length > index$1) {
				value = O[index$1++];
				if (value != value) return true;
			}
			else for (; length > index$1; index$1++) if (IS_INCLUDES || index$1 in O) {
				if (O[index$1] === el) return IS_INCLUDES || index$1 || 0;
			}
			return !IS_INCLUDES && -1;
		};
	};
	var shared$3 = _shared$3("keys");
	var _sharedKey$3 = function(key$1) {
		return shared$3[key$1] || (shared$3[key$1] = _uid$3(key$1));
	};
	var arrayIndexOf$3 = _arrayIncludes$3(false);
	var IE_PROTO$5 = _sharedKey$3("IE_PROTO");
	var _objectKeysInternal$3 = function(object, names) {
		var O = _toIobject$3(object);
		var i$8 = 0;
		var result = [];
		var key$1;
		for (key$1 in O) if (key$1 != IE_PROTO$5) _has$3(O, key$1) && result.push(key$1);
		while (names.length > i$8) if (_has$3(O, key$1 = names[i$8++])) ~arrayIndexOf$3(result, key$1) || result.push(key$1);
		return result;
	};
	var _enumBugKeys$3 = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
	var _objectKeys$3 = Object.keys || function keys$6(O) {
		return _objectKeysInternal$3(O, _enumBugKeys$3);
	};
	var _objectGops$3 = { f: Object.getOwnPropertySymbols };
	var _objectPie$3 = { f: {}.propertyIsEnumerable };
	var _enumKeys$3 = function(it) {
		var result = _objectKeys$3(it);
		var getSymbols = _objectGops$3.f;
		if (getSymbols) {
			var symbols = getSymbols(it);
			var isEnum$7 = _objectPie$3.f;
			var i$8 = 0;
			var key$1;
			while (symbols.length > i$8) if (isEnum$7.call(it, key$1 = symbols[i$8++])) result.push(key$1);
		}
		return result;
	};
	var _isArray$3 = Array.isArray || function isArray$11(arg) {
		return _cof$3(arg) == "Array";
	};
	var _toObject$3 = function(it) {
		return Object(_defined$3(it));
	};
	var _objectDps$3 = _descriptors$3 ? Object.defineProperties : function defineProperties(O, Properties) {
		_anObject$3(O);
		var keys$6 = _objectKeys$3(Properties);
		var length = keys$6.length;
		var i$8 = 0;
		var P;
		while (length > i$8) _objectDp$3.f(O, P = keys$6[i$8++], Properties[P]);
		return O;
	};
	var document$2$2 = _global$3.document;
	var _html$3 = document$2$2 && document$2$2.documentElement;
	var IE_PROTO$1$6 = _sharedKey$3("IE_PROTO");
	var Empty$3 = function() {};
	var PROTOTYPE$1$8 = "prototype";
	var createDict$3 = function() {
		var iframe = _domCreate$3("iframe");
		var i$8 = _enumBugKeys$3.length;
		var lt = "<";
		var gt = ">";
		var iframeDocument;
		iframe.style.display = "none";
		_html$3.appendChild(iframe);
		iframe.src = "javascript:";
		iframeDocument = iframe.contentWindow.document;
		iframeDocument.open();
		iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
		iframeDocument.close();
		createDict$3 = iframeDocument.F;
		while (i$8--) delete createDict$3[PROTOTYPE$1$8][_enumBugKeys$3[i$8]];
		return createDict$3();
	};
	var _objectCreate$3 = Object.create || function create(O, Properties) {
		var result;
		if (O !== null) {
			Empty$3[PROTOTYPE$1$8] = _anObject$3(O);
			result = new Empty$3();
			Empty$3[PROTOTYPE$1$8] = null;
			result[IE_PROTO$1$6] = O;
		} else result = createDict$3();
		return Properties === void 0 ? result : _objectDps$3(result, Properties);
	};
	var hiddenKeys$3 = _enumBugKeys$3.concat("length", "prototype");
	var _objectGopn$3 = { f: Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		return _objectKeysInternal$3(O, hiddenKeys$3);
	} };
	var gOPN$3 = _objectGopn$3.f;
	var toString$1$9 = {}.toString;
	var windowNames$3 = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
	var getWindowNames$3 = function(it) {
		try {
			return gOPN$3(it);
		} catch (e) {
			return windowNames$3.slice();
		}
	};
	var _objectGopnExt$3 = { f: function getOwnPropertyNames(it) {
		return windowNames$3 && toString$1$9.call(it) == "[object Window]" ? getWindowNames$3(it) : gOPN$3(_toIobject$3(it));
	} };
	var gOPD$3 = Object.getOwnPropertyDescriptor;
	var _objectGopd$3 = { f: _descriptors$3 ? gOPD$3 : function getOwnPropertyDescriptor(O, P) {
		O = _toIobject$3(O);
		P = _toPrimitive$3(P, true);
		if (_ie8DomDefine$3) try {
			return gOPD$3(O, P);
		} catch (e) {}
		if (_has$3(O, P)) return _propertyDesc$3(!_objectPie$3.f.call(O, P), O[P]);
	} };
	var META$3 = _meta$3.KEY;
	var gOPD$1$6 = _objectGopd$3.f;
	var dP$1$7 = _objectDp$3.f;
	var gOPN$1$6 = _objectGopnExt$3.f;
	var $Symbol$3 = _global$3.Symbol;
	var $JSON$3 = _global$3.JSON;
	var _stringify$3 = $JSON$3 && $JSON$3.stringify;
	var PROTOTYPE$2$6 = "prototype";
	var HIDDEN$3 = _wks$3("_hidden");
	var TO_PRIMITIVE$3 = _wks$3("toPrimitive");
	var isEnum$3 = {}.propertyIsEnumerable;
	var SymbolRegistry$3 = _shared$3("symbol-registry");
	var AllSymbols$3 = _shared$3("symbols");
	var OPSymbols$3 = _shared$3("op-symbols");
	var ObjectProto$3 = Object[PROTOTYPE$2$6];
	var USE_NATIVE$3 = typeof $Symbol$3 == "function" && !!_objectGops$3.f;
	var QObject$3 = _global$3.QObject;
	var setter$3 = !QObject$3 || !QObject$3[PROTOTYPE$2$6] || !QObject$3[PROTOTYPE$2$6].findChild;
	var setSymbolDesc$3 = _descriptors$3 && _fails$3(function() {
		return _objectCreate$3(dP$1$7({}, "a", { get: function() {
			return dP$1$7(this, "a", { value: 7 }).a;
		} })).a != 7;
	}) ? function(it, key$1, D) {
		var protoDesc = gOPD$1$6(ObjectProto$3, key$1);
		if (protoDesc) delete ObjectProto$3[key$1];
		dP$1$7(it, key$1, D);
		if (protoDesc && it !== ObjectProto$3) dP$1$7(ObjectProto$3, key$1, protoDesc);
	} : dP$1$7;
	var wrap$6 = function(tag) {
		var sym = AllSymbols$3[tag] = _objectCreate$3($Symbol$3[PROTOTYPE$2$6]);
		sym._k = tag;
		return sym;
	};
	var isSymbol$3 = USE_NATIVE$3 && typeof $Symbol$3.iterator == "symbol" ? function(it) {
		return typeof it == "symbol";
	} : function(it) {
		return it instanceof $Symbol$3;
	};
	var $defineProperty$3 = function defineProperty$8(it, key$1, D) {
		if (it === ObjectProto$3) $defineProperty$3(OPSymbols$3, key$1, D);
		_anObject$3(it);
		key$1 = _toPrimitive$3(key$1, true);
		_anObject$3(D);
		if (_has$3(AllSymbols$3, key$1)) {
			if (!D.enumerable) {
				if (!_has$3(it, HIDDEN$3)) dP$1$7(it, HIDDEN$3, _propertyDesc$3(1, {}));
				it[HIDDEN$3][key$1] = true;
			} else {
				if (_has$3(it, HIDDEN$3) && it[HIDDEN$3][key$1]) it[HIDDEN$3][key$1] = false;
				D = _objectCreate$3(D, { enumerable: _propertyDesc$3(0, false) });
			}
			return setSymbolDesc$3(it, key$1, D);
		}
		return dP$1$7(it, key$1, D);
	};
	var $defineProperties$3 = function defineProperties(it, P) {
		_anObject$3(it);
		var keys$6 = _enumKeys$3(P = _toIobject$3(P));
		var i$8 = 0;
		var l = keys$6.length;
		var key$1;
		while (l > i$8) $defineProperty$3(it, key$1 = keys$6[i$8++], P[key$1]);
		return it;
	};
	var $create$3 = function create(it, P) {
		return P === void 0 ? _objectCreate$3(it) : $defineProperties$3(_objectCreate$3(it), P);
	};
	var $propertyIsEnumerable$3 = function propertyIsEnumerable$1(key$1) {
		var E = isEnum$3.call(this, key$1 = _toPrimitive$3(key$1, true));
		if (this === ObjectProto$3 && _has$3(AllSymbols$3, key$1) && !_has$3(OPSymbols$3, key$1)) return false;
		return E || !_has$3(this, key$1) || !_has$3(AllSymbols$3, key$1) || _has$3(this, HIDDEN$3) && this[HIDDEN$3][key$1] ? E : true;
	};
	var $getOwnPropertyDescriptor$3 = function getOwnPropertyDescriptor(it, key$1) {
		it = _toIobject$3(it);
		key$1 = _toPrimitive$3(key$1, true);
		if (it === ObjectProto$3 && _has$3(AllSymbols$3, key$1) && !_has$3(OPSymbols$3, key$1)) return;
		var D = gOPD$1$6(it, key$1);
		if (D && _has$3(AllSymbols$3, key$1) && !(_has$3(it, HIDDEN$3) && it[HIDDEN$3][key$1])) D.enumerable = true;
		return D;
	};
	var $getOwnPropertyNames$3 = function getOwnPropertyNames(it) {
		var names = gOPN$1$6(_toIobject$3(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (!_has$3(AllSymbols$3, key$1 = names[i$8++]) && key$1 != HIDDEN$3 && key$1 != META$3) result.push(key$1);
		return result;
	};
	var $getOwnPropertySymbols$3 = function getOwnPropertySymbols$2(it) {
		var IS_OP = it === ObjectProto$3;
		var names = gOPN$1$6(IS_OP ? OPSymbols$3 : _toIobject$3(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (_has$3(AllSymbols$3, key$1 = names[i$8++]) && (IS_OP ? _has$3(ObjectProto$3, key$1) : true)) result.push(AllSymbols$3[key$1]);
		return result;
	};
	if (!USE_NATIVE$3) {
		$Symbol$3 = function Symbol$2() {
			if (this instanceof $Symbol$3) throw TypeError("Symbol is not a constructor!");
			var tag = _uid$3(arguments.length > 0 ? arguments[0] : void 0);
			var $set = function(value) {
				if (this === ObjectProto$3) $set.call(OPSymbols$3, value);
				if (_has$3(this, HIDDEN$3) && _has$3(this[HIDDEN$3], tag)) this[HIDDEN$3][tag] = false;
				setSymbolDesc$3(this, tag, _propertyDesc$3(1, value));
			};
			if (_descriptors$3 && setter$3) setSymbolDesc$3(ObjectProto$3, tag, {
				configurable: true,
				set: $set
			});
			return wrap$6(tag);
		};
		_redefine$3($Symbol$3[PROTOTYPE$2$6], "toString", function toString$11() {
			return this._k;
		});
		_objectGopd$3.f = $getOwnPropertyDescriptor$3;
		_objectDp$3.f = $defineProperty$3;
		_objectGopn$3.f = _objectGopnExt$3.f = $getOwnPropertyNames$3;
		_objectPie$3.f = $propertyIsEnumerable$3;
		_objectGops$3.f = $getOwnPropertySymbols$3;
		if (_descriptors$3 && !_library$3) _redefine$3(ObjectProto$3, "propertyIsEnumerable", $propertyIsEnumerable$3, true);
		_wksExt$3.f = function(name) {
			return wrap$6(_wks$3(name));
		};
	}
	_export$3(_export$3.G + _export$3.W + _export$3.F * !USE_NATIVE$3, { Symbol: $Symbol$3 });
	for (var es6Symbols$3 = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j$3 = 0; es6Symbols$3.length > j$3;) _wks$3(es6Symbols$3[j$3++]);
	for (var wellKnownSymbols$3 = _objectKeys$3(_wks$3.store), k$3 = 0; wellKnownSymbols$3.length > k$3;) _wksDefine$3(wellKnownSymbols$3[k$3++]);
	_export$3(_export$3.S + _export$3.F * !USE_NATIVE$3, "Symbol", {
		"for": function(key$1) {
			return _has$3(SymbolRegistry$3, key$1 += "") ? SymbolRegistry$3[key$1] : SymbolRegistry$3[key$1] = $Symbol$3(key$1);
		},
		keyFor: function keyFor$1(sym) {
			if (!isSymbol$3(sym)) throw TypeError(sym + " is not a symbol!");
			for (var key$1 in SymbolRegistry$3) if (SymbolRegistry$3[key$1] === sym) return key$1;
		},
		useSetter: function() {
			setter$3 = true;
		},
		useSimple: function() {
			setter$3 = false;
		}
	});
	_export$3(_export$3.S + _export$3.F * !USE_NATIVE$3, "Object", {
		create: $create$3,
		defineProperty: $defineProperty$3,
		defineProperties: $defineProperties$3,
		getOwnPropertyDescriptor: $getOwnPropertyDescriptor$3,
		getOwnPropertyNames: $getOwnPropertyNames$3,
		getOwnPropertySymbols: $getOwnPropertySymbols$3
	});
	var FAILS_ON_PRIMITIVES$3 = _fails$3(function() {
		_objectGops$3.f(1);
	});
	_export$3(_export$3.S + _export$3.F * FAILS_ON_PRIMITIVES$3, "Object", { getOwnPropertySymbols: function getOwnPropertySymbols$2(it) {
		return _objectGops$3.f(_toObject$3(it));
	} });
	$JSON$3 && _export$3(_export$3.S + _export$3.F * (!USE_NATIVE$3 || _fails$3(function() {
		var S = $Symbol$3();
		return _stringify$3([S]) != "[null]" || _stringify$3({ a: S }) != "{}" || _stringify$3(Object(S)) != "{}";
	})), "JSON", { stringify: function stringify$14(it) {
		var args = [it];
		var i$8 = 1;
		var replacer, $replacer;
		while (arguments.length > i$8) args.push(arguments[i$8++]);
		$replacer = replacer = args[1];
		if (!_isObject$3(replacer) && it === void 0 || isSymbol$3(it)) return;
		if (!_isArray$3(replacer)) replacer = function(key$1, value) {
			if (typeof $replacer == "function") value = $replacer.call(this, key$1, value);
			if (!isSymbol$3(value)) return value;
		};
		args[1] = replacer;
		return _stringify$3.apply($JSON$3, args);
	} });
	$Symbol$3[PROTOTYPE$2$6][TO_PRIMITIVE$3] || _hide$3($Symbol$3[PROTOTYPE$2$6], TO_PRIMITIVE$3, $Symbol$3[PROTOTYPE$2$6].valueOf);
	_setToStringTag$3($Symbol$3, "Symbol");
	_setToStringTag$3(Math, "Math", true);
	_setToStringTag$3(_global$3.JSON, "JSON", true);
	var getOwnPropertySymbols$1$3 = _core$3.Object.getOwnPropertySymbols;
	var _objectSap$3 = function(KEY, exec) {
		var fn = (_core$3.Object || {})[KEY] || Object[KEY];
		var exp = {};
		exp[KEY] = exec(fn);
		_export$3(_export$3.S + _export$3.F * _fails$3(function() {
			fn(1);
		}), "Object", exp);
	};
	var $getOwnPropertyDescriptor$1$6 = _objectGopd$3.f;
	_objectSap$3("getOwnPropertyDescriptor", function() {
		return function getOwnPropertyDescriptor(it, key$1) {
			return $getOwnPropertyDescriptor$1$6(_toIobject$3(it), key$1);
		};
	});
	var $Object$7 = _core$3.Object;
	var getOwnPropertyDescriptor$1$3 = function getOwnPropertyDescriptor(it, key$1) {
		return $Object$7.getOwnPropertyDescriptor(it, key$1);
	};
	var Reflect$4 = _global$3.Reflect;
	var _ownKeys$3 = Reflect$4 && Reflect$4.ownKeys || function ownKeys$8(it) {
		var keys$6 = _objectGopn$3.f(_anObject$3(it));
		var getSymbols = _objectGops$3.f;
		return getSymbols ? keys$6.concat(getSymbols(it)) : keys$6;
	};
	var _createProperty$3 = function(object, index$1, value) {
		if (index$1 in object) _objectDp$3.f(object, index$1, _propertyDesc$3(0, value));
		else object[index$1] = value;
	};
	_export$3(_export$3.S, "Object", { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
		var O = _toIobject$3(object);
		var getDesc = _objectGopd$3.f;
		var keys$6 = _ownKeys$3(O);
		var result = {};
		var i$8 = 0;
		var key$1, desc$1;
		while (keys$6.length > i$8) {
			desc$1 = getDesc(O, key$1 = keys$6[i$8++]);
			if (desc$1 !== void 0) _createProperty$3(result, key$1, desc$1);
		}
		return result;
	} });
	var getOwnPropertyDescriptors$1$3 = _core$3.Object.getOwnPropertyDescriptors;
	_export$3(_export$3.S + _export$3.F * !_descriptors$3, "Object", { defineProperties: _objectDps$3 });
	var $Object$1$8 = _core$3.Object;
	var defineProperties$1$3 = function defineProperties(T, D) {
		return $Object$1$8.defineProperties(T, D);
	};
	_export$3(_export$3.S + _export$3.F * !_descriptors$3, "Object", { defineProperty: _objectDp$3.f });
	var $Object$2$6 = _core$3.Object;
	var defineProperty$2$6 = function defineProperty$8(it, key$1, desc$1) {
		return $Object$2$6.defineProperty(it, key$1, desc$1);
	};
	var _defineProperty$3 = unwrapExports$3(createCommonjsModule$3(function(module$2) {
		function _defineProperty$7(obj, key$1, value) {
			if (key$1 in obj) defineProperty$2$6(obj, key$1, {
				value,
				enumerable: true,
				configurable: true,
				writable: true
			});
			else obj[key$1] = value;
			return obj;
		}
		module$2.exports = _defineProperty$7;
		module$2.exports["default"] = module$2.exports, module$2.exports.__esModule = true;
	}));
	_wksDefine$3("asyncIterator");
	_wksDefine$3("observable");
	var symbol$1$1 = _core$3.Symbol;
	var _iterStep$2 = function(done, value) {
		return {
			value,
			done: !!done
		};
	};
	var _iterators$2 = {};
	var IteratorPrototype$2 = {};
	_hide$3(IteratorPrototype$2, _wks$3("iterator"), function() {
		return this;
	});
	var _iterCreate$2 = function(Constructor, NAME$5, next) {
		Constructor.prototype = _objectCreate$3(IteratorPrototype$2, { next: _propertyDesc$3(1, next) });
		_setToStringTag$3(Constructor, NAME$5 + " Iterator");
	};
	var IE_PROTO$2$5 = _sharedKey$3("IE_PROTO");
	var ObjectProto$1$3 = Object.prototype;
	var _objectGpo$2 = Object.getPrototypeOf || function(O) {
		O = _toObject$3(O);
		if (_has$3(O, IE_PROTO$2$5)) return O[IE_PROTO$2$5];
		if (typeof O.constructor == "function" && O instanceof O.constructor) return O.constructor.prototype;
		return O instanceof Object ? ObjectProto$1$3 : null;
	};
	var ITERATOR$6 = _wks$3("iterator");
	var BUGGY$2 = !([].keys && "next" in [].keys());
	var FF_ITERATOR$2 = "@@iterator";
	var KEYS$2 = "keys";
	var VALUES$2 = "values";
	var returnThis$2 = function() {
		return this;
	};
	var _iterDefine$2 = function(Base, NAME$5, Constructor, next, DEFAULT, IS_SET, FORCED) {
		_iterCreate$2(Constructor, NAME$5, next);
		var getMethod$1 = function(kind) {
			if (!BUGGY$2 && kind in proto$7) return proto$7[kind];
			switch (kind) {
				case KEYS$2: return function keys$6() {
					return new Constructor(this, kind);
				};
				case VALUES$2: return function values() {
					return new Constructor(this, kind);
				};
			}
			return function entries() {
				return new Constructor(this, kind);
			};
		};
		var TAG$7 = NAME$5 + " Iterator";
		var DEF_VALUES = DEFAULT == VALUES$2;
		var VALUES_BUG = false;
		var proto$7 = Base.prototype;
		var $native = proto$7[ITERATOR$6] || proto$7[FF_ITERATOR$2] || DEFAULT && proto$7[DEFAULT];
		var $default = $native || getMethod$1(DEFAULT);
		var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod$1("entries") : void 0;
		var $anyNative = NAME$5 == "Array" ? proto$7.entries || $native : $native;
		var methods$3, key$1, IteratorPrototype$5;
		if ($anyNative) {
			IteratorPrototype$5 = _objectGpo$2($anyNative.call(new Base()));
			if (IteratorPrototype$5 !== Object.prototype && IteratorPrototype$5.next) _setToStringTag$3(IteratorPrototype$5, TAG$7, true);
		}
		if (DEF_VALUES && $native && $native.name !== VALUES$2) {
			VALUES_BUG = true;
			$default = function values() {
				return $native.call(this);
			};
		}
		if (FORCED && (BUGGY$2 || VALUES_BUG || !proto$7[ITERATOR$6])) _hide$3(proto$7, ITERATOR$6, $default);
		_iterators$2[NAME$5] = $default;
		_iterators$2[TAG$7] = returnThis$2;
		if (DEFAULT) {
			methods$3 = {
				values: DEF_VALUES ? $default : getMethod$1(VALUES$2),
				keys: IS_SET ? $default : getMethod$1(KEYS$2),
				entries: $entries
			};
			if (FORCED) {
				for (key$1 in methods$3) if (!(key$1 in proto$7)) _redefine$3(proto$7, key$1, methods$3[key$1]);
			} else _export$3(_export$3.P + _export$3.F * (BUGGY$2 || VALUES_BUG), NAME$5, methods$3);
		}
		return methods$3;
	};
	_iterDefine$2(Array, "Array", function(iterated, kind) {
		this._t = _toIobject$3(iterated);
		this._i = 0;
		this._k = kind;
	}, function() {
		var O = this._t;
		var kind = this._k;
		var index$1 = this._i++;
		if (!O || index$1 >= O.length) {
			this._t = void 0;
			return _iterStep$2(1);
		}
		if (kind == "keys") return _iterStep$2(0, index$1);
		if (kind == "values") return _iterStep$2(0, O[index$1]);
		return _iterStep$2(0, [index$1, O[index$1]]);
	}, "values");
	_iterators$2.Arguments = _iterators$2.Array;
	var TO_STRING_TAG$2 = _wks$3("toStringTag");
	var DOMIterables$2 = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
	for (var i$5 = 0; i$5 < DOMIterables$2.length; i$5++) {
		var NAME$2 = DOMIterables$2[i$5];
		var Collection$2 = _global$3[NAME$2];
		var proto$4 = Collection$2 && Collection$2.prototype;
		if (proto$4 && !proto$4[TO_STRING_TAG$2]) _hide$3(proto$4, TO_STRING_TAG$2, NAME$2);
		_iterators$2[NAME$2] = _iterators$2.Array;
	}
	var SPECIES$5 = _wks$3("species");
	var _arraySpeciesConstructor$1 = function(original) {
		var C;
		if (_isArray$3(original)) {
			C = original.constructor;
			if (typeof C == "function" && (C === Array || _isArray$3(C.prototype))) C = void 0;
			if (_isObject$3(C)) {
				C = C[SPECIES$5];
				if (C === null) C = void 0;
			}
		}
		return C === void 0 ? Array : C;
	};
	var _arraySpeciesCreate$1 = function(original, length) {
		return new (_arraySpeciesConstructor$1(original))(length);
	};
	var _arrayMethods$1 = function(TYPE, $create$7) {
		var IS_MAP = TYPE == 1;
		var IS_FILTER = TYPE == 2;
		var IS_SOME = TYPE == 3;
		var IS_EVERY = TYPE == 4;
		var IS_FIND_INDEX = TYPE == 6;
		var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
		var create = $create$7 || _arraySpeciesCreate$1;
		return function($this, callbackfn, that) {
			var O = _toObject$3($this);
			var self$1 = _iobject$3(O);
			var f = _ctx$3(callbackfn, that, 3);
			var length = _toLength$3(self$1.length);
			var index$1 = 0;
			var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
			var val, res$2;
			for (; length > index$1; index$1++) if (NO_HOLES || index$1 in self$1) {
				val = self$1[index$1];
				res$2 = f(val, index$1, O);
				if (TYPE) {
					if (IS_MAP) result[index$1] = res$2;
					else if (res$2) switch (TYPE) {
						case 3: return true;
						case 5: return val;
						case 6: return index$1;
						case 2: result.push(val);
					}
					else if (IS_EVERY) return false;
				}
			}
			return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
		};
	};
	var $assign$1 = Object.assign;
	var _objectAssign$1 = !$assign$1 || _fails$3(function() {
		var A = {};
		var B = {};
		var S = Symbol();
		var K = "abcdefghijklmnopqrst";
		A[S] = 7;
		K.split("").forEach(function(k$7) {
			B[k$7] = k$7;
		});
		return $assign$1({}, A)[S] != 7 || Object.keys($assign$1({}, B)).join("") != K;
	}) ? function assign$3(target, source) {
		var T = _toObject$3(target);
		var aLen = arguments.length;
		var index$1 = 1;
		var getSymbols = _objectGops$3.f;
		var isEnum$7 = _objectPie$3.f;
		while (aLen > index$1) {
			var S = _iobject$3(arguments[index$1++]);
			var keys$6 = getSymbols ? _objectKeys$3(S).concat(getSymbols(S)) : _objectKeys$3(S);
			var length = keys$6.length;
			var j$7 = 0;
			var key$1;
			while (length > j$7) {
				key$1 = keys$6[j$7++];
				if (!_descriptors$3 || isEnum$7.call(S, key$1)) T[key$1] = S[key$1];
			}
		}
		return T;
	} : $assign$1;
	var _redefineAll$2 = function(target, src$1, safe) {
		for (var key$1 in src$1) if (safe && target[key$1]) target[key$1] = src$1[key$1];
		else _hide$3(target, key$1, src$1[key$1]);
		return target;
	};
	var _anInstance$2 = function(it, Constructor, name, forbiddenField) {
		if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) throw TypeError(name + ": incorrect invocation!");
		return it;
	};
	var _iterCall$2 = function(iterator, fn, value, entries) {
		try {
			return entries ? fn(_anObject$3(value)[0], value[1]) : fn(value);
		} catch (e) {
			var ret = iterator["return"];
			if (ret !== void 0) _anObject$3(ret.call(iterator));
			throw e;
		}
	};
	var ITERATOR$1$7 = _wks$3("iterator");
	var ArrayProto$2 = Array.prototype;
	var _isArrayIter$2 = function(it) {
		return it !== void 0 && (_iterators$2.Array === it || ArrayProto$2[ITERATOR$1$7] === it);
	};
	var TAG$1$3 = _wks$3("toStringTag");
	var ARG$2 = _cof$3(function() {
		return arguments;
	}()) == "Arguments";
	var tryGet$2 = function(it, key$1) {
		try {
			return it[key$1];
		} catch (e) {}
	};
	var _classof$2 = function(it) {
		var O, T, B;
		return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet$2(O = Object(it), TAG$1$3)) == "string" ? T : ARG$2 ? _cof$3(O) : (B = _cof$3(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
	};
	var ITERATOR$2$4 = _wks$3("iterator");
	var core_getIteratorMethod$2 = _core$3.getIteratorMethod = function(it) {
		if (it != void 0) return it[ITERATOR$2$4] || it["@@iterator"] || _iterators$2[_classof$2(it)];
	};
	var _forOf$2 = createCommonjsModule$3(function(module$2) {
		var BREAK = {};
		var RETURN = {};
		var exports$1 = module$2.exports = function(iterable, entries, fn, that, ITERATOR$5) {
			var iterFn = ITERATOR$5 ? function() {
				return iterable;
			} : core_getIteratorMethod$2(iterable);
			var f = _ctx$3(fn, that, entries ? 2 : 1);
			var index$1 = 0;
			var length, step, iterator, result;
			if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
			if (_isArrayIter$2(iterFn)) for (length = _toLength$3(iterable.length); length > index$1; index$1++) {
				result = entries ? f(_anObject$3(step = iterable[index$1])[0], step[1]) : f(iterable[index$1]);
				if (result === BREAK || result === RETURN) return result;
			}
			else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
				result = _iterCall$2(iterator, f, step.value, entries);
				if (result === BREAK || result === RETURN) return result;
			}
		};
		exports$1.BREAK = BREAK;
		exports$1.RETURN = RETURN;
	});
	var _validateCollection$1 = function(it, TYPE) {
		if (!_isObject$3(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
		return it;
	};
	var getWeak = _meta$3.getWeak;
	var arrayFind = _arrayMethods$1(5);
	var arrayFindIndex = _arrayMethods$1(6);
	var id$1$1 = 0;
	var uncaughtFrozenStore = function(that) {
		return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function() {
		this.a = [];
	};
	var findUncaughtFrozen = function(store, key$1) {
		return arrayFind(store.a, function(it) {
			return it[0] === key$1;
		});
	};
	UncaughtFrozenStore.prototype = {
		get: function(key$1) {
			var entry = findUncaughtFrozen(this, key$1);
			if (entry) return entry[1];
		},
		has: function(key$1) {
			return !!findUncaughtFrozen(this, key$1);
		},
		set: function(key$1, value) {
			var entry = findUncaughtFrozen(this, key$1);
			if (entry) entry[1] = value;
			else this.a.push([key$1, value]);
		},
		"delete": function(key$1) {
			var index$1 = arrayFindIndex(this.a, function(it) {
				return it[0] === key$1;
			});
			if (~index$1) this.a.splice(index$1, 1);
			return !!~index$1;
		}
	};
	var _collectionWeak = {
		getConstructor: function(wrapper, NAME$5, IS_MAP, ADDER) {
			var C = wrapper(function(that, iterable) {
				_anInstance$2(that, C, NAME$5, "_i");
				that._t = NAME$5;
				that._i = id$1$1++;
				that._l = void 0;
				if (iterable != void 0) _forOf$2(iterable, IS_MAP, that[ADDER], that);
			});
			_redefineAll$2(C.prototype, {
				"delete": function(key$1) {
					if (!_isObject$3(key$1)) return false;
					var data = getWeak(key$1);
					if (data === true) return uncaughtFrozenStore(_validateCollection$1(this, NAME$5))["delete"](key$1);
					return data && _has$3(data, this._i) && delete data[this._i];
				},
				has: function has$8(key$1) {
					if (!_isObject$3(key$1)) return false;
					var data = getWeak(key$1);
					if (data === true) return uncaughtFrozenStore(_validateCollection$1(this, NAME$5)).has(key$1);
					return data && _has$3(data, this._i);
				}
			});
			return C;
		},
		def: function(that, key$1, value) {
			var data = getWeak(_anObject$3(key$1), true);
			if (data === true) uncaughtFrozenStore(that).set(key$1, value);
			else data[that._i] = value;
			return that;
		},
		ufstore: uncaughtFrozenStore
	};
	var dP$2$5 = _objectDp$3.f;
	var each$1 = _arrayMethods$1(0);
	var _collection$1 = function(NAME$5, wrapper, methods$3, common$9, IS_MAP, IS_WEAK) {
		var Base = _global$3[NAME$5];
		var C = Base;
		var ADDER = IS_MAP ? "set" : "add";
		var proto$7 = C && C.prototype;
		var O = {};
		if (!_descriptors$3 || typeof C != "function" || !(IS_WEAK || proto$7.forEach && !_fails$3(function() {
			new C().entries().next();
		}))) {
			C = common$9.getConstructor(wrapper, NAME$5, IS_MAP, ADDER);
			_redefineAll$2(C.prototype, methods$3);
			_meta$3.NEED = true;
		} else {
			C = wrapper(function(target, iterable) {
				_anInstance$2(target, C, NAME$5, "_c");
				target._c = new Base();
				if (iterable != void 0) _forOf$2(iterable, IS_MAP, target[ADDER], target);
			});
			each$1("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(KEY) {
				var IS_ADDER = KEY == "add" || KEY == "set";
				if (KEY in proto$7 && !(IS_WEAK && KEY == "clear")) _hide$3(C.prototype, KEY, function(a, b) {
					_anInstance$2(this, C, KEY);
					if (!IS_ADDER && IS_WEAK && !_isObject$3(a)) return KEY == "get" ? void 0 : false;
					var result = this._c[KEY](a === 0 ? 0 : a, b);
					return IS_ADDER ? this : result;
				});
			});
			IS_WEAK || dP$2$5(C.prototype, "size", { get: function() {
				return this._c.size;
			} });
		}
		_setToStringTag$3(C, NAME$5);
		O[NAME$5] = C;
		_export$3(_export$3.G + _export$3.W + _export$3.F, O);
		if (!IS_WEAK) common$9.setStrong(C, NAME$5, IS_MAP);
		return C;
	};
	createCommonjsModule$3(function(module$2) {
		var each$3 = _arrayMethods$1(0);
		var NATIVE_WEAK_MAP = _validateCollection$1;
		var IS_IE11 = !_global$3.ActiveXObject && "ActiveXObject" in _global$3;
		var WEAK_MAP = "WeakMap";
		var getWeak$2 = _meta$3.getWeak;
		var isExtensible = Object.isExtensible;
		var uncaughtFrozenStore$2 = _collectionWeak.ufstore;
		var InternalMap;
		var wrapper = function(get$1) {
			return function WeakMap$1() {
				return get$1(this, arguments.length > 0 ? arguments[0] : void 0);
			};
		};
		var methods$3 = {
			get: function get$1(key$1) {
				if (_isObject$3(key$1)) {
					var data = getWeak$2(key$1);
					if (data === true) return uncaughtFrozenStore$2(_validateCollection$1(this, WEAK_MAP)).get(key$1);
					return data ? data[this._i] : void 0;
				}
			},
			set: function set$3(key$1, value) {
				return _collectionWeak.def(_validateCollection$1(this, WEAK_MAP), key$1, value);
			}
		};
		var $WeakMap$1 = module$2.exports = _collection$1(WEAK_MAP, wrapper, methods$3, _collectionWeak, true, true);
		if (NATIVE_WEAK_MAP && IS_IE11) {
			InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);
			_objectAssign$1(InternalMap.prototype, methods$3);
			_meta$3.NEED = true;
			each$3([
				"delete",
				"has",
				"get",
				"set"
			], function(key$1) {
				var proto$7 = $WeakMap$1.prototype;
				var method$1 = proto$7[key$1];
				_redefine$3(proto$7, key$1, function(a, b) {
					if (_isObject$3(a) && !isExtensible(a)) {
						if (!this._f) this._f = new InternalMap();
						var result = this._f[key$1](a, b);
						return key$1 == "set" ? this : result;
					}
					return method$1.call(this, a, b);
				});
			});
		}
	});
	var _setCollectionOf$1 = function(COLLECTION) {
		_export$3(_export$3.S, COLLECTION, { of: function of() {
			var length = arguments.length;
			var A = new Array(length);
			while (length--) A[length] = arguments[length];
			return new this(A);
		} });
	};
	_setCollectionOf$1("WeakMap");
	var _setCollectionFrom$1 = function(COLLECTION) {
		_export$3(_export$3.S, COLLECTION, { from: function from(source) {
			var mapFn = arguments[1];
			var mapping, A, n, cb;
			_aFunction$3(this);
			mapping = mapFn !== void 0;
			if (mapping) _aFunction$3(mapFn);
			if (source == void 0) return new this();
			A = [];
			if (mapping) {
				n = 0;
				cb = _ctx$3(mapFn, arguments[2], 2);
				_forOf$2(source, false, function(nextItem) {
					A.push(cb(nextItem, n++));
				});
			} else _forOf$2(source, false, A.push, A);
			return new this(A);
		} });
	};
	_setCollectionFrom$1("WeakMap");
	var weakMap$1 = _core$3.WeakMap;
	_objectSap$3("keys", function() {
		return function keys$6(it) {
			return _objectKeys$3(_toObject$3(it));
		};
	});
	var keys$1$3 = _core$3.Object.keys;
	var _stringAt$2 = function(TO_STRING) {
		return function(that, pos) {
			var s$3 = String(_defined$3(that));
			var i$8 = _toInteger$3(pos);
			var l = s$3.length;
			var a, b;
			if (i$8 < 0 || i$8 >= l) return TO_STRING ? "" : void 0;
			a = s$3.charCodeAt(i$8);
			return a < 55296 || a > 56319 || i$8 + 1 === l || (b = s$3.charCodeAt(i$8 + 1)) < 56320 || b > 57343 ? TO_STRING ? s$3.charAt(i$8) : a : TO_STRING ? s$3.slice(i$8, i$8 + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
		};
	};
	var $at$2 = _stringAt$2(true);
	_iterDefine$2(String, "String", function(iterated) {
		this._t = String(iterated);
		this._i = 0;
	}, function() {
		var O = this._t;
		var index$1 = this._i;
		var point;
		if (index$1 >= O.length) return {
			value: void 0,
			done: true
		};
		point = $at$2(O, index$1);
		this._i += point.length;
		return {
			value: point,
			done: false
		};
	});
	var SPECIES$1$6 = _wks$3("species");
	var _speciesConstructor$2 = function(O, D) {
		var C = _anObject$3(O).constructor;
		var S;
		return C === void 0 || (S = _anObject$3(C)[SPECIES$1$6]) == void 0 ? D : _aFunction$3(S);
	};
	var _invoke$2 = function(fn, args, that) {
		var un = that === void 0;
		switch (args.length) {
			case 0: return un ? fn() : fn.call(that);
			case 1: return un ? fn(args[0]) : fn.call(that, args[0]);
			case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
			case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
			case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
		}
		return fn.apply(that, args);
	};
	var process$1$4 = _global$3.process;
	var setTask$2 = _global$3.setImmediate;
	var clearTask$2 = _global$3.clearImmediate;
	var MessageChannel$2 = _global$3.MessageChannel;
	var Dispatch$2 = _global$3.Dispatch;
	var counter$2 = 0;
	var queue$2 = {};
	var ONREADYSTATECHANGE$2 = "onreadystatechange";
	var defer$5, channel$2, port$2;
	var run$2 = function() {
		var id$7 = +this;
		if (queue$2.hasOwnProperty(id$7)) {
			var fn = queue$2[id$7];
			delete queue$2[id$7];
			fn();
		}
	};
	var listener$3 = function(event) {
		run$2.call(event.data);
	};
	if (!setTask$2 || !clearTask$2) {
		setTask$2 = function setImmediate$3(fn) {
			var args = [];
			var i$8 = 1;
			while (arguments.length > i$8) args.push(arguments[i$8++]);
			queue$2[++counter$2] = function() {
				_invoke$2(typeof fn == "function" ? fn : Function(fn), args);
			};
			defer$5(counter$2);
			return counter$2;
		};
		clearTask$2 = function clearImmediate$1(id$7) {
			delete queue$2[id$7];
		};
		if (_cof$3(process$1$4) == "process") defer$5 = function(id$7) {
			process$1$4.nextTick(_ctx$3(run$2, id$7, 1));
		};
		else if (Dispatch$2 && Dispatch$2.now) defer$5 = function(id$7) {
			Dispatch$2.now(_ctx$3(run$2, id$7, 1));
		};
		else if (MessageChannel$2) {
			channel$2 = new MessageChannel$2();
			port$2 = channel$2.port2;
			channel$2.port1.onmessage = listener$3;
			defer$5 = _ctx$3(port$2.postMessage, port$2, 1);
		} else if (_global$3.addEventListener && typeof postMessage == "function" && !_global$3.importScripts) {
			defer$5 = function(id$7) {
				_global$3.postMessage(id$7 + "", "*");
			};
			_global$3.addEventListener("message", listener$3, false);
		} else if (ONREADYSTATECHANGE$2 in _domCreate$3("script")) defer$5 = function(id$7) {
			_html$3.appendChild(_domCreate$3("script"))[ONREADYSTATECHANGE$2] = function() {
				_html$3.removeChild(this);
				run$2.call(id$7);
			};
		};
		else defer$5 = function(id$7) {
			setTimeout(_ctx$3(run$2, id$7, 1), 0);
		};
	}
	var _task$2 = {
		set: setTask$2,
		clear: clearTask$2
	};
	var macrotask$2 = _task$2.set;
	var Observer$2 = _global$3.MutationObserver || _global$3.WebKitMutationObserver;
	var process$2$5 = _global$3.process;
	var Promise$3 = _global$3.Promise;
	var isNode$4 = _cof$3(process$2$5) == "process";
	var _microtask$2 = function() {
		var head, last, notify$6;
		var flush = function() {
			var parent, fn;
			if (isNode$4 && (parent = process$2$5.domain)) parent.exit();
			while (head) {
				fn = head.fn;
				head = head.next;
				try {
					fn();
				} catch (e) {
					if (head) notify$6();
					else last = void 0;
					throw e;
				}
			}
			last = void 0;
			if (parent) parent.enter();
		};
		if (isNode$4) notify$6 = function() {
			process$2$5.nextTick(flush);
		};
		else if (Observer$2 && !(_global$3.navigator && _global$3.navigator.standalone)) {
			var toggle = true;
			var node$1 = document.createTextNode("");
			new Observer$2(flush).observe(node$1, { characterData: true });
			notify$6 = function() {
				node$1.data = toggle = !toggle;
			};
		} else if (Promise$3 && Promise$3.resolve) {
			var promise = Promise$3.resolve(void 0);
			notify$6 = function() {
				promise.then(flush);
			};
		} else notify$6 = function() {
			macrotask$2.call(_global$3, flush);
		};
		return function(fn) {
			var task$5 = {
				fn,
				next: void 0
			};
			if (last) last.next = task$5;
			if (!head) {
				head = task$5;
				notify$6();
			}
			last = task$5;
		};
	};
	function PromiseCapability$2(C) {
		var resolve$6, reject;
		this.promise = new C(function($$resolve, $$reject) {
			if (resolve$6 !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
			resolve$6 = $$resolve;
			reject = $$reject;
		});
		this.resolve = _aFunction$3(resolve$6);
		this.reject = _aFunction$3(reject);
	}
	var f$7$2 = function(C) {
		return new PromiseCapability$2(C);
	};
	var _newPromiseCapability$2 = { f: f$7$2 };
	var _perform$2 = function(exec) {
		try {
			return {
				e: false,
				v: exec()
			};
		} catch (e) {
			return {
				e: true,
				v: e
			};
		}
	};
	var navigator$1$1 = _global$3.navigator;
	var _userAgent$2 = navigator$1$1 && navigator$1$1.userAgent || "";
	var _promiseResolve$2 = function(C, x) {
		_anObject$3(C);
		if (_isObject$3(x) && x.constructor === C) return x;
		var promiseCapability = _newPromiseCapability$2.f(C);
		var resolve$6 = promiseCapability.resolve;
		resolve$6(x);
		return promiseCapability.promise;
	};
	var SPECIES$2$4 = _wks$3("species");
	var _setSpecies$2 = function(KEY) {
		var C = typeof _core$3[KEY] == "function" ? _core$3[KEY] : _global$3[KEY];
		if (_descriptors$3 && C && !C[SPECIES$2$4]) _objectDp$3.f(C, SPECIES$2$4, {
			configurable: true,
			get: function() {
				return this;
			}
		});
	};
	var ITERATOR$3$5 = _wks$3("iterator");
	var SAFE_CLOSING$2 = false;
	try {
		var riter$2 = [7][ITERATOR$3$5]();
		riter$2["return"] = function() {
			SAFE_CLOSING$2 = true;
		};
		Array.from(riter$2, function() {
			throw 2;
		});
	} catch (e) {}
	var _iterDetect$2 = function(exec, skipClosing) {
		if (!skipClosing && !SAFE_CLOSING$2) return false;
		var safe = false;
		try {
			var arr = [7];
			var iter = arr[ITERATOR$3$5]();
			iter.next = function() {
				return { done: safe = true };
			};
			arr[ITERATOR$3$5] = function() {
				return iter;
			};
			exec(arr);
		} catch (e) {}
		return safe;
	};
	var task$2 = _task$2.set;
	var microtask$2 = _microtask$2();
	var PROMISE$2 = "Promise";
	var TypeError$1$2 = _global$3.TypeError;
	var process$3$1 = _global$3.process;
	var versions$2 = process$3$1 && process$3$1.versions;
	var v8$2 = versions$2 && versions$2.v8 || "";
	var $Promise$2 = _global$3[PROMISE$2];
	var isNode$1$5 = _classof$2(process$3$1) == "process";
	var empty$2 = function() {};
	var Internal$2, newGenericPromiseCapability$2, OwnPromiseCapability$2, Wrapper$2;
	var newPromiseCapability$2 = newGenericPromiseCapability$2 = _newPromiseCapability$2.f;
	var USE_NATIVE$1$3 = !!function() {
		try {
			var promise = $Promise$2.resolve(1);
			var FakePromise = (promise.constructor = {})[_wks$3("species")] = function(exec) {
				exec(empty$2, empty$2);
			};
			return (isNode$1$5 || typeof PromiseRejectionEvent == "function") && promise.then(empty$2) instanceof FakePromise && v8$2.indexOf("6.6") !== 0 && _userAgent$2.indexOf("Chrome/66") === -1;
		} catch (e) {}
	}();
	var isThenable$2 = function(it) {
		var then;
		return _isObject$3(it) && typeof (then = it.then) == "function" ? then : false;
	};
	var notify$2 = function(promise, isReject) {
		if (promise._n) return;
		promise._n = true;
		var chain = promise._c;
		microtask$2(function() {
			var value = promise._v;
			var ok = promise._s == 1;
			var i$8 = 0;
			var run$5 = function(reaction) {
				var handler = ok ? reaction.ok : reaction.fail;
				var resolve$6 = reaction.resolve;
				var reject = reaction.reject;
				var domain = reaction.domain;
				var result, then, exited;
				try {
					if (handler) {
						if (!ok) {
							if (promise._h == 2) onHandleUnhandled$2(promise);
							promise._h = 1;
						}
						if (handler === true) result = value;
						else {
							if (domain) domain.enter();
							result = handler(value);
							if (domain) {
								domain.exit();
								exited = true;
							}
						}
						if (result === reaction.promise) reject(TypeError$1$2("Promise-chain cycle"));
						else if (then = isThenable$2(result)) then.call(result, resolve$6, reject);
						else resolve$6(result);
					} else reject(value);
				} catch (e) {
					if (domain && !exited) domain.exit();
					reject(e);
				}
			};
			while (chain.length > i$8) run$5(chain[i$8++]);
			promise._c = [];
			promise._n = false;
			if (isReject && !promise._h) onUnhandled$2(promise);
		});
	};
	var onUnhandled$2 = function(promise) {
		task$2.call(_global$3, function() {
			var value = promise._v;
			var unhandled = isUnhandled$2(promise);
			var result, handler, console$1;
			if (unhandled) {
				result = _perform$2(function() {
					if (isNode$1$5) process$3$1.emit("unhandledRejection", value, promise);
					else if (handler = _global$3.onunhandledrejection) handler({
						promise,
						reason: value
					});
					else if ((console$1 = _global$3.console) && console$1.error) console$1.error("Unhandled promise rejection", value);
				});
				promise._h = isNode$1$5 || isUnhandled$2(promise) ? 2 : 1;
			}
			promise._a = void 0;
			if (unhandled && result.e) throw result.v;
		});
	};
	var isUnhandled$2 = function(promise) {
		return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled$2 = function(promise) {
		task$2.call(_global$3, function() {
			var handler;
			if (isNode$1$5) process$3$1.emit("rejectionHandled", promise);
			else if (handler = _global$3.onrejectionhandled) handler({
				promise,
				reason: promise._v
			});
		});
	};
	var $reject$2 = function(value) {
		var promise = this;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		promise._v = value;
		promise._s = 2;
		if (!promise._a) promise._a = promise._c.slice();
		notify$2(promise, true);
	};
	var $resolve$2 = function(value) {
		var promise = this;
		var then;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		try {
			if (promise === value) throw TypeError$1$2("Promise can't be resolved itself");
			if (then = isThenable$2(value)) microtask$2(function() {
				var wrapper = {
					_w: promise,
					_d: false
				};
				try {
					then.call(value, _ctx$3($resolve$2, wrapper, 1), _ctx$3($reject$2, wrapper, 1));
				} catch (e) {
					$reject$2.call(wrapper, e);
				}
			});
			else {
				promise._v = value;
				promise._s = 1;
				notify$2(promise, false);
			}
		} catch (e) {
			$reject$2.call({
				_w: promise,
				_d: false
			}, e);
		}
	};
	if (!USE_NATIVE$1$3) {
		$Promise$2 = function Promise$6(executor) {
			_anInstance$2(this, $Promise$2, PROMISE$2, "_h");
			_aFunction$3(executor);
			Internal$2.call(this);
			try {
				executor(_ctx$3($resolve$2, this, 1), _ctx$3($reject$2, this, 1));
			} catch (err) {
				$reject$2.call(this, err);
			}
		};
		Internal$2 = function Promise$6(executor) {
			this._c = [];
			this._a = void 0;
			this._s = 0;
			this._d = false;
			this._v = void 0;
			this._h = 0;
			this._n = false;
		};
		Internal$2.prototype = _redefineAll$2($Promise$2.prototype, {
			then: function then(onFulfilled, onRejected) {
				var reaction = newPromiseCapability$2(_speciesConstructor$2(this, $Promise$2));
				reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
				reaction.fail = typeof onRejected == "function" && onRejected;
				reaction.domain = isNode$1$5 ? process$3$1.domain : void 0;
				this._c.push(reaction);
				if (this._a) this._a.push(reaction);
				if (this._s) notify$2(this, false);
				return reaction.promise;
			},
			"catch": function(onRejected) {
				return this.then(void 0, onRejected);
			}
		});
		OwnPromiseCapability$2 = function() {
			var promise = new Internal$2();
			this.promise = promise;
			this.resolve = _ctx$3($resolve$2, promise, 1);
			this.reject = _ctx$3($reject$2, promise, 1);
		};
		_newPromiseCapability$2.f = newPromiseCapability$2 = function(C) {
			return C === $Promise$2 || C === Wrapper$2 ? new OwnPromiseCapability$2(C) : newGenericPromiseCapability$2(C);
		};
	}
	_export$3(_export$3.G + _export$3.W + _export$3.F * !USE_NATIVE$1$3, { Promise: $Promise$2 });
	_setToStringTag$3($Promise$2, PROMISE$2);
	_setSpecies$2(PROMISE$2);
	Wrapper$2 = _core$3[PROMISE$2];
	_export$3(_export$3.S + _export$3.F * !USE_NATIVE$1$3, PROMISE$2, { reject: function reject(r) {
		var capability = newPromiseCapability$2(this);
		var $$reject = capability.reject;
		$$reject(r);
		return capability.promise;
	} });
	_export$3(_export$3.S + _export$3.F * _library$3, PROMISE$2, { resolve: function resolve$6(x) {
		return _promiseResolve$2(this === Wrapper$2 ? $Promise$2 : this, x);
	} });
	_export$3(_export$3.S + _export$3.F * !(USE_NATIVE$1$3 && _iterDetect$2(function(iter) {
		$Promise$2.all(iter)["catch"](empty$2);
	})), PROMISE$2, {
		all: function all(iterable) {
			var C = this;
			var capability = newPromiseCapability$2(C);
			var resolve$6 = capability.resolve;
			var reject = capability.reject;
			var result = _perform$2(function() {
				var values = [];
				var index$1 = 0;
				var remaining = 1;
				_forOf$2(iterable, false, function(promise) {
					var $index = index$1++;
					var alreadyCalled = false;
					values.push(void 0);
					remaining++;
					C.resolve(promise).then(function(value) {
						if (alreadyCalled) return;
						alreadyCalled = true;
						values[$index] = value;
						--remaining || resolve$6(values);
					}, reject);
				});
				--remaining || resolve$6(values);
			});
			if (result.e) reject(result.v);
			return capability.promise;
		},
		race: function race(iterable) {
			var C = this;
			var capability = newPromiseCapability$2(C);
			var reject = capability.reject;
			var result = _perform$2(function() {
				_forOf$2(iterable, false, function(promise) {
					C.resolve(promise).then(capability.resolve, reject);
				});
			});
			if (result.e) reject(result.v);
			return capability.promise;
		}
	});
	_export$3(_export$3.P + _export$3.R, "Promise", { "finally": function(onFinally) {
		var C = _speciesConstructor$2(this, _core$3.Promise || _global$3.Promise);
		var isFunction$3 = typeof onFinally == "function";
		return this.then(isFunction$3 ? function(x) {
			return _promiseResolve$2(C, onFinally()).then(function() {
				return x;
			});
		} : onFinally, isFunction$3 ? function(e) {
			return _promiseResolve$2(C, onFinally()).then(function() {
				throw e;
			});
		} : onFinally);
	} });
	_export$3(_export$3.S, "Promise", { "try": function(callbackfn) {
		var promiseCapability = _newPromiseCapability$2.f(this);
		var result = _perform$2(callbackfn);
		(result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
		return promiseCapability.promise;
	} });
	var promise$1$2 = _core$3.Promise;
	var $JSON$1$1 = _core$3.JSON || (_core$3.JSON = { stringify: JSON.stringify });
	var stringify$1$1 = function stringify$14(it) {
		return $JSON$1$1.stringify.apply($JSON$1$1, arguments);
	};
	/**
	* Helpers.
	*/
	var s$1 = 1e3;
	var m$1 = s$1 * 60;
	var h$1 = m$1 * 60;
	var d$1 = h$1 * 24;
	var w = d$1 * 7;
	var y$1 = d$1 * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	var ms$1 = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$14(val);
		else if (type === "number" && isNaN(val) === false) return options.long ? fmtLong$1(val) : fmtShort$1(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$14(str) {
		str = String(str);
		if (str.length > 100) return;
		var match$1 = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match$1) return;
		var n = parseFloat(match$1[1]);
		switch ((match$1[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y$1;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d$1;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h$1;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m$1;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s$1;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort$1(ms$2) {
		var msAbs = Math.abs(ms$2);
		if (msAbs >= d$1) return Math.round(ms$2 / d$1) + "d";
		if (msAbs >= h$1) return Math.round(ms$2 / h$1) + "h";
		if (msAbs >= m$1) return Math.round(ms$2 / m$1) + "m";
		if (msAbs >= s$1) return Math.round(ms$2 / s$1) + "s";
		return ms$2 + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong$1(ms$2) {
		var msAbs = Math.abs(ms$2);
		if (msAbs >= d$1) return plural$1(ms$2, msAbs, d$1, "day");
		if (msAbs >= h$1) return plural$1(ms$2, msAbs, h$1, "hour");
		if (msAbs >= m$1) return plural$1(ms$2, msAbs, m$1, "minute");
		if (msAbs >= s$1) return plural$1(ms$2, msAbs, s$1, "second");
		return ms$2 + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural$1(ms$2, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms$2 / n) + " " + name + (isPlural ? "s" : "");
	}
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env$2) {
		createDebug$1.debug = createDebug$1;
		createDebug$1.default = createDebug$1;
		createDebug$1.coerce = coerce$1;
		createDebug$1.disable = disable$1;
		createDebug$1.enable = enable$1;
		createDebug$1.enabled = enabled$1;
		createDebug$1.humanize = ms$1;
		Object.keys(env$2).forEach((key$1) => {
			createDebug$1[key$1] = env$2[key$1];
		});
		/**
		* Active `debug` instances.
		*/
		createDebug$1.instances = [];
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug$1.names = [];
		createDebug$1.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug$1.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor$1(namespace) {
			let hash = 0;
			for (let i$8 = 0; i$8 < namespace.length; i$8++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i$8);
				hash |= 0;
			}
			return createDebug$1.colors[Math.abs(hash) % createDebug$1.colors.length];
		}
		createDebug$1.selectColor = selectColor$1;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug$1(namespace) {
			let prevTime$1;
			function debug$23(...args) {
				if (!debug$23.enabled) return;
				const self$1 = debug$23;
				const curr = Number(/* @__PURE__ */ new Date());
				self$1.diff = curr - (prevTime$1 || curr);
				self$1.prev = prevTime$1;
				self$1.curr = curr;
				prevTime$1 = curr;
				args[0] = createDebug$1.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index$1 = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match$1, format$6) => {
					if (match$1 === "%%") return match$1;
					index$1++;
					const formatter = createDebug$1.formatters[format$6];
					if (typeof formatter === "function") {
						const val = args[index$1];
						match$1 = formatter.call(self$1, val);
						args.splice(index$1, 1);
						index$1--;
					}
					return match$1;
				});
				createDebug$1.formatArgs.call(self$1, args);
				(self$1.log || createDebug$1.log).apply(self$1, args);
			}
			debug$23.namespace = namespace;
			debug$23.enabled = createDebug$1.enabled(namespace);
			debug$23.useColors = createDebug$1.useColors();
			debug$23.color = selectColor$1(namespace);
			debug$23.destroy = destroy$3;
			debug$23.extend = extend;
			if (typeof createDebug$1.init === "function") createDebug$1.init(debug$23);
			createDebug$1.instances.push(debug$23);
			return debug$23;
		}
		function destroy$3() {
			const index$1 = createDebug$1.instances.indexOf(this);
			if (index$1 !== -1) {
				createDebug$1.instances.splice(index$1, 1);
				return true;
			}
			return false;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug$1(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable$1(namespaces) {
			createDebug$1.save(namespaces);
			createDebug$1.names = [];
			createDebug$1.skips = [];
			let i$8;
			const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
			const len$1 = split.length;
			for (i$8 = 0; i$8 < len$1; i$8++) {
				if (!split[i$8]) continue;
				namespaces = split[i$8].replace(/\*/g, ".*?");
				if (namespaces[0] === "-") createDebug$1.skips.push(/* @__PURE__ */ new RegExp("^" + namespaces.substr(1) + "$"));
				else createDebug$1.names.push(/* @__PURE__ */ new RegExp("^" + namespaces + "$"));
			}
			for (i$8 = 0; i$8 < createDebug$1.instances.length; i$8++) {
				const instance = createDebug$1.instances[i$8];
				instance.enabled = createDebug$1.enabled(instance.namespace);
			}
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable$1() {
			const namespaces = [...createDebug$1.names.map(toNamespace), ...createDebug$1.skips.map(toNamespace).map((namespace) => "-" + namespace)].join(",");
			createDebug$1.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled$1(name) {
			if (name[name.length - 1] === "*") return true;
			let i$8;
			let len$1;
			for (i$8 = 0, len$1 = createDebug$1.skips.length; i$8 < len$1; i$8++) if (createDebug$1.skips[i$8].test(name)) return false;
			for (i$8 = 0, len$1 = createDebug$1.names.length; i$8 < len$1; i$8++) if (createDebug$1.names[i$8].test(name)) return true;
			return false;
		}
		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce$1(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		createDebug$1.enable(createDebug$1.load());
		return createDebug$1;
	}
	var common = setup;
	var browser$1 = createCommonjsModule$3(function(module$2, exports$1) {
		/**
		* This is the web browser implementation of `debug()`.
		*/
		exports$1.log = log$4;
		exports$1.formatArgs = formatArgs$4;
		exports$1.save = save$4;
		exports$1.load = load$7;
		exports$1.useColors = useColors$4;
		exports$1.storage = localstorage$2();
		/**
		* Colors.
		*/
		exports$1.colors = [
			"#0000CC",
			"#0000FF",
			"#0033CC",
			"#0033FF",
			"#0066CC",
			"#0066FF",
			"#0099CC",
			"#0099FF",
			"#00CC00",
			"#00CC33",
			"#00CC66",
			"#00CC99",
			"#00CCCC",
			"#00CCFF",
			"#3300CC",
			"#3300FF",
			"#3333CC",
			"#3333FF",
			"#3366CC",
			"#3366FF",
			"#3399CC",
			"#3399FF",
			"#33CC00",
			"#33CC33",
			"#33CC66",
			"#33CC99",
			"#33CCCC",
			"#33CCFF",
			"#6600CC",
			"#6600FF",
			"#6633CC",
			"#6633FF",
			"#66CC00",
			"#66CC33",
			"#9900CC",
			"#9900FF",
			"#9933CC",
			"#9933FF",
			"#99CC00",
			"#99CC33",
			"#CC0000",
			"#CC0033",
			"#CC0066",
			"#CC0099",
			"#CC00CC",
			"#CC00FF",
			"#CC3300",
			"#CC3333",
			"#CC3366",
			"#CC3399",
			"#CC33CC",
			"#CC33FF",
			"#CC6600",
			"#CC6633",
			"#CC9900",
			"#CC9933",
			"#CCCC00",
			"#CCCC33",
			"#FF0000",
			"#FF0033",
			"#FF0066",
			"#FF0099",
			"#FF00CC",
			"#FF00FF",
			"#FF3300",
			"#FF3333",
			"#FF3366",
			"#FF3399",
			"#FF33CC",
			"#FF33FF",
			"#FF6600",
			"#FF6633",
			"#FF9900",
			"#FF9933",
			"#FFCC00",
			"#FFCC33"
		];
		/**
		* Currently only WebKit-based Web Inspectors, Firefox >= v31,
		* and the Firebug extension (any Firefox version) are known
		* to support "%c" CSS customizations.
		*
		* TODO: add a `localStorage` variable to explicitly enable/disable colors
		*/
		function useColors$4() {
			if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
			if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
			return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
		}
		/**
		* Colorize log arguments if enabled.
		*
		* @api public
		*/
		function formatArgs$4(args) {
			args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module$2.exports.humanize(this.diff);
			if (!this.useColors) return;
			const c = "color: " + this.color;
			args.splice(1, 0, c, "color: inherit");
			let index$1 = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, (match$1) => {
				if (match$1 === "%%") return;
				index$1++;
				if (match$1 === "%c") lastC = index$1;
			});
			args.splice(lastC, 0, c);
		}
		/**
		* Invokes `console.log()` when available.
		* No-op when `console.log` is not a "function".
		*
		* @api public
		*/
		function log$4(...args) {
			return typeof console === "object" && console.log && console.log(...args);
		}
		/**
		* Save `namespaces`.
		*
		* @param {String} namespaces
		* @api private
		*/
		function save$4(namespaces) {
			try {
				if (namespaces) exports$1.storage.setItem("debug", namespaces);
				else exports$1.storage.removeItem("debug");
			} catch (error) {}
		}
		/**
		* Load `namespaces`.
		*
		* @return {String} returns the previously persisted debug modes
		* @api private
		*/
		function load$7() {
			let r;
			try {
				r = exports$1.storage.getItem("debug");
			} catch (error) {}
			if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
			return r;
		}
		/**
		* Localstorage attempts to return the localstorage.
		*
		* This is necessary because safari throws
		* when a user disables cookies/localstorage
		* and you attempt to access it.
		*
		* @return {LocalStorage}
		* @api private
		*/
		function localstorage$2() {
			try {
				return localStorage;
			} catch (error) {}
		}
		module$2.exports = common(exports$1);
		const { formatters: formatters$2 } = module$2.exports;
		/**
		* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		*/
		formatters$2.j = function(v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return "[UnexpectedJSONParseError]: " + error.message;
			}
		};
	});
	browser$1.log;
	browser$1.formatArgs;
	browser$1.save;
	browser$1.load;
	browser$1.useColors;
	browser$1.storage;
	browser$1.colors;
	var hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf("--");
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	const { env } = process;
	let forceColor;
	if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) forceColor = 0;
	else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) forceColor = 1;
	if ("FORCE_COLOR" in env) if (env.FORCE_COLOR === "true") forceColor = 1;
	else if (env.FORCE_COLOR === "false") forceColor = 0;
	else forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	function translateLevel(level) {
		if (level === 0) return false;
		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}
	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) return 0;
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
		if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
		const min$8 = forceColor || 0;
		if (env.TERM === "dumb") return min$8;
		if (process.platform === "win32") {
			const osRelease = os.release().split(".");
			if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
			return 1;
		}
		if ("CI" in env) {
			if ([
				"TRAVIS",
				"CIRCLECI",
				"APPVEYOR",
				"GITLAB_CI",
				"GITHUB_ACTIONS",
				"BUILDKITE"
			].some((sign$2) => sign$2 in env) || env.CI_NAME === "codeship") return 1;
			return min$8;
		}
		if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		if (env.COLORTERM === "truecolor") return 3;
		if ("TERM_PROGRAM" in env) {
			const version$1 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
			switch (env.TERM_PROGRAM) {
				case "iTerm.app": return version$1 >= 3 ? 3 : 2;
				case "Apple_Terminal": return 2;
			}
		}
		if (/-256(color)?$/i.test(env.TERM)) return 2;
		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
		if ("COLORTERM" in env) return 1;
		return min$8;
	}
	function getSupportLevel(stream$3) {
		return translateLevel(supportsColor(stream$3, stream$3 && stream$3.isTTY));
	}
	var supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty$1.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty$1.isatty(2)))
	};
	var node = createCommonjsModule$3(function(module$2, exports$1) {
		/**
		* Module dependencies.
		*/
		/**
		* This is the Node.js implementation of `debug()`.
		*/
		exports$1.init = init$2;
		exports$1.log = log$4;
		exports$1.formatArgs = formatArgs$4;
		exports$1.save = save$4;
		exports$1.load = load$7;
		exports$1.useColors = useColors$4;
		/**
		* Colors.
		*/
		exports$1.colors = [
			6,
			2,
			3,
			4,
			5,
			1
		];
		try {
			const supportsColor$2 = supportsColor_1;
			if (supportsColor$2 && (supportsColor$2.stderr || supportsColor$2).level >= 2) exports$1.colors = [
				20,
				21,
				26,
				27,
				32,
				33,
				38,
				39,
				40,
				41,
				42,
				43,
				44,
				45,
				56,
				57,
				62,
				63,
				68,
				69,
				74,
				75,
				76,
				77,
				78,
				79,
				80,
				81,
				92,
				93,
				98,
				99,
				112,
				113,
				128,
				129,
				134,
				135,
				148,
				149,
				160,
				161,
				162,
				163,
				164,
				165,
				166,
				167,
				168,
				169,
				170,
				171,
				172,
				173,
				178,
				179,
				184,
				185,
				196,
				197,
				198,
				199,
				200,
				201,
				202,
				203,
				204,
				205,
				206,
				207,
				208,
				209,
				214,
				215,
				220,
				221
			];
		} catch (error) {}
		/**
		* Build up the default `inspectOpts` object from the environment variables.
		*
		*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		*/
		exports$1.inspectOpts = Object.keys(process.env).filter((key$1) => {
			return /^debug_/i.test(key$1);
		}).reduce((obj, key$1) => {
			const prop = key$1.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k$7) => {
				return k$7.toUpperCase();
			});
			let val = process.env[key$1];
			if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
			else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
			else if (val === "null") val = null;
			else val = Number(val);
			obj[prop] = val;
			return obj;
		}, {});
		/**
		* Is stdout a TTY? Colored output is enabled when `true`.
		*/
		function useColors$4() {
			return "colors" in exports$1.inspectOpts ? Boolean(exports$1.inspectOpts.colors) : tty$1.isatty(process.stderr.fd);
		}
		/**
		* Adds ANSI color escape codes if enabled.
		*
		* @api public
		*/
		function formatArgs$4(args) {
			const { namespace: name, useColors: useColors$5 } = this;
			if (useColors$5) {
				const c = this.color;
				const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;
				args[0] = prefix + args[0].split("\n").join("\n" + prefix);
				args.push(colorCode + "m+" + module$2.exports.humanize(this.diff) + "\x1B[0m");
			} else args[0] = getDate$1() + name + " " + args[0];
		}
		function getDate$1() {
			if (exports$1.inspectOpts.hideDate) return "";
			return (/* @__PURE__ */ new Date()).toISOString() + " ";
		}
		/**
		* Invokes `util.format()` with the specified arguments and writes to stderr.
		*/
		function log$4(...args) {
			return process.stderr.write(util$5.format(...args) + "\n");
		}
		/**
		* Save `namespaces`.
		*
		* @param {String} namespaces
		* @api private
		*/
		function save$4(namespaces) {
			if (namespaces) process.env.DEBUG = namespaces;
			else delete process.env.DEBUG;
		}
		/**
		* Load `namespaces`.
		*
		* @return {String} returns the previously persisted debug modes
		* @api private
		*/
		function load$7() {
			return process.env.DEBUG;
		}
		/**
		* Init logic for `debug` instances.
		*
		* Create a new `inspectOpts` object in case `useColors` is set
		* differently for a particular `debug` instance.
		*/
		function init$2(debug$23) {
			debug$23.inspectOpts = {};
			const keys$6 = Object.keys(exports$1.inspectOpts);
			for (let i$8 = 0; i$8 < keys$6.length; i$8++) debug$23.inspectOpts[keys$6[i$8]] = exports$1.inspectOpts[keys$6[i$8]];
		}
		module$2.exports = common(exports$1);
		const { formatters: formatters$2 } = module$2.exports;
		/**
		* Map %o to `util.inspect()`, all on a single line.
		*/
		formatters$2.o = function(v) {
			this.inspectOpts.colors = this.useColors;
			return util$5.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, " ");
		};
		/**
		* Map %O to `util.inspect()`, allowing multiple lines if needed.
		*/
		formatters$2.O = function(v) {
			this.inspectOpts.colors = this.useColors;
			return util$5.inspect(v, this.inspectOpts);
		};
	});
	node.init;
	node.log;
	node.formatArgs;
	node.save;
	node.load;
	node.useColors;
	node.colors;
	node.inspectOpts;
	var src = createCommonjsModule$3(function(module$2) {
		/**
		* Detect Electron renderer / nwjs process, which is node, but we should
		* treat as a browser.
		*/
		if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) module$2.exports = browser$1;
		else module$2.exports = node;
	});
	/**
	* lodash (Custom Build) <https://lodash.com/>
	* Build: `lodash modularize exports="npm" -o ./`
	* Copyright jQuery Foundation and other contributors <https://jquery.org/>
	* Released under MIT license <https://lodash.com/license>
	* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	*/
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = "Expected a function";
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
	/** Used as references for various `Number` constants. */
	var INFINITY = Infinity, MAX_SAFE_INTEGER = 9007199254740991;
	/** `Object#toString` result references. */
	var funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	/**
	* Used to match `RegExp`
	* [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	*/
	var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	/** Detect free variable `global` from Node.js. */
	var freeGlobal$1 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
	/** Detect free variable `self`. */
	var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
	/** Used as a reference to the global object. */
	var root$1 = freeGlobal$1 || freeSelf$1 || Function("return this")();
	/**
	* Gets the value at `key` of `object`.
	*
	* @private
	* @param {Object} [object] The object to query.
	* @param {string} key The key of the property to get.
	* @returns {*} Returns the property value.
	*/
	function getValue$1(object, key$1) {
		return object == null ? void 0 : object[key$1];
	}
	/**
	* Checks if `value` is a host object in IE < 9.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	*/
	function isHostObject(value) {
		var result = false;
		if (value != null && typeof value.toString != "function") try {
			result = !!(value + "");
		} catch (e) {}
		return result;
	}
	/** Used for built-in method references. */
	var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto$1 = Object.prototype;
	/** Used to detect overreaching core-js shims. */
	var coreJsData$1 = root$1["__core-js_shared__"];
	/** Used to detect methods masquerading as native. */
	var maskSrcKey$1 = function() {
		var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
		return uid ? "Symbol(src)_1." + uid : "";
	}();
	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto.toString;
	/** Used to check objects for own properties. */
	var hasOwnProperty$1$2 = objectProto$1.hasOwnProperty;
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var objectToString$1 = objectProto$1.toString;
	/** Used to detect if a method is native. */
	var reIsNative$1 = RegExp("^" + funcToString$2.call(hasOwnProperty$1$2).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	/** Built-in value references. */
	var Symbol$1$1 = root$1.Symbol, splice$1 = arrayProto.splice;
	var Map$2 = getNative$1(root$1, "Map"), nativeCreate$1 = getNative$1(Object, "create");
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1$1 ? Symbol$1$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
	/**
	* Creates a hash object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function Hash$1(entries) {
		var index$1 = -1, length = entries ? entries.length : 0;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	/**
	* Removes all key-value entries from the hash.
	*
	* @private
	* @name clear
	* @memberOf Hash
	*/
	function hashClear$1() {
		this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
	}
	/**
	* Removes `key` and its value from the hash.
	*
	* @private
	* @name delete
	* @memberOf Hash
	* @param {Object} hash The hash to modify.
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function hashDelete$1(key$1) {
		return this.has(key$1) && delete this.__data__[key$1];
	}
	/**
	* Gets the hash value for `key`.
	*
	* @private
	* @name get
	* @memberOf Hash
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function hashGet$1(key$1) {
		var data = this.__data__;
		if (nativeCreate$1) {
			var result = data[key$1];
			return result === HASH_UNDEFINED$3 ? void 0 : result;
		}
		return hasOwnProperty$1$2.call(data, key$1) ? data[key$1] : void 0;
	}
	/**
	* Checks if a hash value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf Hash
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function hashHas$1(key$1) {
		var data = this.__data__;
		return nativeCreate$1 ? data[key$1] !== void 0 : hasOwnProperty$1$2.call(data, key$1);
	}
	/**
	* Sets the hash `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf Hash
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the hash instance.
	*/
	function hashSet$1(key$1, value) {
		var data = this.__data__;
		data[key$1] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$3 : value;
		return this;
	}
	Hash$1.prototype.clear = hashClear$1;
	Hash$1.prototype["delete"] = hashDelete$1;
	Hash$1.prototype.get = hashGet$1;
	Hash$1.prototype.has = hashHas$1;
	Hash$1.prototype.set = hashSet$1;
	/**
	* Creates an list cache object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function ListCache$1(entries) {
		var index$1 = -1, length = entries ? entries.length : 0;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	/**
	* Removes all key-value entries from the list cache.
	*
	* @private
	* @name clear
	* @memberOf ListCache
	*/
	function listCacheClear$1() {
		this.__data__ = [];
	}
	/**
	* Removes `key` and its value from the list cache.
	*
	* @private
	* @name delete
	* @memberOf ListCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function listCacheDelete$1(key$1) {
		var data = this.__data__, index$1 = assocIndexOf$1(data, key$1);
		if (index$1 < 0) return false;
		if (index$1 == data.length - 1) data.pop();
		else splice$1.call(data, index$1, 1);
		return true;
	}
	/**
	* Gets the list cache value for `key`.
	*
	* @private
	* @name get
	* @memberOf ListCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function listCacheGet$1(key$1) {
		var data = this.__data__, index$1 = assocIndexOf$1(data, key$1);
		return index$1 < 0 ? void 0 : data[index$1][1];
	}
	/**
	* Checks if a list cache value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf ListCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function listCacheHas$1(key$1) {
		return assocIndexOf$1(this.__data__, key$1) > -1;
	}
	/**
	* Sets the list cache `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf ListCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the list cache instance.
	*/
	function listCacheSet$1(key$1, value) {
		var data = this.__data__, index$1 = assocIndexOf$1(data, key$1);
		if (index$1 < 0) data.push([key$1, value]);
		else data[index$1][1] = value;
		return this;
	}
	ListCache$1.prototype.clear = listCacheClear$1;
	ListCache$1.prototype["delete"] = listCacheDelete$1;
	ListCache$1.prototype.get = listCacheGet$1;
	ListCache$1.prototype.has = listCacheHas$1;
	ListCache$1.prototype.set = listCacheSet$1;
	/**
	* Creates a map cache object to store key-value pairs.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function MapCache$1(entries) {
		var index$1 = -1, length = entries ? entries.length : 0;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	/**
	* Removes all key-value entries from the map.
	*
	* @private
	* @name clear
	* @memberOf MapCache
	*/
	function mapCacheClear$1() {
		this.__data__ = {
			"hash": new Hash$1(),
			"map": new (Map$2 || ListCache$1)(),
			"string": new Hash$1()
		};
	}
	/**
	* Removes `key` and its value from the map.
	*
	* @private
	* @name delete
	* @memberOf MapCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function mapCacheDelete$1(key$1) {
		return getMapData$1(this, key$1)["delete"](key$1);
	}
	/**
	* Gets the map value for `key`.
	*
	* @private
	* @name get
	* @memberOf MapCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function mapCacheGet$1(key$1) {
		return getMapData$1(this, key$1).get(key$1);
	}
	/**
	* Checks if a map value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf MapCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function mapCacheHas$1(key$1) {
		return getMapData$1(this, key$1).has(key$1);
	}
	/**
	* Sets the map `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf MapCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the map cache instance.
	*/
	function mapCacheSet$1(key$1, value) {
		getMapData$1(this, key$1).set(key$1, value);
		return this;
	}
	MapCache$1.prototype.clear = mapCacheClear$1;
	MapCache$1.prototype["delete"] = mapCacheDelete$1;
	MapCache$1.prototype.get = mapCacheGet$1;
	MapCache$1.prototype.has = mapCacheHas$1;
	MapCache$1.prototype.set = mapCacheSet$1;
	/**
	* Assigns `value` to `key` of `object` if the existing value is not equivalent
	* using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	* for equality comparisons.
	*
	* @private
	* @param {Object} object The object to modify.
	* @param {string} key The key of the property to assign.
	* @param {*} value The value to assign.
	*/
	function assignValue(object, key$1, value) {
		var objValue = object[key$1];
		if (!(hasOwnProperty$1$2.call(object, key$1) && eq$1(objValue, value)) || value === void 0 && !(key$1 in object)) object[key$1] = value;
	}
	/**
	* Gets the index at which the `key` is found in `array` of key-value pairs.
	*
	* @private
	* @param {Array} array The array to inspect.
	* @param {*} key The key to search for.
	* @returns {number} Returns the index of the matched value, else `-1`.
	*/
	function assocIndexOf$1(array, key$1) {
		var length = array.length;
		while (length--) if (eq$1(array[length][0], key$1)) return length;
		return -1;
	}
	/**
	* The base implementation of `_.isNative` without bad shim checks.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a native function,
	*  else `false`.
	*/
	function baseIsNative$1(value) {
		if (!isObject$1(value) || isMasked$1(value)) return false;
		return (isFunction$1(value) || isHostObject(value) ? reIsNative$1 : reIsHostCtor$1).test(toSource$1(value));
	}
	/**
	* The base implementation of `_.set`.
	*
	* @private
	* @param {Object} object The object to modify.
	* @param {Array|string} path The path of the property to set.
	* @param {*} value The value to set.
	* @param {Function} [customizer] The function to customize path creation.
	* @returns {Object} Returns `object`.
	*/
	function baseSet(object, path$19, value, customizer$1) {
		if (!isObject$1(object)) return object;
		path$19 = isKey(path$19, object) ? [path$19] : castPath(path$19);
		var index$1 = -1, length = path$19.length, lastIndex = length - 1, nested = object;
		while (nested != null && ++index$1 < length) {
			var key$1 = toKey(path$19[index$1]), newValue = value;
			if (index$1 != lastIndex) {
				var objValue = nested[key$1];
				newValue = customizer$1 ? customizer$1(objValue, key$1, nested) : void 0;
				if (newValue === void 0) newValue = isObject$1(objValue) ? objValue : isIndex(path$19[index$1 + 1]) ? [] : {};
			}
			assignValue(nested, key$1, newValue);
			nested = nested[key$1];
		}
		return object;
	}
	/**
	* The base implementation of `_.toString` which doesn't convert nullish
	* values to empty strings.
	*
	* @private
	* @param {*} value The value to process.
	* @returns {string} Returns the string.
	*/
	function baseToString(value) {
		if (typeof value == "string") return value;
		if (isSymbol$1$1(value)) return symbolToString ? symbolToString.call(value) : "";
		var result = value + "";
		return result == "0" && 1 / value == -INFINITY ? "-0" : result;
	}
	/**
	* Casts `value` to a path array if it's not one.
	*
	* @private
	* @param {*} value The value to inspect.
	* @returns {Array} Returns the cast property path array.
	*/
	function castPath(value) {
		return isArray$4(value) ? value : stringToPath(value);
	}
	/**
	* Gets the data for `map`.
	*
	* @private
	* @param {Object} map The map to query.
	* @param {string} key The reference key.
	* @returns {*} Returns the map data.
	*/
	function getMapData$1(map$2, key$1) {
		var data = map$2.__data__;
		return isKeyable$1(key$1) ? data[typeof key$1 == "string" ? "string" : "hash"] : data.map;
	}
	/**
	* Gets the native function at `key` of `object`.
	*
	* @private
	* @param {Object} object The object to query.
	* @param {string} key The key of the method to get.
	* @returns {*} Returns the function if it's native, else `undefined`.
	*/
	function getNative$1(object, key$1) {
		var value = getValue$1(object, key$1);
		return baseIsNative$1(value) ? value : void 0;
	}
	/**
	* Checks if `value` is a valid array-like index.
	*
	* @private
	* @param {*} value The value to check.
	* @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	* @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	*/
	function isIndex(value, length) {
		length = length == null ? MAX_SAFE_INTEGER : length;
		return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}
	/**
	* Checks if `value` is a property name and not a property path.
	*
	* @private
	* @param {*} value The value to check.
	* @param {Object} [object] The object to query keys on.
	* @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	*/
	function isKey(value, object) {
		if (isArray$4(value)) return false;
		var type = typeof value;
		if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1$1(value)) return true;
		return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
	}
	/**
	* Checks if `value` is suitable for use as unique object key.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	*/
	function isKeyable$1(value) {
		var type = typeof value;
		return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
	}
	/**
	* Checks if `func` has its source masked.
	*
	* @private
	* @param {Function} func The function to check.
	* @returns {boolean} Returns `true` if `func` is masked, else `false`.
	*/
	function isMasked$1(func) {
		return !!maskSrcKey$1 && maskSrcKey$1 in func;
	}
	/**
	* Converts `string` to a property path array.
	*
	* @private
	* @param {string} string The string to convert.
	* @returns {Array} Returns the property path array.
	*/
	var stringToPath = memoize(function(string) {
		string = toString$2$3(string);
		var result = [];
		if (reLeadingDot.test(string)) result.push("");
		string.replace(rePropName, function(match$1, number, quote$1, string$1) {
			result.push(quote$1 ? string$1.replace(reEscapeChar, "$1") : number || match$1);
		});
		return result;
	});
	/**
	* Converts `value` to a string key if it's not a string or symbol.
	*
	* @private
	* @param {*} value The value to inspect.
	* @returns {string|symbol} Returns the key.
	*/
	function toKey(value) {
		if (typeof value == "string" || isSymbol$1$1(value)) return value;
		var result = value + "";
		return result == "0" && 1 / value == -INFINITY ? "-0" : result;
	}
	/**
	* Converts `func` to its source code.
	*
	* @private
	* @param {Function} func The function to process.
	* @returns {string} Returns the source code.
	*/
	function toSource$1(func) {
		if (func != null) {
			try {
				return funcToString$2.call(func);
			} catch (e) {}
			try {
				return func + "";
			} catch (e) {}
		}
		return "";
	}
	/**
	* Creates a function that memoizes the result of `func`. If `resolver` is
	* provided, it determines the cache key for storing the result based on the
	* arguments provided to the memoized function. By default, the first argument
	* provided to the memoized function is used as the map cache key. The `func`
	* is invoked with the `this` binding of the memoized function.
	*
	* **Note:** The cache is exposed as the `cache` property on the memoized
	* function. Its creation may be customized by replacing the `_.memoize.Cache`
	* constructor with one whose instances implement the
	* [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	* method interface of `delete`, `get`, `has`, and `set`.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Function
	* @param {Function} func The function to have its output memoized.
	* @param {Function} [resolver] The function to resolve the cache key.
	* @returns {Function} Returns the new memoized function.
	* @example
	*
	* var object = { 'a': 1, 'b': 2 };
	* var other = { 'c': 3, 'd': 4 };
	*
	* var values = _.memoize(_.values);
	* values(object);
	* // => [1, 2]
	*
	* values(other);
	* // => [3, 4]
	*
	* object.a = 2;
	* values(object);
	* // => [1, 2]
	*
	* // Modify the result cache.
	* values.cache.set(object, ['a', 'b']);
	* values(object);
	* // => ['a', 'b']
	*
	* // Replace `_.memoize.Cache`.
	* _.memoize.Cache = WeakMap;
	*/
	function memoize(func, resolver) {
		if (typeof func != "function" || resolver && typeof resolver != "function") throw new TypeError(FUNC_ERROR_TEXT);
		var memoized = function() {
			var args = arguments, key$1 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
			if (cache.has(key$1)) return cache.get(key$1);
			var result = func.apply(this, args);
			memoized.cache = cache.set(key$1, result);
			return result;
		};
		memoized.cache = new (memoize.Cache || MapCache$1)();
		return memoized;
	}
	memoize.Cache = MapCache$1;
	/**
	* Performs a
	* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	* comparison between two values to determine if they are equivalent.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to compare.
	* @param {*} other The other value to compare.
	* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	* @example
	*
	* var object = { 'a': 1 };
	* var other = { 'a': 1 };
	*
	* _.eq(object, object);
	* // => true
	*
	* _.eq(object, other);
	* // => false
	*
	* _.eq('a', 'a');
	* // => true
	*
	* _.eq('a', Object('a'));
	* // => false
	*
	* _.eq(NaN, NaN);
	* // => true
	*/
	function eq$1(value, other) {
		return value === other || value !== value && other !== other;
	}
	/**
	* Checks if `value` is classified as an `Array` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an array, else `false`.
	* @example
	*
	* _.isArray([1, 2, 3]);
	* // => true
	*
	* _.isArray(document.body.children);
	* // => false
	*
	* _.isArray('abc');
	* // => false
	*
	* _.isArray(_.noop);
	* // => false
	*/
	var isArray$4 = Array.isArray;
	/**
	* Checks if `value` is classified as a `Function` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a function, else `false`.
	* @example
	*
	* _.isFunction(_);
	* // => true
	*
	* _.isFunction(/abc/);
	* // => false
	*/
	function isFunction$1(value) {
		var tag = isObject$1(value) ? objectToString$1.call(value) : "";
		return tag == funcTag$1 || tag == genTag$1;
	}
	/**
	* Checks if `value` is the
	* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an object, else `false`.
	* @example
	*
	* _.isObject({});
	* // => true
	*
	* _.isObject([1, 2, 3]);
	* // => true
	*
	* _.isObject(_.noop);
	* // => true
	*
	* _.isObject(null);
	* // => false
	*/
	function isObject$1(value) {
		var type = typeof value;
		return !!value && (type == "object" || type == "function");
	}
	/**
	* Checks if `value` is object-like. A value is object-like if it's not `null`
	* and has a `typeof` result of "object".
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	* @example
	*
	* _.isObjectLike({});
	* // => true
	*
	* _.isObjectLike([1, 2, 3]);
	* // => true
	*
	* _.isObjectLike(_.noop);
	* // => false
	*
	* _.isObjectLike(null);
	* // => false
	*/
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	/**
	* Checks if `value` is classified as a `Symbol` primitive or object.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	* @example
	*
	* _.isSymbol(Symbol.iterator);
	* // => true
	*
	* _.isSymbol('abc');
	* // => false
	*/
	function isSymbol$1$1(value) {
		return typeof value == "symbol" || isObjectLike(value) && objectToString$1.call(value) == symbolTag;
	}
	/**
	* Converts `value` to a string. An empty string is returned for `null`
	* and `undefined` values. The sign of `-0` is preserved.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to process.
	* @returns {string} Returns the string.
	* @example
	*
	* _.toString(null);
	* // => ''
	*
	* _.toString(-0);
	* // => '-0'
	*
	* _.toString([1, 2, 3]);
	* // => '1,2,3'
	*/
	function toString$2$3(value) {
		return value == null ? "" : baseToString(value);
	}
	/**
	* Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	* it's created. Arrays are created for missing index properties while objects
	* are created for all other missing properties. Use `_.setWith` to customize
	* `path` creation.
	*
	* **Note:** This method mutates `object`.
	*
	* @static
	* @memberOf _
	* @since 3.7.0
	* @category Object
	* @param {Object} object The object to modify.
	* @param {Array|string} path The path of the property to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns `object`.
	* @example
	*
	* var object = { 'a': [{ 'b': { 'c': 3 } }] };
	*
	* _.set(object, 'a[0].b.c', 4);
	* console.log(object.a[0].b.c);
	* // => 4
	*
	* _.set(object, ['x', '0', 'y', 'z'], 5);
	* console.log(object.x[0].y.z);
	* // => 5
	*/
	function set(object, path$19, value) {
		return object == null ? object : baseSet(object, path$19, value);
	}
	var lodash_set = set;
	const debug$14 = src("nock.common");
	/**
	* Normalizes the request options so that it always has `host` property.
	*
	* @param  {Object} options - a parsed options object of the request
	*/
	function normalizeRequestOptions(options) {
		options.proto = options.proto || "http";
		options.port = options.port || (options.proto === "http" ? 80 : 443);
		if (options.host) {
			debug$14("options.host:", options.host);
			if (!options.hostname) if (options.host.split(":").length === 2) options.hostname = options.host.split(":")[0];
			else options.hostname = options.host;
		}
		debug$14("options.hostname in the end: %j", options.hostname);
		options.host = `${options.hostname || "localhost"}:${options.port}`;
		debug$14("options.host in the end: %j", options.host);
		["hostname", "host"].forEach(function(attr) {
			if (options[attr]) options[attr] = options[attr].toLowerCase();
		});
		return options;
	}
	/**
	* Returns true if the data contained in buffer can be reconstructed
	* from its utf8 representation.
	*
	* @param  {Object} buffer - a Buffer object
	* @returns {boolean}
	*/
	function isUtf8Representable(buffer$5) {
		const utfEncodedBuffer = buffer$5.toString("utf8");
		return Buffer.from(utfEncodedBuffer, "utf8").equals(buffer$5);
	}
	let requestOverrides = {};
	/**
	* Overrides the current `request` function of `http` and `https` modules with
	* our own version which intercepts issues HTTP/HTTPS requests and forwards them
	* to the given `newRequest` function.
	*
	* @param  {Function} newRequest - a function handling requests; it accepts four arguments:
	*   - proto - a string with the overridden module's protocol name (either `http` or `https`)
	*   - overriddenRequest - the overridden module's request function already bound to module's object
	*   - options - the options of the issued request
	*   - callback - the callback of the issued request
	*/
	function overrideRequests(newRequest) {
		debug$14("overriding requests");
		["http", "https"].forEach(function(proto$7) {
			debug$14("- overriding request for", proto$7);
			const moduleName = proto$7;
			const module$2 = {
				http: http$5,
				https
			}[moduleName];
			const overriddenRequest = module$2.request;
			const overriddenGet = module$2.get;
			if (requestOverrides[moduleName]) throw new Error(`Module's request already overridden for ${moduleName} protocol.`);
			requestOverrides[moduleName] = {
				module: module$2,
				request: overriddenRequest,
				get: overriddenGet
			};
			module$2.request = function(input, options, callback) {
				return newRequest(proto$7, overriddenRequest.bind(module$2), [
					input,
					options,
					callback
				]);
			};
			module$2.get = function(input, options, callback) {
				const req$2 = newRequest(proto$7, overriddenGet.bind(module$2), [
					input,
					options,
					callback
				]);
				req$2.end();
				return req$2;
			};
			debug$14("- overridden request for", proto$7);
		});
	}
	/**
	* Restores `request` function of `http` and `https` modules to values they
	* held before they were overridden by us.
	*/
	function restoreOverriddenRequests() {
		debug$14("restoring requests");
		Object.entries(requestOverrides).forEach(([proto$7, { module: module$2, request, get: get$1 }]) => {
			debug$14("- restoring request for", proto$7);
			module$2.request = request;
			module$2.get = get$1;
			debug$14("- restored request for", proto$7);
		});
		requestOverrides = {};
	}
	/**
	* In WHATWG URL vernacular, this returns the origin portion of a URL.
	* However, the port is not included if it's standard and not already present on the host.
	*/
	function normalizeOrigin(proto$7, host, port$6) {
		return `${proto$7}://${host}${host.includes(":") || proto$7 === "http" && (port$6 === 80 || port$6 === "80") || proto$7 === "https" && (port$6 === 443 || port$6 === "443") ? "" : `:${port$6}`}`;
	}
	/**
	* Get high level information about request as string
	* @param  {Object} options
	* @param  {string} options.method
	* @param  {number|string} options.port
	* @param  {string} options.proto Set internally. always http or https
	* @param  {string} options.hostname
	* @param  {string} options.path
	* @param  {Object} options.headers
	* @param  {string} body
	* @return {string}
	*/
	function stringifyRequest(options, body$1) {
		const { method: method$1 = "GET", path: path$19 = "", port: port$6 } = options;
		const log$4 = {
			method: method$1,
			url: `${normalizeOrigin(options.proto, options.hostname, port$6)}${path$19}`,
			headers: options.headers
		};
		if (body$1) log$4.body = body$1;
		return JSON.stringify(log$4, null, 2);
	}
	function isContentEncoded(headers$1) {
		const contentEncoding$2 = headers$1["content-encoding"];
		return typeof contentEncoding$2 === "string" && contentEncoding$2 !== "";
	}
	function contentEncoding(headers$1, encoder) {
		const contentEncoding$2 = headers$1["content-encoding"];
		return contentEncoding$2 !== void 0 && contentEncoding$2.toString() === encoder;
	}
	function isJSONContent(headers$1) {
		return String(headers$1["content-type"] || "").toLowerCase().startsWith("application/json");
	}
	/**
	* Return a new object with all field names of the headers lower-cased.
	*
	* Duplicates throw an error.
	*/
	function headersFieldNamesToLowerCase(headers$1) {
		if (!isPlainObject(headers$1)) throw Error("Headers must be provided as an object");
		const lowerCaseHeaders = {};
		Object.entries(headers$1).forEach(([fieldName, fieldValue]) => {
			const key$1 = fieldName.toLowerCase();
			if (lowerCaseHeaders[key$1] !== void 0) throw Error(`Failed to convert header keys to lower case due to field name conflict: ${key$1}`);
			lowerCaseHeaders[key$1] = fieldValue;
		});
		return lowerCaseHeaders;
	}
	const headersFieldsArrayToLowerCase = (headers$1) => [...new Set(headers$1.map((fieldName) => fieldName.toLowerCase()))];
	/**
	* Converts the various accepted formats of headers into a flat array representing "raw headers".
	*
	* Nock allows headers to be provided as a raw array, a plain object, or a Map.
	*
	* While all the header names are expected to be strings, the values are left intact as they can
	* be functions, strings, or arrays of strings.
	*
	*  https://nodejs.org/api/http.html#http_message_rawheaders
	*/
	function headersInputToRawArray(headers$1) {
		if (headers$1 === void 0) return [];
		if (Array.isArray(headers$1)) {
			if (headers$1.length % 2) throw new Error(`Raw headers must be provided as an array with an even number of items. [fieldName, value, ...]`);
			return [...headers$1];
		}
		if (util$5.types.isMap(headers$1)) return [].concat(...Array.from(headers$1, ([k$7, v]) => [k$7.toString(), v]));
		if (isPlainObject(headers$1)) return [].concat(...Object.entries(headers$1));
		throw new Error(`Headers must be provided as an array of raw values, a Map, or a plain Object. ${headers$1}`);
	}
	/**
	* Converts an array of raw headers to an object, using the same rules as Nodes `http.IncomingMessage.headers`.
	*
	* Header names/keys are lower-cased.
	*/
	function headersArrayToObject(rawHeaders) {
		if (!Array.isArray(rawHeaders)) throw Error("Expected a header array");
		const accumulator = {};
		forEachHeader(rawHeaders, (value, fieldName) => {
			addHeaderLine(accumulator, fieldName, value);
		});
		return accumulator;
	}
	const noDuplicatesHeaders = new Set([
		"age",
		"authorization",
		"content-length",
		"content-type",
		"etag",
		"expires",
		"from",
		"host",
		"if-modified-since",
		"if-unmodified-since",
		"last-modified",
		"location",
		"max-forwards",
		"proxy-authorization",
		"referer",
		"retry-after",
		"user-agent"
	]);
	/**
	* Set key/value data in accordance with Node's logic for folding duplicate headers.
	*
	* The `value` param should be a function, string, or array of strings.
	*
	* Node's docs and source:
	* https://nodejs.org/api/http.html#http_message_headers
	* https://github.com/nodejs/node/blob/908292cf1f551c614a733d858528ffb13fb3a524/lib/_http_incoming.js#L245
	*
	* Header names are lower-cased.
	* Duplicates in raw headers are handled in the following ways, depending on the header name:
	* - Duplicates of field names listed in `noDuplicatesHeaders` (above) are discarded.
	* - `set-cookie` is always an array. Duplicates are added to the array.
	* - For duplicate `cookie` headers, the values are joined together with '; '.
	* - For all other headers, the values are joined together with ', '.
	*
	* Node's implementation is larger because it highly optimizes for not having to call `toLowerCase()`.
	* We've opted to always call `toLowerCase` in exchange for a more concise function.
	*
	* While Node has the luxury of knowing `value` is always a string, we do an extra step of coercion at the top.
	*/
	function addHeaderLine(headers$1, name, value) {
		let values;
		if (typeof value === "function") values = [value.name];
		else if (Array.isArray(value)) values = value.map(String);
		else values = [String(value)];
		const key$1 = name.toLowerCase();
		if (key$1 === "set-cookie") if (headers$1["set-cookie"] === void 0) headers$1["set-cookie"] = values;
		else headers$1["set-cookie"].push(...values);
		else if (noDuplicatesHeaders.has(key$1)) {
			if (headers$1[key$1] === void 0) headers$1[key$1] = values[0];
		} else {
			if (headers$1[key$1] !== void 0) values = [headers$1[key$1], ...values];
			const separator = key$1 === "cookie" ? "; " : ", ";
			headers$1[key$1] = values.join(separator);
		}
	}
	/**
	* Deletes the given `fieldName` property from `headers` object by performing
	* case-insensitive search through keys.
	*
	* @headers   {Object} headers - object of header field names and values
	* @fieldName {String} field name - string with the case-insensitive field name
	*/
	function deleteHeadersField(headers$1, fieldNameToDelete) {
		if (!isPlainObject(headers$1)) throw Error("headers must be an object");
		if (typeof fieldNameToDelete !== "string") throw Error("field name must be a string");
		const lowerCaseFieldNameToDelete = fieldNameToDelete.toLowerCase();
		Object.keys(headers$1).filter((fieldName) => fieldName.toLowerCase() === lowerCaseFieldNameToDelete).forEach((fieldName) => delete headers$1[fieldName]);
	}
	/**
	* Utility for iterating over a raw headers array.
	*
	* The callback is called with:
	*  - The header value. string, array of strings, or a function
	*  - The header field name. string
	*  - Index of the header field in the raw header array.
	*/
	function forEachHeader(rawHeaders, callback) {
		for (let i$8 = 0; i$8 < rawHeaders.length; i$8 += 2) callback(rawHeaders[i$8 + 1], rawHeaders[i$8], i$8);
	}
	function percentDecode(str) {
		try {
			return decodeURIComponent(str.replace(/\+/g, " "));
		} catch (e) {
			return str;
		}
	}
	/**
	* URI encode the provided string, stringently adhering to RFC 3986.
	*
	* RFC 3986 reserves !, ', (, ), and * but encodeURIComponent does not encode them so we do it manually.
	*
	* https://tools.ietf.org/html/rfc3986
	* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
	*/
	function percentEncode(str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
			return `%${c.charCodeAt(0).toString(16).toUpperCase()}`;
		});
	}
	function matchStringOrRegexp(target, pattern) {
		const targetStr = target === void 0 || target === null ? "" : String(target);
		if (pattern instanceof RegExp) {
			pattern.lastIndex = 0;
			return pattern.test(targetStr);
		}
		return targetStr === String(pattern);
	}
	/**
	* Formats a query parameter.
	*
	* @param key                The key of the query parameter to format.
	* @param value              The value of the query parameter to format.
	* @param stringFormattingFn The function used to format string values. Can
	*                           be used to encode or decode the query value.
	*
	* @returns *[] the formatted [key, value] pair.
	*/
	function formatQueryValue(key$1, value, stringFormattingFn) {
		switch (true) {
			case typeof value === "number":
			case typeof value === "boolean":
				value = value.toString();
				break;
			case value === null:
			case value === void 0:
				value = "";
				break;
			case typeof value === "string":
				if (stringFormattingFn) value = stringFormattingFn(value);
				break;
			case value instanceof RegExp: break;
			case Array.isArray(value):
				value = value.map(function(val, idx) {
					return formatQueryValue(idx, val, stringFormattingFn)[1];
				});
				break;
			case typeof value === "object":
				value = Object.entries(value).reduce(function(acc, [subKey, subVal]) {
					const subPair = formatQueryValue(subKey, subVal, stringFormattingFn);
					acc[subPair[0]] = subPair[1];
					return acc;
				}, {});
				break;
		}
		if (stringFormattingFn) key$1 = stringFormattingFn(key$1);
		return [key$1, value];
	}
	function isStream(obj) {
		return obj && typeof obj !== "string" && !Buffer.isBuffer(obj) && typeof obj.setEncoding === "function";
	}
	/**
	* Converts the arguments from the various signatures of http[s].request into a standard
	* options object and an optional callback function.
	*
	* https://nodejs.org/api/http.html#http_http_request_url_options_callback
	*
	* Taken from the beginning of the native `ClientRequest`.
	* https://github.com/nodejs/node/blob/908292cf1f551c614a733d858528ffb13fb3a524/lib/_http_client.js#L68
	*/
	function normalizeClientRequestArgs(input, options, cb) {
		if (typeof input === "string") input = urlToOptions(new url__default.URL(input));
		else if (input instanceof url__default.URL) input = urlToOptions(input);
		else {
			cb = options;
			options = input;
			input = null;
		}
		if (typeof options === "function") {
			cb = options;
			options = input || {};
		} else options = Object.assign(input || {}, options);
		return {
			options,
			callback: cb
		};
	}
	/**
	* Utility function that converts a URL object into an ordinary
	* options object as expected by the http.request and https.request APIs.
	*
	* This was copied from Node's source
	* https://github.com/nodejs/node/blob/908292cf1f551c614a733d858528ffb13fb3a524/lib/internal/url.js#L1257
	*/
	function urlToOptions(url$6) {
		const options = {
			protocol: url$6.protocol,
			hostname: typeof url$6.hostname === "string" && url$6.hostname.startsWith("[") ? url$6.hostname.slice(1, -1) : url$6.hostname,
			hash: url$6.hash,
			search: url$6.search,
			pathname: url$6.pathname,
			path: `${url$6.pathname}${url$6.search || ""}`,
			href: url$6.href
		};
		if (url$6.port !== "") options.port = Number(url$6.port);
		if (url$6.username || url$6.password) options.auth = `${url$6.username}:${url$6.password}`;
		return options;
	}
	/**
	* Determines if request data matches the expected schema.
	*
	* Used for comparing decoded search parameters, request body JSON objects,
	* and URL decoded request form bodies.
	*
	* Performs a general recursive strict comparison with two caveats:
	*  - The expected data can use regexp to compare values
	*  - JSON path notation and nested objects are considered equal
	*/
	const dataEqual = (expected, actual) => {
		if (isPlainObject(expected)) expected = expand(expected);
		if (isPlainObject(actual)) actual = expand(actual);
		return deepEqual(expected, actual);
	};
	/**
	* Converts flat objects whose keys use JSON path notation to nested objects.
	*
	* The input object is not mutated.
	*
	* @example
	* { 'foo[bar][0]': 'baz' } -> { foo: { bar: [ 'baz' ] } }
	*/
	const expand = (input) => Object.entries(input).reduce((acc, [k$7, v]) => lodash_set(acc, k$7, v), {});
	/**
	* Performs a recursive strict comparison between two values.
	*
	* Expected values or leaf nodes of expected object values that are RegExp use test() for comparison.
	*/
	function deepEqual(expected, actual) {
		debug$14("deepEqual comparing", typeof expected, expected, typeof actual, actual);
		if (expected instanceof RegExp) return expected.test(actual);
		if (Array.isArray(expected) && Array.isArray(actual)) {
			if (expected.length !== actual.length) return false;
			return expected.every((expVal, idx) => deepEqual(expVal, actual[idx]));
		}
		if (isPlainObject(expected) && isPlainObject(actual)) return Array.from(new Set(Object.keys(expected).concat(Object.keys(actual)))).every((key$1) => deepEqual(expected[key$1], actual[key$1]));
		return expected === actual;
	}
	/**
	* Checks if `value` is a plain object, that is, an object created by the
	* `Object` constructor or one with a `[[Prototype]]` of `null`.
	* https://github.com/lodash/lodash/blob/588bf3e20db0ae039a822a14a8fa238c5b298e65/isPlainObject.js
	*
	* @param {*} value The value to check.
	* @return {boolean}
	*/
	function isPlainObject(value) {
		const isObjectLike$2 = typeof value === "object" && value !== null;
		const tag = Object.prototype.toString.call(value);
		if (!isObjectLike$2 || tag !== "[object Object]") return false;
		if (Object.getPrototypeOf(value) === null) return true;
		let proto$7 = value;
		while (Object.getPrototypeOf(proto$7) !== null) proto$7 = Object.getPrototypeOf(proto$7);
		return Object.getPrototypeOf(value) === proto$7;
	}
	/**
	* Creates an object with the same keys as `object` and values generated
	* by running each own enumerable string keyed property of `object` thru
	* `iteratee`. (iteration order is not guaranteed)
	* The iteratee is invoked with three arguments: (value, key, object).
	* https://github.com/lodash/lodash/blob/588bf3e20db0ae039a822a14a8fa238c5b298e65/mapValue.js
	*
	* @param {Object} object The object to iterate over.
	* @param {Function} iteratee The function invoked per iteration.
	* @returns {Object} Returns the new mapped object.
	*/
	function mapValue(object, iteratee) {
		object = Object(object);
		const result = {};
		Object.keys(object).forEach((key$1) => {
			result[key$1] = iteratee(object[key$1], key$1, object);
		});
		return result;
	}
	const timeouts = [];
	const intervals = [];
	const immediates = [];
	const wrapTimer = (timer, ids) => (...args) => {
		const id$7 = timer(...args);
		ids.push(id$7);
		return id$7;
	};
	const setTimeout$1 = wrapTimer(timers.setTimeout, timeouts);
	const setInterval = wrapTimer(timers.setInterval, intervals);
	const setImmediate$1 = wrapTimer(timers.setImmediate, immediates);
	function clearTimer(clear$1, ids) {
		while (ids.length) clear$1(ids.shift());
	}
	function removeAllTimers() {
		clearTimer(clearTimeout, timeouts);
		clearTimer(clearInterval, intervals);
		clearTimer(clearImmediate, immediates);
	}
	/**
	* Check if the Client Request has been cancelled.
	*
	* Until Node 14 is the minimum, we need to look at both flags to see if the request has been cancelled.
	* The two flags have the same purpose, but the Node maintainers are migrating from `abort(ed)` to
	* `destroy(ed)` terminology, to be more consistent with `stream.Writable`.
	* In Node 14.x+, Calling `abort()` will set both `aborted` and `destroyed` to true, however,
	* calling `destroy()` will only set `destroyed` to true.
	* Falling back on checking if the socket is destroyed to cover the case of Node <14.x where
	* `destroy()` is called, but `destroyed` is undefined.
	*
	* Node Client Request history:
	* - `request.abort()`: Added in: v0.3.8, Deprecated since: v14.1.0, v13.14.0
	* - `request.aborted`: Added in: v0.11.14, Became a boolean instead of a timestamp: v11.0.0, Not deprecated (yet)
	* - `request.destroy()`: Added in: v0.3.0
	* - `request.destroyed`: Added in: v14.1.0, v13.14.0
	*
	* @param {ClientRequest} req
	* @returns {boolean}
	*/
	function isRequestDestroyed(req$2) {
		return !!(req$2.destroyed === true || req$2.aborted || req$2.socket && req$2.socket.destroyed);
	}
	var common$1 = {
		contentEncoding,
		dataEqual,
		deleteHeadersField,
		forEachHeader,
		formatQueryValue,
		headersArrayToObject,
		headersFieldNamesToLowerCase,
		headersFieldsArrayToLowerCase,
		headersInputToRawArray,
		isContentEncoded,
		isJSONContent,
		isPlainObject,
		isRequestDestroyed,
		isStream,
		isUtf8Representable,
		mapValue,
		matchStringOrRegexp,
		normalizeClientRequestArgs,
		normalizeOrigin,
		normalizeRequestOptions,
		overrideRequests,
		percentDecode,
		percentEncode,
		removeAllTimers,
		restoreOverriddenRequests,
		setImmediate: setImmediate$1,
		setInterval,
		setTimeout: setTimeout$1,
		stringifyRequest
	};
	var common_10 = common$1.isContentEncoded;
	var common_15 = common$1.isUtf8Representable;
	var common_18 = common$1.normalizeClientRequestArgs;
	/**
	* Generate an absolute url from options passed into `new http.ClientRequest`.
	*
	* @export
	* @param {Object} [options]
	* @returns {string}
	*/
	function getUrlFromOptions(options = {}) {
		if (options.href) return options.href;
		const protocol = options.protocol || `${options.proto}:` || "http:";
		const host = options.hostname || options.host || "localhost";
		const { path: path$19, port: port$6 } = options;
		const url$6 = new utils$5.URL();
		url$6.set("protocol", protocol);
		url$6.set("host", host);
		url$6.set("pathname", path$19);
		if (port$6 && !host.includes(":") && (port$6 !== 80 || protocol !== "http:") && (port$6 !== 443 || protocol !== "https:")) url$6.set("port", port$6);
		return url$6.href;
	}
	/**
	* Merge an array of strings into a single string or concat an array
	* of buffers into a single buffer.
	*
	* @export
	* @param {string[] | Buffer[]} [chunks]
	* @returns {string | Buffer}
	*/
	function mergeChunks(chunks) {
		if (!chunks || chunks.length === 0) return Buffer.alloc(0);
		if (!Buffer.isBuffer(chunks[0])) return chunks.join("");
		return Buffer.concat(chunks);
	}
	/**
	* Utility function that converts a URL object into an ordinary
	* options object as expected by the http.request and https.request APIs.
	*
	* This was copied from Node's source
	* https://github.com/nodejs/node/blob/908292cf1f551c614a733d858528ffb13fb3a524/lib/internal/url.js#L1257
	*/
	function urlToOptions$1(url$6) {
		const options = {
			protocol: url$6.protocol,
			hostname: typeof url$6.hostname === "string" && url$6.hostname.startsWith("[") ? url$6.hostname.slice(1, -1) : url$6.hostname,
			hash: url$6.hash,
			search: url$6.search,
			pathname: url$6.pathname,
			path: `${url$6.pathname}${url$6.search || ""}`,
			href: url$6.href
		};
		if (url$6.port !== "") options.port = Number(url$6.port);
		if (url$6.username || url$6.password) options.auth = `${url$6.username}:${url$6.password}`;
		return options;
	}
	function ownKeys$4(object, enumerableOnly) {
		var keys$6 = keys$1$3(object);
		if (getOwnPropertySymbols$1$3) {
			var symbols = getOwnPropertySymbols$1$3(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1$3(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$4(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$4(Object(source), true).forEach(function(key$1) {
				_defineProperty$3(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1$3) defineProperties$1$3(target, getOwnPropertyDescriptors$1$3(source));
			else ownKeys$4(Object(source)).forEach(function(key$1) {
				defineProperty$2$6(target, key$1, getOwnPropertyDescriptor$1$3(source, key$1));
			});
		}
		return target;
	}
	const IS_STUBBED$1 = symbol$1$1();
	const ABORT_HANDLER$1 = symbol$1$1();
	const REQUEST_ARGUMENTS$1 = new weakMap$1();
	nock.restore();
	var HttpAdapter = class extends Adapter$1 {
		static get id() {
			return "node-http";
		}
		onConnect() {
			this.assert("Running concurrent node-http adapters is unsupported, stop any running Polly instances.", !http$5.ClientRequest[IS_STUBBED$1]);
			this.assert("Running nock concurrently with the node-http adapter is unsupported. Run nock.restore() before connecting to this adapter.", !nock.isActive());
			this.NativeClientRequest = http$5.ClientRequest;
			this.setupNock();
			this.patchOverriddenMethods();
		}
		onDisconnect() {
			this.unpatchOverriddenMethods();
			nock.cleanAll();
			nock.restore();
			this.NativeClientRequest = null;
		}
		setupNock() {
			const adapter = this;
			nock.cleanAll();
			const interceptor = nock(/.*/).persist();
			utils$5.HTTP_METHODS.forEach((m$3) => {
				interceptor.intercept(/.*/, m$3).reply(function(_, _body, respond) {
					const { req: req$2, method: method$1 } = this;
					const { headers: headers$1 } = req$2;
					const parsedArguments = common_18(...REQUEST_ARGUMENTS$1.get(req$2));
					const url$6 = getUrlFromOptions(parsedArguments.options);
					const requestBodyBuffer = Buffer.concat(req$2.requestBodyBuffers);
					const body$1 = common_15(requestBodyBuffer) ? requestBodyBuffer.toString("utf8") : requestBodyBuffer;
					adapter.handleRequest({
						url: url$6,
						method: method$1,
						headers: headers$1,
						body: body$1,
						requestArguments: {
							req: req$2,
							body: body$1,
							respond,
							parsedArguments
						}
					});
				});
			});
			nock.activate();
		}
		patchOverriddenMethods() {
			const modules$1 = {
				http: http$5,
				https
			};
			const { ClientRequest: ClientRequest$1 } = http$5;
			http$5.ClientRequest = function _ClientRequest() {
				const req$2 = new ClientRequest$1(...arguments);
				REQUEST_ARGUMENTS$1.set(req$2, [...arguments]);
				return req$2;
			};
			http$5.ClientRequest[IS_STUBBED$1] = true;
			keys$1$3(modules$1).forEach((moduleName) => {
				const module$2 = modules$1[moduleName];
				const { request, get: get$1, globalAgent } = module$2;
				this[moduleName] = {
					get: get$1,
					request
				};
				function parseArgs() {
					const args = common_18(...arguments);
					if (moduleName === "https") args.options = _objectSpread$4(_objectSpread$4({}, {
						port: 443,
						protocol: "https:",
						_defaultAgent: globalAgent
					}), args.options);
					else args.options = _objectSpread$4(_objectSpread$4({}, {
						port: 80,
						protocol: "http:"
					}), args.options);
					return args;
				}
				module$2.request = function _request() {
					const { options, callback } = parseArgs(...arguments);
					return request(options, callback);
				};
				module$2.get = function _get() {
					const { options, callback } = parseArgs(...arguments);
					return get$1(options, callback);
				};
			});
		}
		unpatchOverriddenMethods() {
			const modules$1 = {
				http: http$5,
				https
			};
			keys$1$3(modules$1).forEach((moduleName) => {
				const module$2 = modules$1[moduleName];
				module$2.request = this[moduleName].request;
				module$2.get = this[moduleName].get;
				this[moduleName] = void 0;
			});
		}
		onRequest(pollyRequest) {
			const { req: req$2 } = pollyRequest.requestArguments;
			if (req$2.aborted) pollyRequest.abort();
			else {
				pollyRequest[ABORT_HANDLER$1] = () => {
					if (!pollyRequest.aborted && (req$2.aborted || req$2.destroyed)) pollyRequest.abort();
				};
				req$2.once("abort", pollyRequest[ABORT_HANDLER$1]);
				req$2.once("close", pollyRequest[ABORT_HANDLER$1]);
			}
		}
		async onFetchResponse(pollyRequest) {
			const { parsedArguments } = pollyRequest.requestArguments;
			const { method: method$1, headers: headers$1, body: body$1 } = pollyRequest;
			const { options } = parsedArguments;
			const request = new this.NativeClientRequest(_objectSpread$4(_objectSpread$4({}, options), {}, {
				method: method$1,
				headers: _objectSpread$4({}, headers$1)
			}, urlToOptions$1(new url$2.URL(pollyRequest.url))));
			const chunks = this.getChunksFromBody(body$1, headers$1);
			const responsePromise = new promise$1$2((resolve$6, reject) => {
				request.once("response", resolve$6);
				request.once("error", reject);
				request.once("timeout", reject);
			});
			chunks.forEach((chunk) => request.write(chunk));
			request.end();
			const response = await responsePromise;
			const responseBody = await new promise$1$2((resolve$6, reject) => {
				const chunks$1 = [];
				response.on("data", (chunk) => chunks$1.push(chunk));
				response.once("end", () => resolve$6(this.getBodyFromChunks(chunks$1, response.headers)));
				response.once("error", reject);
			});
			return {
				headers: response.headers,
				statusCode: response.statusCode,
				body: responseBody.body,
				encoding: responseBody.encoding
			};
		}
		async onRespond(pollyRequest, error) {
			const { req: req$2, respond } = pollyRequest.requestArguments;
			const { statusCode, body: body$1, headers: headers$1, encoding } = pollyRequest.response;
			if (pollyRequest[ABORT_HANDLER$1]) {
				req$2.off("abort", pollyRequest[ABORT_HANDLER$1]);
				req$2.off("close", pollyRequest[ABORT_HANDLER$1]);
			}
			if (pollyRequest.aborted) {
				respond(null, [
					0,
					void 0,
					{}
				]);
				return;
			}
			if (error) {
				respond(error);
				return;
			}
			const chunks = this.getChunksFromBody(body$1, headers$1, encoding);
			const stream$1$1 = new stream$1.Readable();
			chunks.forEach((chunk) => stream$1$1.push(chunk));
			stream$1$1.push(null);
			const requestFinishedPromise = new promise$1$2((resolve$6) => {
				if (req$2.aborted) resolve$6();
				else {
					req$2.once("response", resolve$6);
					req$2.once("abort", resolve$6);
					req$2.once("error", resolve$6);
				}
			});
			respond(null, [
				statusCode,
				stream$1$1,
				headers$1
			]);
			await requestFinishedPromise;
		}
		getBodyFromChunks(chunks, headers$1) {
			if (common_10(headers$1)) return {
				encoding: "base64",
				body: stringify$1$1(chunks.map((chunk) => {
					if (!Buffer.isBuffer(chunk)) {
						this.assert("content-encoded responses must all be binary buffers", typeof chunk === "string");
						chunk = Buffer.from(chunk);
					}
					return chunk.toString("base64");
				}))
			};
			const buffer$5 = mergeChunks(chunks);
			const isBinaryBuffer = !common_15(buffer$5);
			return {
				encoding: isBinaryBuffer ? "base64" : void 0,
				body: buffer$5.toString(isBinaryBuffer ? "base64" : "utf8")
			};
		}
		getChunksFromBody(body$1, headers$1, encoding) {
			if (!body$1) return [];
			if (Buffer.isBuffer(body$1)) return [body$1];
			if (common_10(headers$1)) return JSON.parse(body$1).map((chunk) => Buffer.from(chunk, encoding));
			return [Buffer.from(body$1, encoding ? encoding : "utf8")];
		}
	};
	module.exports = HttpAdapter;
}) });

//#endregion
//#region ../../node_modules/.pnpm/to-arraybuffer@1.0.1/node_modules/to-arraybuffer/index.js
var require_to_arraybuffer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/to-arraybuffer@1.0.1/node_modules/to-arraybuffer/index.js": ((exports, module) => {
	var Buffer$16 = __require("buffer").Buffer;
	module.exports = function(buf) {
		if (buf instanceof Uint8Array) {
			if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) return buf.buffer;
			else if (typeof buf.buffer.slice === "function") return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		}
		if (Buffer$16.isBuffer(buf)) {
			var arrayCopy = new Uint8Array(buf.length);
			var len$1 = buf.length;
			for (var i$8 = 0; i$8 < len$1; i$8++) arrayCopy[i$8] = buf[i$8];
			return arrayCopy.buffer;
		} else throw new Error("Argument must be a Buffer");
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/@pollyjs+adapter-fetch@6.0.7/node_modules/@pollyjs/adapter-fetch/dist/cjs/pollyjs-adapter-fetch.js
var require_pollyjs_adapter_fetch = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/@pollyjs+adapter-fetch@6.0.7/node_modules/@pollyjs/adapter-fetch/dist/cjs/pollyjs-adapter-fetch.js": ((exports, module) => {
	function _interopDefault$3(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var Adapter = _interopDefault$3(require_pollyjs_adapter());
	var utils$4 = require_pollyjs_utils();
	var bufferToArrayBuffer = _interopDefault$3(require_to_arraybuffer());
	var _defined$2 = function(it) {
		if (it == void 0) throw TypeError("Can't call method on  " + it);
		return it;
	};
	var _toObject$2 = function(it) {
		return Object(_defined$2(it));
	};
	var hasOwnProperty$6 = {}.hasOwnProperty;
	var _has$2 = function(it, key$1) {
		return hasOwnProperty$6.call(it, key$1);
	};
	var toString$7 = {}.toString;
	var _cof$2 = function(it) {
		return toString$7.call(it).slice(8, -1);
	};
	var _iobject$2 = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
		return _cof$2(it) == "String" ? it.split("") : Object(it);
	};
	var _toIobject$2 = function(it) {
		return _iobject$2(_defined$2(it));
	};
	var ceil$2 = Math.ceil;
	var floor$2 = Math.floor;
	var _toInteger$2 = function(it) {
		return isNaN(it = +it) ? 0 : (it > 0 ? floor$2 : ceil$2)(it);
	};
	var min$4 = Math.min;
	var _toLength$2 = function(it) {
		return it > 0 ? min$4(_toInteger$2(it), 9007199254740991) : 0;
	};
	var max$2 = Math.max;
	var min$1$5 = Math.min;
	var _toAbsoluteIndex$2 = function(index$1, length) {
		index$1 = _toInteger$2(index$1);
		return index$1 < 0 ? max$2(index$1 + length, 0) : min$1$5(index$1, length);
	};
	var _arrayIncludes$2 = function(IS_INCLUDES) {
		return function($this, el, fromIndex) {
			var O = _toIobject$2($this);
			var length = _toLength$2(O.length);
			var index$1 = _toAbsoluteIndex$2(fromIndex, length);
			var value;
			if (IS_INCLUDES && el != el) while (length > index$1) {
				value = O[index$1++];
				if (value != value) return true;
			}
			else for (; length > index$1; index$1++) if (IS_INCLUDES || index$1 in O) {
				if (O[index$1] === el) return IS_INCLUDES || index$1 || 0;
			}
			return !IS_INCLUDES && -1;
		};
	};
	var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
	function unwrapExports$2(x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
	}
	function createCommonjsModule$2(fn, module$2) {
		return module$2 = { exports: {} }, fn(module$2, module$2.exports), module$2.exports;
	}
	function getCjsExportFromNamespace$1(n) {
		return n && n["default"] || n;
	}
	var _core$2 = createCommonjsModule$2(function(module$2) {
		var core = module$2.exports = { version: "2.6.9" };
		if (typeof __e == "number") __e = core;
	});
	_core$2.version;
	var _global$2 = createCommonjsModule$2(function(module$2) {
		var global$1 = module$2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
		if (typeof __g == "number") __g = global$1;
	});
	var _library$2 = true;
	var _shared$2 = createCommonjsModule$2(function(module$2) {
		var SHARED = "__core-js_shared__";
		var store = _global$2[SHARED] || (_global$2[SHARED] = {});
		(module$2.exports = function(key$1, value) {
			return store[key$1] || (store[key$1] = value !== void 0 ? value : {});
		})("versions", []).push({
			version: _core$2.version,
			mode: "pure",
			copyright: " 2019 Denis Pushkarev (zloirock.ru)"
		});
	});
	var id$2 = 0;
	var px$2 = Math.random();
	var _uid$2 = function(key$1) {
		return "Symbol(".concat(key$1 === void 0 ? "" : key$1, ")_", (++id$2 + px$2).toString(36));
	};
	var shared$2 = _shared$2("keys");
	var _sharedKey$2 = function(key$1) {
		return shared$2[key$1] || (shared$2[key$1] = _uid$2(key$1));
	};
	var arrayIndexOf$2 = _arrayIncludes$2(false);
	var IE_PROTO$3 = _sharedKey$2("IE_PROTO");
	var _objectKeysInternal$2 = function(object, names) {
		var O = _toIobject$2(object);
		var i$8 = 0;
		var result = [];
		var key$1;
		for (key$1 in O) if (key$1 != IE_PROTO$3) _has$2(O, key$1) && result.push(key$1);
		while (names.length > i$8) if (_has$2(O, key$1 = names[i$8++])) ~arrayIndexOf$2(result, key$1) || result.push(key$1);
		return result;
	};
	var _enumBugKeys$2 = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
	var _objectKeys$2 = Object.keys || function keys$6(O) {
		return _objectKeysInternal$2(O, _enumBugKeys$2);
	};
	var _aFunction$2 = function(it) {
		if (typeof it != "function") throw TypeError(it + " is not a function!");
		return it;
	};
	var _ctx$2 = function(fn, that, length) {
		_aFunction$2(fn);
		if (that === void 0) return fn;
		switch (length) {
			case 1: return function(a) {
				return fn.call(that, a);
			};
			case 2: return function(a, b) {
				return fn.call(that, a, b);
			};
			case 3: return function(a, b, c) {
				return fn.call(that, a, b, c);
			};
		}
		return function() {
			return fn.apply(that, arguments);
		};
	};
	var _isObject$2 = function(it) {
		return typeof it === "object" ? it !== null : typeof it === "function";
	};
	var _anObject$2 = function(it) {
		if (!_isObject$2(it)) throw TypeError(it + " is not an object!");
		return it;
	};
	var _fails$2 = function(exec) {
		try {
			return !!exec();
		} catch (e) {
			return true;
		}
	};
	var _descriptors$2 = !_fails$2(function() {
		return Object.defineProperty({}, "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var document$1$3 = _global$2.document;
	var is$3 = _isObject$2(document$1$3) && _isObject$2(document$1$3.createElement);
	var _domCreate$2 = function(it) {
		return is$3 ? document$1$3.createElement(it) : {};
	};
	var _ie8DomDefine$2 = !_descriptors$2 && !_fails$2(function() {
		return Object.defineProperty(_domCreate$2("div"), "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var _toPrimitive$2 = function(it, S) {
		if (!_isObject$2(it)) return it;
		var fn, val;
		if (S && typeof (fn = it.toString) == "function" && !_isObject$2(val = fn.call(it))) return val;
		if (typeof (fn = it.valueOf) == "function" && !_isObject$2(val = fn.call(it))) return val;
		if (!S && typeof (fn = it.toString) == "function" && !_isObject$2(val = fn.call(it))) return val;
		throw TypeError("Can't convert object to primitive value");
	};
	var dP$4 = Object.defineProperty;
	var _objectDp$2 = { f: _descriptors$2 ? Object.defineProperty : function defineProperty$8(O, P, Attributes) {
		_anObject$2(O);
		P = _toPrimitive$2(P, true);
		_anObject$2(Attributes);
		if (_ie8DomDefine$2) try {
			return dP$4(O, P, Attributes);
		} catch (e) {}
		if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
		if ("value" in Attributes) O[P] = Attributes.value;
		return O;
	} };
	var _propertyDesc$2 = function(bitmap, value) {
		return {
			enumerable: !(bitmap & 1),
			configurable: !(bitmap & 2),
			writable: !(bitmap & 4),
			value
		};
	};
	var _hide$2 = _descriptors$2 ? function(object, key$1, value) {
		return _objectDp$2.f(object, key$1, _propertyDesc$2(1, value));
	} : function(object, key$1, value) {
		object[key$1] = value;
		return object;
	};
	var PROTOTYPE$5 = "prototype";
	var $export$2 = function(type, name, source) {
		var IS_FORCED = type & $export$2.F;
		var IS_GLOBAL = type & $export$2.G;
		var IS_STATIC = type & $export$2.S;
		var IS_PROTO = type & $export$2.P;
		var IS_BIND = type & $export$2.B;
		var IS_WRAP = type & $export$2.W;
		var exports$1 = IS_GLOBAL ? _core$2 : _core$2[name] || (_core$2[name] = {});
		var expProto = exports$1[PROTOTYPE$5];
		var target = IS_GLOBAL ? _global$2 : IS_STATIC ? _global$2[name] : (_global$2[name] || {})[PROTOTYPE$5];
		var key$1, own, out;
		if (IS_GLOBAL) source = name;
		for (key$1 in source) {
			own = !IS_FORCED && target && target[key$1] !== void 0;
			if (own && _has$2(exports$1, key$1)) continue;
			out = own ? target[key$1] : source[key$1];
			exports$1[key$1] = IS_GLOBAL && typeof target[key$1] != "function" ? source[key$1] : IS_BIND && own ? _ctx$2(out, _global$2) : IS_WRAP && target[key$1] == out ? (function(C) {
				var F = function(a, b, c) {
					if (this instanceof C) {
						switch (arguments.length) {
							case 0: return new C();
							case 1: return new C(a);
							case 2: return new C(a, b);
						}
						return new C(a, b, c);
					}
					return C.apply(this, arguments);
				};
				F[PROTOTYPE$5] = C[PROTOTYPE$5];
				return F;
			})(out) : IS_PROTO && typeof out == "function" ? _ctx$2(Function.call, out) : out;
			if (IS_PROTO) {
				(exports$1.virtual || (exports$1.virtual = {}))[key$1] = out;
				if (type & $export$2.R && expProto && !expProto[key$1]) _hide$2(expProto, key$1, out);
			}
		}
	};
	$export$2.F = 1;
	$export$2.G = 2;
	$export$2.S = 4;
	$export$2.P = 8;
	$export$2.B = 16;
	$export$2.W = 32;
	$export$2.U = 64;
	$export$2.R = 128;
	var _export$2 = $export$2;
	var _objectSap$2 = function(KEY, exec) {
		var fn = (_core$2.Object || {})[KEY] || Object[KEY];
		var exp = {};
		exp[KEY] = exec(fn);
		_export$2(_export$2.S + _export$2.F * _fails$2(function() {
			fn(1);
		}), "Object", exp);
	};
	_objectSap$2("keys", function() {
		return function keys$6(it) {
			return _objectKeys$2(_toObject$2(it));
		};
	});
	var keys$1$2 = _core$2.Object.keys;
	var _redefine$2 = _hide$2;
	var _meta$2 = createCommonjsModule$2(function(module$2) {
		var META$7 = _uid$2("meta");
		var setDesc = _objectDp$2.f;
		var id$7 = 0;
		var isExtensible = Object.isExtensible || function() {
			return true;
		};
		var FREEZE = !_fails$2(function() {
			return isExtensible(Object.preventExtensions({}));
		});
		var setMeta = function(it) {
			setDesc(it, META$7, { value: {
				i: "O" + ++id$7,
				w: {}
			} });
		};
		var fastKey$2 = function(it, create) {
			if (!_isObject$2(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
			if (!_has$2(it, META$7)) {
				if (!isExtensible(it)) return "F";
				if (!create) return "E";
				setMeta(it);
			}
			return it[META$7].i;
		};
		var getWeak$2 = function(it, create) {
			if (!_has$2(it, META$7)) {
				if (!isExtensible(it)) return true;
				if (!create) return false;
				setMeta(it);
			}
			return it[META$7].w;
		};
		var onFreeze = function(it) {
			if (FREEZE && meta.NEED && isExtensible(it) && !_has$2(it, META$7)) setMeta(it);
			return it;
		};
		var meta = module$2.exports = {
			KEY: META$7,
			NEED: false,
			fastKey: fastKey$2,
			getWeak: getWeak$2,
			onFreeze
		};
	});
	_meta$2.KEY;
	_meta$2.NEED;
	_meta$2.fastKey;
	_meta$2.getWeak;
	_meta$2.onFreeze;
	var _wks$2 = createCommonjsModule$2(function(module$2) {
		var store = _shared$2("wks");
		var Symbol$2 = _global$2.Symbol;
		var USE_SYMBOL = typeof Symbol$2 == "function";
		var $exports = module$2.exports = function(name) {
			return store[name] || (store[name] = USE_SYMBOL && Symbol$2[name] || (USE_SYMBOL ? Symbol$2 : _uid$2)("Symbol." + name));
		};
		$exports.store = store;
	});
	var def$2 = _objectDp$2.f;
	var TAG$2 = _wks$2("toStringTag");
	var _setToStringTag$2 = function(it, tag, stat$4) {
		if (it && !_has$2(it = stat$4 ? it : it.prototype, TAG$2)) def$2(it, TAG$2, {
			configurable: true,
			value: tag
		});
	};
	var _wksExt$2 = { f: _wks$2 };
	var defineProperty$3 = _objectDp$2.f;
	var _wksDefine$2 = function(name) {
		var $Symbol$7 = _core$2.Symbol || (_core$2.Symbol = {});
		if (name.charAt(0) != "_" && !(name in $Symbol$7)) defineProperty$3($Symbol$7, name, { value: _wksExt$2.f(name) });
	};
	var _objectGops$2 = { f: Object.getOwnPropertySymbols };
	var _objectPie$2 = { f: {}.propertyIsEnumerable };
	var _enumKeys$2 = function(it) {
		var result = _objectKeys$2(it);
		var getSymbols = _objectGops$2.f;
		if (getSymbols) {
			var symbols = getSymbols(it);
			var isEnum$7 = _objectPie$2.f;
			var i$8 = 0;
			var key$1;
			while (symbols.length > i$8) if (isEnum$7.call(it, key$1 = symbols[i$8++])) result.push(key$1);
		}
		return result;
	};
	var _isArray$2 = Array.isArray || function isArray$11(arg) {
		return _cof$2(arg) == "Array";
	};
	var _objectDps$2 = _descriptors$2 ? Object.defineProperties : function defineProperties(O, Properties) {
		_anObject$2(O);
		var keys$6 = _objectKeys$2(Properties);
		var length = keys$6.length;
		var i$8 = 0;
		var P;
		while (length > i$8) _objectDp$2.f(O, P = keys$6[i$8++], Properties[P]);
		return O;
	};
	var document$2$1 = _global$2.document;
	var _html$2 = document$2$1 && document$2$1.documentElement;
	var IE_PROTO$1$4 = _sharedKey$2("IE_PROTO");
	var Empty$2 = function() {};
	var PROTOTYPE$1$6 = "prototype";
	var createDict$2 = function() {
		var iframe = _domCreate$2("iframe");
		var i$8 = _enumBugKeys$2.length;
		var lt = "<";
		var gt = ">";
		var iframeDocument;
		iframe.style.display = "none";
		_html$2.appendChild(iframe);
		iframe.src = "javascript:";
		iframeDocument = iframe.contentWindow.document;
		iframeDocument.open();
		iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
		iframeDocument.close();
		createDict$2 = iframeDocument.F;
		while (i$8--) delete createDict$2[PROTOTYPE$1$6][_enumBugKeys$2[i$8]];
		return createDict$2();
	};
	var _objectCreate$2 = Object.create || function create(O, Properties) {
		var result;
		if (O !== null) {
			Empty$2[PROTOTYPE$1$6] = _anObject$2(O);
			result = new Empty$2();
			Empty$2[PROTOTYPE$1$6] = null;
			result[IE_PROTO$1$4] = O;
		} else result = createDict$2();
		return Properties === void 0 ? result : _objectDps$2(result, Properties);
	};
	var hiddenKeys$2 = _enumBugKeys$2.concat("length", "prototype");
	var _objectGopn$2 = { f: Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		return _objectKeysInternal$2(O, hiddenKeys$2);
	} };
	var gOPN$4 = _objectGopn$2.f;
	var toString$1$8 = {}.toString;
	var windowNames$2 = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
	var getWindowNames$2 = function(it) {
		try {
			return gOPN$4(it);
		} catch (e) {
			return windowNames$2.slice();
		}
	};
	var _objectGopnExt$2 = { f: function getOwnPropertyNames(it) {
		return windowNames$2 && toString$1$8.call(it) == "[object Window]" ? getWindowNames$2(it) : gOPN$4(_toIobject$2(it));
	} };
	var gOPD$4 = Object.getOwnPropertyDescriptor;
	var _objectGopd$2 = { f: _descriptors$2 ? gOPD$4 : function getOwnPropertyDescriptor(O, P) {
		O = _toIobject$2(O);
		P = _toPrimitive$2(P, true);
		if (_ie8DomDefine$2) try {
			return gOPD$4(O, P);
		} catch (e) {}
		if (_has$2(O, P)) return _propertyDesc$2(!_objectPie$2.f.call(O, P), O[P]);
	} };
	var META$2 = _meta$2.KEY;
	var gOPD$1$5 = _objectGopd$2.f;
	var dP$1$5 = _objectDp$2.f;
	var gOPN$1$5 = _objectGopnExt$2.f;
	var $Symbol$2 = _global$2.Symbol;
	var $JSON$2 = _global$2.JSON;
	var _stringify$2 = $JSON$2 && $JSON$2.stringify;
	var PROTOTYPE$2$4 = "prototype";
	var HIDDEN$2 = _wks$2("_hidden");
	var TO_PRIMITIVE$2 = _wks$2("toPrimitive");
	var isEnum$2 = {}.propertyIsEnumerable;
	var SymbolRegistry$2 = _shared$2("symbol-registry");
	var AllSymbols$2 = _shared$2("symbols");
	var OPSymbols$2 = _shared$2("op-symbols");
	var ObjectProto$2 = Object[PROTOTYPE$2$4];
	var USE_NATIVE$2 = typeof $Symbol$2 == "function" && !!_objectGops$2.f;
	var QObject$2 = _global$2.QObject;
	var setter$2 = !QObject$2 || !QObject$2[PROTOTYPE$2$4] || !QObject$2[PROTOTYPE$2$4].findChild;
	var setSymbolDesc$2 = _descriptors$2 && _fails$2(function() {
		return _objectCreate$2(dP$1$5({}, "a", { get: function() {
			return dP$1$5(this, "a", { value: 7 }).a;
		} })).a != 7;
	}) ? function(it, key$1, D) {
		var protoDesc = gOPD$1$5(ObjectProto$2, key$1);
		if (protoDesc) delete ObjectProto$2[key$1];
		dP$1$5(it, key$1, D);
		if (protoDesc && it !== ObjectProto$2) dP$1$5(ObjectProto$2, key$1, protoDesc);
	} : dP$1$5;
	var wrap$5 = function(tag) {
		var sym = AllSymbols$2[tag] = _objectCreate$2($Symbol$2[PROTOTYPE$2$4]);
		sym._k = tag;
		return sym;
	};
	var isSymbol$2 = USE_NATIVE$2 && typeof $Symbol$2.iterator == "symbol" ? function(it) {
		return typeof it == "symbol";
	} : function(it) {
		return it instanceof $Symbol$2;
	};
	var $defineProperty$2 = function defineProperty$8(it, key$1, D) {
		if (it === ObjectProto$2) $defineProperty$2(OPSymbols$2, key$1, D);
		_anObject$2(it);
		key$1 = _toPrimitive$2(key$1, true);
		_anObject$2(D);
		if (_has$2(AllSymbols$2, key$1)) {
			if (!D.enumerable) {
				if (!_has$2(it, HIDDEN$2)) dP$1$5(it, HIDDEN$2, _propertyDesc$2(1, {}));
				it[HIDDEN$2][key$1] = true;
			} else {
				if (_has$2(it, HIDDEN$2) && it[HIDDEN$2][key$1]) it[HIDDEN$2][key$1] = false;
				D = _objectCreate$2(D, { enumerable: _propertyDesc$2(0, false) });
			}
			return setSymbolDesc$2(it, key$1, D);
		}
		return dP$1$5(it, key$1, D);
	};
	var $defineProperties$2 = function defineProperties(it, P) {
		_anObject$2(it);
		var keys$6 = _enumKeys$2(P = _toIobject$2(P));
		var i$8 = 0;
		var l = keys$6.length;
		var key$1;
		while (l > i$8) $defineProperty$2(it, key$1 = keys$6[i$8++], P[key$1]);
		return it;
	};
	var $create$2 = function create(it, P) {
		return P === void 0 ? _objectCreate$2(it) : $defineProperties$2(_objectCreate$2(it), P);
	};
	var $propertyIsEnumerable$2 = function propertyIsEnumerable$1(key$1) {
		var E = isEnum$2.call(this, key$1 = _toPrimitive$2(key$1, true));
		if (this === ObjectProto$2 && _has$2(AllSymbols$2, key$1) && !_has$2(OPSymbols$2, key$1)) return false;
		return E || !_has$2(this, key$1) || !_has$2(AllSymbols$2, key$1) || _has$2(this, HIDDEN$2) && this[HIDDEN$2][key$1] ? E : true;
	};
	var $getOwnPropertyDescriptor$4 = function getOwnPropertyDescriptor(it, key$1) {
		it = _toIobject$2(it);
		key$1 = _toPrimitive$2(key$1, true);
		if (it === ObjectProto$2 && _has$2(AllSymbols$2, key$1) && !_has$2(OPSymbols$2, key$1)) return;
		var D = gOPD$1$5(it, key$1);
		if (D && _has$2(AllSymbols$2, key$1) && !(_has$2(it, HIDDEN$2) && it[HIDDEN$2][key$1])) D.enumerable = true;
		return D;
	};
	var $getOwnPropertyNames$2 = function getOwnPropertyNames(it) {
		var names = gOPN$1$5(_toIobject$2(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (!_has$2(AllSymbols$2, key$1 = names[i$8++]) && key$1 != HIDDEN$2 && key$1 != META$2) result.push(key$1);
		return result;
	};
	var $getOwnPropertySymbols$2 = function getOwnPropertySymbols$2(it) {
		var IS_OP = it === ObjectProto$2;
		var names = gOPN$1$5(IS_OP ? OPSymbols$2 : _toIobject$2(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (_has$2(AllSymbols$2, key$1 = names[i$8++]) && (IS_OP ? _has$2(ObjectProto$2, key$1) : true)) result.push(AllSymbols$2[key$1]);
		return result;
	};
	if (!USE_NATIVE$2) {
		$Symbol$2 = function Symbol$2() {
			if (this instanceof $Symbol$2) throw TypeError("Symbol is not a constructor!");
			var tag = _uid$2(arguments.length > 0 ? arguments[0] : void 0);
			var $set = function(value) {
				if (this === ObjectProto$2) $set.call(OPSymbols$2, value);
				if (_has$2(this, HIDDEN$2) && _has$2(this[HIDDEN$2], tag)) this[HIDDEN$2][tag] = false;
				setSymbolDesc$2(this, tag, _propertyDesc$2(1, value));
			};
			if (_descriptors$2 && setter$2) setSymbolDesc$2(ObjectProto$2, tag, {
				configurable: true,
				set: $set
			});
			return wrap$5(tag);
		};
		_redefine$2($Symbol$2[PROTOTYPE$2$4], "toString", function toString$11() {
			return this._k;
		});
		_objectGopd$2.f = $getOwnPropertyDescriptor$4;
		_objectDp$2.f = $defineProperty$2;
		_objectGopn$2.f = _objectGopnExt$2.f = $getOwnPropertyNames$2;
		_objectPie$2.f = $propertyIsEnumerable$2;
		_objectGops$2.f = $getOwnPropertySymbols$2;
		if (_descriptors$2 && !_library$2) _redefine$2(ObjectProto$2, "propertyIsEnumerable", $propertyIsEnumerable$2, true);
		_wksExt$2.f = function(name) {
			return wrap$5(_wks$2(name));
		};
	}
	_export$2(_export$2.G + _export$2.W + _export$2.F * !USE_NATIVE$2, { Symbol: $Symbol$2 });
	for (var es6Symbols$2 = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j$2 = 0; es6Symbols$2.length > j$2;) _wks$2(es6Symbols$2[j$2++]);
	for (var wellKnownSymbols$2 = _objectKeys$2(_wks$2.store), k$2 = 0; wellKnownSymbols$2.length > k$2;) _wksDefine$2(wellKnownSymbols$2[k$2++]);
	_export$2(_export$2.S + _export$2.F * !USE_NATIVE$2, "Symbol", {
		"for": function(key$1) {
			return _has$2(SymbolRegistry$2, key$1 += "") ? SymbolRegistry$2[key$1] : SymbolRegistry$2[key$1] = $Symbol$2(key$1);
		},
		keyFor: function keyFor$1(sym) {
			if (!isSymbol$2(sym)) throw TypeError(sym + " is not a symbol!");
			for (var key$1 in SymbolRegistry$2) if (SymbolRegistry$2[key$1] === sym) return key$1;
		},
		useSetter: function() {
			setter$2 = true;
		},
		useSimple: function() {
			setter$2 = false;
		}
	});
	_export$2(_export$2.S + _export$2.F * !USE_NATIVE$2, "Object", {
		create: $create$2,
		defineProperty: $defineProperty$2,
		defineProperties: $defineProperties$2,
		getOwnPropertyDescriptor: $getOwnPropertyDescriptor$4,
		getOwnPropertyNames: $getOwnPropertyNames$2,
		getOwnPropertySymbols: $getOwnPropertySymbols$2
	});
	var FAILS_ON_PRIMITIVES$2 = _fails$2(function() {
		_objectGops$2.f(1);
	});
	_export$2(_export$2.S + _export$2.F * FAILS_ON_PRIMITIVES$2, "Object", { getOwnPropertySymbols: function getOwnPropertySymbols$2(it) {
		return _objectGops$2.f(_toObject$2(it));
	} });
	$JSON$2 && _export$2(_export$2.S + _export$2.F * (!USE_NATIVE$2 || _fails$2(function() {
		var S = $Symbol$2();
		return _stringify$2([S]) != "[null]" || _stringify$2({ a: S }) != "{}" || _stringify$2(Object(S)) != "{}";
	})), "JSON", { stringify: function stringify$14(it) {
		var args = [it];
		var i$8 = 1;
		var replacer, $replacer;
		while (arguments.length > i$8) args.push(arguments[i$8++]);
		$replacer = replacer = args[1];
		if (!_isObject$2(replacer) && it === void 0 || isSymbol$2(it)) return;
		if (!_isArray$2(replacer)) replacer = function(key$1, value) {
			if (typeof $replacer == "function") value = $replacer.call(this, key$1, value);
			if (!isSymbol$2(value)) return value;
		};
		args[1] = replacer;
		return _stringify$2.apply($JSON$2, args);
	} });
	$Symbol$2[PROTOTYPE$2$4][TO_PRIMITIVE$2] || _hide$2($Symbol$2[PROTOTYPE$2$4], TO_PRIMITIVE$2, $Symbol$2[PROTOTYPE$2$4].valueOf);
	_setToStringTag$2($Symbol$2, "Symbol");
	_setToStringTag$2(Math, "Math", true);
	_setToStringTag$2(_global$2.JSON, "JSON", true);
	var getOwnPropertySymbols$1$2 = _core$2.Object.getOwnPropertySymbols;
	var $getOwnPropertyDescriptor$1$5 = _objectGopd$2.f;
	_objectSap$2("getOwnPropertyDescriptor", function() {
		return function getOwnPropertyDescriptor(it, key$1) {
			return $getOwnPropertyDescriptor$1$5(_toIobject$2(it), key$1);
		};
	});
	var $Object$5 = _core$2.Object;
	var getOwnPropertyDescriptor$1$2 = function getOwnPropertyDescriptor(it, key$1) {
		return $Object$5.getOwnPropertyDescriptor(it, key$1);
	};
	var Reflect$3 = _global$2.Reflect;
	var _ownKeys$2 = Reflect$3 && Reflect$3.ownKeys || function ownKeys$8(it) {
		var keys$6 = _objectGopn$2.f(_anObject$2(it));
		var getSymbols = _objectGops$2.f;
		return getSymbols ? keys$6.concat(getSymbols(it)) : keys$6;
	};
	var _createProperty$2 = function(object, index$1, value) {
		if (index$1 in object) _objectDp$2.f(object, index$1, _propertyDesc$2(0, value));
		else object[index$1] = value;
	};
	_export$2(_export$2.S, "Object", { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
		var O = _toIobject$2(object);
		var getDesc = _objectGopd$2.f;
		var keys$6 = _ownKeys$2(O);
		var result = {};
		var i$8 = 0;
		var key$1, desc$1;
		while (keys$6.length > i$8) {
			desc$1 = getDesc(O, key$1 = keys$6[i$8++]);
			if (desc$1 !== void 0) _createProperty$2(result, key$1, desc$1);
		}
		return result;
	} });
	var getOwnPropertyDescriptors$1$2 = _core$2.Object.getOwnPropertyDescriptors;
	_export$2(_export$2.S + _export$2.F * !_descriptors$2, "Object", { defineProperties: _objectDps$2 });
	var $Object$1$6 = _core$2.Object;
	var defineProperties$1$2 = function defineProperties(T, D) {
		return $Object$1$6.defineProperties(T, D);
	};
	_export$2(_export$2.S + _export$2.F * !_descriptors$2, "Object", { defineProperty: _objectDp$2.f });
	var $Object$2$4 = _core$2.Object;
	var defineProperty$2$4 = function defineProperty$8(it, key$1, desc$1) {
		return $Object$2$4.defineProperty(it, key$1, desc$1);
	};
	var _defineProperty$2 = unwrapExports$2(createCommonjsModule$2(function(module$2) {
		function _defineProperty$7(obj, key$1, value) {
			if (key$1 in obj) defineProperty$2$4(obj, key$1, {
				value,
				enumerable: true,
				configurable: true,
				writable: true
			});
			else obj[key$1] = value;
			return obj;
		}
		module$2.exports = _defineProperty$7;
		module$2.exports["default"] = module$2.exports, module$2.exports.__esModule = true;
	}));
	var es6_object_toString$1 = /* @__PURE__ */ Object.freeze({});
	_wksDefine$2("asyncIterator");
	_wksDefine$2("observable");
	getCjsExportFromNamespace$1(es6_object_toString$1);
	var symbol$1 = _core$2.Symbol;
	var _stringAt$1 = function(TO_STRING) {
		return function(that, pos) {
			var s$3 = String(_defined$2(that));
			var i$8 = _toInteger$2(pos);
			var l = s$3.length;
			var a, b;
			if (i$8 < 0 || i$8 >= l) return TO_STRING ? "" : void 0;
			a = s$3.charCodeAt(i$8);
			return a < 55296 || a > 56319 || i$8 + 1 === l || (b = s$3.charCodeAt(i$8 + 1)) < 56320 || b > 57343 ? TO_STRING ? s$3.charAt(i$8) : a : TO_STRING ? s$3.slice(i$8, i$8 + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
		};
	};
	var _iterators$1 = {};
	var IteratorPrototype$1 = {};
	_hide$2(IteratorPrototype$1, _wks$2("iterator"), function() {
		return this;
	});
	var _iterCreate$1 = function(Constructor, NAME$5, next) {
		Constructor.prototype = _objectCreate$2(IteratorPrototype$1, { next: _propertyDesc$2(1, next) });
		_setToStringTag$2(Constructor, NAME$5 + " Iterator");
	};
	var IE_PROTO$2$4 = _sharedKey$2("IE_PROTO");
	var ObjectProto$1$2 = Object.prototype;
	var _objectGpo$1 = Object.getPrototypeOf || function(O) {
		O = _toObject$2(O);
		if (_has$2(O, IE_PROTO$2$4)) return O[IE_PROTO$2$4];
		if (typeof O.constructor == "function" && O instanceof O.constructor) return O.constructor.prototype;
		return O instanceof Object ? ObjectProto$1$2 : null;
	};
	var ITERATOR$4 = _wks$2("iterator");
	var BUGGY$1 = !([].keys && "next" in [].keys());
	var FF_ITERATOR$1 = "@@iterator";
	var KEYS$1 = "keys";
	var VALUES$1 = "values";
	var returnThis$1 = function() {
		return this;
	};
	var _iterDefine$1 = function(Base, NAME$5, Constructor, next, DEFAULT, IS_SET, FORCED) {
		_iterCreate$1(Constructor, NAME$5, next);
		var getMethod$1 = function(kind) {
			if (!BUGGY$1 && kind in proto$7) return proto$7[kind];
			switch (kind) {
				case KEYS$1: return function keys$6() {
					return new Constructor(this, kind);
				};
				case VALUES$1: return function values() {
					return new Constructor(this, kind);
				};
			}
			return function entries() {
				return new Constructor(this, kind);
			};
		};
		var TAG$7 = NAME$5 + " Iterator";
		var DEF_VALUES = DEFAULT == VALUES$1;
		var VALUES_BUG = false;
		var proto$7 = Base.prototype;
		var $native = proto$7[ITERATOR$4] || proto$7[FF_ITERATOR$1] || DEFAULT && proto$7[DEFAULT];
		var $default = $native || getMethod$1(DEFAULT);
		var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod$1("entries") : void 0;
		var $anyNative = NAME$5 == "Array" ? proto$7.entries || $native : $native;
		var methods$3, key$1, IteratorPrototype$5;
		if ($anyNative) {
			IteratorPrototype$5 = _objectGpo$1($anyNative.call(new Base()));
			if (IteratorPrototype$5 !== Object.prototype && IteratorPrototype$5.next) _setToStringTag$2(IteratorPrototype$5, TAG$7, true);
		}
		if (DEF_VALUES && $native && $native.name !== VALUES$1) {
			VALUES_BUG = true;
			$default = function values() {
				return $native.call(this);
			};
		}
		if (FORCED && (BUGGY$1 || VALUES_BUG || !proto$7[ITERATOR$4])) _hide$2(proto$7, ITERATOR$4, $default);
		_iterators$1[NAME$5] = $default;
		_iterators$1[TAG$7] = returnThis$1;
		if (DEFAULT) {
			methods$3 = {
				values: DEF_VALUES ? $default : getMethod$1(VALUES$1),
				keys: IS_SET ? $default : getMethod$1(KEYS$1),
				entries: $entries
			};
			if (FORCED) {
				for (key$1 in methods$3) if (!(key$1 in proto$7)) _redefine$2(proto$7, key$1, methods$3[key$1]);
			} else _export$2(_export$2.P + _export$2.F * (BUGGY$1 || VALUES_BUG), NAME$5, methods$3);
		}
		return methods$3;
	};
	var $at$1 = _stringAt$1(true);
	_iterDefine$1(String, "String", function(iterated) {
		this._t = String(iterated);
		this._i = 0;
	}, function() {
		var O = this._t;
		var index$1 = this._i;
		var point;
		if (index$1 >= O.length) return {
			value: void 0,
			done: true
		};
		point = $at$1(O, index$1);
		this._i += point.length;
		return {
			value: point,
			done: false
		};
	});
	var _iterStep$1 = function(done, value) {
		return {
			value,
			done: !!done
		};
	};
	_iterDefine$1(Array, "Array", function(iterated, kind) {
		this._t = _toIobject$2(iterated);
		this._i = 0;
		this._k = kind;
	}, function() {
		var O = this._t;
		var kind = this._k;
		var index$1 = this._i++;
		if (!O || index$1 >= O.length) {
			this._t = void 0;
			return _iterStep$1(1);
		}
		if (kind == "keys") return _iterStep$1(0, index$1);
		if (kind == "values") return _iterStep$1(0, O[index$1]);
		return _iterStep$1(0, [index$1, O[index$1]]);
	}, "values");
	_iterators$1.Arguments = _iterators$1.Array;
	var TO_STRING_TAG$1 = _wks$2("toStringTag");
	var DOMIterables$1 = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
	for (var i$4 = 0; i$4 < DOMIterables$1.length; i$4++) {
		var NAME$1 = DOMIterables$1[i$4];
		var Collection$1 = _global$2[NAME$1];
		var proto$3 = Collection$1 && Collection$1.prototype;
		if (proto$3 && !proto$3[TO_STRING_TAG$1]) _hide$2(proto$3, TO_STRING_TAG$1, NAME$1);
		_iterators$1[NAME$1] = _iterators$1.Array;
	}
	var TAG$1$2 = _wks$2("toStringTag");
	var ARG$1 = _cof$2(function() {
		return arguments;
	}()) == "Arguments";
	var tryGet$1 = function(it, key$1) {
		try {
			return it[key$1];
		} catch (e) {}
	};
	var _classof$1 = function(it) {
		var O, T, B;
		return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet$1(O = Object(it), TAG$1$2)) == "string" ? T : ARG$1 ? _cof$2(O) : (B = _cof$2(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
	};
	var _anInstance$1 = function(it, Constructor, name, forbiddenField) {
		if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) throw TypeError(name + ": incorrect invocation!");
		return it;
	};
	var _iterCall$1 = function(iterator, fn, value, entries) {
		try {
			return entries ? fn(_anObject$2(value)[0], value[1]) : fn(value);
		} catch (e) {
			var ret = iterator["return"];
			if (ret !== void 0) _anObject$2(ret.call(iterator));
			throw e;
		}
	};
	var ITERATOR$1$5 = _wks$2("iterator");
	var ArrayProto$1 = Array.prototype;
	var _isArrayIter$1 = function(it) {
		return it !== void 0 && (_iterators$1.Array === it || ArrayProto$1[ITERATOR$1$5] === it);
	};
	var ITERATOR$2$2 = _wks$2("iterator");
	var core_getIteratorMethod$1 = _core$2.getIteratorMethod = function(it) {
		if (it != void 0) return it[ITERATOR$2$2] || it["@@iterator"] || _iterators$1[_classof$1(it)];
	};
	var _forOf$1 = createCommonjsModule$2(function(module$2) {
		var BREAK = {};
		var RETURN = {};
		var exports$1 = module$2.exports = function(iterable, entries, fn, that, ITERATOR$5) {
			var iterFn = ITERATOR$5 ? function() {
				return iterable;
			} : core_getIteratorMethod$1(iterable);
			var f = _ctx$2(fn, that, entries ? 2 : 1);
			var index$1 = 0;
			var length, step, iterator, result;
			if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
			if (_isArrayIter$1(iterFn)) for (length = _toLength$2(iterable.length); length > index$1; index$1++) {
				result = entries ? f(_anObject$2(step = iterable[index$1])[0], step[1]) : f(iterable[index$1]);
				if (result === BREAK || result === RETURN) return result;
			}
			else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
				result = _iterCall$1(iterator, f, step.value, entries);
				if (result === BREAK || result === RETURN) return result;
			}
		};
		exports$1.BREAK = BREAK;
		exports$1.RETURN = RETURN;
	});
	var SPECIES$3 = _wks$2("species");
	var _speciesConstructor$1 = function(O, D) {
		var C = _anObject$2(O).constructor;
		var S;
		return C === void 0 || (S = _anObject$2(C)[SPECIES$3]) == void 0 ? D : _aFunction$2(S);
	};
	var _invoke$1 = function(fn, args, that) {
		var un = that === void 0;
		switch (args.length) {
			case 0: return un ? fn() : fn.call(that);
			case 1: return un ? fn(args[0]) : fn.call(that, args[0]);
			case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
			case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
			case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
		}
		return fn.apply(that, args);
	};
	var process$3 = _global$2.process;
	var setTask$1 = _global$2.setImmediate;
	var clearTask$1 = _global$2.clearImmediate;
	var MessageChannel$1 = _global$2.MessageChannel;
	var Dispatch$1 = _global$2.Dispatch;
	var counter$1 = 0;
	var queue$1 = {};
	var ONREADYSTATECHANGE$1 = "onreadystatechange";
	var defer$4, channel$1, port$1;
	var run$1 = function() {
		var id$7 = +this;
		if (queue$1.hasOwnProperty(id$7)) {
			var fn = queue$1[id$7];
			delete queue$1[id$7];
			fn();
		}
	};
	var listener$2 = function(event) {
		run$1.call(event.data);
	};
	if (!setTask$1 || !clearTask$1) {
		setTask$1 = function setImmediate$3(fn) {
			var args = [];
			var i$8 = 1;
			while (arguments.length > i$8) args.push(arguments[i$8++]);
			queue$1[++counter$1] = function() {
				_invoke$1(typeof fn == "function" ? fn : Function(fn), args);
			};
			defer$4(counter$1);
			return counter$1;
		};
		clearTask$1 = function clearImmediate$1(id$7) {
			delete queue$1[id$7];
		};
		if (_cof$2(process$3) == "process") defer$4 = function(id$7) {
			process$3.nextTick(_ctx$2(run$1, id$7, 1));
		};
		else if (Dispatch$1 && Dispatch$1.now) defer$4 = function(id$7) {
			Dispatch$1.now(_ctx$2(run$1, id$7, 1));
		};
		else if (MessageChannel$1) {
			channel$1 = new MessageChannel$1();
			port$1 = channel$1.port2;
			channel$1.port1.onmessage = listener$2;
			defer$4 = _ctx$2(port$1.postMessage, port$1, 1);
		} else if (_global$2.addEventListener && typeof postMessage == "function" && !_global$2.importScripts) {
			defer$4 = function(id$7) {
				_global$2.postMessage(id$7 + "", "*");
			};
			_global$2.addEventListener("message", listener$2, false);
		} else if (ONREADYSTATECHANGE$1 in _domCreate$2("script")) defer$4 = function(id$7) {
			_html$2.appendChild(_domCreate$2("script"))[ONREADYSTATECHANGE$1] = function() {
				_html$2.removeChild(this);
				run$1.call(id$7);
			};
		};
		else defer$4 = function(id$7) {
			setTimeout(_ctx$2(run$1, id$7, 1), 0);
		};
	}
	var _task$1 = {
		set: setTask$1,
		clear: clearTask$1
	};
	var macrotask$1 = _task$1.set;
	var Observer$1 = _global$2.MutationObserver || _global$2.WebKitMutationObserver;
	var process$1$3 = _global$2.process;
	var Promise$2 = _global$2.Promise;
	var isNode$2 = _cof$2(process$1$3) == "process";
	var _microtask$1 = function() {
		var head, last, notify$6;
		var flush = function() {
			var parent, fn;
			if (isNode$2 && (parent = process$1$3.domain)) parent.exit();
			while (head) {
				fn = head.fn;
				head = head.next;
				try {
					fn();
				} catch (e) {
					if (head) notify$6();
					else last = void 0;
					throw e;
				}
			}
			last = void 0;
			if (parent) parent.enter();
		};
		if (isNode$2) notify$6 = function() {
			process$1$3.nextTick(flush);
		};
		else if (Observer$1 && !(_global$2.navigator && _global$2.navigator.standalone)) {
			var toggle = true;
			var node$1 = document.createTextNode("");
			new Observer$1(flush).observe(node$1, { characterData: true });
			notify$6 = function() {
				node$1.data = toggle = !toggle;
			};
		} else if (Promise$2 && Promise$2.resolve) {
			var promise = Promise$2.resolve(void 0);
			notify$6 = function() {
				promise.then(flush);
			};
		} else notify$6 = function() {
			macrotask$1.call(_global$2, flush);
		};
		return function(fn) {
			var task$5 = {
				fn,
				next: void 0
			};
			if (last) last.next = task$5;
			if (!head) {
				head = task$5;
				notify$6();
			}
			last = task$5;
		};
	};
	function PromiseCapability$1(C) {
		var resolve$6, reject;
		this.promise = new C(function($$resolve, $$reject) {
			if (resolve$6 !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
			resolve$6 = $$resolve;
			reject = $$reject;
		});
		this.resolve = _aFunction$2(resolve$6);
		this.reject = _aFunction$2(reject);
	}
	var f$7$1 = function(C) {
		return new PromiseCapability$1(C);
	};
	var _newPromiseCapability$1 = { f: f$7$1 };
	var _perform$1 = function(exec) {
		try {
			return {
				e: false,
				v: exec()
			};
		} catch (e) {
			return {
				e: true,
				v: e
			};
		}
	};
	var navigator$2 = _global$2.navigator;
	var _userAgent$1 = navigator$2 && navigator$2.userAgent || "";
	var _promiseResolve$1 = function(C, x) {
		_anObject$2(C);
		if (_isObject$2(x) && x.constructor === C) return x;
		var promiseCapability = _newPromiseCapability$1.f(C);
		var resolve$6 = promiseCapability.resolve;
		resolve$6(x);
		return promiseCapability.promise;
	};
	var _redefineAll$1 = function(target, src$1, safe) {
		for (var key$1 in src$1) if (safe && target[key$1]) target[key$1] = src$1[key$1];
		else _hide$2(target, key$1, src$1[key$1]);
		return target;
	};
	var SPECIES$1$4 = _wks$2("species");
	var _setSpecies$1 = function(KEY) {
		var C = typeof _core$2[KEY] == "function" ? _core$2[KEY] : _global$2[KEY];
		if (_descriptors$2 && C && !C[SPECIES$1$4]) _objectDp$2.f(C, SPECIES$1$4, {
			configurable: true,
			get: function() {
				return this;
			}
		});
	};
	var ITERATOR$3$2 = _wks$2("iterator");
	var SAFE_CLOSING$1 = false;
	try {
		var riter$1 = [7][ITERATOR$3$2]();
		riter$1["return"] = function() {
			SAFE_CLOSING$1 = true;
		};
		Array.from(riter$1, function() {
			throw 2;
		});
	} catch (e) {}
	var _iterDetect$1 = function(exec, skipClosing) {
		if (!skipClosing && !SAFE_CLOSING$1) return false;
		var safe = false;
		try {
			var arr = [7];
			var iter = arr[ITERATOR$3$2]();
			iter.next = function() {
				return { done: safe = true };
			};
			arr[ITERATOR$3$2] = function() {
				return iter;
			};
			exec(arr);
		} catch (e) {}
		return safe;
	};
	var task$1 = _task$1.set;
	var microtask$1 = _microtask$1();
	var PROMISE$1 = "Promise";
	var TypeError$1$1 = _global$2.TypeError;
	var process$2$4 = _global$2.process;
	var versions$1 = process$2$4 && process$2$4.versions;
	var v8$1 = versions$1 && versions$1.v8 || "";
	var $Promise$1 = _global$2[PROMISE$1];
	var isNode$1$3 = _classof$1(process$2$4) == "process";
	var empty$1 = function() {};
	var Internal$1, newGenericPromiseCapability$1, OwnPromiseCapability$1, Wrapper$1;
	var newPromiseCapability$1 = newGenericPromiseCapability$1 = _newPromiseCapability$1.f;
	var USE_NATIVE$1$2 = !!function() {
		try {
			var promise = $Promise$1.resolve(1);
			var FakePromise = (promise.constructor = {})[_wks$2("species")] = function(exec) {
				exec(empty$1, empty$1);
			};
			return (isNode$1$3 || typeof PromiseRejectionEvent == "function") && promise.then(empty$1) instanceof FakePromise && v8$1.indexOf("6.6") !== 0 && _userAgent$1.indexOf("Chrome/66") === -1;
		} catch (e) {}
	}();
	var isThenable$1 = function(it) {
		var then;
		return _isObject$2(it) && typeof (then = it.then) == "function" ? then : false;
	};
	var notify$1 = function(promise, isReject) {
		if (promise._n) return;
		promise._n = true;
		var chain = promise._c;
		microtask$1(function() {
			var value = promise._v;
			var ok = promise._s == 1;
			var i$8 = 0;
			var run$5 = function(reaction) {
				var handler = ok ? reaction.ok : reaction.fail;
				var resolve$6 = reaction.resolve;
				var reject = reaction.reject;
				var domain = reaction.domain;
				var result, then, exited;
				try {
					if (handler) {
						if (!ok) {
							if (promise._h == 2) onHandleUnhandled$1(promise);
							promise._h = 1;
						}
						if (handler === true) result = value;
						else {
							if (domain) domain.enter();
							result = handler(value);
							if (domain) {
								domain.exit();
								exited = true;
							}
						}
						if (result === reaction.promise) reject(TypeError$1$1("Promise-chain cycle"));
						else if (then = isThenable$1(result)) then.call(result, resolve$6, reject);
						else resolve$6(result);
					} else reject(value);
				} catch (e) {
					if (domain && !exited) domain.exit();
					reject(e);
				}
			};
			while (chain.length > i$8) run$5(chain[i$8++]);
			promise._c = [];
			promise._n = false;
			if (isReject && !promise._h) onUnhandled$1(promise);
		});
	};
	var onUnhandled$1 = function(promise) {
		task$1.call(_global$2, function() {
			var value = promise._v;
			var unhandled = isUnhandled$1(promise);
			var result, handler, console$1;
			if (unhandled) {
				result = _perform$1(function() {
					if (isNode$1$3) process$2$4.emit("unhandledRejection", value, promise);
					else if (handler = _global$2.onunhandledrejection) handler({
						promise,
						reason: value
					});
					else if ((console$1 = _global$2.console) && console$1.error) console$1.error("Unhandled promise rejection", value);
				});
				promise._h = isNode$1$3 || isUnhandled$1(promise) ? 2 : 1;
			}
			promise._a = void 0;
			if (unhandled && result.e) throw result.v;
		});
	};
	var isUnhandled$1 = function(promise) {
		return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled$1 = function(promise) {
		task$1.call(_global$2, function() {
			var handler;
			if (isNode$1$3) process$2$4.emit("rejectionHandled", promise);
			else if (handler = _global$2.onrejectionhandled) handler({
				promise,
				reason: promise._v
			});
		});
	};
	var $reject$1 = function(value) {
		var promise = this;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		promise._v = value;
		promise._s = 2;
		if (!promise._a) promise._a = promise._c.slice();
		notify$1(promise, true);
	};
	var $resolve$1 = function(value) {
		var promise = this;
		var then;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		try {
			if (promise === value) throw TypeError$1$1("Promise can't be resolved itself");
			if (then = isThenable$1(value)) microtask$1(function() {
				var wrapper = {
					_w: promise,
					_d: false
				};
				try {
					then.call(value, _ctx$2($resolve$1, wrapper, 1), _ctx$2($reject$1, wrapper, 1));
				} catch (e) {
					$reject$1.call(wrapper, e);
				}
			});
			else {
				promise._v = value;
				promise._s = 1;
				notify$1(promise, false);
			}
		} catch (e) {
			$reject$1.call({
				_w: promise,
				_d: false
			}, e);
		}
	};
	if (!USE_NATIVE$1$2) {
		$Promise$1 = function Promise$6(executor) {
			_anInstance$1(this, $Promise$1, PROMISE$1, "_h");
			_aFunction$2(executor);
			Internal$1.call(this);
			try {
				executor(_ctx$2($resolve$1, this, 1), _ctx$2($reject$1, this, 1));
			} catch (err) {
				$reject$1.call(this, err);
			}
		};
		Internal$1 = function Promise$6(executor) {
			this._c = [];
			this._a = void 0;
			this._s = 0;
			this._d = false;
			this._v = void 0;
			this._h = 0;
			this._n = false;
		};
		Internal$1.prototype = _redefineAll$1($Promise$1.prototype, {
			then: function then(onFulfilled, onRejected) {
				var reaction = newPromiseCapability$1(_speciesConstructor$1(this, $Promise$1));
				reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
				reaction.fail = typeof onRejected == "function" && onRejected;
				reaction.domain = isNode$1$3 ? process$2$4.domain : void 0;
				this._c.push(reaction);
				if (this._a) this._a.push(reaction);
				if (this._s) notify$1(this, false);
				return reaction.promise;
			},
			"catch": function(onRejected) {
				return this.then(void 0, onRejected);
			}
		});
		OwnPromiseCapability$1 = function() {
			var promise = new Internal$1();
			this.promise = promise;
			this.resolve = _ctx$2($resolve$1, promise, 1);
			this.reject = _ctx$2($reject$1, promise, 1);
		};
		_newPromiseCapability$1.f = newPromiseCapability$1 = function(C) {
			return C === $Promise$1 || C === Wrapper$1 ? new OwnPromiseCapability$1(C) : newGenericPromiseCapability$1(C);
		};
	}
	_export$2(_export$2.G + _export$2.W + _export$2.F * !USE_NATIVE$1$2, { Promise: $Promise$1 });
	_setToStringTag$2($Promise$1, PROMISE$1);
	_setSpecies$1(PROMISE$1);
	Wrapper$1 = _core$2[PROMISE$1];
	_export$2(_export$2.S + _export$2.F * !USE_NATIVE$1$2, PROMISE$1, { reject: function reject(r) {
		var capability = newPromiseCapability$1(this);
		var $$reject = capability.reject;
		$$reject(r);
		return capability.promise;
	} });
	_export$2(_export$2.S + _export$2.F * _library$2, PROMISE$1, { resolve: function resolve$6(x) {
		return _promiseResolve$1(this === Wrapper$1 ? $Promise$1 : this, x);
	} });
	_export$2(_export$2.S + _export$2.F * !(USE_NATIVE$1$2 && _iterDetect$1(function(iter) {
		$Promise$1.all(iter)["catch"](empty$1);
	})), PROMISE$1, {
		all: function all(iterable) {
			var C = this;
			var capability = newPromiseCapability$1(C);
			var resolve$6 = capability.resolve;
			var reject = capability.reject;
			var result = _perform$1(function() {
				var values = [];
				var index$1 = 0;
				var remaining = 1;
				_forOf$1(iterable, false, function(promise) {
					var $index = index$1++;
					var alreadyCalled = false;
					values.push(void 0);
					remaining++;
					C.resolve(promise).then(function(value) {
						if (alreadyCalled) return;
						alreadyCalled = true;
						values[$index] = value;
						--remaining || resolve$6(values);
					}, reject);
				});
				--remaining || resolve$6(values);
			});
			if (result.e) reject(result.v);
			return capability.promise;
		},
		race: function race(iterable) {
			var C = this;
			var capability = newPromiseCapability$1(C);
			var reject = capability.reject;
			var result = _perform$1(function() {
				_forOf$1(iterable, false, function(promise) {
					C.resolve(promise).then(capability.resolve, reject);
				});
			});
			if (result.e) reject(result.v);
			return capability.promise;
		}
	});
	_export$2(_export$2.P + _export$2.R, "Promise", { "finally": function(onFinally) {
		var C = _speciesConstructor$1(this, _core$2.Promise || _global$2.Promise);
		var isFunction$3 = typeof onFinally == "function";
		return this.then(isFunction$3 ? function(x) {
			return _promiseResolve$1(C, onFinally()).then(function() {
				return x;
			});
		} : onFinally, isFunction$3 ? function(e) {
			return _promiseResolve$1(C, onFinally()).then(function() {
				throw e;
			});
		} : onFinally);
	} });
	_export$2(_export$2.S, "Promise", { "try": function(callbackfn) {
		var promiseCapability = _newPromiseCapability$1.f(this);
		var result = _perform$1(callbackfn);
		(result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
		return promiseCapability.promise;
	} });
	var promise$1$1 = _core$2.Promise;
	var byteLength_1 = byteLength;
	var toByteArray_1 = toByteArray;
	var fromByteArray_1 = fromByteArray;
	var lookup$1 = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
	var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	for (var i$1$1 = 0, len = code.length; i$1$1 < len; ++i$1$1) {
		lookup$1[i$1$1] = code[i$1$1];
		revLookup[code.charCodeAt(i$1$1)] = i$1$1;
	}
	revLookup["-".charCodeAt(0)] = 62;
	revLookup["_".charCodeAt(0)] = 63;
	function getLens(b64) {
		var len$1 = b64.length;
		if (len$1 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
		var validLen = b64.indexOf("=");
		if (validLen === -1) validLen = len$1;
		var placeHoldersLen = validLen === len$1 ? 0 : 4 - validLen % 4;
		return [validLen, placeHoldersLen];
	}
	function byteLength(b64) {
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function _byteLength(b64, validLen, placeHoldersLen) {
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function toByteArray(b64) {
		var tmp;
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		var curByte = 0;
		var len$1 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		for (var i$8 = 0; i$8 < len$1; i$8 += 4) {
			tmp = revLookup[b64.charCodeAt(i$8)] << 18 | revLookup[b64.charCodeAt(i$8 + 1)] << 12 | revLookup[b64.charCodeAt(i$8 + 2)] << 6 | revLookup[b64.charCodeAt(i$8 + 3)];
			arr[curByte++] = tmp >> 16 & 255;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 2) {
			tmp = revLookup[b64.charCodeAt(i$8)] << 2 | revLookup[b64.charCodeAt(i$8 + 1)] >> 4;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 1) {
			tmp = revLookup[b64.charCodeAt(i$8)] << 10 | revLookup[b64.charCodeAt(i$8 + 1)] << 4 | revLookup[b64.charCodeAt(i$8 + 2)] >> 2;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		return arr;
	}
	function tripletToBase64(num) {
		return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
	}
	function encodeChunk(uint8, start, end) {
		var tmp;
		var output = [];
		for (var i$8 = start; i$8 < end; i$8 += 3) {
			tmp = (uint8[i$8] << 16 & 16711680) + (uint8[i$8 + 1] << 8 & 65280) + (uint8[i$8 + 2] & 255);
			output.push(tripletToBase64(tmp));
		}
		return output.join("");
	}
	function fromByteArray(uint8) {
		var tmp;
		var len$1 = uint8.length;
		var extraBytes = len$1 % 3;
		var parts = [];
		var maxChunkLength = 16383;
		for (var i$8 = 0, len2 = len$1 - extraBytes; i$8 < len2; i$8 += maxChunkLength) parts.push(encodeChunk(uint8, i$8, i$8 + maxChunkLength > len2 ? len2 : i$8 + maxChunkLength));
		if (extraBytes === 1) {
			tmp = uint8[len$1 - 1];
			parts.push(lookup$1[tmp >> 2] + lookup$1[tmp << 4 & 63] + "==");
		} else if (extraBytes === 2) {
			tmp = (uint8[len$1 - 2] << 8) + uint8[len$1 - 1];
			parts.push(lookup$1[tmp >> 10] + lookup$1[tmp >> 4 & 63] + lookup$1[tmp << 2 & 63] + "=");
		}
		return parts.join("");
	}
	var base64Js = {
		byteLength: byteLength_1,
		toByteArray: toByteArray_1,
		fromByteArray: fromByteArray_1
	};
	var read$5 = function(buffer$5, offset, isLE, mLen, nBytes) {
		var e, m$3;
		var eLen = nBytes * 8 - mLen - 1;
		var eMax = (1 << eLen) - 1;
		var eBias = eMax >> 1;
		var nBits = -7;
		var i$8 = isLE ? nBytes - 1 : 0;
		var d$3 = isLE ? -1 : 1;
		var s$3 = buffer$5[offset + i$8];
		i$8 += d$3;
		e = s$3 & (1 << -nBits) - 1;
		s$3 >>= -nBits;
		nBits += eLen;
		for (; nBits > 0; e = e * 256 + buffer$5[offset + i$8], i$8 += d$3, nBits -= 8);
		m$3 = e & (1 << -nBits) - 1;
		e >>= -nBits;
		nBits += mLen;
		for (; nBits > 0; m$3 = m$3 * 256 + buffer$5[offset + i$8], i$8 += d$3, nBits -= 8);
		if (e === 0) e = 1 - eBias;
		else if (e === eMax) return m$3 ? NaN : (s$3 ? -1 : 1) * Infinity;
		else {
			m$3 = m$3 + Math.pow(2, mLen);
			e = e - eBias;
		}
		return (s$3 ? -1 : 1) * m$3 * Math.pow(2, e - mLen);
	};
	var write = function(buffer$5, value, offset, isLE, mLen, nBytes) {
		var e, m$3, c;
		var eLen = nBytes * 8 - mLen - 1;
		var eMax = (1 << eLen) - 1;
		var eBias = eMax >> 1;
		var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
		var i$8 = isLE ? 0 : nBytes - 1;
		var d$3 = isLE ? 1 : -1;
		var s$3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
		value = Math.abs(value);
		if (isNaN(value) || value === Infinity) {
			m$3 = isNaN(value) ? 1 : 0;
			e = eMax;
		} else {
			e = Math.floor(Math.log(value) / Math.LN2);
			if (value * (c = Math.pow(2, -e)) < 1) {
				e--;
				c *= 2;
			}
			if (e + eBias >= 1) value += rt / c;
			else value += rt * Math.pow(2, 1 - eBias);
			if (value * c >= 2) {
				e++;
				c /= 2;
			}
			if (e + eBias >= eMax) {
				m$3 = 0;
				e = eMax;
			} else if (e + eBias >= 1) {
				m$3 = (value * c - 1) * Math.pow(2, mLen);
				e = e + eBias;
			} else {
				m$3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
				e = 0;
			}
		}
		for (; mLen >= 8; buffer$5[offset + i$8] = m$3 & 255, i$8 += d$3, m$3 /= 256, mLen -= 8);
		e = e << mLen | m$3;
		eLen += mLen;
		for (; eLen > 0; buffer$5[offset + i$8] = e & 255, i$8 += d$3, e /= 256, eLen -= 8);
		buffer$5[offset + i$8 - d$3] |= s$3 * 128;
	};
	var ieee754 = {
		read: read$5,
		write
	};
	var toString$2$2 = {}.toString;
	var isarray = Array.isArray || function(arr) {
		return toString$2$2.call(arr) == "[object Array]";
	};
	var buffer$3 = createCommonjsModule$2(function(module$2, exports$1) {
		exports$1.Buffer = Buffer$18;
		exports$1.SlowBuffer = SlowBuffer;
		exports$1.INSPECT_MAX_BYTES = 50;
		/**
		* If `Buffer.TYPED_ARRAY_SUPPORT`:
		*   === true    Use Uint8Array implementation (fastest)
		*   === false   Use Object implementation (most compatible, even IE6)
		*
		* Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		* Opera 11.6+, iOS 4.2+.
		*
		* Due to various browser bugs, sometimes the Object implementation will be used even
		* when the browser supports typed arrays.
		*
		* Note:
		*
		*   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
		*     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
		*
		*   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
		*
		*   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
		*     incorrect length in some situations.
		
		* We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
		* get the Object implementation, which is slower but behaves correctly.
		*/
		Buffer$18.TYPED_ARRAY_SUPPORT = commonjsGlobal.TYPED_ARRAY_SUPPORT !== void 0 ? commonjsGlobal.TYPED_ARRAY_SUPPORT : typedArraySupport();
		exports$1.kMaxLength = kMaxLength();
		function typedArraySupport() {
			try {
				var arr = new Uint8Array(1);
				arr.__proto__ = {
					__proto__: Uint8Array.prototype,
					foo: function() {
						return 42;
					}
				};
				return arr.foo() === 42 && typeof arr.subarray === "function" && arr.subarray(1, 1).byteLength === 0;
			} catch (e) {
				return false;
			}
		}
		function kMaxLength() {
			return Buffer$18.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
		}
		function createBuffer(that, length) {
			if (kMaxLength() < length) throw new RangeError("Invalid typed array length");
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				that = new Uint8Array(length);
				that.__proto__ = Buffer$18.prototype;
			} else {
				if (that === null) that = new Buffer$18(length);
				that.length = length;
			}
			return that;
		}
		/**
		* The Buffer constructor returns instances of `Uint8Array` that have their
		* prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
		* `Uint8Array`, so the returned instances will have all the node `Buffer` methods
		* and the `Uint8Array` methods. Square bracket notation works as expected -- it
		* returns a single octet.
		*
		* The `Uint8Array` prototype remains unmodified.
		*/
		function Buffer$18(arg, encodingOrOffset, length) {
			if (!Buffer$18.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$18)) return new Buffer$18(arg, encodingOrOffset, length);
			if (typeof arg === "number") {
				if (typeof encodingOrOffset === "string") throw new Error("If encoding is specified then the first argument must be a string");
				return allocUnsafe$1(this, arg);
			}
			return from(this, arg, encodingOrOffset, length);
		}
		Buffer$18.poolSize = 8192;
		Buffer$18._augment = function(arr) {
			arr.__proto__ = Buffer$18.prototype;
			return arr;
		};
		function from(that, value, encodingOrOffset, length) {
			if (typeof value === "number") throw new TypeError("\"value\" argument must not be a number");
			if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) return fromArrayBuffer(that, value, encodingOrOffset, length);
			if (typeof value === "string") return fromString(that, value, encodingOrOffset);
			return fromObject(that, value);
		}
		/**
		* Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
		* if value is a number.
		* Buffer.from(str[, encoding])
		* Buffer.from(array)
		* Buffer.from(buffer)
		* Buffer.from(arrayBuffer[, byteOffset[, length]])
		**/
		Buffer$18.from = function(value, encodingOrOffset, length) {
			return from(null, value, encodingOrOffset, length);
		};
		if (Buffer$18.TYPED_ARRAY_SUPPORT) {
			Buffer$18.prototype.__proto__ = Uint8Array.prototype;
			Buffer$18.__proto__ = Uint8Array;
			if (typeof Symbol !== "undefined" && Symbol.species && Buffer$18[Symbol.species] === Buffer$18) Object.defineProperty(Buffer$18, Symbol.species, {
				value: null,
				configurable: true
			});
		}
		function assertSize(size) {
			if (typeof size !== "number") throw new TypeError("\"size\" argument must be a number");
			else if (size < 0) throw new RangeError("\"size\" argument must not be negative");
		}
		function alloc(that, size, fill, encoding) {
			assertSize(size);
			if (size <= 0) return createBuffer(that, size);
			if (fill !== void 0) return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
			return createBuffer(that, size);
		}
		/**
		* Creates a new filled Buffer instance.
		* alloc(size[, fill[, encoding]])
		**/
		Buffer$18.alloc = function(size, fill, encoding) {
			return alloc(null, size, fill, encoding);
		};
		function allocUnsafe$1(that, size) {
			assertSize(size);
			that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
			if (!Buffer$18.TYPED_ARRAY_SUPPORT) for (var i$8 = 0; i$8 < size; ++i$8) that[i$8] = 0;
			return that;
		}
		/**
		* Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
		* */
		Buffer$18.allocUnsafe = function(size) {
			return allocUnsafe$1(null, size);
		};
		/**
		* Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
		*/
		Buffer$18.allocUnsafeSlow = function(size) {
			return allocUnsafe$1(null, size);
		};
		function fromString(that, string, encoding) {
			if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
			if (!Buffer$18.isEncoding(encoding)) throw new TypeError("\"encoding\" must be a valid string encoding");
			var length = byteLength$1(string, encoding) | 0;
			that = createBuffer(that, length);
			var actual = that.write(string, encoding);
			if (actual !== length) that = that.slice(0, actual);
			return that;
		}
		function fromArrayLike(that, array) {
			var length = array.length < 0 ? 0 : checked(array.length) | 0;
			that = createBuffer(that, length);
			for (var i$8 = 0; i$8 < length; i$8 += 1) that[i$8] = array[i$8] & 255;
			return that;
		}
		function fromArrayBuffer(that, array, byteOffset, length) {
			array.byteLength;
			if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError("'offset' is out of bounds");
			if (array.byteLength < byteOffset + (length || 0)) throw new RangeError("'length' is out of bounds");
			if (byteOffset === void 0 && length === void 0) array = new Uint8Array(array);
			else if (length === void 0) array = new Uint8Array(array, byteOffset);
			else array = new Uint8Array(array, byteOffset, length);
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				that = array;
				that.__proto__ = Buffer$18.prototype;
			} else that = fromArrayLike(that, array);
			return that;
		}
		function fromObject(that, obj) {
			if (Buffer$18.isBuffer(obj)) {
				var len$1 = checked(obj.length) | 0;
				that = createBuffer(that, len$1);
				if (that.length === 0) return that;
				obj.copy(that, 0, 0, len$1);
				return that;
			}
			if (obj) {
				if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
					if (typeof obj.length !== "number" || isnan(obj.length)) return createBuffer(that, 0);
					return fromArrayLike(that, obj);
				}
				if (obj.type === "Buffer" && isarray(obj.data)) return fromArrayLike(that, obj.data);
			}
			throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
		}
		function checked(length) {
			if (length >= kMaxLength()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
			return length | 0;
		}
		function SlowBuffer(length) {
			if (+length != length) length = 0;
			return Buffer$18.alloc(+length);
		}
		Buffer$18.isBuffer = function isBuffer$3(b) {
			return !!(b != null && b._isBuffer);
		};
		Buffer$18.compare = function compare(a, b) {
			if (!Buffer$18.isBuffer(a) || !Buffer$18.isBuffer(b)) throw new TypeError("Arguments must be Buffers");
			if (a === b) return 0;
			var x = a.length;
			var y$3 = b.length;
			for (var i$8 = 0, len$1 = Math.min(x, y$3); i$8 < len$1; ++i$8) if (a[i$8] !== b[i$8]) {
				x = a[i$8];
				y$3 = b[i$8];
				break;
			}
			if (x < y$3) return -1;
			if (y$3 < x) return 1;
			return 0;
		};
		Buffer$18.isEncoding = function isEncoding(encoding) {
			switch (String(encoding).toLowerCase()) {
				case "hex":
				case "utf8":
				case "utf-8":
				case "ascii":
				case "latin1":
				case "binary":
				case "base64":
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le": return true;
				default: return false;
			}
		};
		Buffer$18.concat = function concat(list, length) {
			if (!isarray(list)) throw new TypeError("\"list\" argument must be an Array of Buffers");
			if (list.length === 0) return Buffer$18.alloc(0);
			var i$8;
			if (length === void 0) {
				length = 0;
				for (i$8 = 0; i$8 < list.length; ++i$8) length += list[i$8].length;
			}
			var buffer$5 = Buffer$18.allocUnsafe(length);
			var pos = 0;
			for (i$8 = 0; i$8 < list.length; ++i$8) {
				var buf = list[i$8];
				if (!Buffer$18.isBuffer(buf)) throw new TypeError("\"list\" argument must be an Array of Buffers");
				buf.copy(buffer$5, pos);
				pos += buf.length;
			}
			return buffer$5;
		};
		function byteLength$1(string, encoding) {
			if (Buffer$18.isBuffer(string)) return string.length;
			if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) return string.byteLength;
			if (typeof string !== "string") string = "" + string;
			var len$1 = string.length;
			if (len$1 === 0) return 0;
			var loweredCase = false;
			for (;;) switch (encoding) {
				case "ascii":
				case "latin1":
				case "binary": return len$1;
				case "utf8":
				case "utf-8":
				case void 0: return utf8ToBytes(string).length;
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le": return len$1 * 2;
				case "hex": return len$1 >>> 1;
				case "base64": return base64ToBytes(string).length;
				default:
					if (loweredCase) return utf8ToBytes(string).length;
					encoding = ("" + encoding).toLowerCase();
					loweredCase = true;
			}
		}
		Buffer$18.byteLength = byteLength$1;
		function slowToString(encoding, start, end) {
			var loweredCase = false;
			if (start === void 0 || start < 0) start = 0;
			if (start > this.length) return "";
			if (end === void 0 || end > this.length) end = this.length;
			if (end <= 0) return "";
			end >>>= 0;
			start >>>= 0;
			if (end <= start) return "";
			if (!encoding) encoding = "utf8";
			while (true) switch (encoding) {
				case "hex": return hexSlice(this, start, end);
				case "utf8":
				case "utf-8": return utf8Slice(this, start, end);
				case "ascii": return asciiSlice(this, start, end);
				case "latin1":
				case "binary": return latin1Slice(this, start, end);
				case "base64": return base64Slice(this, start, end);
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le": return utf16leSlice(this, start, end);
				default:
					if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
					encoding = (encoding + "").toLowerCase();
					loweredCase = true;
			}
		}
		Buffer$18.prototype._isBuffer = true;
		function swap(b, n, m$3) {
			var i$8 = b[n];
			b[n] = b[m$3];
			b[m$3] = i$8;
		}
		Buffer$18.prototype.swap16 = function swap16() {
			var len$1 = this.length;
			if (len$1 % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
			for (var i$8 = 0; i$8 < len$1; i$8 += 2) swap(this, i$8, i$8 + 1);
			return this;
		};
		Buffer$18.prototype.swap32 = function swap32() {
			var len$1 = this.length;
			if (len$1 % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
			for (var i$8 = 0; i$8 < len$1; i$8 += 4) {
				swap(this, i$8, i$8 + 3);
				swap(this, i$8 + 1, i$8 + 2);
			}
			return this;
		};
		Buffer$18.prototype.swap64 = function swap64() {
			var len$1 = this.length;
			if (len$1 % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
			for (var i$8 = 0; i$8 < len$1; i$8 += 8) {
				swap(this, i$8, i$8 + 7);
				swap(this, i$8 + 1, i$8 + 6);
				swap(this, i$8 + 2, i$8 + 5);
				swap(this, i$8 + 3, i$8 + 4);
			}
			return this;
		};
		Buffer$18.prototype.toString = function toString$11() {
			var length = this.length | 0;
			if (length === 0) return "";
			if (arguments.length === 0) return utf8Slice(this, 0, length);
			return slowToString.apply(this, arguments);
		};
		Buffer$18.prototype.equals = function equals(b) {
			if (!Buffer$18.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
			if (this === b) return true;
			return Buffer$18.compare(this, b) === 0;
		};
		Buffer$18.prototype.inspect = function inspect$5() {
			var str = "";
			var max$9 = exports$1.INSPECT_MAX_BYTES;
			if (this.length > 0) {
				str = this.toString("hex", 0, max$9).match(/.{2}/g).join(" ");
				if (this.length > max$9) str += " ... ";
			}
			return "<Buffer " + str + ">";
		};
		Buffer$18.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
			if (!Buffer$18.isBuffer(target)) throw new TypeError("Argument must be a Buffer");
			if (start === void 0) start = 0;
			if (end === void 0) end = target ? target.length : 0;
			if (thisStart === void 0) thisStart = 0;
			if (thisEnd === void 0) thisEnd = this.length;
			if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
			if (thisStart >= thisEnd && start >= end) return 0;
			if (thisStart >= thisEnd) return -1;
			if (start >= end) return 1;
			start >>>= 0;
			end >>>= 0;
			thisStart >>>= 0;
			thisEnd >>>= 0;
			if (this === target) return 0;
			var x = thisEnd - thisStart;
			var y$3 = end - start;
			var len$1 = Math.min(x, y$3);
			var thisCopy = this.slice(thisStart, thisEnd);
			var targetCopy = target.slice(start, end);
			for (var i$8 = 0; i$8 < len$1; ++i$8) if (thisCopy[i$8] !== targetCopy[i$8]) {
				x = thisCopy[i$8];
				y$3 = targetCopy[i$8];
				break;
			}
			if (x < y$3) return -1;
			if (y$3 < x) return 1;
			return 0;
		};
		function bidirectionalIndexOf(buffer$5, val, byteOffset, encoding, dir) {
			if (buffer$5.length === 0) return -1;
			if (typeof byteOffset === "string") {
				encoding = byteOffset;
				byteOffset = 0;
			} else if (byteOffset > 2147483647) byteOffset = 2147483647;
			else if (byteOffset < -2147483648) byteOffset = -2147483648;
			byteOffset = +byteOffset;
			if (isNaN(byteOffset)) byteOffset = dir ? 0 : buffer$5.length - 1;
			if (byteOffset < 0) byteOffset = buffer$5.length + byteOffset;
			if (byteOffset >= buffer$5.length) if (dir) return -1;
			else byteOffset = buffer$5.length - 1;
			else if (byteOffset < 0) if (dir) byteOffset = 0;
			else return -1;
			if (typeof val === "string") val = Buffer$18.from(val, encoding);
			if (Buffer$18.isBuffer(val)) {
				if (val.length === 0) return -1;
				return arrayIndexOf$7(buffer$5, val, byteOffset, encoding, dir);
			} else if (typeof val === "number") {
				val = val & 255;
				if (Buffer$18.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") if (dir) return Uint8Array.prototype.indexOf.call(buffer$5, val, byteOffset);
				else return Uint8Array.prototype.lastIndexOf.call(buffer$5, val, byteOffset);
				return arrayIndexOf$7(buffer$5, [val], byteOffset, encoding, dir);
			}
			throw new TypeError("val must be string, number or Buffer");
		}
		function arrayIndexOf$7(arr, val, byteOffset, encoding, dir) {
			var indexSize = 1;
			var arrLength = arr.length;
			var valLength = val.length;
			if (encoding !== void 0) {
				encoding = String(encoding).toLowerCase();
				if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
					if (arr.length < 2 || val.length < 2) return -1;
					indexSize = 2;
					arrLength /= 2;
					valLength /= 2;
					byteOffset /= 2;
				}
			}
			function read$6(buf, i$9) {
				if (indexSize === 1) return buf[i$9];
				else return buf.readUInt16BE(i$9 * indexSize);
			}
			var i$8;
			if (dir) {
				var foundIndex = -1;
				for (i$8 = byteOffset; i$8 < arrLength; i$8++) if (read$6(arr, i$8) === read$6(val, foundIndex === -1 ? 0 : i$8 - foundIndex)) {
					if (foundIndex === -1) foundIndex = i$8;
					if (i$8 - foundIndex + 1 === valLength) return foundIndex * indexSize;
				} else {
					if (foundIndex !== -1) i$8 -= i$8 - foundIndex;
					foundIndex = -1;
				}
			} else {
				if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
				for (i$8 = byteOffset; i$8 >= 0; i$8--) {
					var found = true;
					for (var j$7 = 0; j$7 < valLength; j$7++) if (read$6(arr, i$8 + j$7) !== read$6(val, j$7)) {
						found = false;
						break;
					}
					if (found) return i$8;
				}
			}
			return -1;
		}
		Buffer$18.prototype.includes = function includes(val, byteOffset, encoding) {
			return this.indexOf(val, byteOffset, encoding) !== -1;
		};
		Buffer$18.prototype.indexOf = function indexOf$1(val, byteOffset, encoding) {
			return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
		};
		Buffer$18.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
			return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
		};
		function hexWrite(buf, string, offset, length) {
			offset = Number(offset) || 0;
			var remaining = buf.length - offset;
			if (!length) length = remaining;
			else {
				length = Number(length);
				if (length > remaining) length = remaining;
			}
			var strLen = string.length;
			if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
			if (length > strLen / 2) length = strLen / 2;
			for (var i$8 = 0; i$8 < length; ++i$8) {
				var parsed = parseInt(string.substr(i$8 * 2, 2), 16);
				if (isNaN(parsed)) return i$8;
				buf[offset + i$8] = parsed;
			}
			return i$8;
		}
		function utf8Write(buf, string, offset, length) {
			return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
		}
		function asciiWrite(buf, string, offset, length) {
			return blitBuffer(asciiToBytes(string), buf, offset, length);
		}
		function latin1Write(buf, string, offset, length) {
			return asciiWrite(buf, string, offset, length);
		}
		function base64Write(buf, string, offset, length) {
			return blitBuffer(base64ToBytes(string), buf, offset, length);
		}
		function ucs2Write(buf, string, offset, length) {
			return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
		}
		Buffer$18.prototype.write = function write$1(string, offset, length, encoding) {
			if (offset === void 0) {
				encoding = "utf8";
				length = this.length;
				offset = 0;
			} else if (length === void 0 && typeof offset === "string") {
				encoding = offset;
				length = this.length;
				offset = 0;
			} else if (isFinite(offset)) {
				offset = offset | 0;
				if (isFinite(length)) {
					length = length | 0;
					if (encoding === void 0) encoding = "utf8";
				} else {
					encoding = length;
					length = void 0;
				}
			} else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
			var remaining = this.length - offset;
			if (length === void 0 || length > remaining) length = remaining;
			if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
			if (!encoding) encoding = "utf8";
			var loweredCase = false;
			for (;;) switch (encoding) {
				case "hex": return hexWrite(this, string, offset, length);
				case "utf8":
				case "utf-8": return utf8Write(this, string, offset, length);
				case "ascii": return asciiWrite(this, string, offset, length);
				case "latin1":
				case "binary": return latin1Write(this, string, offset, length);
				case "base64": return base64Write(this, string, offset, length);
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le": return ucs2Write(this, string, offset, length);
				default:
					if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
					encoding = ("" + encoding).toLowerCase();
					loweredCase = true;
			}
		};
		Buffer$18.prototype.toJSON = function toJSON$1() {
			return {
				type: "Buffer",
				data: Array.prototype.slice.call(this._arr || this, 0)
			};
		};
		function base64Slice(buf, start, end) {
			if (start === 0 && end === buf.length) return base64Js.fromByteArray(buf);
			else return base64Js.fromByteArray(buf.slice(start, end));
		}
		function utf8Slice(buf, start, end) {
			end = Math.min(buf.length, end);
			var res$2 = [];
			var i$8 = start;
			while (i$8 < end) {
				var firstByte = buf[i$8];
				var codePoint = null;
				var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
				if (i$8 + bytesPerSequence <= end) {
					var secondByte, thirdByte, fourthByte, tempCodePoint;
					switch (bytesPerSequence) {
						case 1:
							if (firstByte < 128) codePoint = firstByte;
							break;
						case 2:
							secondByte = buf[i$8 + 1];
							if ((secondByte & 192) === 128) {
								tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
								if (tempCodePoint > 127) codePoint = tempCodePoint;
							}
							break;
						case 3:
							secondByte = buf[i$8 + 1];
							thirdByte = buf[i$8 + 2];
							if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
								tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
								if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
							}
							break;
						case 4:
							secondByte = buf[i$8 + 1];
							thirdByte = buf[i$8 + 2];
							fourthByte = buf[i$8 + 3];
							if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
								tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
								if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
							}
					}
				}
				if (codePoint === null) {
					codePoint = 65533;
					bytesPerSequence = 1;
				} else if (codePoint > 65535) {
					codePoint -= 65536;
					res$2.push(codePoint >>> 10 & 1023 | 55296);
					codePoint = 56320 | codePoint & 1023;
				}
				res$2.push(codePoint);
				i$8 += bytesPerSequence;
			}
			return decodeCodePointsArray(res$2);
		}
		var MAX_ARGUMENTS_LENGTH = 4096;
		function decodeCodePointsArray(codePoints) {
			var len$1 = codePoints.length;
			if (len$1 <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
			var res$2 = "";
			var i$8 = 0;
			while (i$8 < len$1) res$2 += String.fromCharCode.apply(String, codePoints.slice(i$8, i$8 += MAX_ARGUMENTS_LENGTH));
			return res$2;
		}
		function asciiSlice(buf, start, end) {
			var ret = "";
			end = Math.min(buf.length, end);
			for (var i$8 = start; i$8 < end; ++i$8) ret += String.fromCharCode(buf[i$8] & 127);
			return ret;
		}
		function latin1Slice(buf, start, end) {
			var ret = "";
			end = Math.min(buf.length, end);
			for (var i$8 = start; i$8 < end; ++i$8) ret += String.fromCharCode(buf[i$8]);
			return ret;
		}
		function hexSlice(buf, start, end) {
			var len$1 = buf.length;
			if (!start || start < 0) start = 0;
			if (!end || end < 0 || end > len$1) end = len$1;
			var out = "";
			for (var i$8 = start; i$8 < end; ++i$8) out += toHex(buf[i$8]);
			return out;
		}
		function utf16leSlice(buf, start, end) {
			var bytes$6 = buf.slice(start, end);
			var res$2 = "";
			for (var i$8 = 0; i$8 < bytes$6.length; i$8 += 2) res$2 += String.fromCharCode(bytes$6[i$8] + bytes$6[i$8 + 1] * 256);
			return res$2;
		}
		Buffer$18.prototype.slice = function slice$3(start, end) {
			var len$1 = this.length;
			start = ~~start;
			end = end === void 0 ? len$1 : ~~end;
			if (start < 0) {
				start += len$1;
				if (start < 0) start = 0;
			} else if (start > len$1) start = len$1;
			if (end < 0) {
				end += len$1;
				if (end < 0) end = 0;
			} else if (end > len$1) end = len$1;
			if (end < start) end = start;
			var newBuf;
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				newBuf = this.subarray(start, end);
				newBuf.__proto__ = Buffer$18.prototype;
			} else {
				var sliceLen = end - start;
				newBuf = new Buffer$18(sliceLen, void 0);
				for (var i$8 = 0; i$8 < sliceLen; ++i$8) newBuf[i$8] = this[i$8 + start];
			}
			return newBuf;
		};
		function checkOffset(offset, ext, length) {
			if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
			if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
		}
		Buffer$18.prototype.readUIntLE = function readUIntLE(offset, byteLength$2, noAssert) {
			offset = offset | 0;
			byteLength$2 = byteLength$2 | 0;
			if (!noAssert) checkOffset(offset, byteLength$2, this.length);
			var val = this[offset];
			var mul = 1;
			var i$8 = 0;
			while (++i$8 < byteLength$2 && (mul *= 256)) val += this[offset + i$8] * mul;
			return val;
		};
		Buffer$18.prototype.readUIntBE = function readUIntBE(offset, byteLength$2, noAssert) {
			offset = offset | 0;
			byteLength$2 = byteLength$2 | 0;
			if (!noAssert) checkOffset(offset, byteLength$2, this.length);
			var val = this[offset + --byteLength$2];
			var mul = 1;
			while (byteLength$2 > 0 && (mul *= 256)) val += this[offset + --byteLength$2] * mul;
			return val;
		};
		Buffer$18.prototype.readUInt8 = function readUInt8(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 1, this.length);
			return this[offset];
		};
		Buffer$18.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 2, this.length);
			return this[offset] | this[offset + 1] << 8;
		};
		Buffer$18.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 2, this.length);
			return this[offset] << 8 | this[offset + 1];
		};
		Buffer$18.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 4, this.length);
			return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
		};
		Buffer$18.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 4, this.length);
			return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
		};
		Buffer$18.prototype.readIntLE = function readIntLE(offset, byteLength$2, noAssert) {
			offset = offset | 0;
			byteLength$2 = byteLength$2 | 0;
			if (!noAssert) checkOffset(offset, byteLength$2, this.length);
			var val = this[offset];
			var mul = 1;
			var i$8 = 0;
			while (++i$8 < byteLength$2 && (mul *= 256)) val += this[offset + i$8] * mul;
			mul *= 128;
			if (val >= mul) val -= Math.pow(2, 8 * byteLength$2);
			return val;
		};
		Buffer$18.prototype.readIntBE = function readIntBE(offset, byteLength$2, noAssert) {
			offset = offset | 0;
			byteLength$2 = byteLength$2 | 0;
			if (!noAssert) checkOffset(offset, byteLength$2, this.length);
			var i$8 = byteLength$2;
			var mul = 1;
			var val = this[offset + --i$8];
			while (i$8 > 0 && (mul *= 256)) val += this[offset + --i$8] * mul;
			mul *= 128;
			if (val >= mul) val -= Math.pow(2, 8 * byteLength$2);
			return val;
		};
		Buffer$18.prototype.readInt8 = function readInt8(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 1, this.length);
			if (!(this[offset] & 128)) return this[offset];
			return (255 - this[offset] + 1) * -1;
		};
		Buffer$18.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 2, this.length);
			var val = this[offset] | this[offset + 1] << 8;
			return val & 32768 ? val | 4294901760 : val;
		};
		Buffer$18.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 2, this.length);
			var val = this[offset + 1] | this[offset] << 8;
			return val & 32768 ? val | 4294901760 : val;
		};
		Buffer$18.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 4, this.length);
			return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
		};
		Buffer$18.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 4, this.length);
			return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
		};
		Buffer$18.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 4, this.length);
			return ieee754.read(this, offset, true, 23, 4);
		};
		Buffer$18.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 4, this.length);
			return ieee754.read(this, offset, false, 23, 4);
		};
		Buffer$18.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 8, this.length);
			return ieee754.read(this, offset, true, 52, 8);
		};
		Buffer$18.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
			if (!noAssert) checkOffset(offset, 8, this.length);
			return ieee754.read(this, offset, false, 52, 8);
		};
		function checkInt(buf, value, offset, ext, max$9, min$8) {
			if (!Buffer$18.isBuffer(buf)) throw new TypeError("\"buffer\" argument must be a Buffer instance");
			if (value > max$9 || value < min$8) throw new RangeError("\"value\" argument is out of bounds");
			if (offset + ext > buf.length) throw new RangeError("Index out of range");
		}
		Buffer$18.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength$2, noAssert) {
			value = +value;
			offset = offset | 0;
			byteLength$2 = byteLength$2 | 0;
			if (!noAssert) {
				var maxBytes = Math.pow(2, 8 * byteLength$2) - 1;
				checkInt(this, value, offset, byteLength$2, maxBytes, 0);
			}
			var mul = 1;
			var i$8 = 0;
			this[offset] = value & 255;
			while (++i$8 < byteLength$2 && (mul *= 256)) this[offset + i$8] = value / mul & 255;
			return offset + byteLength$2;
		};
		Buffer$18.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength$2, noAssert) {
			value = +value;
			offset = offset | 0;
			byteLength$2 = byteLength$2 | 0;
			if (!noAssert) {
				var maxBytes = Math.pow(2, 8 * byteLength$2) - 1;
				checkInt(this, value, offset, byteLength$2, maxBytes, 0);
			}
			var i$8 = byteLength$2 - 1;
			var mul = 1;
			this[offset + i$8] = value & 255;
			while (--i$8 >= 0 && (mul *= 256)) this[offset + i$8] = value / mul & 255;
			return offset + byteLength$2;
		};
		Buffer$18.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
			if (!Buffer$18.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
			this[offset] = value & 255;
			return offset + 1;
		};
		function objectWriteUInt16(buf, value, offset, littleEndian) {
			if (value < 0) value = 65535 + value + 1;
			for (var i$8 = 0, j$7 = Math.min(buf.length - offset, 2); i$8 < j$7; ++i$8) buf[offset + i$8] = (value & 255 << 8 * (littleEndian ? i$8 : 1 - i$8)) >>> (littleEndian ? i$8 : 1 - i$8) * 8;
		}
		Buffer$18.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				this[offset] = value & 255;
				this[offset + 1] = value >>> 8;
			} else objectWriteUInt16(this, value, offset, true);
			return offset + 2;
		};
		Buffer$18.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				this[offset] = value >>> 8;
				this[offset + 1] = value & 255;
			} else objectWriteUInt16(this, value, offset, false);
			return offset + 2;
		};
		function objectWriteUInt32(buf, value, offset, littleEndian) {
			if (value < 0) value = 4294967295 + value + 1;
			for (var i$8 = 0, j$7 = Math.min(buf.length - offset, 4); i$8 < j$7; ++i$8) buf[offset + i$8] = value >>> (littleEndian ? i$8 : 3 - i$8) * 8 & 255;
		}
		Buffer$18.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				this[offset + 3] = value >>> 24;
				this[offset + 2] = value >>> 16;
				this[offset + 1] = value >>> 8;
				this[offset] = value & 255;
			} else objectWriteUInt32(this, value, offset, true);
			return offset + 4;
		};
		Buffer$18.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				this[offset] = value >>> 24;
				this[offset + 1] = value >>> 16;
				this[offset + 2] = value >>> 8;
				this[offset + 3] = value & 255;
			} else objectWriteUInt32(this, value, offset, false);
			return offset + 4;
		};
		Buffer$18.prototype.writeIntLE = function writeIntLE(value, offset, byteLength$2, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) {
				var limit$2 = Math.pow(2, 8 * byteLength$2 - 1);
				checkInt(this, value, offset, byteLength$2, limit$2 - 1, -limit$2);
			}
			var i$8 = 0;
			var mul = 1;
			var sub = 0;
			this[offset] = value & 255;
			while (++i$8 < byteLength$2 && (mul *= 256)) {
				if (value < 0 && sub === 0 && this[offset + i$8 - 1] !== 0) sub = 1;
				this[offset + i$8] = (value / mul >> 0) - sub & 255;
			}
			return offset + byteLength$2;
		};
		Buffer$18.prototype.writeIntBE = function writeIntBE(value, offset, byteLength$2, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) {
				var limit$2 = Math.pow(2, 8 * byteLength$2 - 1);
				checkInt(this, value, offset, byteLength$2, limit$2 - 1, -limit$2);
			}
			var i$8 = byteLength$2 - 1;
			var mul = 1;
			var sub = 0;
			this[offset + i$8] = value & 255;
			while (--i$8 >= 0 && (mul *= 256)) {
				if (value < 0 && sub === 0 && this[offset + i$8 + 1] !== 0) sub = 1;
				this[offset + i$8] = (value / mul >> 0) - sub & 255;
			}
			return offset + byteLength$2;
		};
		Buffer$18.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
			if (!Buffer$18.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
			if (value < 0) value = 255 + value + 1;
			this[offset] = value & 255;
			return offset + 1;
		};
		Buffer$18.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				this[offset] = value & 255;
				this[offset + 1] = value >>> 8;
			} else objectWriteUInt16(this, value, offset, true);
			return offset + 2;
		};
		Buffer$18.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				this[offset] = value >>> 8;
				this[offset + 1] = value & 255;
			} else objectWriteUInt16(this, value, offset, false);
			return offset + 2;
		};
		Buffer$18.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				this[offset] = value & 255;
				this[offset + 1] = value >>> 8;
				this[offset + 2] = value >>> 16;
				this[offset + 3] = value >>> 24;
			} else objectWriteUInt32(this, value, offset, true);
			return offset + 4;
		};
		Buffer$18.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
			value = +value;
			offset = offset | 0;
			if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
			if (value < 0) value = 4294967295 + value + 1;
			if (Buffer$18.TYPED_ARRAY_SUPPORT) {
				this[offset] = value >>> 24;
				this[offset + 1] = value >>> 16;
				this[offset + 2] = value >>> 8;
				this[offset + 3] = value & 255;
			} else objectWriteUInt32(this, value, offset, false);
			return offset + 4;
		};
		function checkIEEE754(buf, value, offset, ext, max$9, min$8) {
			if (offset + ext > buf.length) throw new RangeError("Index out of range");
			if (offset < 0) throw new RangeError("Index out of range");
		}
		function writeFloat(buf, value, offset, littleEndian, noAssert) {
			if (!noAssert) checkIEEE754(buf, value, offset, 4);
			ieee754.write(buf, value, offset, littleEndian, 23, 4);
			return offset + 4;
		}
		Buffer$18.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
			return writeFloat(this, value, offset, true, noAssert);
		};
		Buffer$18.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
			return writeFloat(this, value, offset, false, noAssert);
		};
		function writeDouble(buf, value, offset, littleEndian, noAssert) {
			if (!noAssert) checkIEEE754(buf, value, offset, 8);
			ieee754.write(buf, value, offset, littleEndian, 52, 8);
			return offset + 8;
		}
		Buffer$18.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
			return writeDouble(this, value, offset, true, noAssert);
		};
		Buffer$18.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
			return writeDouble(this, value, offset, false, noAssert);
		};
		Buffer$18.prototype.copy = function copy$2(target, targetStart, start, end) {
			if (!start) start = 0;
			if (!end && end !== 0) end = this.length;
			if (targetStart >= target.length) targetStart = target.length;
			if (!targetStart) targetStart = 0;
			if (end > 0 && end < start) end = start;
			if (end === start) return 0;
			if (target.length === 0 || this.length === 0) return 0;
			if (targetStart < 0) throw new RangeError("targetStart out of bounds");
			if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
			if (end < 0) throw new RangeError("sourceEnd out of bounds");
			if (end > this.length) end = this.length;
			if (target.length - targetStart < end - start) end = target.length - targetStart + start;
			var len$1 = end - start;
			var i$8;
			if (this === target && start < targetStart && targetStart < end) for (i$8 = len$1 - 1; i$8 >= 0; --i$8) target[i$8 + targetStart] = this[i$8 + start];
			else if (len$1 < 1e3 || !Buffer$18.TYPED_ARRAY_SUPPORT) for (i$8 = 0; i$8 < len$1; ++i$8) target[i$8 + targetStart] = this[i$8 + start];
			else Uint8Array.prototype.set.call(target, this.subarray(start, start + len$1), targetStart);
			return len$1;
		};
		Buffer$18.prototype.fill = function fill(val, start, end, encoding) {
			if (typeof val === "string") {
				if (typeof start === "string") {
					encoding = start;
					start = 0;
					end = this.length;
				} else if (typeof end === "string") {
					encoding = end;
					end = this.length;
				}
				if (val.length === 1) {
					var code$1 = val.charCodeAt(0);
					if (code$1 < 256) val = code$1;
				}
				if (encoding !== void 0 && typeof encoding !== "string") throw new TypeError("encoding must be a string");
				if (typeof encoding === "string" && !Buffer$18.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
			} else if (typeof val === "number") val = val & 255;
			if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
			if (end <= start) return this;
			start = start >>> 0;
			end = end === void 0 ? this.length : end >>> 0;
			if (!val) val = 0;
			var i$8;
			if (typeof val === "number") for (i$8 = start; i$8 < end; ++i$8) this[i$8] = val;
			else {
				var bytes$6 = Buffer$18.isBuffer(val) ? val : utf8ToBytes(new Buffer$18(val, encoding).toString());
				var len$1 = bytes$6.length;
				for (i$8 = 0; i$8 < end - start; ++i$8) this[i$8 + start] = bytes$6[i$8 % len$1];
			}
			return this;
		};
		var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
		function base64clean(str) {
			str = stringtrim(str).replace(INVALID_BASE64_RE, "");
			if (str.length < 2) return "";
			while (str.length % 4 !== 0) str = str + "=";
			return str;
		}
		function stringtrim(str) {
			if (str.trim) return str.trim();
			return str.replace(/^\s+|\s+$/g, "");
		}
		function toHex(n) {
			if (n < 16) return "0" + n.toString(16);
			return n.toString(16);
		}
		function utf8ToBytes(string, units) {
			units = units || Infinity;
			var codePoint;
			var length = string.length;
			var leadSurrogate = null;
			var bytes$6 = [];
			for (var i$8 = 0; i$8 < length; ++i$8) {
				codePoint = string.charCodeAt(i$8);
				if (codePoint > 55295 && codePoint < 57344) {
					if (!leadSurrogate) {
						if (codePoint > 56319) {
							if ((units -= 3) > -1) bytes$6.push(239, 191, 189);
							continue;
						} else if (i$8 + 1 === length) {
							if ((units -= 3) > -1) bytes$6.push(239, 191, 189);
							continue;
						}
						leadSurrogate = codePoint;
						continue;
					}
					if (codePoint < 56320) {
						if ((units -= 3) > -1) bytes$6.push(239, 191, 189);
						leadSurrogate = codePoint;
						continue;
					}
					codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
				} else if (leadSurrogate) {
					if ((units -= 3) > -1) bytes$6.push(239, 191, 189);
				}
				leadSurrogate = null;
				if (codePoint < 128) {
					if ((units -= 1) < 0) break;
					bytes$6.push(codePoint);
				} else if (codePoint < 2048) {
					if ((units -= 2) < 0) break;
					bytes$6.push(codePoint >> 6 | 192, codePoint & 63 | 128);
				} else if (codePoint < 65536) {
					if ((units -= 3) < 0) break;
					bytes$6.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
				} else if (codePoint < 1114112) {
					if ((units -= 4) < 0) break;
					bytes$6.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
				} else throw new Error("Invalid code point");
			}
			return bytes$6;
		}
		function asciiToBytes(str) {
			var byteArray = [];
			for (var i$8 = 0; i$8 < str.length; ++i$8) byteArray.push(str.charCodeAt(i$8) & 255);
			return byteArray;
		}
		function utf16leToBytes(str, units) {
			var c, hi, lo;
			var byteArray = [];
			for (var i$8 = 0; i$8 < str.length; ++i$8) {
				if ((units -= 2) < 0) break;
				c = str.charCodeAt(i$8);
				hi = c >> 8;
				lo = c % 256;
				byteArray.push(lo);
				byteArray.push(hi);
			}
			return byteArray;
		}
		function base64ToBytes(str) {
			return base64Js.toByteArray(base64clean(str));
		}
		function blitBuffer(src$1, dst, offset, length) {
			for (var i$8 = 0; i$8 < length; ++i$8) {
				if (i$8 + offset >= dst.length || i$8 >= src$1.length) break;
				dst[i$8 + offset] = src$1[i$8];
			}
			return i$8;
		}
		function isnan(val) {
			return val !== val;
		}
	});
	var buffer_1 = buffer$3.Buffer;
	buffer$3.SlowBuffer;
	buffer$3.INSPECT_MAX_BYTES;
	buffer$3.kMaxLength;
	/**
	* Serialize a Headers instance into a pojo since it cannot be stringified.
	* @param {*} headers
	*/
	function serializeHeaders(headers$1) {
		if (headers$1 && typeof headers$1.forEach === "function") {
			const serializedHeaders = {};
			headers$1.forEach((value, key$1) => serializedHeaders[key$1] = value);
			return serializedHeaders;
		}
		return headers$1 || {};
	}
	function ownKeys$3(object, enumerableOnly) {
		var keys$6 = keys$1$2(object);
		if (getOwnPropertySymbols$1$2) {
			var symbols = getOwnPropertySymbols$1$2(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1$2(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$3(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$3(Object(source), true).forEach(function(key$1) {
				_defineProperty$2(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1$2) defineProperties$1$2(target, getOwnPropertyDescriptors$1$2(source));
			else ownKeys$3(Object(source)).forEach(function(key$1) {
				defineProperty$2$4(target, key$1, getOwnPropertyDescriptor$1$2(source, key$1));
			});
		}
		return target;
	}
	const { defineProperty: defineProperty$4 } = Object;
	const IS_STUBBED = symbol$1();
	const ABORT_HANDLER = symbol$1();
	const REQUEST_ARGUMENTS = symbol$1();
	var FetchAdapter$1 = class extends Adapter {
		static get id() {
			return "fetch";
		}
		get defaultOptions() {
			return { context: global };
		}
		onConnect() {
			const { context } = this.options;
			[
				"fetch",
				"Request",
				"Response",
				"Headers"
			].forEach((key$1) => this.assert(`${key$1} global not found.`, !!(context && context[key$1])));
			this.assert("Running concurrent fetch adapters is unsupported, stop any running Polly instances.", !context.fetch[IS_STUBBED] && !context.Request[IS_STUBBED]);
			this.nativeFetch = context.fetch;
			this.NativeRequest = context.Request;
			const NativeRequest = this.NativeRequest;
			context.Request = function Request$1(url$6, options) {
				const request = new NativeRequest(url$6, options);
				let args;
				options = options || {};
				if (typeof url$6 === "object" && url$6[REQUEST_ARGUMENTS]) {
					const reqArgs = url$6[REQUEST_ARGUMENTS];
					args = _objectSpread$3(_objectSpread$3({}, reqArgs), {}, { options: _objectSpread$3(_objectSpread$3({}, reqArgs.options), options) });
				} else args = {
					url: url$6,
					options
				};
				defineProperty$4(request, REQUEST_ARGUMENTS, { value: args });
				request.clone = function clone$2() {
					return new context.Request(request);
				};
				return request;
			};
			defineProperty$4(context.Request, IS_STUBBED, { value: true });
			context.fetch = (url$6, options = {}) => {
				let respond;
				if (typeof url$6 === "object" && url$6[REQUEST_ARGUMENTS]) {
					const req$2 = url$6;
					const reqArgs = req$2[REQUEST_ARGUMENTS];
					url$6 = reqArgs.url;
					options = _objectSpread$3(_objectSpread$3({}, reqArgs.options), options);
					if ("body" in reqArgs.options) defineProperty$4(req$2, "bodyUsed", { value: true });
				}
				const promise = new promise$1$1((resolve$6, reject) => {
					respond = ({ response, error }) => {
						if (error) reject(error);
						else resolve$6(response);
					};
				});
				this.handleRequest({
					url: url$6,
					method: options.method || "GET",
					headers: serializeHeaders(new context.Headers(options.headers)),
					body: options.body,
					requestArguments: {
						options,
						respond
					}
				});
				return promise;
			};
			defineProperty$4(context.fetch, IS_STUBBED, { value: true });
		}
		onDisconnect() {
			const { context } = this.options;
			context.fetch = this.nativeFetch;
			context.Request = this.NativeRequest;
			this.nativeFetch = null;
			this.NativeRequest = null;
		}
		onRequest(pollyRequest) {
			const { options: { signal } } = pollyRequest.requestArguments;
			if (signal) if (signal.aborted) pollyRequest.abort();
			else {
				pollyRequest[ABORT_HANDLER] = () => pollyRequest.abort();
				signal.addEventListener("abort", pollyRequest[ABORT_HANDLER]);
			}
		}
		async onFetchResponse(pollyRequest) {
			const { context } = this.options;
			const { options } = pollyRequest.requestArguments;
			const response = await this.nativeFetch.apply(context, [pollyRequest.url, _objectSpread$3(_objectSpread$3({}, options), {}, {
				method: pollyRequest.method,
				headers: pollyRequest.headers,
				body: pollyRequest.body
			})]);
			let arrayBuffer = await response.arrayBuffer();
			if (arrayBuffer && !(arrayBuffer instanceof ArrayBuffer) && "byteLength" in arrayBuffer) arrayBuffer = utils$4.cloneArrayBuffer(arrayBuffer);
			const buffer$5 = buffer_1.from(arrayBuffer);
			const isBinaryBuffer = !utils$4.isBufferUtf8Representable(buffer$5);
			return {
				statusCode: response.status,
				headers: serializeHeaders(response.headers),
				body: buffer$5.toString(isBinaryBuffer ? "base64" : "utf8"),
				encoding: isBinaryBuffer ? "base64" : void 0
			};
		}
		onRespond(pollyRequest, error) {
			const { context: { Response: Response$1 } } = this.options;
			const { respond, options: { signal } } = pollyRequest.requestArguments;
			if (signal && pollyRequest[ABORT_HANDLER]) signal.removeEventListener("abort", pollyRequest[ABORT_HANDLER]);
			if (pollyRequest.aborted) {
				respond({ error: new DOMException("The user aborted a request.", "AbortError") });
				return;
			}
			if (error) {
				respond({ error });
				return;
			}
			const { absoluteUrl, response: pollyResponse } = pollyRequest;
			const { statusCode, body: body$1, encoding } = pollyResponse;
			let responseBody = body$1;
			if (statusCode === 204 && responseBody === "") responseBody = null;
			else if (encoding) responseBody = bufferToArrayBuffer(buffer_1.from(body$1, encoding));
			const response = new Response$1(responseBody, {
				status: statusCode,
				statusText: pollyResponse.statusText,
				headers: pollyResponse.headers
			});
			defineProperty$4(response, "url", { value: absoluteUrl });
			respond({ response });
		}
	};
	module.exports = FetchAdapter$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/es5.js
var require_es5 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/bowser@2.12.1/node_modules/bowser/es5.js": ((exports, module) => {
	(function(e, t) {
		"object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.bowser = t() : e.bowser = t();
	})(exports, (function() {
		return function(e) {
			var t = {};
			function r(i$8) {
				if (t[i$8]) return t[i$8].exports;
				var n = t[i$8] = {
					i: i$8,
					l: !1,
					exports: {}
				};
				return e[i$8].call(n.exports, n, n.exports, r), n.l = !0, n.exports;
			}
			return r.m = e, r.c = t, r.d = function(e$1, t$1, i$8) {
				r.o(e$1, t$1) || Object.defineProperty(e$1, t$1, {
					enumerable: !0,
					get: i$8
				});
			}, r.r = function(e$1) {
				"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e$1, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e$1, "__esModule", { value: !0 });
			}, r.t = function(e$1, t$1) {
				if (1 & t$1 && (e$1 = r(e$1)), 8 & t$1) return e$1;
				if (4 & t$1 && "object" == typeof e$1 && e$1 && e$1.__esModule) return e$1;
				var i$8 = Object.create(null);
				if (r.r(i$8), Object.defineProperty(i$8, "default", {
					enumerable: !0,
					value: e$1
				}), 2 & t$1 && "string" != typeof e$1) for (var n in e$1) r.d(i$8, n, function(t$2) {
					return e$1[t$2];
				}.bind(null, n));
				return i$8;
			}, r.n = function(e$1) {
				var t$1 = e$1 && e$1.__esModule ? function() {
					return e$1.default;
				} : function() {
					return e$1;
				};
				return r.d(t$1, "a", t$1), t$1;
			}, r.o = function(e$1, t$1) {
				return Object.prototype.hasOwnProperty.call(e$1, t$1);
			}, r.p = "", r(r.s = 90);
		}({
			17: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i$8 = r(18);
				t.default = function() {
					function e$1() {}
					return e$1.getFirstMatch = function(e$2, t$1) {
						var r$1 = t$1.match(e$2);
						return r$1 && r$1.length > 0 && r$1[1] || "";
					}, e$1.getSecondMatch = function(e$2, t$1) {
						var r$1 = t$1.match(e$2);
						return r$1 && r$1.length > 1 && r$1[2] || "";
					}, e$1.matchAndReturnConst = function(e$2, t$1, r$1) {
						if (e$2.test(t$1)) return r$1;
					}, e$1.getWindowsVersionName = function(e$2) {
						switch (e$2) {
							case "NT": return "NT";
							case "XP": return "XP";
							case "NT 5.0": return "2000";
							case "NT 5.1": return "XP";
							case "NT 5.2": return "2003";
							case "NT 6.0": return "Vista";
							case "NT 6.1": return "7";
							case "NT 6.2": return "8";
							case "NT 6.3": return "8.1";
							case "NT 10.0": return "10";
							default: return;
						}
					}, e$1.getMacOSVersionName = function(e$2) {
						var t$1 = e$2.split(".").splice(0, 2).map((function(e$3) {
							return parseInt(e$3, 10) || 0;
						}));
						if (t$1.push(0), 10 === t$1[0]) switch (t$1[1]) {
							case 5: return "Leopard";
							case 6: return "Snow Leopard";
							case 7: return "Lion";
							case 8: return "Mountain Lion";
							case 9: return "Mavericks";
							case 10: return "Yosemite";
							case 11: return "El Capitan";
							case 12: return "Sierra";
							case 13: return "High Sierra";
							case 14: return "Mojave";
							case 15: return "Catalina";
							default: return;
						}
					}, e$1.getAndroidVersionName = function(e$2) {
						var t$1 = e$2.split(".").splice(0, 2).map((function(e$3) {
							return parseInt(e$3, 10) || 0;
						}));
						if (t$1.push(0), !(1 === t$1[0] && t$1[1] < 5)) return 1 === t$1[0] && t$1[1] < 6 ? "Cupcake" : 1 === t$1[0] && t$1[1] >= 6 ? "Donut" : 2 === t$1[0] && t$1[1] < 2 ? "Eclair" : 2 === t$1[0] && 2 === t$1[1] ? "Froyo" : 2 === t$1[0] && t$1[1] > 2 ? "Gingerbread" : 3 === t$1[0] ? "Honeycomb" : 4 === t$1[0] && t$1[1] < 1 ? "Ice Cream Sandwich" : 4 === t$1[0] && t$1[1] < 4 ? "Jelly Bean" : 4 === t$1[0] && t$1[1] >= 4 ? "KitKat" : 5 === t$1[0] ? "Lollipop" : 6 === t$1[0] ? "Marshmallow" : 7 === t$1[0] ? "Nougat" : 8 === t$1[0] ? "Oreo" : 9 === t$1[0] ? "Pie" : void 0;
					}, e$1.getVersionPrecision = function(e$2) {
						return e$2.split(".").length;
					}, e$1.compareVersions = function(t$1, r$1, i$9) {
						void 0 === i$9 && (i$9 = !1);
						var n = e$1.getVersionPrecision(t$1), s$3 = e$1.getVersionPrecision(r$1), a = Math.max(n, s$3), o = 0, u$12 = e$1.map([t$1, r$1], (function(t$2) {
							var r$2 = a - e$1.getVersionPrecision(t$2), i$10 = t$2 + new Array(r$2 + 1).join(".0");
							return e$1.map(i$10.split("."), (function(e$2) {
								return new Array(20 - e$2.length).join("0") + e$2;
							})).reverse();
						}));
						for (i$9 && (o = a - Math.min(n, s$3)), a -= 1; a >= o;) {
							if (u$12[0][a] > u$12[1][a]) return 1;
							if (u$12[0][a] === u$12[1][a]) {
								if (a === o) return 0;
								a -= 1;
							} else if (u$12[0][a] < u$12[1][a]) return -1;
						}
					}, e$1.map = function(e$2, t$1) {
						var r$1, i$9 = [];
						if (Array.prototype.map) return Array.prototype.map.call(e$2, t$1);
						for (r$1 = 0; r$1 < e$2.length; r$1 += 1) i$9.push(t$1(e$2[r$1]));
						return i$9;
					}, e$1.find = function(e$2, t$1) {
						var r$1, i$9;
						if (Array.prototype.find) return Array.prototype.find.call(e$2, t$1);
						for (r$1 = 0, i$9 = e$2.length; r$1 < i$9; r$1 += 1) {
							var n = e$2[r$1];
							if (t$1(n, r$1)) return n;
						}
					}, e$1.assign = function(e$2) {
						for (var t$1, r$1, i$9 = e$2, n = arguments.length, s$3 = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) s$3[a - 1] = arguments[a];
						if (Object.assign) return Object.assign.apply(Object, [e$2].concat(s$3));
						var o = function() {
							var e$3 = s$3[t$1];
							"object" == typeof e$3 && null !== e$3 && Object.keys(e$3).forEach((function(t$2) {
								i$9[t$2] = e$3[t$2];
							}));
						};
						for (t$1 = 0, r$1 = s$3.length; t$1 < r$1; t$1 += 1) o();
						return e$2;
					}, e$1.getBrowserAlias = function(e$2) {
						return i$8.BROWSER_ALIASES_MAP[e$2];
					}, e$1.getBrowserTypeByAlias = function(e$2) {
						return i$8.BROWSER_MAP[e$2] || "";
					}, e$1;
				}(), e.exports = t.default;
			},
			18: function(e, t, r) {
				t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0;
				t.BROWSER_ALIASES_MAP = {
					"Amazon Silk": "amazon_silk",
					"Android Browser": "android",
					Bada: "bada",
					BlackBerry: "blackberry",
					Chrome: "chrome",
					Chromium: "chromium",
					Electron: "electron",
					Epiphany: "epiphany",
					Firefox: "firefox",
					Focus: "focus",
					Generic: "generic",
					"Google Search": "google_search",
					Googlebot: "googlebot",
					"Internet Explorer": "ie",
					"K-Meleon": "k_meleon",
					Maxthon: "maxthon",
					"Microsoft Edge": "edge",
					"MZ Browser": "mz",
					"NAVER Whale Browser": "naver",
					Opera: "opera",
					"Opera Coast": "opera_coast",
					"Pale Moon": "pale_moon",
					PhantomJS: "phantomjs",
					Puffin: "puffin",
					QupZilla: "qupzilla",
					QQ: "qq",
					QQLite: "qqlite",
					Safari: "safari",
					Sailfish: "sailfish",
					"Samsung Internet for Android": "samsung_internet",
					SeaMonkey: "seamonkey",
					Sleipnir: "sleipnir",
					Swing: "swing",
					Tizen: "tizen",
					"UC Browser": "uc",
					Vivaldi: "vivaldi",
					"WebOS Browser": "webos",
					WeChat: "wechat",
					"Yandex Browser": "yandex",
					Roku: "roku"
				};
				t.BROWSER_MAP = {
					amazon_silk: "Amazon Silk",
					android: "Android Browser",
					bada: "Bada",
					blackberry: "BlackBerry",
					chrome: "Chrome",
					chromium: "Chromium",
					electron: "Electron",
					epiphany: "Epiphany",
					firefox: "Firefox",
					focus: "Focus",
					generic: "Generic",
					googlebot: "Googlebot",
					google_search: "Google Search",
					ie: "Internet Explorer",
					k_meleon: "K-Meleon",
					maxthon: "Maxthon",
					edge: "Microsoft Edge",
					mz: "MZ Browser",
					naver: "NAVER Whale Browser",
					opera: "Opera",
					opera_coast: "Opera Coast",
					pale_moon: "Pale Moon",
					phantomjs: "PhantomJS",
					puffin: "Puffin",
					qupzilla: "QupZilla",
					qq: "QQ Browser",
					qqlite: "QQ Browser Lite",
					safari: "Safari",
					sailfish: "Sailfish",
					samsung_internet: "Samsung Internet for Android",
					seamonkey: "SeaMonkey",
					sleipnir: "Sleipnir",
					swing: "Swing",
					tizen: "Tizen",
					uc: "UC Browser",
					vivaldi: "Vivaldi",
					webos: "WebOS Browser",
					wechat: "WeChat",
					yandex: "Yandex Browser"
				};
				t.PLATFORMS_MAP = {
					tablet: "tablet",
					mobile: "mobile",
					desktop: "desktop",
					tv: "tv",
					bot: "bot"
				};
				t.OS_MAP = {
					WindowsPhone: "Windows Phone",
					Windows: "Windows",
					MacOS: "macOS",
					iOS: "iOS",
					Android: "Android",
					WebOS: "WebOS",
					BlackBerry: "BlackBerry",
					Bada: "Bada",
					Tizen: "Tizen",
					Linux: "Linux",
					ChromeOS: "Chrome OS",
					PlayStation4: "PlayStation 4",
					Roku: "Roku"
				};
				t.ENGINE_MAP = {
					EdgeHTML: "EdgeHTML",
					Blink: "Blink",
					Trident: "Trident",
					Presto: "Presto",
					Gecko: "Gecko",
					WebKit: "WebKit"
				};
			},
			90: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i$8, n = (i$8 = r(91)) && i$8.__esModule ? i$8 : { default: i$8 }, s$3 = r(18);
				function a(e$1, t$1) {
					for (var r$1 = 0; r$1 < t$1.length; r$1++) {
						var i$9 = t$1[r$1];
						i$9.enumerable = i$9.enumerable || !1, i$9.configurable = !0, "value" in i$9 && (i$9.writable = !0), Object.defineProperty(e$1, i$9.key, i$9);
					}
				}
				t.default = function() {
					function e$1() {}
					var t$1, r$1, i$9;
					return e$1.getParser = function(e$2, t$2) {
						if (void 0 === t$2 && (t$2 = !1), "string" != typeof e$2) throw new Error("UserAgent should be a string");
						return new n.default(e$2, t$2);
					}, e$1.parse = function(e$2) {
						return new n.default(e$2).getResult();
					}, t$1 = e$1, i$9 = [
						{
							key: "BROWSER_MAP",
							get: function() {
								return s$3.BROWSER_MAP;
							}
						},
						{
							key: "ENGINE_MAP",
							get: function() {
								return s$3.ENGINE_MAP;
							}
						},
						{
							key: "OS_MAP",
							get: function() {
								return s$3.OS_MAP;
							}
						},
						{
							key: "PLATFORMS_MAP",
							get: function() {
								return s$3.PLATFORMS_MAP;
							}
						}
					], (r$1 = null) && a(t$1.prototype, r$1), i$9 && a(t$1, i$9), e$1;
				}(), e.exports = t.default;
			},
			91: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i$8 = u$12(r(92)), n = u$12(r(93)), s$3 = u$12(r(94)), a = u$12(r(95)), o = u$12(r(17));
				function u$12(e$1) {
					return e$1 && e$1.__esModule ? e$1 : { default: e$1 };
				}
				t.default = function() {
					function e$1(e$2, t$2) {
						if (void 0 === t$2 && (t$2 = !1), null == e$2 || "" === e$2) throw new Error("UserAgent parameter can't be empty");
						this._ua = e$2, this.parsedResult = {}, !0 !== t$2 && this.parse();
					}
					var t$1 = e$1.prototype;
					return t$1.getUA = function() {
						return this._ua;
					}, t$1.test = function(e$2) {
						return e$2.test(this._ua);
					}, t$1.parseBrowser = function() {
						var e$2 = this;
						this.parsedResult.browser = {};
						var t$2 = o.default.find(i$8.default, (function(t$3) {
							if ("function" == typeof t$3.test) return t$3.test(e$2);
							if (Array.isArray(t$3.test)) return t$3.test.some((function(t$4) {
								return e$2.test(t$4);
							}));
							throw new Error("Browser's test function is not valid");
						}));
						return t$2 && (this.parsedResult.browser = t$2.describe(this.getUA())), this.parsedResult.browser;
					}, t$1.getBrowser = function() {
						return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
					}, t$1.getBrowserName = function(e$2) {
						return e$2 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
					}, t$1.getBrowserVersion = function() {
						return this.getBrowser().version;
					}, t$1.getOS = function() {
						return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
					}, t$1.parseOS = function() {
						var e$2 = this;
						this.parsedResult.os = {};
						var t$2 = o.default.find(n.default, (function(t$3) {
							if ("function" == typeof t$3.test) return t$3.test(e$2);
							if (Array.isArray(t$3.test)) return t$3.test.some((function(t$4) {
								return e$2.test(t$4);
							}));
							throw new Error("Browser's test function is not valid");
						}));
						return t$2 && (this.parsedResult.os = t$2.describe(this.getUA())), this.parsedResult.os;
					}, t$1.getOSName = function(e$2) {
						var t$2 = this.getOS().name;
						return e$2 ? String(t$2).toLowerCase() || "" : t$2 || "";
					}, t$1.getOSVersion = function() {
						return this.getOS().version;
					}, t$1.getPlatform = function() {
						return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
					}, t$1.getPlatformType = function(e$2) {
						void 0 === e$2 && (e$2 = !1);
						var t$2 = this.getPlatform().type;
						return e$2 ? String(t$2).toLowerCase() || "" : t$2 || "";
					}, t$1.parsePlatform = function() {
						var e$2 = this;
						this.parsedResult.platform = {};
						var t$2 = o.default.find(s$3.default, (function(t$3) {
							if ("function" == typeof t$3.test) return t$3.test(e$2);
							if (Array.isArray(t$3.test)) return t$3.test.some((function(t$4) {
								return e$2.test(t$4);
							}));
							throw new Error("Browser's test function is not valid");
						}));
						return t$2 && (this.parsedResult.platform = t$2.describe(this.getUA())), this.parsedResult.platform;
					}, t$1.getEngine = function() {
						return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
					}, t$1.getEngineName = function(e$2) {
						return e$2 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
					}, t$1.parseEngine = function() {
						var e$2 = this;
						this.parsedResult.engine = {};
						var t$2 = o.default.find(a.default, (function(t$3) {
							if ("function" == typeof t$3.test) return t$3.test(e$2);
							if (Array.isArray(t$3.test)) return t$3.test.some((function(t$4) {
								return e$2.test(t$4);
							}));
							throw new Error("Browser's test function is not valid");
						}));
						return t$2 && (this.parsedResult.engine = t$2.describe(this.getUA())), this.parsedResult.engine;
					}, t$1.parse = function() {
						return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
					}, t$1.getResult = function() {
						return o.default.assign({}, this.parsedResult);
					}, t$1.satisfies = function(e$2) {
						var t$2 = this, r$1 = {}, i$9 = 0, n$1 = {}, s$4 = 0;
						if (Object.keys(e$2).forEach((function(t$3) {
							var a$2 = e$2[t$3];
							"string" == typeof a$2 ? (n$1[t$3] = a$2, s$4 += 1) : "object" == typeof a$2 && (r$1[t$3] = a$2, i$9 += 1);
						})), i$9 > 0) {
							var a$1 = Object.keys(r$1), u$13 = o.default.find(a$1, (function(e$3) {
								return t$2.isOS(e$3);
							}));
							if (u$13) {
								var d$3 = this.satisfies(r$1[u$13]);
								if (void 0 !== d$3) return d$3;
							}
							var c = o.default.find(a$1, (function(e$3) {
								return t$2.isPlatform(e$3);
							}));
							if (c) {
								var f = this.satisfies(r$1[c]);
								if (void 0 !== f) return f;
							}
						}
						if (s$4 > 0) {
							var l = Object.keys(n$1), h$3 = o.default.find(l, (function(e$3) {
								return t$2.isBrowser(e$3, !0);
							}));
							if (void 0 !== h$3) return this.compareVersion(n$1[h$3]);
						}
					}, t$1.isBrowser = function(e$2, t$2) {
						void 0 === t$2 && (t$2 = !1);
						var r$1 = this.getBrowserName().toLowerCase(), i$9 = e$2.toLowerCase(), n$1 = o.default.getBrowserTypeByAlias(i$9);
						return t$2 && n$1 && (i$9 = n$1.toLowerCase()), i$9 === r$1;
					}, t$1.compareVersion = function(e$2) {
						var t$2 = [0], r$1 = e$2, i$9 = !1, n$1 = this.getBrowserVersion();
						if ("string" == typeof n$1) return ">" === e$2[0] || "<" === e$2[0] ? (r$1 = e$2.substr(1), "=" === e$2[1] ? (i$9 = !0, r$1 = e$2.substr(2)) : t$2 = [], ">" === e$2[0] ? t$2.push(1) : t$2.push(-1)) : "=" === e$2[0] ? r$1 = e$2.substr(1) : "~" === e$2[0] && (i$9 = !0, r$1 = e$2.substr(1)), t$2.indexOf(o.default.compareVersions(n$1, r$1, i$9)) > -1;
					}, t$1.isOS = function(e$2) {
						return this.getOSName(!0) === String(e$2).toLowerCase();
					}, t$1.isPlatform = function(e$2) {
						return this.getPlatformType(!0) === String(e$2).toLowerCase();
					}, t$1.isEngine = function(e$2) {
						return this.getEngineName(!0) === String(e$2).toLowerCase();
					}, t$1.is = function(e$2, t$2) {
						return void 0 === t$2 && (t$2 = !1), this.isBrowser(e$2, t$2) || this.isOS(e$2) || this.isPlatform(e$2);
					}, t$1.some = function(e$2) {
						var t$2 = this;
						return void 0 === e$2 && (e$2 = []), e$2.some((function(e$3) {
							return t$2.is(e$3);
						}));
					}, e$1;
				}(), e.exports = t.default;
			},
			92: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i$8, n = (i$8 = r(17)) && i$8.__esModule ? i$8 : { default: i$8 };
				var s$3 = /version\/(\d+(\.?_?\d+)+)/i;
				t.default = [
					{
						test: [/googlebot/i],
						describe: function(e$1) {
							var t$1 = { name: "Googlebot" }, r$1 = n.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/opera/i],
						describe: function(e$1) {
							var t$1 = { name: "Opera" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/opr\/|opios/i],
						describe: function(e$1) {
							var t$1 = { name: "Opera" }, r$1 = n.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/SamsungBrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "Samsung Internet for Android" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/Whale/i],
						describe: function(e$1) {
							var t$1 = { name: "NAVER Whale Browser" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/PaleMoon/i],
						describe: function(e$1) {
							var t$1 = { name: "Pale Moon" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:PaleMoon)[\s/](\d+(?:\.\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/MZBrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "MZ Browser" }, r$1 = n.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/focus/i],
						describe: function(e$1) {
							var t$1 = { name: "Focus" }, r$1 = n.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/swing/i],
						describe: function(e$1) {
							var t$1 = { name: "Swing" }, r$1 = n.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/coast/i],
						describe: function(e$1) {
							var t$1 = { name: "Opera Coast" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/opt\/\d+(?:.?_?\d+)+/i],
						describe: function(e$1) {
							var t$1 = { name: "Opera Touch" }, r$1 = n.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/yabrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "Yandex Browser" }, r$1 = n.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/ucbrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "UC Browser" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/Maxthon|mxios/i],
						describe: function(e$1) {
							var t$1 = { name: "Maxthon" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/epiphany/i],
						describe: function(e$1) {
							var t$1 = { name: "Epiphany" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/puffin/i],
						describe: function(e$1) {
							var t$1 = { name: "Puffin" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/sleipnir/i],
						describe: function(e$1) {
							var t$1 = { name: "Sleipnir" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/k-meleon/i],
						describe: function(e$1) {
							var t$1 = { name: "K-Meleon" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/micromessenger/i],
						describe: function(e$1) {
							var t$1 = { name: "WeChat" }, r$1 = n.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/qqbrowser/i],
						describe: function(e$1) {
							var t$1 = { name: /qqbrowserlite/i.test(e$1) ? "QQ Browser Lite" : "QQ Browser" }, r$1 = n.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/msie|trident/i],
						describe: function(e$1) {
							var t$1 = { name: "Internet Explorer" }, r$1 = n.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/\sedg\//i],
						describe: function(e$1) {
							var t$1 = { name: "Microsoft Edge" }, r$1 = n.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/edg([ea]|ios)/i],
						describe: function(e$1) {
							var t$1 = { name: "Microsoft Edge" }, r$1 = n.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/vivaldi/i],
						describe: function(e$1) {
							var t$1 = { name: "Vivaldi" }, r$1 = n.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/seamonkey/i],
						describe: function(e$1) {
							var t$1 = { name: "SeaMonkey" }, r$1 = n.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/sailfish/i],
						describe: function(e$1) {
							var t$1 = { name: "Sailfish" }, r$1 = n.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/silk/i],
						describe: function(e$1) {
							var t$1 = { name: "Amazon Silk" }, r$1 = n.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/phantom/i],
						describe: function(e$1) {
							var t$1 = { name: "PhantomJS" }, r$1 = n.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/slimerjs/i],
						describe: function(e$1) {
							var t$1 = { name: "SlimerJS" }, r$1 = n.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
						describe: function(e$1) {
							var t$1 = { name: "BlackBerry" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/(web|hpw)[o0]s/i],
						describe: function(e$1) {
							var t$1 = { name: "WebOS Browser" }, r$1 = n.default.getFirstMatch(s$3, e$1) || n.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/bada/i],
						describe: function(e$1) {
							var t$1 = { name: "Bada" }, r$1 = n.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/tizen/i],
						describe: function(e$1) {
							var t$1 = { name: "Tizen" }, r$1 = n.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/qupzilla/i],
						describe: function(e$1) {
							var t$1 = { name: "QupZilla" }, r$1 = n.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/firefox|iceweasel|fxios/i],
						describe: function(e$1) {
							var t$1 = { name: "Firefox" }, r$1 = n.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/electron/i],
						describe: function(e$1) {
							var t$1 = { name: "Electron" }, r$1 = n.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/MiuiBrowser/i],
						describe: function(e$1) {
							var t$1 = { name: "Miui" }, r$1 = n.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/chromium/i],
						describe: function(e$1) {
							var t$1 = { name: "Chromium" }, r$1 = n.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e$1) || n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/chrome|crios|crmo/i],
						describe: function(e$1) {
							var t$1 = { name: "Chrome" }, r$1 = n.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/GSA/i],
						describe: function(e$1) {
							var t$1 = { name: "Google Search" }, r$1 = n.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: function(e$1) {
							var t$1 = !e$1.test(/like android/i), r$1 = e$1.test(/android/i);
							return t$1 && r$1;
						},
						describe: function(e$1) {
							var t$1 = { name: "Android Browser" }, r$1 = n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/playstation 4/i],
						describe: function(e$1) {
							var t$1 = { name: "PlayStation 4" }, r$1 = n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/safari|applewebkit/i],
						describe: function(e$1) {
							var t$1 = { name: "Safari" }, r$1 = n.default.getFirstMatch(s$3, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/.*/i],
						describe: function(e$1) {
							var t$1 = -1 !== e$1.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
							return {
								name: n.default.getFirstMatch(t$1, e$1),
								version: n.default.getSecondMatch(t$1, e$1)
							};
						}
					}
				], e.exports = t.default;
			},
			93: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i$8, n = (i$8 = r(17)) && i$8.__esModule ? i$8 : { default: i$8 }, s$3 = r(18);
				t.default = [
					{
						test: [/Roku\/DVP/],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e$1);
							return {
								name: s$3.OS_MAP.Roku,
								version: t$1
							};
						}
					},
					{
						test: [/windows phone/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e$1);
							return {
								name: s$3.OS_MAP.WindowsPhone,
								version: t$1
							};
						}
					},
					{
						test: [/windows /i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e$1), r$1 = n.default.getWindowsVersionName(t$1);
							return {
								name: s$3.OS_MAP.Windows,
								version: t$1,
								versionName: r$1
							};
						}
					},
					{
						test: [/Macintosh(.*?) FxiOS(.*?)\//],
						describe: function(e$1) {
							var t$1 = { name: s$3.OS_MAP.iOS }, r$1 = n.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/macintosh/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e$1).replace(/[_\s]/g, "."), r$1 = n.default.getMacOSVersionName(t$1), i$9 = {
								name: s$3.OS_MAP.MacOS,
								version: t$1
							};
							return r$1 && (i$9.versionName = r$1), i$9;
						}
					},
					{
						test: [/(ipod|iphone|ipad)/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e$1).replace(/[_\s]/g, ".");
							return {
								name: s$3.OS_MAP.iOS,
								version: t$1
							};
						}
					},
					{
						test: function(e$1) {
							var t$1 = !e$1.test(/like android/i), r$1 = e$1.test(/android/i);
							return t$1 && r$1;
						},
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e$1), r$1 = n.default.getAndroidVersionName(t$1), i$9 = {
								name: s$3.OS_MAP.Android,
								version: t$1
							};
							return r$1 && (i$9.versionName = r$1), i$9;
						}
					},
					{
						test: [/(web|hpw)[o0]s/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e$1), r$1 = { name: s$3.OS_MAP.WebOS };
							return t$1 && t$1.length && (r$1.version = t$1), r$1;
						}
					},
					{
						test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e$1) || n.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e$1) || n.default.getFirstMatch(/\bbb(\d+)/i, e$1);
							return {
								name: s$3.OS_MAP.BlackBerry,
								version: t$1
							};
						}
					},
					{
						test: [/bada/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e$1);
							return {
								name: s$3.OS_MAP.Bada,
								version: t$1
							};
						}
					},
					{
						test: [/tizen/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e$1);
							return {
								name: s$3.OS_MAP.Tizen,
								version: t$1
							};
						}
					},
					{
						test: [/linux/i],
						describe: function() {
							return { name: s$3.OS_MAP.Linux };
						}
					},
					{
						test: [/CrOS/],
						describe: function() {
							return { name: s$3.OS_MAP.ChromeOS };
						}
					},
					{
						test: [/PlayStation 4/],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e$1);
							return {
								name: s$3.OS_MAP.PlayStation4,
								version: t$1
							};
						}
					}
				], e.exports = t.default;
			},
			94: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i$8, n = (i$8 = r(17)) && i$8.__esModule ? i$8 : { default: i$8 }, s$3 = r(18);
				t.default = [
					{
						test: [/googlebot/i],
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.bot,
								vendor: "Google"
							};
						}
					},
					{
						test: [/huawei/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/(can-l01)/i, e$1) && "Nova", r$1 = {
								type: s$3.PLATFORMS_MAP.mobile,
								vendor: "Huawei"
							};
							return t$1 && (r$1.model = t$1), r$1;
						}
					},
					{
						test: [/nexus\s*(?:7|8|9|10).*/i],
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.tablet,
								vendor: "Nexus"
							};
						}
					},
					{
						test: [/ipad/i],
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.tablet,
								vendor: "Apple",
								model: "iPad"
							};
						}
					},
					{
						test: [/Macintosh(.*?) FxiOS(.*?)\//],
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.tablet,
								vendor: "Apple",
								model: "iPad"
							};
						}
					},
					{
						test: [/kftt build/i],
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.tablet,
								vendor: "Amazon",
								model: "Kindle Fire HD 7"
							};
						}
					},
					{
						test: [/silk/i],
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.tablet,
								vendor: "Amazon"
							};
						}
					},
					{
						test: [/tablet(?! pc)/i],
						describe: function() {
							return { type: s$3.PLATFORMS_MAP.tablet };
						}
					},
					{
						test: function(e$1) {
							var t$1 = e$1.test(/ipod|iphone/i), r$1 = e$1.test(/like (ipod|iphone)/i);
							return t$1 && !r$1;
						},
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/(ipod|iphone)/i, e$1);
							return {
								type: s$3.PLATFORMS_MAP.mobile,
								vendor: "Apple",
								model: t$1
							};
						}
					},
					{
						test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.mobile,
								vendor: "Nexus"
							};
						}
					},
					{
						test: [/Nokia/i],
						describe: function(e$1) {
							var t$1 = n.default.getFirstMatch(/Nokia\s+([0-9]+(\.[0-9]+)?)/i, e$1), r$1 = {
								type: s$3.PLATFORMS_MAP.mobile,
								vendor: "Nokia"
							};
							return t$1 && (r$1.model = t$1), r$1;
						}
					},
					{
						test: [/[^-]mobi/i],
						describe: function() {
							return { type: s$3.PLATFORMS_MAP.mobile };
						}
					},
					{
						test: function(e$1) {
							return "blackberry" === e$1.getBrowserName(!0);
						},
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.mobile,
								vendor: "BlackBerry"
							};
						}
					},
					{
						test: function(e$1) {
							return "bada" === e$1.getBrowserName(!0);
						},
						describe: function() {
							return { type: s$3.PLATFORMS_MAP.mobile };
						}
					},
					{
						test: function(e$1) {
							return "windows phone" === e$1.getBrowserName();
						},
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.mobile,
								vendor: "Microsoft"
							};
						}
					},
					{
						test: function(e$1) {
							var t$1 = Number(String(e$1.getOSVersion()).split(".")[0]);
							return "android" === e$1.getOSName(!0) && t$1 >= 3;
						},
						describe: function() {
							return { type: s$3.PLATFORMS_MAP.tablet };
						}
					},
					{
						test: function(e$1) {
							return "android" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: s$3.PLATFORMS_MAP.mobile };
						}
					},
					{
						test: function(e$1) {
							return "macos" === e$1.getOSName(!0);
						},
						describe: function() {
							return {
								type: s$3.PLATFORMS_MAP.desktop,
								vendor: "Apple"
							};
						}
					},
					{
						test: function(e$1) {
							return "windows" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: s$3.PLATFORMS_MAP.desktop };
						}
					},
					{
						test: function(e$1) {
							return "linux" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: s$3.PLATFORMS_MAP.desktop };
						}
					},
					{
						test: function(e$1) {
							return "playstation 4" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: s$3.PLATFORMS_MAP.tv };
						}
					},
					{
						test: function(e$1) {
							return "roku" === e$1.getOSName(!0);
						},
						describe: function() {
							return { type: s$3.PLATFORMS_MAP.tv };
						}
					}
				], e.exports = t.default;
			},
			95: function(e, t, r) {
				t.__esModule = !0, t.default = void 0;
				var i$8, n = (i$8 = r(17)) && i$8.__esModule ? i$8 : { default: i$8 }, s$3 = r(18);
				t.default = [
					{
						test: function(e$1) {
							return "microsoft edge" === e$1.getBrowserName(!0);
						},
						describe: function(e$1) {
							if (/\sedg\//i.test(e$1)) return { name: s$3.ENGINE_MAP.Blink };
							var t$1 = n.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e$1);
							return {
								name: s$3.ENGINE_MAP.EdgeHTML,
								version: t$1
							};
						}
					},
					{
						test: [/trident/i],
						describe: function(e$1) {
							var t$1 = { name: s$3.ENGINE_MAP.Trident }, r$1 = n.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: function(e$1) {
							return e$1.test(/presto/i);
						},
						describe: function(e$1) {
							var t$1 = { name: s$3.ENGINE_MAP.Presto }, r$1 = n.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: function(e$1) {
							var t$1 = e$1.test(/gecko/i), r$1 = e$1.test(/like gecko/i);
							return t$1 && !r$1;
						},
						describe: function(e$1) {
							var t$1 = { name: s$3.ENGINE_MAP.Gecko }, r$1 = n.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					},
					{
						test: [/(apple)?webkit\/537\.36/i],
						describe: function() {
							return { name: s$3.ENGINE_MAP.Blink };
						}
					},
					{
						test: [/(apple)?webkit/i],
						describe: function(e$1) {
							var t$1 = { name: s$3.ENGINE_MAP.WebKit }, r$1 = n.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e$1);
							return r$1 && (t$1.version = r$1), t$1;
						}
					}
				], e.exports = t.default;
			}
		});
	}));
}) });

//#endregion
//#region ../../node_modules/.pnpm/utf8-byte-length@1.0.5/node_modules/utf8-byte-length/index.js
var require_utf8_byte_length = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/utf8-byte-length@1.0.5/node_modules/utf8-byte-length/index.js": ((exports, module) => {
	module.exports = function getByteLength$1(string) {
		if (typeof string !== "string") throw new Error("Input must be string");
		return Buffer.byteLength(string, "utf8");
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/set-cookie-parser@2.7.2/node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/set-cookie-parser@2.7.2/node_modules/set-cookie-parser/lib/set-cookie.js": ((exports, module) => {
	var defaultParseOptions = {
		decodeValues: true,
		map: false,
		silent: false
	};
	function isForbiddenKey(key$1) {
		return typeof key$1 !== "string" || key$1 in {};
	}
	function createNullObj() {
		return Object.create(null);
	}
	function isNonEmptyString(str) {
		return typeof str === "string" && !!str.trim();
	}
	function parseString(setCookieValue, options) {
		var parts = setCookieValue.split(";").filter(isNonEmptyString);
		var parsed = parseNameValuePair(parts.shift());
		var name = parsed.name;
		var value = parsed.value;
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (isForbiddenKey(name)) return null;
		try {
			value = options.decodeValues ? decodeURIComponent(value) : value;
		} catch (e) {
			console.error("set-cookie-parser: failed to decode cookie value. Set options.decodeValues=false to disable decoding.", e);
		}
		var cookie$1 = createNullObj();
		cookie$1.name = name;
		cookie$1.value = value;
		parts.forEach(function(part) {
			var sides = part.split("=");
			var key$1 = sides.shift().trimLeft().toLowerCase();
			if (isForbiddenKey(key$1)) return;
			var value$1 = sides.join("=");
			if (key$1 === "expires") cookie$1.expires = new Date(value$1);
			else if (key$1 === "max-age") {
				var n = parseInt(value$1, 10);
				if (!Number.isNaN(n)) cookie$1.maxAge = n;
			} else if (key$1 === "secure") cookie$1.secure = true;
			else if (key$1 === "httponly") cookie$1.httpOnly = true;
			else if (key$1 === "samesite") cookie$1.sameSite = value$1;
			else if (key$1 === "partitioned") cookie$1.partitioned = true;
			else if (key$1) cookie$1[key$1] = value$1;
		});
		return cookie$1;
	}
	function parseNameValuePair(nameValuePairStr) {
		var name = "";
		var value = "";
		var nameValueArr = nameValuePairStr.split("=");
		if (nameValueArr.length > 1) {
			name = nameValueArr.shift();
			value = nameValueArr.join("=");
		} else value = nameValuePairStr;
		return {
			name,
			value
		};
	}
	function parse$13(input, options) {
		options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
		if (!input) if (!options.map) return [];
		else return createNullObj();
		if (input.headers) if (typeof input.headers.getSetCookie === "function") input = input.headers.getSetCookie();
		else if (input.headers["set-cookie"]) input = input.headers["set-cookie"];
		else {
			var sch = input.headers[Object.keys(input.headers).find(function(key$1) {
				return key$1.toLowerCase() === "set-cookie";
			})];
			if (!sch && input.headers.cookie && !options.silent) console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
			input = sch;
		}
		if (!Array.isArray(input)) input = [input];
		if (!options.map) return input.filter(isNonEmptyString).map(function(str) {
			return parseString(str, options);
		}).filter(Boolean);
		else {
			var cookies = createNullObj();
			return input.filter(isNonEmptyString).reduce(function(cookies$1, str) {
				var cookie$1 = parseString(str, options);
				if (cookie$1 && !isForbiddenKey(cookie$1.name)) cookies$1[cookie$1.name] = cookie$1;
				return cookies$1;
			}, cookies);
		}
	}
	function splitCookiesString(cookiesString) {
		if (Array.isArray(cookiesString)) return cookiesString;
		if (typeof cookiesString !== "string") return [];
		var cookiesStrings = [];
		var pos = 0;
		var start;
		var ch;
		var lastComma;
		var nextStart;
		var cookiesSeparatorFound;
		function skipWhitespace() {
			while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) pos += 1;
			return pos < cookiesString.length;
		}
		function notSpecialChar() {
			ch = cookiesString.charAt(pos);
			return ch !== "=" && ch !== ";" && ch !== ",";
		}
		while (pos < cookiesString.length) {
			start = pos;
			cookiesSeparatorFound = false;
			while (skipWhitespace()) {
				ch = cookiesString.charAt(pos);
				if (ch === ",") {
					lastComma = pos;
					pos += 1;
					skipWhitespace();
					nextStart = pos;
					while (pos < cookiesString.length && notSpecialChar()) pos += 1;
					if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
						cookiesSeparatorFound = true;
						pos = nextStart;
						cookiesStrings.push(cookiesString.substring(start, lastComma));
						start = pos;
					} else pos = lastComma + 1;
				} else pos += 1;
			}
			if (!cookiesSeparatorFound || pos >= cookiesString.length) cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
		}
		return cookiesStrings;
	}
	module.exports = parse$13;
	module.exports.parse = parse$13;
	module.exports.parseString = parseString;
	module.exports.splitCookiesString = splitCookiesString;
}) });

//#endregion
//#region ../../node_modules/.pnpm/@pollyjs+persister@6.0.6/node_modules/@pollyjs/persister/dist/cjs/pollyjs-persister.js
var require_pollyjs_persister = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/@pollyjs+persister@6.0.6/node_modules/@pollyjs/persister/dist/cjs/pollyjs-persister.js": ((exports, module) => {
	function _interopDefault$2(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var stringify$8 = _interopDefault$2(require_fast_json_stable_stringify());
	var utils$3 = require_pollyjs_utils();
	var Bowser = _interopDefault$2(require_es5());
	var getByteLength = _interopDefault$2(require_utf8_byte_length());
	var setCookies = _interopDefault$2(require_set_cookie());
	var _defined$1 = function(it) {
		if (it == void 0) throw TypeError("Can't call method on  " + it);
		return it;
	};
	var _toObject$1 = function(it) {
		return Object(_defined$1(it));
	};
	var hasOwnProperty$5 = {}.hasOwnProperty;
	var _has$1 = function(it, key$1) {
		return hasOwnProperty$5.call(it, key$1);
	};
	var toString$5 = {}.toString;
	var _cof$1 = function(it) {
		return toString$5.call(it).slice(8, -1);
	};
	var _iobject$1 = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
		return _cof$1(it) == "String" ? it.split("") : Object(it);
	};
	var _toIobject$1 = function(it) {
		return _iobject$1(_defined$1(it));
	};
	var ceil$1 = Math.ceil;
	var floor$1 = Math.floor;
	var _toInteger$1 = function(it) {
		return isNaN(it = +it) ? 0 : (it > 0 ? floor$1 : ceil$1)(it);
	};
	var min$2 = Math.min;
	var _toLength$1 = function(it) {
		return it > 0 ? min$2(_toInteger$1(it), 9007199254740991) : 0;
	};
	var max$1 = Math.max;
	var min$1$3 = Math.min;
	var _toAbsoluteIndex$1 = function(index$1, length) {
		index$1 = _toInteger$1(index$1);
		return index$1 < 0 ? max$1(index$1 + length, 0) : min$1$3(index$1, length);
	};
	var _arrayIncludes$1 = function(IS_INCLUDES) {
		return function($this, el, fromIndex) {
			var O = _toIobject$1($this);
			var length = _toLength$1(O.length);
			var index$1 = _toAbsoluteIndex$1(fromIndex, length);
			var value;
			if (IS_INCLUDES && el != el) while (length > index$1) {
				value = O[index$1++];
				if (value != value) return true;
			}
			else for (; length > index$1; index$1++) if (IS_INCLUDES || index$1 in O) {
				if (O[index$1] === el) return IS_INCLUDES || index$1 || 0;
			}
			return !IS_INCLUDES && -1;
		};
	};
	function unwrapExports$1(x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
	}
	function createCommonjsModule$1(fn, module$2) {
		return module$2 = { exports: {} }, fn(module$2, module$2.exports), module$2.exports;
	}
	function getCjsExportFromNamespace(n) {
		return n && n["default"] || n;
	}
	var _core$1 = createCommonjsModule$1(function(module$2) {
		var core = module$2.exports = { version: "2.6.9" };
		if (typeof __e == "number") __e = core;
	});
	_core$1.version;
	var _global$1 = createCommonjsModule$1(function(module$2) {
		var global$1 = module$2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
		if (typeof __g == "number") __g = global$1;
	});
	var _library$1 = true;
	var _shared$1 = createCommonjsModule$1(function(module$2) {
		var SHARED = "__core-js_shared__";
		var store = _global$1[SHARED] || (_global$1[SHARED] = {});
		(module$2.exports = function(key$1, value) {
			return store[key$1] || (store[key$1] = value !== void 0 ? value : {});
		})("versions", []).push({
			version: _core$1.version,
			mode: "pure",
			copyright: " 2019 Denis Pushkarev (zloirock.ru)"
		});
	});
	var id$1 = 0;
	var px$1 = Math.random();
	var _uid$1 = function(key$1) {
		return "Symbol(".concat(key$1 === void 0 ? "" : key$1, ")_", (++id$1 + px$1).toString(36));
	};
	var shared$1 = _shared$1("keys");
	var _sharedKey$1 = function(key$1) {
		return shared$1[key$1] || (shared$1[key$1] = _uid$1(key$1));
	};
	var arrayIndexOf$1 = _arrayIncludes$1(false);
	var IE_PROTO$2 = _sharedKey$1("IE_PROTO");
	var _objectKeysInternal$1 = function(object, names) {
		var O = _toIobject$1(object);
		var i$8 = 0;
		var result = [];
		var key$1;
		for (key$1 in O) if (key$1 != IE_PROTO$2) _has$1(O, key$1) && result.push(key$1);
		while (names.length > i$8) if (_has$1(O, key$1 = names[i$8++])) ~arrayIndexOf$1(result, key$1) || result.push(key$1);
		return result;
	};
	var _enumBugKeys$1 = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
	var _objectKeys$1 = Object.keys || function keys$6(O) {
		return _objectKeysInternal$1(O, _enumBugKeys$1);
	};
	var _aFunction$1 = function(it) {
		if (typeof it != "function") throw TypeError(it + " is not a function!");
		return it;
	};
	var _ctx$1 = function(fn, that, length) {
		_aFunction$1(fn);
		if (that === void 0) return fn;
		switch (length) {
			case 1: return function(a) {
				return fn.call(that, a);
			};
			case 2: return function(a, b) {
				return fn.call(that, a, b);
			};
			case 3: return function(a, b, c) {
				return fn.call(that, a, b, c);
			};
		}
		return function() {
			return fn.apply(that, arguments);
		};
	};
	var _isObject$1 = function(it) {
		return typeof it === "object" ? it !== null : typeof it === "function";
	};
	var _anObject$1 = function(it) {
		if (!_isObject$1(it)) throw TypeError(it + " is not an object!");
		return it;
	};
	var _fails$1 = function(exec) {
		try {
			return !!exec();
		} catch (e) {
			return true;
		}
	};
	var _descriptors$1 = !_fails$1(function() {
		return Object.defineProperty({}, "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var document$1$2 = _global$1.document;
	var is$2 = _isObject$1(document$1$2) && _isObject$1(document$1$2.createElement);
	var _domCreate$1 = function(it) {
		return is$2 ? document$1$2.createElement(it) : {};
	};
	var _ie8DomDefine$1 = !_descriptors$1 && !_fails$1(function() {
		return Object.defineProperty(_domCreate$1("div"), "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var _toPrimitive$1 = function(it, S) {
		if (!_isObject$1(it)) return it;
		var fn, val;
		if (S && typeof (fn = it.toString) == "function" && !_isObject$1(val = fn.call(it))) return val;
		if (typeof (fn = it.valueOf) == "function" && !_isObject$1(val = fn.call(it))) return val;
		if (!S && typeof (fn = it.toString) == "function" && !_isObject$1(val = fn.call(it))) return val;
		throw TypeError("Can't convert object to primitive value");
	};
	var dP$2 = Object.defineProperty;
	var _objectDp$1 = { f: _descriptors$1 ? Object.defineProperty : function defineProperty$8(O, P, Attributes) {
		_anObject$1(O);
		P = _toPrimitive$1(P, true);
		_anObject$1(Attributes);
		if (_ie8DomDefine$1) try {
			return dP$2(O, P, Attributes);
		} catch (e) {}
		if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
		if ("value" in Attributes) O[P] = Attributes.value;
		return O;
	} };
	var _propertyDesc$1 = function(bitmap, value) {
		return {
			enumerable: !(bitmap & 1),
			configurable: !(bitmap & 2),
			writable: !(bitmap & 4),
			value
		};
	};
	var _hide$1 = _descriptors$1 ? function(object, key$1, value) {
		return _objectDp$1.f(object, key$1, _propertyDesc$1(1, value));
	} : function(object, key$1, value) {
		object[key$1] = value;
		return object;
	};
	var PROTOTYPE$3 = "prototype";
	var $export$1 = function(type, name, source) {
		var IS_FORCED = type & $export$1.F;
		var IS_GLOBAL = type & $export$1.G;
		var IS_STATIC = type & $export$1.S;
		var IS_PROTO = type & $export$1.P;
		var IS_BIND = type & $export$1.B;
		var IS_WRAP = type & $export$1.W;
		var exports$1 = IS_GLOBAL ? _core$1 : _core$1[name] || (_core$1[name] = {});
		var expProto = exports$1[PROTOTYPE$3];
		var target = IS_GLOBAL ? _global$1 : IS_STATIC ? _global$1[name] : (_global$1[name] || {})[PROTOTYPE$3];
		var key$1, own, out;
		if (IS_GLOBAL) source = name;
		for (key$1 in source) {
			own = !IS_FORCED && target && target[key$1] !== void 0;
			if (own && _has$1(exports$1, key$1)) continue;
			out = own ? target[key$1] : source[key$1];
			exports$1[key$1] = IS_GLOBAL && typeof target[key$1] != "function" ? source[key$1] : IS_BIND && own ? _ctx$1(out, _global$1) : IS_WRAP && target[key$1] == out ? (function(C) {
				var F = function(a, b, c) {
					if (this instanceof C) {
						switch (arguments.length) {
							case 0: return new C();
							case 1: return new C(a);
							case 2: return new C(a, b);
						}
						return new C(a, b, c);
					}
					return C.apply(this, arguments);
				};
				F[PROTOTYPE$3] = C[PROTOTYPE$3];
				return F;
			})(out) : IS_PROTO && typeof out == "function" ? _ctx$1(Function.call, out) : out;
			if (IS_PROTO) {
				(exports$1.virtual || (exports$1.virtual = {}))[key$1] = out;
				if (type & $export$1.R && expProto && !expProto[key$1]) _hide$1(expProto, key$1, out);
			}
		}
	};
	$export$1.F = 1;
	$export$1.G = 2;
	$export$1.S = 4;
	$export$1.P = 8;
	$export$1.B = 16;
	$export$1.W = 32;
	$export$1.U = 64;
	$export$1.R = 128;
	var _export$1 = $export$1;
	var _objectSap$1 = function(KEY, exec) {
		var fn = (_core$1.Object || {})[KEY] || Object[KEY];
		var exp = {};
		exp[KEY] = exec(fn);
		_export$1(_export$1.S + _export$1.F * _fails$1(function() {
			fn(1);
		}), "Object", exp);
	};
	_objectSap$1("keys", function() {
		return function keys$6(it) {
			return _objectKeys$1(_toObject$1(it));
		};
	});
	var keys$1$1 = _core$1.Object.keys;
	var _redefine$1 = _hide$1;
	var _meta$1 = createCommonjsModule$1(function(module$2) {
		var META$7 = _uid$1("meta");
		var setDesc = _objectDp$1.f;
		var id$7 = 0;
		var isExtensible = Object.isExtensible || function() {
			return true;
		};
		var FREEZE = !_fails$1(function() {
			return isExtensible(Object.preventExtensions({}));
		});
		var setMeta = function(it) {
			setDesc(it, META$7, { value: {
				i: "O" + ++id$7,
				w: {}
			} });
		};
		var fastKey$2 = function(it, create) {
			if (!_isObject$1(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
			if (!_has$1(it, META$7)) {
				if (!isExtensible(it)) return "F";
				if (!create) return "E";
				setMeta(it);
			}
			return it[META$7].i;
		};
		var getWeak$2 = function(it, create) {
			if (!_has$1(it, META$7)) {
				if (!isExtensible(it)) return true;
				if (!create) return false;
				setMeta(it);
			}
			return it[META$7].w;
		};
		var onFreeze = function(it) {
			if (FREEZE && meta.NEED && isExtensible(it) && !_has$1(it, META$7)) setMeta(it);
			return it;
		};
		var meta = module$2.exports = {
			KEY: META$7,
			NEED: false,
			fastKey: fastKey$2,
			getWeak: getWeak$2,
			onFreeze
		};
	});
	_meta$1.KEY;
	_meta$1.NEED;
	_meta$1.fastKey;
	_meta$1.getWeak;
	_meta$1.onFreeze;
	var _wks$1 = createCommonjsModule$1(function(module$2) {
		var store = _shared$1("wks");
		var Symbol$2 = _global$1.Symbol;
		var USE_SYMBOL = typeof Symbol$2 == "function";
		var $exports = module$2.exports = function(name) {
			return store[name] || (store[name] = USE_SYMBOL && Symbol$2[name] || (USE_SYMBOL ? Symbol$2 : _uid$1)("Symbol." + name));
		};
		$exports.store = store;
	});
	var def$1 = _objectDp$1.f;
	var TAG$1 = _wks$1("toStringTag");
	var _setToStringTag$1 = function(it, tag, stat$4) {
		if (it && !_has$1(it = stat$4 ? it : it.prototype, TAG$1)) def$1(it, TAG$1, {
			configurable: true,
			value: tag
		});
	};
	var _wksExt$1 = { f: _wks$1 };
	var defineProperty$1 = _objectDp$1.f;
	var _wksDefine$1 = function(name) {
		var $Symbol$7 = _core$1.Symbol || (_core$1.Symbol = {});
		if (name.charAt(0) != "_" && !(name in $Symbol$7)) defineProperty$1($Symbol$7, name, { value: _wksExt$1.f(name) });
	};
	var _objectGops$1 = { f: Object.getOwnPropertySymbols };
	var _objectPie$1 = { f: {}.propertyIsEnumerable };
	var _enumKeys$1 = function(it) {
		var result = _objectKeys$1(it);
		var getSymbols = _objectGops$1.f;
		if (getSymbols) {
			var symbols = getSymbols(it);
			var isEnum$7 = _objectPie$1.f;
			var i$8 = 0;
			var key$1;
			while (symbols.length > i$8) if (isEnum$7.call(it, key$1 = symbols[i$8++])) result.push(key$1);
		}
		return result;
	};
	var _isArray$1 = Array.isArray || function isArray$11(arg) {
		return _cof$1(arg) == "Array";
	};
	var _objectDps$1 = _descriptors$1 ? Object.defineProperties : function defineProperties(O, Properties) {
		_anObject$1(O);
		var keys$6 = _objectKeys$1(Properties);
		var length = keys$6.length;
		var i$8 = 0;
		var P;
		while (length > i$8) _objectDp$1.f(O, P = keys$6[i$8++], Properties[P]);
		return O;
	};
	var document$2 = _global$1.document;
	var _html$1 = document$2 && document$2.documentElement;
	var IE_PROTO$1$3 = _sharedKey$1("IE_PROTO");
	var Empty$1 = function() {};
	var PROTOTYPE$1$4 = "prototype";
	var createDict$1 = function() {
		var iframe = _domCreate$1("iframe");
		var i$8 = _enumBugKeys$1.length;
		var lt = "<";
		var gt = ">";
		var iframeDocument;
		iframe.style.display = "none";
		_html$1.appendChild(iframe);
		iframe.src = "javascript:";
		iframeDocument = iframe.contentWindow.document;
		iframeDocument.open();
		iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
		iframeDocument.close();
		createDict$1 = iframeDocument.F;
		while (i$8--) delete createDict$1[PROTOTYPE$1$4][_enumBugKeys$1[i$8]];
		return createDict$1();
	};
	var _objectCreate$1 = Object.create || function create(O, Properties) {
		var result;
		if (O !== null) {
			Empty$1[PROTOTYPE$1$4] = _anObject$1(O);
			result = new Empty$1();
			Empty$1[PROTOTYPE$1$4] = null;
			result[IE_PROTO$1$3] = O;
		} else result = createDict$1();
		return Properties === void 0 ? result : _objectDps$1(result, Properties);
	};
	var hiddenKeys$1 = _enumBugKeys$1.concat("length", "prototype");
	var _objectGopn$1 = { f: Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		return _objectKeysInternal$1(O, hiddenKeys$1);
	} };
	var gOPN$2 = _objectGopn$1.f;
	var toString$1$6 = {}.toString;
	var windowNames$1 = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
	var getWindowNames$1 = function(it) {
		try {
			return gOPN$2(it);
		} catch (e) {
			return windowNames$1.slice();
		}
	};
	var _objectGopnExt$1 = { f: function getOwnPropertyNames(it) {
		return windowNames$1 && toString$1$6.call(it) == "[object Window]" ? getWindowNames$1(it) : gOPN$2(_toIobject$1(it));
	} };
	var gOPD$2 = Object.getOwnPropertyDescriptor;
	var _objectGopd$1 = { f: _descriptors$1 ? gOPD$2 : function getOwnPropertyDescriptor(O, P) {
		O = _toIobject$1(O);
		P = _toPrimitive$1(P, true);
		if (_ie8DomDefine$1) try {
			return gOPD$2(O, P);
		} catch (e) {}
		if (_has$1(O, P)) return _propertyDesc$1(!_objectPie$1.f.call(O, P), O[P]);
	} };
	var META$1 = _meta$1.KEY;
	var gOPD$1$3 = _objectGopd$1.f;
	var dP$1$3 = _objectDp$1.f;
	var gOPN$1$3 = _objectGopnExt$1.f;
	var $Symbol$1 = _global$1.Symbol;
	var $JSON$1 = _global$1.JSON;
	var _stringify$1 = $JSON$1 && $JSON$1.stringify;
	var PROTOTYPE$2$2 = "prototype";
	var HIDDEN$1 = _wks$1("_hidden");
	var TO_PRIMITIVE$1 = _wks$1("toPrimitive");
	var isEnum$1 = {}.propertyIsEnumerable;
	var SymbolRegistry$1 = _shared$1("symbol-registry");
	var AllSymbols$1 = _shared$1("symbols");
	var OPSymbols$1 = _shared$1("op-symbols");
	var ObjectProto$1 = Object[PROTOTYPE$2$2];
	var USE_NATIVE$1 = typeof $Symbol$1 == "function" && !!_objectGops$1.f;
	var QObject$1 = _global$1.QObject;
	var setter$1 = !QObject$1 || !QObject$1[PROTOTYPE$2$2] || !QObject$1[PROTOTYPE$2$2].findChild;
	var setSymbolDesc$1 = _descriptors$1 && _fails$1(function() {
		return _objectCreate$1(dP$1$3({}, "a", { get: function() {
			return dP$1$3(this, "a", { value: 7 }).a;
		} })).a != 7;
	}) ? function(it, key$1, D) {
		var protoDesc = gOPD$1$3(ObjectProto$1, key$1);
		if (protoDesc) delete ObjectProto$1[key$1];
		dP$1$3(it, key$1, D);
		if (protoDesc && it !== ObjectProto$1) dP$1$3(ObjectProto$1, key$1, protoDesc);
	} : dP$1$3;
	var wrap$4 = function(tag) {
		var sym = AllSymbols$1[tag] = _objectCreate$1($Symbol$1[PROTOTYPE$2$2]);
		sym._k = tag;
		return sym;
	};
	var isSymbol$1 = USE_NATIVE$1 && typeof $Symbol$1.iterator == "symbol" ? function(it) {
		return typeof it == "symbol";
	} : function(it) {
		return it instanceof $Symbol$1;
	};
	var $defineProperty$1 = function defineProperty$8(it, key$1, D) {
		if (it === ObjectProto$1) $defineProperty$1(OPSymbols$1, key$1, D);
		_anObject$1(it);
		key$1 = _toPrimitive$1(key$1, true);
		_anObject$1(D);
		if (_has$1(AllSymbols$1, key$1)) {
			if (!D.enumerable) {
				if (!_has$1(it, HIDDEN$1)) dP$1$3(it, HIDDEN$1, _propertyDesc$1(1, {}));
				it[HIDDEN$1][key$1] = true;
			} else {
				if (_has$1(it, HIDDEN$1) && it[HIDDEN$1][key$1]) it[HIDDEN$1][key$1] = false;
				D = _objectCreate$1(D, { enumerable: _propertyDesc$1(0, false) });
			}
			return setSymbolDesc$1(it, key$1, D);
		}
		return dP$1$3(it, key$1, D);
	};
	var $defineProperties$1 = function defineProperties(it, P) {
		_anObject$1(it);
		var keys$6 = _enumKeys$1(P = _toIobject$1(P));
		var i$8 = 0;
		var l = keys$6.length;
		var key$1;
		while (l > i$8) $defineProperty$1(it, key$1 = keys$6[i$8++], P[key$1]);
		return it;
	};
	var $create$1 = function create(it, P) {
		return P === void 0 ? _objectCreate$1(it) : $defineProperties$1(_objectCreate$1(it), P);
	};
	var $propertyIsEnumerable$1 = function propertyIsEnumerable$1(key$1) {
		var E = isEnum$1.call(this, key$1 = _toPrimitive$1(key$1, true));
		if (this === ObjectProto$1 && _has$1(AllSymbols$1, key$1) && !_has$1(OPSymbols$1, key$1)) return false;
		return E || !_has$1(this, key$1) || !_has$1(AllSymbols$1, key$1) || _has$1(this, HIDDEN$1) && this[HIDDEN$1][key$1] ? E : true;
	};
	var $getOwnPropertyDescriptor$2 = function getOwnPropertyDescriptor(it, key$1) {
		it = _toIobject$1(it);
		key$1 = _toPrimitive$1(key$1, true);
		if (it === ObjectProto$1 && _has$1(AllSymbols$1, key$1) && !_has$1(OPSymbols$1, key$1)) return;
		var D = gOPD$1$3(it, key$1);
		if (D && _has$1(AllSymbols$1, key$1) && !(_has$1(it, HIDDEN$1) && it[HIDDEN$1][key$1])) D.enumerable = true;
		return D;
	};
	var $getOwnPropertyNames$1 = function getOwnPropertyNames(it) {
		var names = gOPN$1$3(_toIobject$1(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (!_has$1(AllSymbols$1, key$1 = names[i$8++]) && key$1 != HIDDEN$1 && key$1 != META$1) result.push(key$1);
		return result;
	};
	var $getOwnPropertySymbols$1 = function getOwnPropertySymbols$2(it) {
		var IS_OP = it === ObjectProto$1;
		var names = gOPN$1$3(IS_OP ? OPSymbols$1 : _toIobject$1(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (_has$1(AllSymbols$1, key$1 = names[i$8++]) && (IS_OP ? _has$1(ObjectProto$1, key$1) : true)) result.push(AllSymbols$1[key$1]);
		return result;
	};
	if (!USE_NATIVE$1) {
		$Symbol$1 = function Symbol$2() {
			if (this instanceof $Symbol$1) throw TypeError("Symbol is not a constructor!");
			var tag = _uid$1(arguments.length > 0 ? arguments[0] : void 0);
			var $set = function(value) {
				if (this === ObjectProto$1) $set.call(OPSymbols$1, value);
				if (_has$1(this, HIDDEN$1) && _has$1(this[HIDDEN$1], tag)) this[HIDDEN$1][tag] = false;
				setSymbolDesc$1(this, tag, _propertyDesc$1(1, value));
			};
			if (_descriptors$1 && setter$1) setSymbolDesc$1(ObjectProto$1, tag, {
				configurable: true,
				set: $set
			});
			return wrap$4(tag);
		};
		_redefine$1($Symbol$1[PROTOTYPE$2$2], "toString", function toString$11() {
			return this._k;
		});
		_objectGopd$1.f = $getOwnPropertyDescriptor$2;
		_objectDp$1.f = $defineProperty$1;
		_objectGopn$1.f = _objectGopnExt$1.f = $getOwnPropertyNames$1;
		_objectPie$1.f = $propertyIsEnumerable$1;
		_objectGops$1.f = $getOwnPropertySymbols$1;
		if (_descriptors$1 && !_library$1) _redefine$1(ObjectProto$1, "propertyIsEnumerable", $propertyIsEnumerable$1, true);
		_wksExt$1.f = function(name) {
			return wrap$4(_wks$1(name));
		};
	}
	_export$1(_export$1.G + _export$1.W + _export$1.F * !USE_NATIVE$1, { Symbol: $Symbol$1 });
	for (var es6Symbols$1 = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j$1 = 0; es6Symbols$1.length > j$1;) _wks$1(es6Symbols$1[j$1++]);
	for (var wellKnownSymbols$1 = _objectKeys$1(_wks$1.store), k$1 = 0; wellKnownSymbols$1.length > k$1;) _wksDefine$1(wellKnownSymbols$1[k$1++]);
	_export$1(_export$1.S + _export$1.F * !USE_NATIVE$1, "Symbol", {
		"for": function(key$1) {
			return _has$1(SymbolRegistry$1, key$1 += "") ? SymbolRegistry$1[key$1] : SymbolRegistry$1[key$1] = $Symbol$1(key$1);
		},
		keyFor: function keyFor$1(sym) {
			if (!isSymbol$1(sym)) throw TypeError(sym + " is not a symbol!");
			for (var key$1 in SymbolRegistry$1) if (SymbolRegistry$1[key$1] === sym) return key$1;
		},
		useSetter: function() {
			setter$1 = true;
		},
		useSimple: function() {
			setter$1 = false;
		}
	});
	_export$1(_export$1.S + _export$1.F * !USE_NATIVE$1, "Object", {
		create: $create$1,
		defineProperty: $defineProperty$1,
		defineProperties: $defineProperties$1,
		getOwnPropertyDescriptor: $getOwnPropertyDescriptor$2,
		getOwnPropertyNames: $getOwnPropertyNames$1,
		getOwnPropertySymbols: $getOwnPropertySymbols$1
	});
	var FAILS_ON_PRIMITIVES$1 = _fails$1(function() {
		_objectGops$1.f(1);
	});
	_export$1(_export$1.S + _export$1.F * FAILS_ON_PRIMITIVES$1, "Object", { getOwnPropertySymbols: function getOwnPropertySymbols$2(it) {
		return _objectGops$1.f(_toObject$1(it));
	} });
	$JSON$1 && _export$1(_export$1.S + _export$1.F * (!USE_NATIVE$1 || _fails$1(function() {
		var S = $Symbol$1();
		return _stringify$1([S]) != "[null]" || _stringify$1({ a: S }) != "{}" || _stringify$1(Object(S)) != "{}";
	})), "JSON", { stringify: function stringify$14(it) {
		var args = [it];
		var i$8 = 1;
		var replacer, $replacer;
		while (arguments.length > i$8) args.push(arguments[i$8++]);
		$replacer = replacer = args[1];
		if (!_isObject$1(replacer) && it === void 0 || isSymbol$1(it)) return;
		if (!_isArray$1(replacer)) replacer = function(key$1, value) {
			if (typeof $replacer == "function") value = $replacer.call(this, key$1, value);
			if (!isSymbol$1(value)) return value;
		};
		args[1] = replacer;
		return _stringify$1.apply($JSON$1, args);
	} });
	$Symbol$1[PROTOTYPE$2$2][TO_PRIMITIVE$1] || _hide$1($Symbol$1[PROTOTYPE$2$2], TO_PRIMITIVE$1, $Symbol$1[PROTOTYPE$2$2].valueOf);
	_setToStringTag$1($Symbol$1, "Symbol");
	_setToStringTag$1(Math, "Math", true);
	_setToStringTag$1(_global$1.JSON, "JSON", true);
	var getOwnPropertySymbols$1$1 = _core$1.Object.getOwnPropertySymbols;
	var $getOwnPropertyDescriptor$1$3 = _objectGopd$1.f;
	_objectSap$1("getOwnPropertyDescriptor", function() {
		return function getOwnPropertyDescriptor(it, key$1) {
			return $getOwnPropertyDescriptor$1$3(_toIobject$1(it), key$1);
		};
	});
	var $Object$3 = _core$1.Object;
	var getOwnPropertyDescriptor$1$1 = function getOwnPropertyDescriptor(it, key$1) {
		return $Object$3.getOwnPropertyDescriptor(it, key$1);
	};
	var Reflect$2 = _global$1.Reflect;
	var _ownKeys$1 = Reflect$2 && Reflect$2.ownKeys || function ownKeys$8(it) {
		var keys$6 = _objectGopn$1.f(_anObject$1(it));
		var getSymbols = _objectGops$1.f;
		return getSymbols ? keys$6.concat(getSymbols(it)) : keys$6;
	};
	var _createProperty$1 = function(object, index$1, value) {
		if (index$1 in object) _objectDp$1.f(object, index$1, _propertyDesc$1(0, value));
		else object[index$1] = value;
	};
	_export$1(_export$1.S, "Object", { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
		var O = _toIobject$1(object);
		var getDesc = _objectGopd$1.f;
		var keys$6 = _ownKeys$1(O);
		var result = {};
		var i$8 = 0;
		var key$1, desc$1;
		while (keys$6.length > i$8) {
			desc$1 = getDesc(O, key$1 = keys$6[i$8++]);
			if (desc$1 !== void 0) _createProperty$1(result, key$1, desc$1);
		}
		return result;
	} });
	var getOwnPropertyDescriptors$1$1 = _core$1.Object.getOwnPropertyDescriptors;
	_export$1(_export$1.S + _export$1.F * !_descriptors$1, "Object", { defineProperties: _objectDps$1 });
	var $Object$1$4 = _core$1.Object;
	var defineProperties$1$1 = function defineProperties(T, D) {
		return $Object$1$4.defineProperties(T, D);
	};
	_export$1(_export$1.S + _export$1.F * !_descriptors$1, "Object", { defineProperty: _objectDp$1.f });
	var $Object$2$2 = _core$1.Object;
	var defineProperty$2$1 = function defineProperty$8(it, key$1, desc$1) {
		return $Object$2$2.defineProperty(it, key$1, desc$1);
	};
	var _defineProperty$1 = unwrapExports$1(createCommonjsModule$1(function(module$2) {
		function _defineProperty$7(obj, key$1, value) {
			if (key$1 in obj) defineProperty$2$1(obj, key$1, {
				value,
				enumerable: true,
				configurable: true,
				writable: true
			});
			else obj[key$1] = value;
			return obj;
		}
		module$2.exports = _defineProperty$7;
		module$2.exports["default"] = module$2.exports, module$2.exports.__esModule = true;
	}));
	var es6_object_toString = /* @__PURE__ */ Object.freeze({});
	var _stringAt = function(TO_STRING) {
		return function(that, pos) {
			var s$3 = String(_defined$1(that));
			var i$8 = _toInteger$1(pos);
			var l = s$3.length;
			var a, b;
			if (i$8 < 0 || i$8 >= l) return TO_STRING ? "" : void 0;
			a = s$3.charCodeAt(i$8);
			return a < 55296 || a > 56319 || i$8 + 1 === l || (b = s$3.charCodeAt(i$8 + 1)) < 56320 || b > 57343 ? TO_STRING ? s$3.charAt(i$8) : a : TO_STRING ? s$3.slice(i$8, i$8 + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
		};
	};
	var _iterators = {};
	var IteratorPrototype = {};
	_hide$1(IteratorPrototype, _wks$1("iterator"), function() {
		return this;
	});
	var _iterCreate = function(Constructor, NAME$5, next) {
		Constructor.prototype = _objectCreate$1(IteratorPrototype, { next: _propertyDesc$1(1, next) });
		_setToStringTag$1(Constructor, NAME$5 + " Iterator");
	};
	var IE_PROTO$2$1 = _sharedKey$1("IE_PROTO");
	var ObjectProto$1$1 = Object.prototype;
	var _objectGpo = Object.getPrototypeOf || function(O) {
		O = _toObject$1(O);
		if (_has$1(O, IE_PROTO$2$1)) return O[IE_PROTO$2$1];
		if (typeof O.constructor == "function" && O instanceof O.constructor) return O.constructor.prototype;
		return O instanceof Object ? ObjectProto$1$1 : null;
	};
	var ITERATOR = _wks$1("iterator");
	var BUGGY = !([].keys && "next" in [].keys());
	var FF_ITERATOR = "@@iterator";
	var KEYS = "keys";
	var VALUES = "values";
	var returnThis = function() {
		return this;
	};
	var _iterDefine = function(Base, NAME$5, Constructor, next, DEFAULT, IS_SET, FORCED) {
		_iterCreate(Constructor, NAME$5, next);
		var getMethod$1 = function(kind) {
			if (!BUGGY && kind in proto$7) return proto$7[kind];
			switch (kind) {
				case KEYS: return function keys$6() {
					return new Constructor(this, kind);
				};
				case VALUES: return function values() {
					return new Constructor(this, kind);
				};
			}
			return function entries() {
				return new Constructor(this, kind);
			};
		};
		var TAG$7 = NAME$5 + " Iterator";
		var DEF_VALUES = DEFAULT == VALUES;
		var VALUES_BUG = false;
		var proto$7 = Base.prototype;
		var $native = proto$7[ITERATOR] || proto$7[FF_ITERATOR] || DEFAULT && proto$7[DEFAULT];
		var $default = $native || getMethod$1(DEFAULT);
		var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod$1("entries") : void 0;
		var $anyNative = NAME$5 == "Array" ? proto$7.entries || $native : $native;
		var methods$3, key$1, IteratorPrototype$5;
		if ($anyNative) {
			IteratorPrototype$5 = _objectGpo($anyNative.call(new Base()));
			if (IteratorPrototype$5 !== Object.prototype && IteratorPrototype$5.next) _setToStringTag$1(IteratorPrototype$5, TAG$7, true);
		}
		if (DEF_VALUES && $native && $native.name !== VALUES) {
			VALUES_BUG = true;
			$default = function values() {
				return $native.call(this);
			};
		}
		if (FORCED && (BUGGY || VALUES_BUG || !proto$7[ITERATOR])) _hide$1(proto$7, ITERATOR, $default);
		_iterators[NAME$5] = $default;
		_iterators[TAG$7] = returnThis;
		if (DEFAULT) {
			methods$3 = {
				values: DEF_VALUES ? $default : getMethod$1(VALUES),
				keys: IS_SET ? $default : getMethod$1(KEYS),
				entries: $entries
			};
			if (FORCED) {
				for (key$1 in methods$3) if (!(key$1 in proto$7)) _redefine$1(proto$7, key$1, methods$3[key$1]);
			} else _export$1(_export$1.P + _export$1.F * (BUGGY || VALUES_BUG), NAME$5, methods$3);
		}
		return methods$3;
	};
	var $at = _stringAt(true);
	_iterDefine(String, "String", function(iterated) {
		this._t = String(iterated);
		this._i = 0;
	}, function() {
		var O = this._t;
		var index$1 = this._i;
		var point;
		if (index$1 >= O.length) return {
			value: void 0,
			done: true
		};
		point = $at(O, index$1);
		this._i += point.length;
		return {
			value: point,
			done: false
		};
	});
	var _iterStep = function(done, value) {
		return {
			value,
			done: !!done
		};
	};
	_iterDefine(Array, "Array", function(iterated, kind) {
		this._t = _toIobject$1(iterated);
		this._i = 0;
		this._k = kind;
	}, function() {
		var O = this._t;
		var kind = this._k;
		var index$1 = this._i++;
		if (!O || index$1 >= O.length) {
			this._t = void 0;
			return _iterStep(1);
		}
		if (kind == "keys") return _iterStep(0, index$1);
		if (kind == "values") return _iterStep(0, O[index$1]);
		return _iterStep(0, [index$1, O[index$1]]);
	}, "values");
	_iterators.Arguments = _iterators.Array;
	var TO_STRING_TAG = _wks$1("toStringTag");
	var DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
	for (var i$3 = 0; i$3 < DOMIterables.length; i$3++) {
		var NAME = DOMIterables[i$3];
		var Collection = _global$1[NAME];
		var proto$2 = Collection && Collection.prototype;
		if (proto$2 && !proto$2[TO_STRING_TAG]) _hide$1(proto$2, TO_STRING_TAG, NAME);
		_iterators[NAME] = _iterators.Array;
	}
	var _redefineAll = function(target, src$1, safe) {
		for (var key$1 in src$1) if (safe && target[key$1]) target[key$1] = src$1[key$1];
		else _hide$1(target, key$1, src$1[key$1]);
		return target;
	};
	var _anInstance = function(it, Constructor, name, forbiddenField) {
		if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) throw TypeError(name + ": incorrect invocation!");
		return it;
	};
	var _iterCall = function(iterator, fn, value, entries) {
		try {
			return entries ? fn(_anObject$1(value)[0], value[1]) : fn(value);
		} catch (e) {
			var ret = iterator["return"];
			if (ret !== void 0) _anObject$1(ret.call(iterator));
			throw e;
		}
	};
	var ITERATOR$1 = _wks$1("iterator");
	var ArrayProto = Array.prototype;
	var _isArrayIter = function(it) {
		return it !== void 0 && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
	};
	var TAG$1$1 = _wks$1("toStringTag");
	var ARG = _cof$1(function() {
		return arguments;
	}()) == "Arguments";
	var tryGet = function(it, key$1) {
		try {
			return it[key$1];
		} catch (e) {}
	};
	var _classof = function(it) {
		var O, T, B;
		return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG$1$1)) == "string" ? T : ARG ? _cof$1(O) : (B = _cof$1(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
	};
	var ITERATOR$2 = _wks$1("iterator");
	var core_getIteratorMethod = _core$1.getIteratorMethod = function(it) {
		if (it != void 0) return it[ITERATOR$2] || it["@@iterator"] || _iterators[_classof(it)];
	};
	var _forOf = createCommonjsModule$1(function(module$2) {
		var BREAK = {};
		var RETURN = {};
		var exports$1 = module$2.exports = function(iterable, entries, fn, that, ITERATOR$5) {
			var iterFn = ITERATOR$5 ? function() {
				return iterable;
			} : core_getIteratorMethod(iterable);
			var f = _ctx$1(fn, that, entries ? 2 : 1);
			var index$1 = 0;
			var length, step, iterator, result;
			if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
			if (_isArrayIter(iterFn)) for (length = _toLength$1(iterable.length); length > index$1; index$1++) {
				result = entries ? f(_anObject$1(step = iterable[index$1])[0], step[1]) : f(iterable[index$1]);
				if (result === BREAK || result === RETURN) return result;
			}
			else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
				result = _iterCall(iterator, f, step.value, entries);
				if (result === BREAK || result === RETURN) return result;
			}
		};
		exports$1.BREAK = BREAK;
		exports$1.RETURN = RETURN;
	});
	var SPECIES = _wks$1("species");
	var _setSpecies = function(KEY) {
		var C = typeof _core$1[KEY] == "function" ? _core$1[KEY] : _global$1[KEY];
		if (_descriptors$1 && C && !C[SPECIES]) _objectDp$1.f(C, SPECIES, {
			configurable: true,
			get: function() {
				return this;
			}
		});
	};
	var _validateCollection = function(it, TYPE) {
		if (!_isObject$1(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
		return it;
	};
	var dP$2$1 = _objectDp$1.f;
	var fastKey = _meta$1.fastKey;
	var SIZE = _descriptors$1 ? "_s" : "size";
	var getEntry = function(that, key$1) {
		var index$1 = fastKey(key$1);
		var entry;
		if (index$1 !== "F") return that._i[index$1];
		for (entry = that._f; entry; entry = entry.n) if (entry.k == key$1) return entry;
	};
	var _collectionStrong = {
		getConstructor: function(wrapper, NAME$5, IS_MAP, ADDER) {
			var C = wrapper(function(that, iterable) {
				_anInstance(that, C, NAME$5, "_i");
				that._t = NAME$5;
				that._i = _objectCreate$1(null);
				that._f = void 0;
				that._l = void 0;
				that[SIZE] = 0;
				if (iterable != void 0) _forOf(iterable, IS_MAP, that[ADDER], that);
			});
			_redefineAll(C.prototype, {
				clear: function clear$1() {
					for (var that = _validateCollection(this, NAME$5), data = that._i, entry = that._f; entry; entry = entry.n) {
						entry.r = true;
						if (entry.p) entry.p = entry.p.n = void 0;
						delete data[entry.i];
					}
					that._f = that._l = void 0;
					that[SIZE] = 0;
				},
				"delete": function(key$1) {
					var that = _validateCollection(this, NAME$5);
					var entry = getEntry(that, key$1);
					if (entry) {
						var next = entry.n;
						var prev = entry.p;
						delete that._i[entry.i];
						entry.r = true;
						if (prev) prev.n = next;
						if (next) next.p = prev;
						if (that._f == entry) that._f = next;
						if (that._l == entry) that._l = prev;
						that[SIZE]--;
					}
					return !!entry;
				},
				forEach: function forEach(callbackfn) {
					_validateCollection(this, NAME$5);
					var f = _ctx$1(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
					var entry;
					while (entry = entry ? entry.n : this._f) {
						f(entry.v, entry.k, this);
						while (entry && entry.r) entry = entry.p;
					}
				},
				has: function has$8(key$1) {
					return !!getEntry(_validateCollection(this, NAME$5), key$1);
				}
			});
			if (_descriptors$1) dP$2$1(C.prototype, "size", { get: function() {
				return _validateCollection(this, NAME$5)[SIZE];
			} });
			return C;
		},
		def: function(that, key$1, value) {
			var entry = getEntry(that, key$1);
			var prev, index$1;
			if (entry) entry.v = value;
			else {
				that._l = entry = {
					i: index$1 = fastKey(key$1, true),
					k: key$1,
					v: value,
					p: prev = that._l,
					n: void 0,
					r: false
				};
				if (!that._f) that._f = entry;
				if (prev) prev.n = entry;
				that[SIZE]++;
				if (index$1 !== "F") that._i[index$1] = entry;
			}
			return that;
		},
		getEntry,
		setStrong: function(C, NAME$5, IS_MAP) {
			_iterDefine(C, NAME$5, function(iterated, kind) {
				this._t = _validateCollection(iterated, NAME$5);
				this._k = kind;
				this._l = void 0;
			}, function() {
				var that = this;
				var kind = that._k;
				var entry = that._l;
				while (entry && entry.r) entry = entry.p;
				if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
					that._t = void 0;
					return _iterStep(1);
				}
				if (kind == "keys") return _iterStep(0, entry.k);
				if (kind == "values") return _iterStep(0, entry.v);
				return _iterStep(0, [entry.k, entry.v]);
			}, IS_MAP ? "entries" : "values", !IS_MAP, true);
			_setSpecies(NAME$5);
		}
	};
	var SPECIES$1 = _wks$1("species");
	var _arraySpeciesConstructor = function(original) {
		var C;
		if (_isArray$1(original)) {
			C = original.constructor;
			if (typeof C == "function" && (C === Array || _isArray$1(C.prototype))) C = void 0;
			if (_isObject$1(C)) {
				C = C[SPECIES$1];
				if (C === null) C = void 0;
			}
		}
		return C === void 0 ? Array : C;
	};
	var _arraySpeciesCreate = function(original, length) {
		return new (_arraySpeciesConstructor(original))(length);
	};
	var _arrayMethods = function(TYPE, $create$7) {
		var IS_MAP = TYPE == 1;
		var IS_FILTER = TYPE == 2;
		var IS_SOME = TYPE == 3;
		var IS_EVERY = TYPE == 4;
		var IS_FIND_INDEX = TYPE == 6;
		var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
		var create = $create$7 || _arraySpeciesCreate;
		return function($this, callbackfn, that) {
			var O = _toObject$1($this);
			var self$1 = _iobject$1(O);
			var f = _ctx$1(callbackfn, that, 3);
			var length = _toLength$1(self$1.length);
			var index$1 = 0;
			var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
			var val, res$2;
			for (; length > index$1; index$1++) if (NO_HOLES || index$1 in self$1) {
				val = self$1[index$1];
				res$2 = f(val, index$1, O);
				if (TYPE) {
					if (IS_MAP) result[index$1] = res$2;
					else if (res$2) switch (TYPE) {
						case 3: return true;
						case 5: return val;
						case 6: return index$1;
						case 2: result.push(val);
					}
					else if (IS_EVERY) return false;
				}
			}
			return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
		};
	};
	var dP$3 = _objectDp$1.f;
	var each = _arrayMethods(0);
	var _collection = function(NAME$5, wrapper, methods$3, common$9, IS_MAP, IS_WEAK) {
		var Base = _global$1[NAME$5];
		var C = Base;
		var ADDER = IS_MAP ? "set" : "add";
		var proto$7 = C && C.prototype;
		var O = {};
		if (!_descriptors$1 || typeof C != "function" || !(IS_WEAK || proto$7.forEach && !_fails$1(function() {
			new C().entries().next();
		}))) {
			C = common$9.getConstructor(wrapper, NAME$5, IS_MAP, ADDER);
			_redefineAll(C.prototype, methods$3);
			_meta$1.NEED = true;
		} else {
			C = wrapper(function(target, iterable) {
				_anInstance(target, C, NAME$5, "_c");
				target._c = new Base();
				if (iterable != void 0) _forOf(iterable, IS_MAP, target[ADDER], target);
			});
			each("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(KEY) {
				var IS_ADDER = KEY == "add" || KEY == "set";
				if (KEY in proto$7 && !(IS_WEAK && KEY == "clear")) _hide$1(C.prototype, KEY, function(a, b) {
					_anInstance(this, C, KEY);
					if (!IS_ADDER && IS_WEAK && !_isObject$1(a)) return KEY == "get" ? void 0 : false;
					var result = this._c[KEY](a === 0 ? 0 : a, b);
					return IS_ADDER ? this : result;
				});
			});
			IS_WEAK || dP$3(C.prototype, "size", { get: function() {
				return this._c.size;
			} });
		}
		_setToStringTag$1(C, NAME$5);
		O[NAME$5] = C;
		_export$1(_export$1.G + _export$1.W + _export$1.F, O);
		if (!IS_WEAK) common$9.setStrong(C, NAME$5, IS_MAP);
		return C;
	};
	var MAP = "Map";
	_collection(MAP, function(get$1) {
		return function Map$4() {
			return get$1(this, arguments.length > 0 ? arguments[0] : void 0);
		};
	}, {
		get: function get$1(key$1) {
			var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key$1);
			return entry && entry.v;
		},
		set: function set$3(key$1, value) {
			return _collectionStrong.def(_validateCollection(this, MAP), key$1 === 0 ? 0 : key$1, value);
		}
	}, _collectionStrong, true);
	var _arrayFromIterable = function(iter, ITERATOR$5) {
		var result = [];
		_forOf(iter, false, result.push, result, ITERATOR$5);
		return result;
	};
	var _collectionToJson = function(NAME$5) {
		return function toJSON$1() {
			if (_classof(this) != NAME$5) throw TypeError(NAME$5 + "#toJSON isn't generic");
			return _arrayFromIterable(this);
		};
	};
	_export$1(_export$1.P + _export$1.R, "Map", { toJSON: _collectionToJson("Map") });
	var _setCollectionOf = function(COLLECTION) {
		_export$1(_export$1.S, COLLECTION, { of: function of() {
			var length = arguments.length;
			var A = new Array(length);
			while (length--) A[length] = arguments[length];
			return new this(A);
		} });
	};
	_setCollectionOf("Map");
	var _setCollectionFrom = function(COLLECTION) {
		_export$1(_export$1.S, COLLECTION, { from: function from(source) {
			var mapFn = arguments[1];
			var mapping, A, n, cb;
			_aFunction$1(this);
			mapping = mapFn !== void 0;
			if (mapping) _aFunction$1(mapFn);
			if (source == void 0) return new this();
			A = [];
			if (mapping) {
				n = 0;
				cb = _ctx$1(mapFn, arguments[2], 2);
				_forOf(source, false, function(nextItem) {
					A.push(cb(nextItem, n++));
				});
			} else _forOf(source, false, A.push, A);
			return new this(A);
		} });
	};
	_setCollectionFrom("Map");
	getCjsExportFromNamespace(es6_object_toString);
	var map$1 = _core$1.Map;
	var SPECIES$2 = _wks$1("species");
	var _speciesConstructor = function(O, D) {
		var C = _anObject$1(O).constructor;
		var S;
		return C === void 0 || (S = _anObject$1(C)[SPECIES$2]) == void 0 ? D : _aFunction$1(S);
	};
	var _invoke = function(fn, args, that) {
		var un = that === void 0;
		switch (args.length) {
			case 0: return un ? fn() : fn.call(that);
			case 1: return un ? fn(args[0]) : fn.call(that, args[0]);
			case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
			case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
			case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
		}
		return fn.apply(that, args);
	};
	var process$1 = _global$1.process;
	var setTask = _global$1.setImmediate;
	var clearTask = _global$1.clearImmediate;
	var MessageChannel = _global$1.MessageChannel;
	var Dispatch = _global$1.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = "onreadystatechange";
	var defer$3, channel, port;
	var run = function() {
		var id$7 = +this;
		if (queue.hasOwnProperty(id$7)) {
			var fn = queue[id$7];
			delete queue[id$7];
			fn();
		}
	};
	var listener$1 = function(event) {
		run.call(event.data);
	};
	if (!setTask || !clearTask) {
		setTask = function setImmediate$3(fn) {
			var args = [];
			var i$8 = 1;
			while (arguments.length > i$8) args.push(arguments[i$8++]);
			queue[++counter] = function() {
				_invoke(typeof fn == "function" ? fn : Function(fn), args);
			};
			defer$3(counter);
			return counter;
		};
		clearTask = function clearImmediate$1(id$7) {
			delete queue[id$7];
		};
		if (_cof$1(process$1) == "process") defer$3 = function(id$7) {
			process$1.nextTick(_ctx$1(run, id$7, 1));
		};
		else if (Dispatch && Dispatch.now) defer$3 = function(id$7) {
			Dispatch.now(_ctx$1(run, id$7, 1));
		};
		else if (MessageChannel) {
			channel = new MessageChannel();
			port = channel.port2;
			channel.port1.onmessage = listener$1;
			defer$3 = _ctx$1(port.postMessage, port, 1);
		} else if (_global$1.addEventListener && typeof postMessage == "function" && !_global$1.importScripts) {
			defer$3 = function(id$7) {
				_global$1.postMessage(id$7 + "", "*");
			};
			_global$1.addEventListener("message", listener$1, false);
		} else if (ONREADYSTATECHANGE in _domCreate$1("script")) defer$3 = function(id$7) {
			_html$1.appendChild(_domCreate$1("script"))[ONREADYSTATECHANGE] = function() {
				_html$1.removeChild(this);
				run.call(id$7);
			};
		};
		else defer$3 = function(id$7) {
			setTimeout(_ctx$1(run, id$7, 1), 0);
		};
	}
	var _task = {
		set: setTask,
		clear: clearTask
	};
	var macrotask = _task.set;
	var Observer = _global$1.MutationObserver || _global$1.WebKitMutationObserver;
	var process$1$1 = _global$1.process;
	var Promise$1 = _global$1.Promise;
	var isNode = _cof$1(process$1$1) == "process";
	var _microtask = function() {
		var head, last, notify$6;
		var flush = function() {
			var parent, fn;
			if (isNode && (parent = process$1$1.domain)) parent.exit();
			while (head) {
				fn = head.fn;
				head = head.next;
				try {
					fn();
				} catch (e) {
					if (head) notify$6();
					else last = void 0;
					throw e;
				}
			}
			last = void 0;
			if (parent) parent.enter();
		};
		if (isNode) notify$6 = function() {
			process$1$1.nextTick(flush);
		};
		else if (Observer && !(_global$1.navigator && _global$1.navigator.standalone)) {
			var toggle = true;
			var node$1 = document.createTextNode("");
			new Observer(flush).observe(node$1, { characterData: true });
			notify$6 = function() {
				node$1.data = toggle = !toggle;
			};
		} else if (Promise$1 && Promise$1.resolve) {
			var promise = Promise$1.resolve(void 0);
			notify$6 = function() {
				promise.then(flush);
			};
		} else notify$6 = function() {
			macrotask.call(_global$1, flush);
		};
		return function(fn) {
			var task$5 = {
				fn,
				next: void 0
			};
			if (last) last.next = task$5;
			if (!head) {
				head = task$5;
				notify$6();
			}
			last = task$5;
		};
	};
	function PromiseCapability(C) {
		var resolve$6, reject;
		this.promise = new C(function($$resolve, $$reject) {
			if (resolve$6 !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
			resolve$6 = $$resolve;
			reject = $$reject;
		});
		this.resolve = _aFunction$1(resolve$6);
		this.reject = _aFunction$1(reject);
	}
	var f$7 = function(C) {
		return new PromiseCapability(C);
	};
	var _newPromiseCapability = { f: f$7 };
	var _perform = function(exec) {
		try {
			return {
				e: false,
				v: exec()
			};
		} catch (e) {
			return {
				e: true,
				v: e
			};
		}
	};
	var navigator$1 = _global$1.navigator;
	var _userAgent = navigator$1 && navigator$1.userAgent || "";
	var _promiseResolve = function(C, x) {
		_anObject$1(C);
		if (_isObject$1(x) && x.constructor === C) return x;
		var promiseCapability = _newPromiseCapability.f(C);
		var resolve$6 = promiseCapability.resolve;
		resolve$6(x);
		return promiseCapability.promise;
	};
	var ITERATOR$3 = _wks$1("iterator");
	var SAFE_CLOSING = false;
	try {
		var riter = [7][ITERATOR$3]();
		riter["return"] = function() {
			SAFE_CLOSING = true;
		};
		Array.from(riter, function() {
			throw 2;
		});
	} catch (e) {}
	var _iterDetect = function(exec, skipClosing) {
		if (!skipClosing && !SAFE_CLOSING) return false;
		var safe = false;
		try {
			var arr = [7];
			var iter = arr[ITERATOR$3]();
			iter.next = function() {
				return { done: safe = true };
			};
			arr[ITERATOR$3] = function() {
				return iter;
			};
			exec(arr);
		} catch (e) {}
		return safe;
	};
	var task = _task.set;
	var microtask = _microtask();
	var PROMISE = "Promise";
	var TypeError$1 = _global$1.TypeError;
	var process$2 = _global$1.process;
	var versions = process$2 && process$2.versions;
	var v8 = versions && versions.v8 || "";
	var $Promise = _global$1[PROMISE];
	var isNode$1 = _classof(process$2) == "process";
	var empty = function() {};
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;
	var USE_NATIVE$1$1 = !!function() {
		try {
			var promise = $Promise.resolve(1);
			var FakePromise = (promise.constructor = {})[_wks$1("species")] = function(exec) {
				exec(empty, empty);
			};
			return (isNode$1 || typeof PromiseRejectionEvent == "function") && promise.then(empty) instanceof FakePromise && v8.indexOf("6.6") !== 0 && _userAgent.indexOf("Chrome/66") === -1;
		} catch (e) {}
	}();
	var isThenable = function(it) {
		var then;
		return _isObject$1(it) && typeof (then = it.then) == "function" ? then : false;
	};
	var notify = function(promise, isReject) {
		if (promise._n) return;
		promise._n = true;
		var chain = promise._c;
		microtask(function() {
			var value = promise._v;
			var ok = promise._s == 1;
			var i$8 = 0;
			var run$5 = function(reaction) {
				var handler = ok ? reaction.ok : reaction.fail;
				var resolve$6 = reaction.resolve;
				var reject = reaction.reject;
				var domain = reaction.domain;
				var result, then, exited;
				try {
					if (handler) {
						if (!ok) {
							if (promise._h == 2) onHandleUnhandled(promise);
							promise._h = 1;
						}
						if (handler === true) result = value;
						else {
							if (domain) domain.enter();
							result = handler(value);
							if (domain) {
								domain.exit();
								exited = true;
							}
						}
						if (result === reaction.promise) reject(TypeError$1("Promise-chain cycle"));
						else if (then = isThenable(result)) then.call(result, resolve$6, reject);
						else resolve$6(result);
					} else reject(value);
				} catch (e) {
					if (domain && !exited) domain.exit();
					reject(e);
				}
			};
			while (chain.length > i$8) run$5(chain[i$8++]);
			promise._c = [];
			promise._n = false;
			if (isReject && !promise._h) onUnhandled(promise);
		});
	};
	var onUnhandled = function(promise) {
		task.call(_global$1, function() {
			var value = promise._v;
			var unhandled = isUnhandled(promise);
			var result, handler, console$1;
			if (unhandled) {
				result = _perform(function() {
					if (isNode$1) process$2.emit("unhandledRejection", value, promise);
					else if (handler = _global$1.onunhandledrejection) handler({
						promise,
						reason: value
					});
					else if ((console$1 = _global$1.console) && console$1.error) console$1.error("Unhandled promise rejection", value);
				});
				promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
			}
			promise._a = void 0;
			if (unhandled && result.e) throw result.v;
		});
	};
	var isUnhandled = function(promise) {
		return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function(promise) {
		task.call(_global$1, function() {
			var handler;
			if (isNode$1) process$2.emit("rejectionHandled", promise);
			else if (handler = _global$1.onrejectionhandled) handler({
				promise,
				reason: promise._v
			});
		});
	};
	var $reject = function(value) {
		var promise = this;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		promise._v = value;
		promise._s = 2;
		if (!promise._a) promise._a = promise._c.slice();
		notify(promise, true);
	};
	var $resolve = function(value) {
		var promise = this;
		var then;
		if (promise._d) return;
		promise._d = true;
		promise = promise._w || promise;
		try {
			if (promise === value) throw TypeError$1("Promise can't be resolved itself");
			if (then = isThenable(value)) microtask(function() {
				var wrapper = {
					_w: promise,
					_d: false
				};
				try {
					then.call(value, _ctx$1($resolve, wrapper, 1), _ctx$1($reject, wrapper, 1));
				} catch (e) {
					$reject.call(wrapper, e);
				}
			});
			else {
				promise._v = value;
				promise._s = 1;
				notify(promise, false);
			}
		} catch (e) {
			$reject.call({
				_w: promise,
				_d: false
			}, e);
		}
	};
	if (!USE_NATIVE$1$1) {
		$Promise = function Promise$6(executor) {
			_anInstance(this, $Promise, PROMISE, "_h");
			_aFunction$1(executor);
			Internal.call(this);
			try {
				executor(_ctx$1($resolve, this, 1), _ctx$1($reject, this, 1));
			} catch (err) {
				$reject.call(this, err);
			}
		};
		Internal = function Promise$6(executor) {
			this._c = [];
			this._a = void 0;
			this._s = 0;
			this._d = false;
			this._v = void 0;
			this._h = 0;
			this._n = false;
		};
		Internal.prototype = _redefineAll($Promise.prototype, {
			then: function then(onFulfilled, onRejected) {
				var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
				reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
				reaction.fail = typeof onRejected == "function" && onRejected;
				reaction.domain = isNode$1 ? process$2.domain : void 0;
				this._c.push(reaction);
				if (this._a) this._a.push(reaction);
				if (this._s) notify(this, false);
				return reaction.promise;
			},
			"catch": function(onRejected) {
				return this.then(void 0, onRejected);
			}
		});
		OwnPromiseCapability = function() {
			var promise = new Internal();
			this.promise = promise;
			this.resolve = _ctx$1($resolve, promise, 1);
			this.reject = _ctx$1($reject, promise, 1);
		};
		_newPromiseCapability.f = newPromiseCapability = function(C) {
			return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
		};
	}
	_export$1(_export$1.G + _export$1.W + _export$1.F * !USE_NATIVE$1$1, { Promise: $Promise });
	_setToStringTag$1($Promise, PROMISE);
	_setSpecies(PROMISE);
	Wrapper = _core$1[PROMISE];
	_export$1(_export$1.S + _export$1.F * !USE_NATIVE$1$1, PROMISE, { reject: function reject(r) {
		var capability = newPromiseCapability(this);
		var $$reject = capability.reject;
		$$reject(r);
		return capability.promise;
	} });
	_export$1(_export$1.S + _export$1.F * _library$1, PROMISE, { resolve: function resolve$6(x) {
		return _promiseResolve(this === Wrapper ? $Promise : this, x);
	} });
	_export$1(_export$1.S + _export$1.F * !(USE_NATIVE$1$1 && _iterDetect(function(iter) {
		$Promise.all(iter)["catch"](empty);
	})), PROMISE, {
		all: function all(iterable) {
			var C = this;
			var capability = newPromiseCapability(C);
			var resolve$6 = capability.resolve;
			var reject = capability.reject;
			var result = _perform(function() {
				var values = [];
				var index$1 = 0;
				var remaining = 1;
				_forOf(iterable, false, function(promise) {
					var $index = index$1++;
					var alreadyCalled = false;
					values.push(void 0);
					remaining++;
					C.resolve(promise).then(function(value) {
						if (alreadyCalled) return;
						alreadyCalled = true;
						values[$index] = value;
						--remaining || resolve$6(values);
					}, reject);
				});
				--remaining || resolve$6(values);
			});
			if (result.e) reject(result.v);
			return capability.promise;
		},
		race: function race(iterable) {
			var C = this;
			var capability = newPromiseCapability(C);
			var reject = capability.reject;
			var result = _perform(function() {
				_forOf(iterable, false, function(promise) {
					C.resolve(promise).then(capability.resolve, reject);
				});
			});
			if (result.e) reject(result.v);
			return capability.promise;
		}
	});
	_export$1(_export$1.P + _export$1.R, "Promise", { "finally": function(onFinally) {
		var C = _speciesConstructor(this, _core$1.Promise || _global$1.Promise);
		var isFunction$3 = typeof onFinally == "function";
		return this.then(isFunction$3 ? function(x) {
			return _promiseResolve(C, onFinally()).then(function() {
				return x;
			});
		} : onFinally, isFunction$3 ? function(e) {
			return _promiseResolve(C, onFinally()).then(function() {
				throw e;
			});
		} : onFinally);
	} });
	_export$1(_export$1.S, "Promise", { "try": function(callbackfn) {
		var promiseCapability = _newPromiseCapability.f(this);
		var result = _perform(callbackfn);
		(result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
		return promiseCapability.promise;
	} });
	var promise$1 = _core$1.Promise;
	var $assign = Object.assign;
	var _objectAssign = !$assign || _fails$1(function() {
		var A = {};
		var B = {};
		var S = Symbol();
		var K = "abcdefghijklmnopqrst";
		A[S] = 7;
		K.split("").forEach(function(k$7) {
			B[k$7] = k$7;
		});
		return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
	}) ? function assign$3(target, source) {
		var T = _toObject$1(target);
		var aLen = arguments.length;
		var index$1 = 1;
		var getSymbols = _objectGops$1.f;
		var isEnum$7 = _objectPie$1.f;
		while (aLen > index$1) {
			var S = _iobject$1(arguments[index$1++]);
			var keys$6 = getSymbols ? _objectKeys$1(S).concat(getSymbols(S)) : _objectKeys$1(S);
			var length = keys$6.length;
			var j$7 = 0;
			var key$1;
			while (length > j$7) {
				key$1 = keys$6[j$7++];
				if (!_descriptors$1 || isEnum$7.call(S, key$1)) T[key$1] = S[key$1];
			}
		}
		return T;
	} : $assign;
	_export$1(_export$1.S + _export$1.F, "Object", { assign: _objectAssign });
	var assign$1 = _core$1.Object.assign;
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
	/** Detect free variable `self`. */
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function("return this")();
	/** Built-in value references. */
	var Symbol$1 = root.Symbol;
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	/** Used to check objects for own properties. */
	var hasOwnProperty$1$1 = objectProto.hasOwnProperty;
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var nativeObjectToString = objectProto.toString;
	/** Built-in value references. */
	var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
	/**
	* A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the raw `toStringTag`.
	*/
	function getRawTag(value) {
		var isOwn = hasOwnProperty$1$1.call(value, symToStringTag), tag = value[symToStringTag];
		try {
			value[symToStringTag] = void 0;
			var unmasked = true;
		} catch (e) {}
		var result = nativeObjectToString.call(value);
		if (unmasked) if (isOwn) value[symToStringTag] = tag;
		else delete value[symToStringTag];
		return result;
	}
	/**
	* Used to resolve the
	* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	* of values.
	*/
	var nativeObjectToString$1 = Object.prototype.toString;
	/**
	* Converts `value` to a string using `Object.prototype.toString`.
	*
	* @private
	* @param {*} value The value to convert.
	* @returns {string} Returns the converted string.
	*/
	function objectToString(value) {
		return nativeObjectToString$1.call(value);
	}
	/** `Object#toString` result references. */
	var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
	/** Built-in value references. */
	var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
	/**
	* The base implementation of `getTag` without fallbacks for buggy environments.
	*
	* @private
	* @param {*} value The value to query.
	* @returns {string} Returns the `toStringTag`.
	*/
	function baseGetTag(value) {
		if (value == null) return value === void 0 ? undefinedTag : nullTag;
		return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
	}
	/**
	* Checks if `value` is the
	* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is an object, else `false`.
	* @example
	*
	* _.isObject({});
	* // => true
	*
	* _.isObject([1, 2, 3]);
	* // => true
	*
	* _.isObject(_.noop);
	* // => true
	*
	* _.isObject(null);
	* // => false
	*/
	function isObject(value) {
		var type = typeof value;
		return value != null && (type == "object" || type == "function");
	}
	/** `Object#toString` result references. */
	var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
	/**
	* Checks if `value` is classified as a `Function` object.
	*
	* @static
	* @memberOf _
	* @since 0.1.0
	* @category Lang
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a function, else `false`.
	* @example
	*
	* _.isFunction(_);
	* // => true
	*
	* _.isFunction(/abc/);
	* // => false
	*/
	function isFunction(value) {
		if (!isObject(value)) return false;
		var tag = baseGetTag(value);
		return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root["__core-js_shared__"];
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = function() {
		var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
		return uid ? "Symbol(src)_1." + uid : "";
	}();
	/**
	* Checks if `func` has its source masked.
	*
	* @private
	* @param {Function} func The function to check.
	* @returns {boolean} Returns `true` if `func` is masked, else `false`.
	*/
	function isMasked(func) {
		return !!maskSrcKey && maskSrcKey in func;
	}
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	/**
	* Converts `func` to its source code.
	*
	* @private
	* @param {Function} func The function to convert.
	* @returns {string} Returns the source code.
	*/
	function toSource(func) {
		if (func != null) {
			try {
				return funcToString.call(func);
			} catch (e) {}
			try {
				return func + "";
			} catch (e) {}
		}
		return "";
	}
	/**
	* Used to match `RegExp`
	* [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	*/
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype, objectProto$2 = Object.prototype;
	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;
	/** Used to check objects for own properties. */
	var hasOwnProperty$2$1 = objectProto$2.hasOwnProperty;
	/** Used to detect if a method is native. */
	var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$2$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	/**
	* The base implementation of `_.isNative` without bad shim checks.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is a native function,
	*  else `false`.
	*/
	function baseIsNative(value) {
		if (!isObject(value) || isMasked(value)) return false;
		return (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
	}
	/**
	* Gets the value at `key` of `object`.
	*
	* @private
	* @param {Object} [object] The object to query.
	* @param {string} key The key of the property to get.
	* @returns {*} Returns the property value.
	*/
	function getValue(object, key$1) {
		return object == null ? void 0 : object[key$1];
	}
	/**
	* Gets the native function at `key` of `object`.
	*
	* @private
	* @param {Object} object The object to query.
	* @param {string} key The key of the method to get.
	* @returns {*} Returns the function if it's native, else `undefined`.
	*/
	function getNative(object, key$1) {
		var value = getValue(object, key$1);
		return baseIsNative(value) ? value : void 0;
	}
	var nativeCreate = getNative(Object, "create");
	/**
	* Removes all key-value entries from the hash.
	*
	* @private
	* @name clear
	* @memberOf Hash
	*/
	function hashClear() {
		this.__data__ = nativeCreate ? nativeCreate(null) : {};
		this.size = 0;
	}
	/**
	* Removes `key` and its value from the hash.
	*
	* @private
	* @name delete
	* @memberOf Hash
	* @param {Object} hash The hash to modify.
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function hashDelete(key$1) {
		var result = this.has(key$1) && delete this.__data__[key$1];
		this.size -= result ? 1 : 0;
		return result;
	}
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	/** Used to check objects for own properties. */
	var hasOwnProperty$3$1 = Object.prototype.hasOwnProperty;
	/**
	* Gets the hash value for `key`.
	*
	* @private
	* @name get
	* @memberOf Hash
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function hashGet(key$1) {
		var data = this.__data__;
		if (nativeCreate) {
			var result = data[key$1];
			return result === HASH_UNDEFINED ? void 0 : result;
		}
		return hasOwnProperty$3$1.call(data, key$1) ? data[key$1] : void 0;
	}
	/** Used to check objects for own properties. */
	var hasOwnProperty$4$1 = Object.prototype.hasOwnProperty;
	/**
	* Checks if a hash value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf Hash
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function hashHas(key$1) {
		var data = this.__data__;
		return nativeCreate ? data[key$1] !== void 0 : hasOwnProperty$4$1.call(data, key$1);
	}
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
	/**
	* Sets the hash `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf Hash
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the hash instance.
	*/
	function hashSet(key$1, value) {
		var data = this.__data__;
		this.size += this.has(key$1) ? 0 : 1;
		data[key$1] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
		return this;
	}
	/**
	* Creates a hash object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function Hash(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	Hash.prototype.clear = hashClear;
	Hash.prototype["delete"] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	/**
	* Removes all key-value entries from the list cache.
	*
	* @private
	* @name clear
	* @memberOf ListCache
	*/
	function listCacheClear() {
		this.__data__ = [];
		this.size = 0;
	}
	/**
	* Performs a
	* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	* comparison between two values to determine if they are equivalent.
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Lang
	* @param {*} value The value to compare.
	* @param {*} other The other value to compare.
	* @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	* @example
	*
	* var object = { 'a': 1 };
	* var other = { 'a': 1 };
	*
	* _.eq(object, object);
	* // => true
	*
	* _.eq(object, other);
	* // => false
	*
	* _.eq('a', 'a');
	* // => true
	*
	* _.eq('a', Object('a'));
	* // => false
	*
	* _.eq(NaN, NaN);
	* // => true
	*/
	function eq(value, other) {
		return value === other || value !== value && other !== other;
	}
	/**
	* Gets the index at which the `key` is found in `array` of key-value pairs.
	*
	* @private
	* @param {Array} array The array to inspect.
	* @param {*} key The key to search for.
	* @returns {number} Returns the index of the matched value, else `-1`.
	*/
	function assocIndexOf(array, key$1) {
		var length = array.length;
		while (length--) if (eq(array[length][0], key$1)) return length;
		return -1;
	}
	/** Built-in value references. */
	var splice = Array.prototype.splice;
	/**
	* Removes `key` and its value from the list cache.
	*
	* @private
	* @name delete
	* @memberOf ListCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function listCacheDelete(key$1) {
		var data = this.__data__, index$1 = assocIndexOf(data, key$1);
		if (index$1 < 0) return false;
		if (index$1 == data.length - 1) data.pop();
		else splice.call(data, index$1, 1);
		--this.size;
		return true;
	}
	/**
	* Gets the list cache value for `key`.
	*
	* @private
	* @name get
	* @memberOf ListCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function listCacheGet(key$1) {
		var data = this.__data__, index$1 = assocIndexOf(data, key$1);
		return index$1 < 0 ? void 0 : data[index$1][1];
	}
	/**
	* Checks if a list cache value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf ListCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function listCacheHas(key$1) {
		return assocIndexOf(this.__data__, key$1) > -1;
	}
	/**
	* Sets the list cache `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf ListCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the list cache instance.
	*/
	function listCacheSet(key$1, value) {
		var data = this.__data__, index$1 = assocIndexOf(data, key$1);
		if (index$1 < 0) {
			++this.size;
			data.push([key$1, value]);
		} else data[index$1][1] = value;
		return this;
	}
	/**
	* Creates an list cache object.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function ListCache(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype["delete"] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	var Map$1 = getNative(root, "Map");
	/**
	* Removes all key-value entries from the map.
	*
	* @private
	* @name clear
	* @memberOf MapCache
	*/
	function mapCacheClear() {
		this.size = 0;
		this.__data__ = {
			"hash": new Hash(),
			"map": new (Map$1 || ListCache)(),
			"string": new Hash()
		};
	}
	/**
	* Checks if `value` is suitable for use as unique object key.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	*/
	function isKeyable(value) {
		var type = typeof value;
		return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
	}
	/**
	* Gets the data for `map`.
	*
	* @private
	* @param {Object} map The map to query.
	* @param {string} key The reference key.
	* @returns {*} Returns the map data.
	*/
	function getMapData(map$2, key$1) {
		var data = map$2.__data__;
		return isKeyable(key$1) ? data[typeof key$1 == "string" ? "string" : "hash"] : data.map;
	}
	/**
	* Removes `key` and its value from the map.
	*
	* @private
	* @name delete
	* @memberOf MapCache
	* @param {string} key The key of the value to remove.
	* @returns {boolean} Returns `true` if the entry was removed, else `false`.
	*/
	function mapCacheDelete(key$1) {
		var result = getMapData(this, key$1)["delete"](key$1);
		this.size -= result ? 1 : 0;
		return result;
	}
	/**
	* Gets the map value for `key`.
	*
	* @private
	* @name get
	* @memberOf MapCache
	* @param {string} key The key of the value to get.
	* @returns {*} Returns the entry value.
	*/
	function mapCacheGet(key$1) {
		return getMapData(this, key$1).get(key$1);
	}
	/**
	* Checks if a map value for `key` exists.
	*
	* @private
	* @name has
	* @memberOf MapCache
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function mapCacheHas(key$1) {
		return getMapData(this, key$1).has(key$1);
	}
	/**
	* Sets the map `key` to `value`.
	*
	* @private
	* @name set
	* @memberOf MapCache
	* @param {string} key The key of the value to set.
	* @param {*} value The value to set.
	* @returns {Object} Returns the map cache instance.
	*/
	function mapCacheSet(key$1, value) {
		var data = getMapData(this, key$1), size = data.size;
		data.set(key$1, value);
		this.size += data.size == size ? 0 : 1;
		return this;
	}
	/**
	* Creates a map cache object to store key-value pairs.
	*
	* @private
	* @constructor
	* @param {Array} [entries] The key-value pairs to cache.
	*/
	function MapCache(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype["delete"] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
	/**
	* Adds `value` to the array cache.
	*
	* @private
	* @name add
	* @memberOf SetCache
	* @alias push
	* @param {*} value The value to cache.
	* @returns {Object} Returns the cache instance.
	*/
	function setCacheAdd(value) {
		this.__data__.set(value, HASH_UNDEFINED$2);
		return this;
	}
	/**
	* Checks if `value` is in the array cache.
	*
	* @private
	* @name has
	* @memberOf SetCache
	* @param {*} value The value to search for.
	* @returns {number} Returns `true` if `value` is found, else `false`.
	*/
	function setCacheHas(value) {
		return this.__data__.has(value);
	}
	/**
	*
	* Creates an array cache object to store unique values.
	*
	* @private
	* @constructor
	* @param {Array} [values] The values to cache.
	*/
	function SetCache(values) {
		var index$1 = -1, length = values == null ? 0 : values.length;
		this.__data__ = new MapCache();
		while (++index$1 < length) this.add(values[index$1]);
	}
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	/**
	* The base implementation of `_.findIndex` and `_.findLastIndex` without
	* support for iteratee shorthands.
	*
	* @private
	* @param {Array} array The array to inspect.
	* @param {Function} predicate The function invoked per iteration.
	* @param {number} fromIndex The index to search from.
	* @param {boolean} [fromRight] Specify iterating from right to left.
	* @returns {number} Returns the index of the matched value, else `-1`.
	*/
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
		var length = array.length, index$1 = fromIndex + (fromRight ? 1 : -1);
		while (fromRight ? index$1-- : ++index$1 < length) if (predicate(array[index$1], index$1, array)) return index$1;
		return -1;
	}
	/**
	* The base implementation of `_.isNaN` without support for number objects.
	*
	* @private
	* @param {*} value The value to check.
	* @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	*/
	function baseIsNaN(value) {
		return value !== value;
	}
	/**
	* A specialized version of `_.indexOf` which performs strict equality
	* comparisons of values, i.e. `===`.
	*
	* @private
	* @param {Array} array The array to inspect.
	* @param {*} value The value to search for.
	* @param {number} fromIndex The index to search from.
	* @returns {number} Returns the index of the matched value, else `-1`.
	*/
	function strictIndexOf(array, value, fromIndex) {
		var index$1 = fromIndex - 1, length = array.length;
		while (++index$1 < length) if (array[index$1] === value) return index$1;
		return -1;
	}
	/**
	* The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	*
	* @private
	* @param {Array} array The array to inspect.
	* @param {*} value The value to search for.
	* @param {number} fromIndex The index to search from.
	* @returns {number} Returns the index of the matched value, else `-1`.
	*/
	function baseIndexOf(array, value, fromIndex) {
		return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
	}
	/**
	* A specialized version of `_.includes` for arrays without support for
	* specifying an index to search from.
	*
	* @private
	* @param {Array} [array] The array to inspect.
	* @param {*} target The value to search for.
	* @returns {boolean} Returns `true` if `target` is found, else `false`.
	*/
	function arrayIncludes(array, value) {
		return !!(array == null ? 0 : array.length) && baseIndexOf(array, value, 0) > -1;
	}
	/**
	* This function is like `arrayIncludes` except that it accepts a comparator.
	*
	* @private
	* @param {Array} [array] The array to inspect.
	* @param {*} target The value to search for.
	* @param {Function} comparator The comparator invoked per element.
	* @returns {boolean} Returns `true` if `target` is found, else `false`.
	*/
	function arrayIncludesWith(array, value, comparator) {
		var index$1 = -1, length = array == null ? 0 : array.length;
		while (++index$1 < length) if (comparator(value, array[index$1])) return true;
		return false;
	}
	/**
	* Checks if a `cache` value for `key` exists.
	*
	* @private
	* @param {Object} cache The cache to query.
	* @param {string} key The key of the entry to check.
	* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	*/
	function cacheHas(cache, key$1) {
		return cache.has(key$1);
	}
	var Set$1 = getNative(root, "Set");
	/**
	* This method returns `undefined`.
	*
	* @static
	* @memberOf _
	* @since 2.3.0
	* @category Util
	* @example
	*
	* _.times(2, _.noop);
	* // => [undefined, undefined]
	*/
	function noop$2() {}
	/**
	* Converts `set` to an array of its values.
	*
	* @private
	* @param {Object} set The set to convert.
	* @returns {Array} Returns the values.
	*/
	function setToArray(set$3) {
		var index$1 = -1, result = Array(set$3.size);
		set$3.forEach(function(value) {
			result[++index$1] = value;
		});
		return result;
	}
	/**
	* Creates a set object of `values`.
	*
	* @private
	* @param {Array} values The values to add to the set.
	* @returns {Object} Returns the new set.
	*/
	var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == Infinity) ? noop$2 : function(values) {
		return new Set$1(values);
	};
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	/**
	* The base implementation of `_.uniqBy` without support for iteratee shorthands.
	*
	* @private
	* @param {Array} array The array to inspect.
	* @param {Function} [iteratee] The iteratee invoked per element.
	* @param {Function} [comparator] The comparator invoked per element.
	* @returns {Array} Returns the new duplicate free array.
	*/
	function baseUniq(array, iteratee, comparator) {
		var index$1 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
		if (comparator) {
			isCommon = false;
			includes = arrayIncludesWith;
		} else if (length >= LARGE_ARRAY_SIZE) {
			var set$3 = iteratee ? null : createSet(array);
			if (set$3) return setToArray(set$3);
			isCommon = false;
			includes = cacheHas;
			seen = new SetCache();
		} else seen = iteratee ? [] : result;
		outer: while (++index$1 < length) {
			var value = array[index$1], computed = iteratee ? iteratee(value) : value;
			value = comparator || value !== 0 ? value : 0;
			if (isCommon && computed === computed) {
				var seenIndex = seen.length;
				while (seenIndex--) if (seen[seenIndex] === computed) continue outer;
				if (iteratee) seen.push(computed);
				result.push(value);
			} else if (!includes(seen, computed, comparator)) {
				if (seen !== result) seen.push(computed);
				result.push(value);
			}
		}
		return result;
	}
	/**
	* This method is like `_.uniq` except that it accepts `comparator` which
	* is invoked to compare elements of `array`. The order of result values is
	* determined by the order they occur in the array.The comparator is invoked
	* with two arguments: (arrVal, othVal).
	*
	* @static
	* @memberOf _
	* @since 4.0.0
	* @category Array
	* @param {Array} array The array to inspect.
	* @param {Function} [comparator] The comparator invoked per element.
	* @returns {Array} Returns the new duplicate free array.
	* @example
	*
	* var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	*
	* _.uniqWith(objects, _.isEqual);
	* // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	*/
	function uniqWith(array, comparator) {
		comparator = typeof comparator == "function" ? comparator : void 0;
		return array && array.length ? baseUniq(array, void 0, comparator) : [];
	}
	const bowser = global.navigator && global.navigator.userAgent ? Bowser.getParser(global.navigator.userAgent).getBrowser() : null;
	const browser = bowser && bowser.name && bowser.version ? {
		name: bowser.name,
		version: bowser.version
	} : null;
	var Log = class {
		constructor(opts = {}) {
			assign$1(this, {
				version: "1.2",
				entries: [],
				pages: []
			}, opts);
			if (!this.browser && browser) this.browser = browser;
		}
		addEntries(entries = []) {
			this.entries = uniqWith([...entries, ...this.entries], (a, b) => a._id === b._id && a._order === b._order);
		}
		sortEntries() {
			this.entries = this.entries.sort((a, b) => new Date(a.startedDateTime) - new Date(b.startedDateTime));
		}
	};
	var HAR = class {
		constructor(opts = {}) {
			this.log = new Log(opts.log);
		}
	};
	var _stringWs = "	\n\v\f\r \xA0\u2028\u2029";
	var space = "[" + _stringWs + "]";
	var non = "";
	var ltrim = RegExp("^" + space + space + "*");
	var rtrim = RegExp(space + space + "*$");
	var exporter = function(KEY, exec, ALIAS) {
		var exp = {};
		var FORCE = _fails$1(function() {
			return !!_stringWs[KEY]() || non[KEY]() != non;
		});
		var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
		if (ALIAS) exp[ALIAS] = fn;
		_export$1(_export$1.P + _export$1.F * FORCE, "String", exp);
	};
	var trim = exporter.trim = function(string, TYPE) {
		string = String(_defined$1(string));
		if (TYPE & 1) string = string.replace(ltrim, "");
		if (TYPE & 2) string = string.replace(rtrim, "");
		return string;
	};
	var _stringTrim = exporter;
	var $parseInt = _global$1.parseInt;
	var $trim = _stringTrim.trim;
	var hex = /^[-+]?0[xX]/;
	var _parseInt = $parseInt(_stringWs + "08") !== 8 || $parseInt(_stringWs + "0x16") !== 22 ? function parseInt$1(str, radix) {
		var string = $trim(String(str), 3);
		return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
	} : $parseInt;
	_export$1(_export$1.G + _export$1.F * (parseInt != _parseInt), { parseInt: _parseInt });
	var _parseInt$2 = _core$1.parseInt;
	const { keys: keys$2 } = Object;
	const { isArray: isArray$3 } = Array;
	function toNVPairs(o) {
		return keys$2(o || {}).reduce((pairs, name) => {
			const value = o[name];
			if (isArray$3(value)) pairs.push(...value.map((v) => ({
				name,
				value: v,
				_fromType: "array"
			})));
			else pairs.push({
				name,
				value
			});
			return pairs;
		}, []);
	}
	const { isArray: isArray$1$1 } = Array;
	/**
	* Get the value of the given header name. If the value is an array,
	* get the first value.
	*
	* @export
	* @param {PollyRequest | PollyResponse} r
	* @param {string} name
	* @returns {string | undefined}
	*/
	function getFirstHeader(r, name) {
		const value = r.getHeader(name);
		if (isArray$1$1(value)) return value.length > 0 ? value[0] : "";
		return value;
	}
	function headersSize(request) {
		const keys$6 = [];
		const values = [];
		request.headers.forEach(({ name, value }) => {
			keys$6.push(name);
			values.push(value);
		});
		return getByteLength(request.method + request.url + keys$6.join() + values.join()) + keys$6.length * 2 + 2 + 12 + 2;
	}
	var Request = class {
		constructor(request) {
			this.httpVersion = "HTTP/1.1";
			this.url = request.absoluteUrl;
			this.method = request.method;
			this.headers = toNVPairs(request.headers);
			this.headersSize = headersSize(this);
			this.queryString = toNVPairs(request.query);
			this.cookies = setCookies.parse(request.getHeader("Set-Cookie"));
			if (request.body) {
				this.postData = {
					mimeType: getFirstHeader(request, "Content-Type") || "text/plain",
					params: []
				};
				if (typeof request.body === "string") this.postData.text = request.body;
			}
			const contentLength = getFirstHeader(request, "Content-Length");
			if (contentLength) this.bodySize = _parseInt$2(contentLength, 10);
			else this.bodySize = this.postData && this.postData.text ? getByteLength(this.postData.text) : 0;
		}
	};
	function headersSize$1(response) {
		const keys$6 = [];
		const values = [];
		response.headers.forEach(({ name, value }) => {
			keys$6.push(name);
			values.push(value);
		});
		return getByteLength(keys$6.join() + values.join()) + keys$6.length * 2 + 2 + 2;
	}
	var Response = class {
		constructor(response) {
			this.httpVersion = "HTTP/1.1";
			this.status = response.statusCode;
			this.statusText = response.statusText;
			this.headers = toNVPairs(response.headers);
			this.headersSize = headersSize$1(this);
			this.cookies = setCookies.parse(response.getHeader("Set-Cookie"));
			this.redirectURL = getFirstHeader(response, "Location") || "";
			this.content = { mimeType: getFirstHeader(response, "Content-Type") || "text/plain" };
			if (response.body && typeof response.body === "string") {
				this.content.text = response.body;
				if (response.encoding) this.content.encoding = response.encoding;
			}
			const contentLength = getFirstHeader(response, "Content-Length");
			if (contentLength) this.content.size = _parseInt$2(contentLength, 10);
			else this.content.size = this.content.text ? getByteLength(this.content.text) : 0;
			this.bodySize = this.content.size;
		}
	};
	const { keys: keys$3 } = Object;
	function totalTime(timings = {}) {
		return keys$3(timings).reduce((total, k$7) => timings[k$7] > 0 ? total += timings[k$7] : total, 0);
	}
	var Entry = class {
		constructor(request) {
			this._id = request.id;
			this._order = request.order;
			this.startedDateTime = request.timestamp;
			this.request = new Request(request);
			this.response = new Response(request.response);
			this.cache = {};
			this.timings = {
				blocked: -1,
				dns: -1,
				connect: -1,
				send: 0,
				wait: request.responseTime,
				receive: 0,
				ssl: -1
			};
			this.time = totalTime(this.timings);
		}
	};
	function ownKeys$2(object, enumerableOnly) {
		var keys$6 = keys$1$1(object);
		if (getOwnPropertySymbols$1$1) {
			var symbols = getOwnPropertySymbols$1$1(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1$1(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$2(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$2(Object(source), true).forEach(function(key$1) {
				_defineProperty$1(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1$1) defineProperties$1$1(target, getOwnPropertyDescriptors$1$1(source));
			else ownKeys$2(Object(source)).forEach(function(key$1) {
				defineProperty$2$1(target, key$1, getOwnPropertyDescriptor$1$1(source, key$1));
			});
		}
		return target;
	}
	const CREATOR_NAME = "Polly.JS";
	var Persister$1 = class {
		constructor(polly) {
			this.polly = polly;
			this.pending = new map$1();
			this._cache = new map$1();
		}
		static get type() {
			return "persister";
		}
		static get id() {
			utils$3.assert("Must override the static `id` getter.");
		}
		get defaultOptions() {
			return {};
		}
		get options() {
			return _objectSpread$2(_objectSpread$2({}, this.defaultOptions || {}), (this.polly.config.persisterOptions || {})[this.constructor.id] || {});
		}
		get hasPending() {
			return this.pending.size > 0;
		}
		async persist() {
			if (!this.hasPending) return;
			const promises = [];
			const creator = {
				name: CREATOR_NAME,
				version: this.polly.constructor.VERSION,
				comment: `${this.constructor.type}:${this.constructor.id}`
			};
			for (const [recordingId, { name, requests }] of this.pending) {
				const entries = [];
				const recording = await this.findRecording(recordingId);
				let har;
				if (!recording) har = new HAR({ log: {
					creator,
					_recordingName: name
				} });
				else har = new HAR(recording);
				for (const request of requests) {
					const entry = new Entry(request);
					this.assert(`Cannot persist response for [${entry.request.method}] ${entry.request.url} because the status code was ${entry.response.status} and \`recordFailedRequests\` is \`false\``, entry.response.status < 400 || request.config.recordFailedRequests);
					await request._emit("beforePersist", entry);
					entries.push(entry);
				}
				har.log.addEntries(entries);
				if (!this.polly.config.persisterOptions.disableSortingHarEntries) har.log.sortEntries();
				if (!this.polly.config.persisterOptions.keepUnusedRequests) this._removeUnusedEntries(recordingId, har);
				promises.push(this.saveRecording(recordingId, har));
			}
			await promise$1.all(promises);
			this.pending.clear();
		}
		recordRequest(pollyRequest) {
			this.assert(`You must pass a PollyRequest to 'recordRequest'.`, pollyRequest);
			this.assert(`Cannot save a request with no response.`, pollyRequest.didRespond);
			const { recordingId, recordingName } = pollyRequest;
			if (!this.pending.has(recordingId)) this.pending.set(recordingId, {
				name: recordingName,
				requests: []
			});
			this.pending.get(recordingId).requests.push(pollyRequest);
		}
		async findRecording(recordingId) {
			const { _cache: cache } = this;
			if (!cache.has(recordingId)) {
				const onFindRecording = async () => {
					const recording = await this.onFindRecording(recordingId);
					if (recording) {
						this.assert(`Recording with id '${recordingId}' is invalid. Please delete the recording so a new one can be created.`, recording.log && recording.log.creator.name === CREATOR_NAME);
						return recording;
					} else {
						cache.delete(recordingId);
						return null;
					}
				};
				cache.set(recordingId, onFindRecording());
			}
			return cache.get(recordingId);
		}
		onFindRecording() {
			this.assert("Must implement the `onFindRecording` hook.");
		}
		async saveRecording(recordingId, har) {
			await this.onSaveRecording(...arguments);
			this._cache.delete(recordingId);
			this.polly.logger.log.debug("Recording saved.", {
				recordingId,
				har
			});
		}
		onSaveRecording() {
			this.assert("Must implement the `onSaveRecording` hook.");
		}
		async deleteRecording(recordingId) {
			await this.onDeleteRecording(...arguments);
			this._cache.delete(recordingId);
		}
		onDeleteRecording() {
			this.assert("Must implement the `onDeleteRecording` hook.");
		}
		async findEntry(pollyRequest) {
			const { id: id$7, order, recordingId } = pollyRequest;
			const recording = await this.findRecording(recordingId);
			return recording && recording.log.entries.find((entry) => entry._id === id$7 && entry._order === order) || null;
		}
		stringify() {
			return stringify$8(...arguments);
		}
		assert(message, ...args) {
			utils$3.assert(`[${this.constructor.type}:${this.constructor.id}] ${message}`, ...args);
		}
		/**
		* Remove all entries from the given HAR that do not match any requests in
		* the current Polly instance.
		*
		* @param {String} recordingId
		* @param {HAR} har
		*/
		_removeUnusedEntries(recordingId, har) {
			const requests = this.polly._requests.filter((r) => r.recordingId === recordingId && (r.action === utils$3.ACTIONS.RECORD || r.action === utils$3.ACTIONS.REPLAY));
			har.log.entries = har.log.entries.filter((entry) => requests.find((r) => entry._id === r.id && entry._order === r.order));
		}
	};
	module.exports = Persister$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js
var require_universalify = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js": ((exports) => {
	exports.fromCallback = function(fn) {
		return Object.defineProperty(function(...args) {
			if (typeof args[args.length - 1] === "function") fn.apply(this, args);
			else return new Promise((resolve$6, reject) => {
				args.push((err, res$2) => err != null ? reject(err) : resolve$6(res$2));
				fn.apply(this, args);
			});
		}, "name", { value: fn.name });
	};
	exports.fromPromise = function(fn) {
		return Object.defineProperty(function(...args) {
			const cb = args[args.length - 1];
			if (typeof cb !== "function") return fn.apply(this, args);
			else {
				args.pop();
				fn.apply(this, args).then((r) => cb(null, r), cb);
			}
		}, "name", { value: fn.name });
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js": ((exports, module) => {
	var constants = __require("constants");
	var origCwd = process.cwd;
	var cwd = null;
	var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
	process.cwd = function() {
		if (!cwd) cwd = origCwd.call(process);
		return cwd;
	};
	try {
		process.cwd();
	} catch (er) {}
	if (typeof process.chdir === "function") {
		var chdir = process.chdir;
		process.chdir = function(d$3) {
			cwd = null;
			chdir.call(process, d$3);
		};
		if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
	}
	module.exports = patch$1;
	function patch$1(fs$26) {
		if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) patchLchmod(fs$26);
		if (!fs$26.lutimes) patchLutimes(fs$26);
		fs$26.chown = chownFix(fs$26.chown);
		fs$26.fchown = chownFix(fs$26.fchown);
		fs$26.lchown = chownFix(fs$26.lchown);
		fs$26.chmod = chmodFix(fs$26.chmod);
		fs$26.fchmod = chmodFix(fs$26.fchmod);
		fs$26.lchmod = chmodFix(fs$26.lchmod);
		fs$26.chownSync = chownFixSync(fs$26.chownSync);
		fs$26.fchownSync = chownFixSync(fs$26.fchownSync);
		fs$26.lchownSync = chownFixSync(fs$26.lchownSync);
		fs$26.chmodSync = chmodFixSync(fs$26.chmodSync);
		fs$26.fchmodSync = chmodFixSync(fs$26.fchmodSync);
		fs$26.lchmodSync = chmodFixSync(fs$26.lchmodSync);
		fs$26.stat = statFix(fs$26.stat);
		fs$26.fstat = statFix(fs$26.fstat);
		fs$26.lstat = statFix(fs$26.lstat);
		fs$26.statSync = statFixSync(fs$26.statSync);
		fs$26.fstatSync = statFixSync(fs$26.fstatSync);
		fs$26.lstatSync = statFixSync(fs$26.lstatSync);
		if (fs$26.chmod && !fs$26.lchmod) {
			fs$26.lchmod = function(path$19, mode, cb) {
				if (cb) process.nextTick(cb);
			};
			fs$26.lchmodSync = function() {};
		}
		if (fs$26.chown && !fs$26.lchown) {
			fs$26.lchown = function(path$19, uid, gid, cb) {
				if (cb) process.nextTick(cb);
			};
			fs$26.lchownSync = function() {};
		}
		if (platform === "win32") fs$26.rename = typeof fs$26.rename !== "function" ? fs$26.rename : (function(fs$rename) {
			function rename$2(from, to, cb) {
				var start = Date.now();
				var backoff = 0;
				fs$rename(from, to, function CB(er) {
					if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
						setTimeout(function() {
							fs$26.stat(to, function(stater, st) {
								if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
								else cb(er);
							});
						}, backoff);
						if (backoff < 100) backoff += 10;
						return;
					}
					if (cb) cb(er);
				});
			}
			if (Object.setPrototypeOf) Object.setPrototypeOf(rename$2, fs$rename);
			return rename$2;
		})(fs$26.rename);
		fs$26.read = typeof fs$26.read !== "function" ? fs$26.read : (function(fs$read) {
			function read$6(fd$1, buffer$5, offset, length, position, callback_) {
				var callback;
				if (callback_ && typeof callback_ === "function") {
					var eagCounter = 0;
					callback = function(er, _, __) {
						if (er && er.code === "EAGAIN" && eagCounter < 10) {
							eagCounter++;
							return fs$read.call(fs$26, fd$1, buffer$5, offset, length, position, callback);
						}
						callback_.apply(this, arguments);
					};
				}
				return fs$read.call(fs$26, fd$1, buffer$5, offset, length, position, callback);
			}
			if (Object.setPrototypeOf) Object.setPrototypeOf(read$6, fs$read);
			return read$6;
		})(fs$26.read);
		fs$26.readSync = typeof fs$26.readSync !== "function" ? fs$26.readSync : (function(fs$readSync) {
			return function(fd$1, buffer$5, offset, length, position) {
				var eagCounter = 0;
				while (true) try {
					return fs$readSync.call(fs$26, fd$1, buffer$5, offset, length, position);
				} catch (er) {
					if (er.code === "EAGAIN" && eagCounter < 10) {
						eagCounter++;
						continue;
					}
					throw er;
				}
			};
		})(fs$26.readSync);
		function patchLchmod(fs$27) {
			fs$27.lchmod = function(path$19, mode, callback) {
				fs$27.open(path$19, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd$1) {
					if (err) {
						if (callback) callback(err);
						return;
					}
					fs$27.fchmod(fd$1, mode, function(err$1) {
						fs$27.close(fd$1, function(err2) {
							if (callback) callback(err$1 || err2);
						});
					});
				});
			};
			fs$27.lchmodSync = function(path$19, mode) {
				var fd$1 = fs$27.openSync(path$19, constants.O_WRONLY | constants.O_SYMLINK, mode);
				var threw = true;
				var ret;
				try {
					ret = fs$27.fchmodSync(fd$1, mode);
					threw = false;
				} finally {
					if (threw) try {
						fs$27.closeSync(fd$1);
					} catch (er) {}
					else fs$27.closeSync(fd$1);
				}
				return ret;
			};
		}
		function patchLutimes(fs$27) {
			if (constants.hasOwnProperty("O_SYMLINK") && fs$27.futimes) {
				fs$27.lutimes = function(path$19, at, mt, cb) {
					fs$27.open(path$19, constants.O_SYMLINK, function(er, fd$1) {
						if (er) {
							if (cb) cb(er);
							return;
						}
						fs$27.futimes(fd$1, at, mt, function(er$1) {
							fs$27.close(fd$1, function(er2) {
								if (cb) cb(er$1 || er2);
							});
						});
					});
				};
				fs$27.lutimesSync = function(path$19, at, mt) {
					var fd$1 = fs$27.openSync(path$19, constants.O_SYMLINK);
					var ret;
					var threw = true;
					try {
						ret = fs$27.futimesSync(fd$1, at, mt);
						threw = false;
					} finally {
						if (threw) try {
							fs$27.closeSync(fd$1);
						} catch (er) {}
						else fs$27.closeSync(fd$1);
					}
					return ret;
				};
			} else if (fs$27.futimes) {
				fs$27.lutimes = function(_a, _b, _c, cb) {
					if (cb) process.nextTick(cb);
				};
				fs$27.lutimesSync = function() {};
			}
		}
		function chmodFix(orig) {
			if (!orig) return orig;
			return function(target, mode, cb) {
				return orig.call(fs$26, target, mode, function(er) {
					if (chownErOk(er)) er = null;
					if (cb) cb.apply(this, arguments);
				});
			};
		}
		function chmodFixSync(orig) {
			if (!orig) return orig;
			return function(target, mode) {
				try {
					return orig.call(fs$26, target, mode);
				} catch (er) {
					if (!chownErOk(er)) throw er;
				}
			};
		}
		function chownFix(orig) {
			if (!orig) return orig;
			return function(target, uid, gid, cb) {
				return orig.call(fs$26, target, uid, gid, function(er) {
					if (chownErOk(er)) er = null;
					if (cb) cb.apply(this, arguments);
				});
			};
		}
		function chownFixSync(orig) {
			if (!orig) return orig;
			return function(target, uid, gid) {
				try {
					return orig.call(fs$26, target, uid, gid);
				} catch (er) {
					if (!chownErOk(er)) throw er;
				}
			};
		}
		function statFix(orig) {
			if (!orig) return orig;
			return function(target, options, cb) {
				if (typeof options === "function") {
					cb = options;
					options = null;
				}
				function callback(er, stats) {
					if (stats) {
						if (stats.uid < 0) stats.uid += 4294967296;
						if (stats.gid < 0) stats.gid += 4294967296;
					}
					if (cb) cb.apply(this, arguments);
				}
				return options ? orig.call(fs$26, target, options, callback) : orig.call(fs$26, target, callback);
			};
		}
		function statFixSync(orig) {
			if (!orig) return orig;
			return function(target, options) {
				var stats = options ? orig.call(fs$26, target, options) : orig.call(fs$26, target);
				if (stats) {
					if (stats.uid < 0) stats.uid += 4294967296;
					if (stats.gid < 0) stats.gid += 4294967296;
				}
				return stats;
			};
		}
		function chownErOk(er) {
			if (!er) return true;
			if (er.code === "ENOSYS") return true;
			if (!process.getuid || process.getuid() !== 0) {
				if (er.code === "EINVAL" || er.code === "EPERM") return true;
			}
			return false;
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js": ((exports, module) => {
	var Stream$2 = __require("stream").Stream;
	module.exports = legacy$1;
	function legacy$1(fs$26) {
		return {
			ReadStream: ReadStream$1,
			WriteStream
		};
		function ReadStream$1(path$19, options) {
			if (!(this instanceof ReadStream$1)) return new ReadStream$1(path$19, options);
			Stream$2.call(this);
			var self$1 = this;
			this.path = path$19;
			this.fd = null;
			this.readable = true;
			this.paused = false;
			this.flags = "r";
			this.mode = 438;
			this.bufferSize = 64 * 1024;
			options = options || {};
			var keys$6 = Object.keys(options);
			for (var index$1 = 0, length = keys$6.length; index$1 < length; index$1++) {
				var key$1 = keys$6[index$1];
				this[key$1] = options[key$1];
			}
			if (this.encoding) this.setEncoding(this.encoding);
			if (this.start !== void 0) {
				if ("number" !== typeof this.start) throw TypeError("start must be a Number");
				if (this.end === void 0) this.end = Infinity;
				else if ("number" !== typeof this.end) throw TypeError("end must be a Number");
				if (this.start > this.end) throw new Error("start must be <= end");
				this.pos = this.start;
			}
			if (this.fd !== null) {
				process.nextTick(function() {
					self$1._read();
				});
				return;
			}
			fs$26.open(this.path, this.flags, this.mode, function(err, fd$1) {
				if (err) {
					self$1.emit("error", err);
					self$1.readable = false;
					return;
				}
				self$1.fd = fd$1;
				self$1.emit("open", fd$1);
				self$1._read();
			});
		}
		function WriteStream(path$19, options) {
			if (!(this instanceof WriteStream)) return new WriteStream(path$19, options);
			Stream$2.call(this);
			this.path = path$19;
			this.fd = null;
			this.writable = true;
			this.flags = "w";
			this.encoding = "binary";
			this.mode = 438;
			this.bytesWritten = 0;
			options = options || {};
			var keys$6 = Object.keys(options);
			for (var index$1 = 0, length = keys$6.length; index$1 < length; index$1++) {
				var key$1 = keys$6[index$1];
				this[key$1] = options[key$1];
			}
			if (this.start !== void 0) {
				if ("number" !== typeof this.start) throw TypeError("start must be a Number");
				if (this.start < 0) throw new Error("start must be >= zero");
				this.pos = this.start;
			}
			this.busy = false;
			this._queue = [];
			if (this.fd === null) {
				this._open = fs$26.open;
				this._queue.push([
					this._open,
					this.path,
					this.flags,
					this.mode,
					void 0
				]);
				this.flush();
			}
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js": ((exports, module) => {
	module.exports = clone$1;
	var getPrototypeOf = Object.getPrototypeOf || function(obj) {
		return obj.__proto__;
	};
	function clone$1(obj) {
		if (obj === null || typeof obj !== "object") return obj;
		if (obj instanceof Object) var copy$2 = { __proto__: getPrototypeOf(obj) };
		else var copy$2 = Object.create(null);
		Object.getOwnPropertyNames(obj).forEach(function(key$1) {
			Object.defineProperty(copy$2, key$1, Object.getOwnPropertyDescriptor(obj, key$1));
		});
		return copy$2;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js": ((exports, module) => {
	var fs$22 = __require("fs");
	var polyfills = require_polyfills();
	var legacy = require_legacy_streams();
	var clone = require_clone();
	var util$4 = __require("util");
	/* istanbul ignore next - node 0.x polyfill */
	var gracefulQueue;
	var previousSymbol;
	/* istanbul ignore else - node 0.x polyfill */
	if (typeof Symbol === "function" && typeof Symbol.for === "function") {
		gracefulQueue = Symbol.for("graceful-fs.queue");
		previousSymbol = Symbol.for("graceful-fs.previous");
	} else {
		gracefulQueue = "___graceful-fs.queue";
		previousSymbol = "___graceful-fs.previous";
	}
	function noop$1() {}
	function publishQueue(context, queue$5) {
		Object.defineProperty(context, gracefulQueue, { get: function() {
			return queue$5;
		} });
	}
	var debug$13 = noop$1;
	if (util$4.debuglog) debug$13 = util$4.debuglog("gfs4");
	else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) debug$13 = function() {
		var m$3 = util$4.format.apply(util$4, arguments);
		m$3 = "GFS4: " + m$3.split(/\n/).join("\nGFS4: ");
		console.error(m$3);
	};
	if (!fs$22[gracefulQueue]) {
		publishQueue(fs$22, global[gracefulQueue] || []);
		fs$22.close = (function(fs$close) {
			function close(fd$1, cb) {
				return fs$close.call(fs$22, fd$1, function(err) {
					if (!err) resetQueue();
					if (typeof cb === "function") cb.apply(this, arguments);
				});
			}
			Object.defineProperty(close, previousSymbol, { value: fs$close });
			return close;
		})(fs$22.close);
		fs$22.closeSync = (function(fs$closeSync) {
			function closeSync(fd$1) {
				fs$closeSync.apply(fs$22, arguments);
				resetQueue();
			}
			Object.defineProperty(closeSync, previousSymbol, { value: fs$closeSync });
			return closeSync;
		})(fs$22.closeSync);
		if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) process.on("exit", function() {
			debug$13(fs$22[gracefulQueue]);
			__require("assert").equal(fs$22[gracefulQueue].length, 0);
		});
	}
	if (!global[gracefulQueue]) publishQueue(global, fs$22[gracefulQueue]);
	module.exports = patch(clone(fs$22));
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$22.__patched) {
		module.exports = patch(fs$22);
		fs$22.__patched = true;
	}
	function patch(fs$26) {
		polyfills(fs$26);
		fs$26.gracefulify = patch;
		fs$26.createReadStream = createReadStream;
		fs$26.createWriteStream = createWriteStream;
		var fs$readFile = fs$26.readFile;
		fs$26.readFile = readFile$2;
		function readFile$2(path$19, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			return go$readFile(path$19, options, cb);
			function go$readFile(path$20, options$1, cb$1, startTime) {
				return fs$readFile(path$20, options$1, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$readFile,
						[
							path$20,
							options$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		var fs$writeFile = fs$26.writeFile;
		fs$26.writeFile = writeFile$2;
		function writeFile$2(path$19, data, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			return go$writeFile(path$19, data, options, cb);
			function go$writeFile(path$20, data$1, options$1, cb$1, startTime) {
				return fs$writeFile(path$20, data$1, options$1, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$writeFile,
						[
							path$20,
							data$1,
							options$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		var fs$appendFile = fs$26.appendFile;
		if (fs$appendFile) fs$26.appendFile = appendFile;
		function appendFile(path$19, data, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			return go$appendFile(path$19, data, options, cb);
			function go$appendFile(path$20, data$1, options$1, cb$1, startTime) {
				return fs$appendFile(path$20, data$1, options$1, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$appendFile,
						[
							path$20,
							data$1,
							options$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		var fs$copyFile = fs$26.copyFile;
		if (fs$copyFile) fs$26.copyFile = copyFile$2;
		function copyFile$2(src$1, dest, flags, cb) {
			if (typeof flags === "function") {
				cb = flags;
				flags = 0;
			}
			return go$copyFile(src$1, dest, flags, cb);
			function go$copyFile(src$2, dest$1, flags$1, cb$1, startTime) {
				return fs$copyFile(src$2, dest$1, flags$1, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$copyFile,
						[
							src$2,
							dest$1,
							flags$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		var fs$readdir = fs$26.readdir;
		fs$26.readdir = readdir;
		var noReaddirOptionVersions = /^v[0-5]\./;
		function readdir(path$19, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir$1(path$20, options$1, cb$1, startTime) {
				return fs$readdir(path$20, fs$readdirCallback(path$20, options$1, cb$1, startTime));
			} : function go$readdir$1(path$20, options$1, cb$1, startTime) {
				return fs$readdir(path$20, options$1, fs$readdirCallback(path$20, options$1, cb$1, startTime));
			};
			return go$readdir(path$19, options, cb);
			function fs$readdirCallback(path$20, options$1, cb$1, startTime) {
				return function(err, files) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$readdir,
						[
							path$20,
							options$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else {
						if (files && files.sort) files.sort();
						if (typeof cb$1 === "function") cb$1.call(this, err, files);
					}
				};
			}
		}
		if (process.version.substr(0, 4) === "v0.8") {
			var legStreams = legacy(fs$26);
			ReadStream$1 = legStreams.ReadStream;
			WriteStream = legStreams.WriteStream;
		}
		var fs$ReadStream = fs$26.ReadStream;
		if (fs$ReadStream) {
			ReadStream$1.prototype = Object.create(fs$ReadStream.prototype);
			ReadStream$1.prototype.open = ReadStream$open;
		}
		var fs$WriteStream = fs$26.WriteStream;
		if (fs$WriteStream) {
			WriteStream.prototype = Object.create(fs$WriteStream.prototype);
			WriteStream.prototype.open = WriteStream$open;
		}
		Object.defineProperty(fs$26, "ReadStream", {
			get: function() {
				return ReadStream$1;
			},
			set: function(val) {
				ReadStream$1 = val;
			},
			enumerable: true,
			configurable: true
		});
		Object.defineProperty(fs$26, "WriteStream", {
			get: function() {
				return WriteStream;
			},
			set: function(val) {
				WriteStream = val;
			},
			enumerable: true,
			configurable: true
		});
		var FileReadStream = ReadStream$1;
		Object.defineProperty(fs$26, "FileReadStream", {
			get: function() {
				return FileReadStream;
			},
			set: function(val) {
				FileReadStream = val;
			},
			enumerable: true,
			configurable: true
		});
		var FileWriteStream = WriteStream;
		Object.defineProperty(fs$26, "FileWriteStream", {
			get: function() {
				return FileWriteStream;
			},
			set: function(val) {
				FileWriteStream = val;
			},
			enumerable: true,
			configurable: true
		});
		function ReadStream$1(path$19, options) {
			if (this instanceof ReadStream$1) return fs$ReadStream.apply(this, arguments), this;
			else return ReadStream$1.apply(Object.create(ReadStream$1.prototype), arguments);
		}
		function ReadStream$open() {
			var that = this;
			open(that.path, that.flags, that.mode, function(err, fd$1) {
				if (err) {
					if (that.autoClose) that.destroy();
					that.emit("error", err);
				} else {
					that.fd = fd$1;
					that.emit("open", fd$1);
					that.read();
				}
			});
		}
		function WriteStream(path$19, options) {
			if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
			else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
		}
		function WriteStream$open() {
			var that = this;
			open(that.path, that.flags, that.mode, function(err, fd$1) {
				if (err) {
					that.destroy();
					that.emit("error", err);
				} else {
					that.fd = fd$1;
					that.emit("open", fd$1);
				}
			});
		}
		function createReadStream(path$19, options) {
			return new fs$26.ReadStream(path$19, options);
		}
		function createWriteStream(path$19, options) {
			return new fs$26.WriteStream(path$19, options);
		}
		var fs$open = fs$26.open;
		fs$26.open = open;
		function open(path$19, flags, mode, cb) {
			if (typeof mode === "function") cb = mode, mode = null;
			return go$open(path$19, flags, mode, cb);
			function go$open(path$20, flags$1, mode$1, cb$1, startTime) {
				return fs$open(path$20, flags$1, mode$1, function(err, fd$1) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$open,
						[
							path$20,
							flags$1,
							mode$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		return fs$26;
	}
	function enqueue(elem) {
		debug$13("ENQUEUE", elem[0].name, elem[1]);
		fs$22[gracefulQueue].push(elem);
		retry();
	}
	var retryTimer;
	function resetQueue() {
		var now = Date.now();
		for (var i$8 = 0; i$8 < fs$22[gracefulQueue].length; ++i$8) if (fs$22[gracefulQueue][i$8].length > 2) {
			fs$22[gracefulQueue][i$8][3] = now;
			fs$22[gracefulQueue][i$8][4] = now;
		}
		retry();
	}
	function retry() {
		clearTimeout(retryTimer);
		retryTimer = void 0;
		if (fs$22[gracefulQueue].length === 0) return;
		var elem = fs$22[gracefulQueue].shift();
		var fn = elem[0];
		var args = elem[1];
		var err = elem[2];
		var startTime = elem[3];
		var lastTime = elem[4];
		if (startTime === void 0) {
			debug$13("RETRY", fn.name, args);
			fn.apply(null, args);
		} else if (Date.now() - startTime >= 6e4) {
			debug$13("TIMEOUT", fn.name, args);
			var cb = args.pop();
			if (typeof cb === "function") cb.call(null, err);
		} else {
			var sinceAttempt = Date.now() - lastTime;
			var sinceStart = Math.max(lastTime - startTime, 1);
			if (sinceAttempt >= Math.min(sinceStart * 1.2, 100)) {
				debug$13("RETRY", fn.name, args);
				fn.apply(null, args.concat([startTime]));
			} else fs$22[gracefulQueue].push(elem);
		}
		if (retryTimer === void 0) retryTimer = setTimeout(retry, 0);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/fs/index.js
var require_fs = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/fs/index.js": ((exports) => {
	const u$11 = require_universalify().fromCallback;
	const fs$21 = require_graceful_fs();
	const api = [
		"access",
		"appendFile",
		"chmod",
		"chown",
		"close",
		"copyFile",
		"fchmod",
		"fchown",
		"fdatasync",
		"fstat",
		"fsync",
		"ftruncate",
		"futimes",
		"lchmod",
		"lchown",
		"link",
		"lstat",
		"mkdir",
		"mkdtemp",
		"open",
		"opendir",
		"readdir",
		"readFile",
		"readlink",
		"realpath",
		"rename",
		"rm",
		"rmdir",
		"stat",
		"symlink",
		"truncate",
		"unlink",
		"utimes",
		"writeFile"
	].filter((key$1) => {
		return typeof fs$21[key$1] === "function";
	});
	Object.assign(exports, fs$21);
	api.forEach((method$1) => {
		exports[method$1] = u$11(fs$21[method$1]);
	});
	exports.exists = function(filename, callback) {
		if (typeof callback === "function") return fs$21.exists(filename, callback);
		return new Promise((resolve$6) => {
			return fs$21.exists(filename, resolve$6);
		});
	};
	exports.read = function(fd$1, buffer$5, offset, length, position, callback) {
		if (typeof callback === "function") return fs$21.read(fd$1, buffer$5, offset, length, position, callback);
		return new Promise((resolve$6, reject) => {
			fs$21.read(fd$1, buffer$5, offset, length, position, (err, bytesRead, buffer$6) => {
				if (err) return reject(err);
				resolve$6({
					bytesRead,
					buffer: buffer$6
				});
			});
		});
	};
	exports.write = function(fd$1, buffer$5, ...args) {
		if (typeof args[args.length - 1] === "function") return fs$21.write(fd$1, buffer$5, ...args);
		return new Promise((resolve$6, reject) => {
			fs$21.write(fd$1, buffer$5, ...args, (err, bytesWritten, buffer$6) => {
				if (err) return reject(err);
				resolve$6({
					bytesWritten,
					buffer: buffer$6
				});
			});
		});
	};
	if (typeof fs$21.writev === "function") exports.writev = function(fd$1, buffers, ...args) {
		if (typeof args[args.length - 1] === "function") return fs$21.writev(fd$1, buffers, ...args);
		return new Promise((resolve$6, reject) => {
			fs$21.writev(fd$1, buffers, ...args, (err, bytesWritten, buffers$1) => {
				if (err) return reject(err);
				resolve$6({
					bytesWritten,
					buffers: buffers$1
				});
			});
		});
	};
	if (typeof fs$21.realpath.native === "function") exports.realpath.native = u$11(fs$21.realpath.native);
	else process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003");
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils$3 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/utils.js": ((exports, module) => {
	const path$17 = __require("path");
	module.exports.checkPath = function checkPath$1(pth) {
		if (process.platform === "win32") {
			if (/[<>:"|?*]/.test(pth.replace(path$17.parse(pth).root, ""))) {
				const error = /* @__PURE__ */ new Error(`Path contains invalid characters: ${pth}`);
				error.code = "EINVAL";
				throw error;
			}
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/make-dir.js": ((exports, module) => {
	const fs$20 = require_fs();
	const { checkPath } = require_utils$3();
	const getMode = (options) => {
		const defaults$5 = { mode: 511 };
		if (typeof options === "number") return options;
		return {
			...defaults$5,
			...options
		}.mode;
	};
	module.exports.makeDir = async (dir, options) => {
		checkPath(dir);
		return fs$20.mkdir(dir, {
			mode: getMode(options),
			recursive: true
		});
	};
	module.exports.makeDirSync = (dir, options) => {
		checkPath(dir);
		return fs$20.mkdirSync(dir, {
			mode: getMode(options),
			recursive: true
		});
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/mkdirs/index.js": ((exports, module) => {
	const u$10 = require_universalify().fromPromise;
	const { makeDir: _makeDir, makeDirSync } = require_make_dir();
	const makeDir = u$10(_makeDir);
	module.exports = {
		mkdirs: makeDir,
		mkdirsSync: makeDirSync,
		mkdirp: makeDir,
		mkdirpSync: makeDirSync,
		ensureDir: makeDir,
		ensureDirSync: makeDirSync
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/path-exists/index.js": ((exports, module) => {
	const u$9 = require_universalify().fromPromise;
	const fs$19 = require_fs();
	function pathExists$6(path$19) {
		return fs$19.access(path$19).then(() => true).catch(() => false);
	}
	module.exports = {
		pathExists: u$9(pathExists$6),
		pathExistsSync: fs$19.existsSync
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/util/utimes.js": ((exports, module) => {
	const fs$18 = require_graceful_fs();
	function utimesMillis$1(path$19, atime, mtime, callback) {
		fs$18.open(path$19, "r+", (err, fd$1) => {
			if (err) return callback(err);
			fs$18.futimes(fd$1, atime, mtime, (futimesErr) => {
				fs$18.close(fd$1, (closeErr) => {
					if (callback) callback(futimesErr || closeErr);
				});
			});
		});
	}
	function utimesMillisSync$1(path$19, atime, mtime) {
		const fd$1 = fs$18.openSync(path$19, "r+");
		fs$18.futimesSync(fd$1, atime, mtime);
		return fs$18.closeSync(fd$1);
	}
	module.exports = {
		utimesMillis: utimesMillis$1,
		utimesMillisSync: utimesMillisSync$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/util/stat.js
var require_stat = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/util/stat.js": ((exports, module) => {
	const fs$17 = require_fs();
	const path$16 = __require("path");
	const util$3 = __require("util");
	function getStats$2(src$1, dest, opts) {
		const statFunc = opts.dereference ? (file) => fs$17.stat(file, { bigint: true }) : (file) => fs$17.lstat(file, { bigint: true });
		return Promise.all([statFunc(src$1), statFunc(dest).catch((err) => {
			if (err.code === "ENOENT") return null;
			throw err;
		})]).then(([srcStat, destStat]) => ({
			srcStat,
			destStat
		}));
	}
	function getStatsSync(src$1, dest, opts) {
		let destStat;
		const statFunc = opts.dereference ? (file) => fs$17.statSync(file, { bigint: true }) : (file) => fs$17.lstatSync(file, { bigint: true });
		const srcStat = statFunc(src$1);
		try {
			destStat = statFunc(dest);
		} catch (err) {
			if (err.code === "ENOENT") return {
				srcStat,
				destStat: null
			};
			throw err;
		}
		return {
			srcStat,
			destStat
		};
	}
	function checkPaths(src$1, dest, funcName, opts, cb) {
		util$3.callbackify(getStats$2)(src$1, dest, opts, (err, stats) => {
			if (err) return cb(err);
			const { srcStat, destStat } = stats;
			if (destStat) {
				if (areIdentical$2(srcStat, destStat)) {
					const srcBaseName = path$16.basename(src$1);
					const destBaseName = path$16.basename(dest);
					if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) return cb(null, {
						srcStat,
						destStat,
						isChangingCase: true
					});
					return cb(/* @__PURE__ */ new Error("Source and destination must not be the same."));
				}
				if (srcStat.isDirectory() && !destStat.isDirectory()) return cb(/* @__PURE__ */ new Error(`Cannot overwrite non-directory '${dest}' with directory '${src$1}'.`));
				if (!srcStat.isDirectory() && destStat.isDirectory()) return cb(/* @__PURE__ */ new Error(`Cannot overwrite directory '${dest}' with non-directory '${src$1}'.`));
			}
			if (srcStat.isDirectory() && isSrcSubdir(src$1, dest)) return cb(new Error(errMsg(src$1, dest, funcName)));
			return cb(null, {
				srcStat,
				destStat
			});
		});
	}
	function checkPathsSync(src$1, dest, funcName, opts) {
		const { srcStat, destStat } = getStatsSync(src$1, dest, opts);
		if (destStat) {
			if (areIdentical$2(srcStat, destStat)) {
				const srcBaseName = path$16.basename(src$1);
				const destBaseName = path$16.basename(dest);
				if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) return {
					srcStat,
					destStat,
					isChangingCase: true
				};
				throw new Error("Source and destination must not be the same.");
			}
			if (srcStat.isDirectory() && !destStat.isDirectory()) throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src$1}'.`);
			if (!srcStat.isDirectory() && destStat.isDirectory()) throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src$1}'.`);
		}
		if (srcStat.isDirectory() && isSrcSubdir(src$1, dest)) throw new Error(errMsg(src$1, dest, funcName));
		return {
			srcStat,
			destStat
		};
	}
	function checkParentPaths(src$1, srcStat, dest, funcName, cb) {
		const srcParent = path$16.resolve(path$16.dirname(src$1));
		const destParent = path$16.resolve(path$16.dirname(dest));
		if (destParent === srcParent || destParent === path$16.parse(destParent).root) return cb();
		fs$17.stat(destParent, { bigint: true }, (err, destStat) => {
			if (err) {
				if (err.code === "ENOENT") return cb();
				return cb(err);
			}
			if (areIdentical$2(srcStat, destStat)) return cb(new Error(errMsg(src$1, dest, funcName)));
			return checkParentPaths(src$1, srcStat, destParent, funcName, cb);
		});
	}
	function checkParentPathsSync(src$1, srcStat, dest, funcName) {
		const srcParent = path$16.resolve(path$16.dirname(src$1));
		const destParent = path$16.resolve(path$16.dirname(dest));
		if (destParent === srcParent || destParent === path$16.parse(destParent).root) return;
		let destStat;
		try {
			destStat = fs$17.statSync(destParent, { bigint: true });
		} catch (err) {
			if (err.code === "ENOENT") return;
			throw err;
		}
		if (areIdentical$2(srcStat, destStat)) throw new Error(errMsg(src$1, dest, funcName));
		return checkParentPathsSync(src$1, srcStat, destParent, funcName);
	}
	function areIdentical$2(srcStat, destStat) {
		return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
	}
	function isSrcSubdir(src$1, dest) {
		const srcArr = path$16.resolve(src$1).split(path$16.sep).filter((i$8) => i$8);
		const destArr = path$16.resolve(dest).split(path$16.sep).filter((i$8) => i$8);
		return srcArr.reduce((acc, cur, i$8) => acc && destArr[i$8] === cur, true);
	}
	function errMsg(src$1, dest, funcName) {
		return `Cannot ${funcName} '${src$1}' to a subdirectory of itself, '${dest}'.`;
	}
	module.exports = {
		checkPaths,
		checkPathsSync,
		checkParentPaths,
		checkParentPathsSync,
		isSrcSubdir,
		areIdentical: areIdentical$2
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/copy.js
var require_copy$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/copy.js": ((exports, module) => {
	const fs$16 = require_graceful_fs();
	const path$15 = __require("path");
	const mkdirs$1 = require_mkdirs().mkdirs;
	const pathExists$5 = require_path_exists().pathExists;
	const utimesMillis = require_utimes().utimesMillis;
	const stat$3 = require_stat();
	function copy$1(src$1, dest, opts, cb) {
		if (typeof opts === "function" && !cb) {
			cb = opts;
			opts = {};
		} else if (typeof opts === "function") opts = { filter: opts };
		cb = cb || function() {};
		opts = opts || {};
		opts.clobber = "clobber" in opts ? !!opts.clobber : true;
		opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
		if (opts.preserveTimestamps && process.arch === "ia32") process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0001");
		stat$3.checkPaths(src$1, dest, "copy", opts, (err, stats) => {
			if (err) return cb(err);
			const { srcStat, destStat } = stats;
			stat$3.checkParentPaths(src$1, srcStat, dest, "copy", (err$1) => {
				if (err$1) return cb(err$1);
				if (opts.filter) return handleFilter(checkParentDir, destStat, src$1, dest, opts, cb);
				return checkParentDir(destStat, src$1, dest, opts, cb);
			});
		});
	}
	function checkParentDir(destStat, src$1, dest, opts, cb) {
		const destParent = path$15.dirname(dest);
		pathExists$5(destParent, (err, dirExists) => {
			if (err) return cb(err);
			if (dirExists) return getStats$1(destStat, src$1, dest, opts, cb);
			mkdirs$1(destParent, (err$1) => {
				if (err$1) return cb(err$1);
				return getStats$1(destStat, src$1, dest, opts, cb);
			});
		});
	}
	function handleFilter(onInclude, destStat, src$1, dest, opts, cb) {
		Promise.resolve(opts.filter(src$1, dest)).then((include) => {
			if (include) return onInclude(destStat, src$1, dest, opts, cb);
			return cb();
		}, (error) => cb(error));
	}
	function startCopy$1(destStat, src$1, dest, opts, cb) {
		if (opts.filter) return handleFilter(getStats$1, destStat, src$1, dest, opts, cb);
		return getStats$1(destStat, src$1, dest, opts, cb);
	}
	function getStats$1(destStat, src$1, dest, opts, cb) {
		(opts.dereference ? fs$16.stat : fs$16.lstat)(src$1, (err, srcStat) => {
			if (err) return cb(err);
			if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src$1, dest, opts, cb);
			else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src$1, dest, opts, cb);
			else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src$1, dest, opts, cb);
			else if (srcStat.isSocket()) return cb(/* @__PURE__ */ new Error(`Cannot copy a socket file: ${src$1}`));
			else if (srcStat.isFIFO()) return cb(/* @__PURE__ */ new Error(`Cannot copy a FIFO pipe: ${src$1}`));
			return cb(/* @__PURE__ */ new Error(`Unknown file: ${src$1}`));
		});
	}
	function onFile$1(srcStat, destStat, src$1, dest, opts, cb) {
		if (!destStat) return copyFile$1(srcStat, src$1, dest, opts, cb);
		return mayCopyFile$1(srcStat, src$1, dest, opts, cb);
	}
	function mayCopyFile$1(srcStat, src$1, dest, opts, cb) {
		if (opts.overwrite) fs$16.unlink(dest, (err) => {
			if (err) return cb(err);
			return copyFile$1(srcStat, src$1, dest, opts, cb);
		});
		else if (opts.errorOnExist) return cb(/* @__PURE__ */ new Error(`'${dest}' already exists`));
		else return cb();
	}
	function copyFile$1(srcStat, src$1, dest, opts, cb) {
		fs$16.copyFile(src$1, dest, (err) => {
			if (err) return cb(err);
			if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src$1, dest, cb);
			return setDestMode$1(dest, srcStat.mode, cb);
		});
	}
	function handleTimestampsAndMode(srcMode, src$1, dest, cb) {
		if (fileIsNotWritable$1(srcMode)) return makeFileWritable$1(dest, srcMode, (err) => {
			if (err) return cb(err);
			return setDestTimestampsAndMode(srcMode, src$1, dest, cb);
		});
		return setDestTimestampsAndMode(srcMode, src$1, dest, cb);
	}
	function fileIsNotWritable$1(srcMode) {
		return (srcMode & 128) === 0;
	}
	function makeFileWritable$1(dest, srcMode, cb) {
		return setDestMode$1(dest, srcMode | 128, cb);
	}
	function setDestTimestampsAndMode(srcMode, src$1, dest, cb) {
		setDestTimestamps$1(src$1, dest, (err) => {
			if (err) return cb(err);
			return setDestMode$1(dest, srcMode, cb);
		});
	}
	function setDestMode$1(dest, srcMode, cb) {
		return fs$16.chmod(dest, srcMode, cb);
	}
	function setDestTimestamps$1(src$1, dest, cb) {
		fs$16.stat(src$1, (err, updatedSrcStat) => {
			if (err) return cb(err);
			return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
		});
	}
	function onDir$1(srcStat, destStat, src$1, dest, opts, cb) {
		if (!destStat) return mkDirAndCopy$1(srcStat.mode, src$1, dest, opts, cb);
		return copyDir$1(src$1, dest, opts, cb);
	}
	function mkDirAndCopy$1(srcMode, src$1, dest, opts, cb) {
		fs$16.mkdir(dest, (err) => {
			if (err) return cb(err);
			copyDir$1(src$1, dest, opts, (err$1) => {
				if (err$1) return cb(err$1);
				return setDestMode$1(dest, srcMode, cb);
			});
		});
	}
	function copyDir$1(src$1, dest, opts, cb) {
		fs$16.readdir(src$1, (err, items) => {
			if (err) return cb(err);
			return copyDirItems(items, src$1, dest, opts, cb);
		});
	}
	function copyDirItems(items, src$1, dest, opts, cb) {
		const item = items.pop();
		if (!item) return cb();
		return copyDirItem$1(items, item, src$1, dest, opts, cb);
	}
	function copyDirItem$1(items, item, src$1, dest, opts, cb) {
		const srcItem = path$15.join(src$1, item);
		const destItem = path$15.join(dest, item);
		stat$3.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
			if (err) return cb(err);
			const { destStat } = stats;
			startCopy$1(destStat, srcItem, destItem, opts, (err$1) => {
				if (err$1) return cb(err$1);
				return copyDirItems(items, src$1, dest, opts, cb);
			});
		});
	}
	function onLink$1(destStat, src$1, dest, opts, cb) {
		fs$16.readlink(src$1, (err, resolvedSrc) => {
			if (err) return cb(err);
			if (opts.dereference) resolvedSrc = path$15.resolve(process.cwd(), resolvedSrc);
			if (!destStat) return fs$16.symlink(resolvedSrc, dest, cb);
			else fs$16.readlink(dest, (err$1, resolvedDest) => {
				if (err$1) {
					if (err$1.code === "EINVAL" || err$1.code === "UNKNOWN") return fs$16.symlink(resolvedSrc, dest, cb);
					return cb(err$1);
				}
				if (opts.dereference) resolvedDest = path$15.resolve(process.cwd(), resolvedDest);
				if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) return cb(/* @__PURE__ */ new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
				if (destStat.isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) return cb(/* @__PURE__ */ new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
				return copyLink$1(resolvedSrc, dest, cb);
			});
		});
	}
	function copyLink$1(resolvedSrc, dest, cb) {
		fs$16.unlink(dest, (err) => {
			if (err) return cb(err);
			return fs$16.symlink(resolvedSrc, dest, cb);
		});
	}
	module.exports = copy$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/copy-sync.js": ((exports, module) => {
	const fs$15 = require_graceful_fs();
	const path$14 = __require("path");
	const mkdirsSync$1 = require_mkdirs().mkdirsSync;
	const utimesMillisSync = require_utimes().utimesMillisSync;
	const stat$2 = require_stat();
	function copySync$1(src$1, dest, opts) {
		if (typeof opts === "function") opts = { filter: opts };
		opts = opts || {};
		opts.clobber = "clobber" in opts ? !!opts.clobber : true;
		opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
		if (opts.preserveTimestamps && process.arch === "ia32") process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0002");
		const { srcStat, destStat } = stat$2.checkPathsSync(src$1, dest, "copy", opts);
		stat$2.checkParentPathsSync(src$1, srcStat, dest, "copy");
		return handleFilterAndCopy(destStat, src$1, dest, opts);
	}
	function handleFilterAndCopy(destStat, src$1, dest, opts) {
		if (opts.filter && !opts.filter(src$1, dest)) return;
		const destParent = path$14.dirname(dest);
		if (!fs$15.existsSync(destParent)) mkdirsSync$1(destParent);
		return getStats(destStat, src$1, dest, opts);
	}
	function startCopy(destStat, src$1, dest, opts) {
		if (opts.filter && !opts.filter(src$1, dest)) return;
		return getStats(destStat, src$1, dest, opts);
	}
	function getStats(destStat, src$1, dest, opts) {
		const srcStat = (opts.dereference ? fs$15.statSync : fs$15.lstatSync)(src$1);
		if (srcStat.isDirectory()) return onDir(srcStat, destStat, src$1, dest, opts);
		else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src$1, dest, opts);
		else if (srcStat.isSymbolicLink()) return onLink(destStat, src$1, dest, opts);
		else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src$1}`);
		else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src$1}`);
		throw new Error(`Unknown file: ${src$1}`);
	}
	function onFile(srcStat, destStat, src$1, dest, opts) {
		if (!destStat) return copyFile(srcStat, src$1, dest, opts);
		return mayCopyFile(srcStat, src$1, dest, opts);
	}
	function mayCopyFile(srcStat, src$1, dest, opts) {
		if (opts.overwrite) {
			fs$15.unlinkSync(dest);
			return copyFile(srcStat, src$1, dest, opts);
		} else if (opts.errorOnExist) throw new Error(`'${dest}' already exists`);
	}
	function copyFile(srcStat, src$1, dest, opts) {
		fs$15.copyFileSync(src$1, dest);
		if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src$1, dest);
		return setDestMode(dest, srcStat.mode);
	}
	function handleTimestamps(srcMode, src$1, dest) {
		if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
		return setDestTimestamps(src$1, dest);
	}
	function fileIsNotWritable(srcMode) {
		return (srcMode & 128) === 0;
	}
	function makeFileWritable(dest, srcMode) {
		return setDestMode(dest, srcMode | 128);
	}
	function setDestMode(dest, srcMode) {
		return fs$15.chmodSync(dest, srcMode);
	}
	function setDestTimestamps(src$1, dest) {
		const updatedSrcStat = fs$15.statSync(src$1);
		return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
	}
	function onDir(srcStat, destStat, src$1, dest, opts) {
		if (!destStat) return mkDirAndCopy(srcStat.mode, src$1, dest, opts);
		return copyDir(src$1, dest, opts);
	}
	function mkDirAndCopy(srcMode, src$1, dest, opts) {
		fs$15.mkdirSync(dest);
		copyDir(src$1, dest, opts);
		return setDestMode(dest, srcMode);
	}
	function copyDir(src$1, dest, opts) {
		fs$15.readdirSync(src$1).forEach((item) => copyDirItem(item, src$1, dest, opts));
	}
	function copyDirItem(item, src$1, dest, opts) {
		const srcItem = path$14.join(src$1, item);
		const destItem = path$14.join(dest, item);
		const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts);
		return startCopy(destStat, srcItem, destItem, opts);
	}
	function onLink(destStat, src$1, dest, opts) {
		let resolvedSrc = fs$15.readlinkSync(src$1);
		if (opts.dereference) resolvedSrc = path$14.resolve(process.cwd(), resolvedSrc);
		if (!destStat) return fs$15.symlinkSync(resolvedSrc, dest);
		else {
			let resolvedDest;
			try {
				resolvedDest = fs$15.readlinkSync(dest);
			} catch (err) {
				if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs$15.symlinkSync(resolvedSrc, dest);
				throw err;
			}
			if (opts.dereference) resolvedDest = path$14.resolve(process.cwd(), resolvedDest);
			if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
			if (fs$15.statSync(dest).isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
			return copyLink(resolvedSrc, dest);
		}
	}
	function copyLink(resolvedSrc, dest) {
		fs$15.unlinkSync(dest);
		return fs$15.symlinkSync(resolvedSrc, dest);
	}
	module.exports = copySync$1;
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/index.js
var require_copy = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/copy/index.js": ((exports, module) => {
	const u$8 = require_universalify().fromCallback;
	module.exports = {
		copy: u$8(require_copy$1()),
		copySync: require_copy_sync()
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/remove/rimraf.js": ((exports, module) => {
	const fs$14 = require_graceful_fs();
	const path$13 = __require("path");
	const assert = __require("assert");
	const isWindows = process.platform === "win32";
	function defaults$2(options) {
		[
			"unlink",
			"chmod",
			"stat",
			"lstat",
			"rmdir",
			"readdir"
		].forEach((m$3) => {
			options[m$3] = options[m$3] || fs$14[m$3];
			m$3 = m$3 + "Sync";
			options[m$3] = options[m$3] || fs$14[m$3];
		});
		options.maxBusyTries = options.maxBusyTries || 3;
	}
	function rimraf$1(p, options, cb) {
		let busyTries = 0;
		if (typeof options === "function") {
			cb = options;
			options = {};
		}
		assert(p, "rimraf: missing path");
		assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
		assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
		assert(options, "rimraf: invalid options argument provided");
		assert.strictEqual(typeof options, "object", "rimraf: options should be object");
		defaults$2(options);
		rimraf_(p, options, function CB(er) {
			if (er) {
				if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
					busyTries++;
					const time = busyTries * 100;
					return setTimeout(() => rimraf_(p, options, CB), time);
				}
				if (er.code === "ENOENT") er = null;
			}
			cb(er);
		});
	}
	function rimraf_(p, options, cb) {
		assert(p);
		assert(options);
		assert(typeof cb === "function");
		options.lstat(p, (er, st) => {
			if (er && er.code === "ENOENT") return cb(null);
			if (er && er.code === "EPERM" && isWindows) return fixWinEPERM(p, options, er, cb);
			if (st && st.isDirectory()) return rmdir(p, options, er, cb);
			options.unlink(p, (er$1) => {
				if (er$1) {
					if (er$1.code === "ENOENT") return cb(null);
					if (er$1.code === "EPERM") return isWindows ? fixWinEPERM(p, options, er$1, cb) : rmdir(p, options, er$1, cb);
					if (er$1.code === "EISDIR") return rmdir(p, options, er$1, cb);
				}
				return cb(er$1);
			});
		});
	}
	function fixWinEPERM(p, options, er, cb) {
		assert(p);
		assert(options);
		assert(typeof cb === "function");
		options.chmod(p, 438, (er2) => {
			if (er2) cb(er2.code === "ENOENT" ? null : er);
			else options.stat(p, (er3, stats) => {
				if (er3) cb(er3.code === "ENOENT" ? null : er);
				else if (stats.isDirectory()) rmdir(p, options, er, cb);
				else options.unlink(p, cb);
			});
		});
	}
	function fixWinEPERMSync(p, options, er) {
		let stats;
		assert(p);
		assert(options);
		try {
			options.chmodSync(p, 438);
		} catch (er2) {
			if (er2.code === "ENOENT") return;
			else throw er;
		}
		try {
			stats = options.statSync(p);
		} catch (er3) {
			if (er3.code === "ENOENT") return;
			else throw er;
		}
		if (stats.isDirectory()) rmdirSync(p, options, er);
		else options.unlinkSync(p);
	}
	function rmdir(p, options, originalEr, cb) {
		assert(p);
		assert(options);
		assert(typeof cb === "function");
		options.rmdir(p, (er) => {
			if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) rmkids(p, options, cb);
			else if (er && er.code === "ENOTDIR") cb(originalEr);
			else cb(er);
		});
	}
	function rmkids(p, options, cb) {
		assert(p);
		assert(options);
		assert(typeof cb === "function");
		options.readdir(p, (er, files) => {
			if (er) return cb(er);
			let n = files.length;
			let errState;
			if (n === 0) return options.rmdir(p, cb);
			files.forEach((f) => {
				rimraf$1(path$13.join(p, f), options, (er$1) => {
					if (errState) return;
					if (er$1) return cb(errState = er$1);
					if (--n === 0) options.rmdir(p, cb);
				});
			});
		});
	}
	function rimrafSync(p, options) {
		let st;
		options = options || {};
		defaults$2(options);
		assert(p, "rimraf: missing path");
		assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
		assert(options, "rimraf: missing options");
		assert.strictEqual(typeof options, "object", "rimraf: options should be object");
		try {
			st = options.lstatSync(p);
		} catch (er) {
			if (er.code === "ENOENT") return;
			if (er.code === "EPERM" && isWindows) fixWinEPERMSync(p, options, er);
		}
		try {
			if (st && st.isDirectory()) rmdirSync(p, options, null);
			else options.unlinkSync(p);
		} catch (er) {
			if (er.code === "ENOENT") return;
			else if (er.code === "EPERM") return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
			else if (er.code !== "EISDIR") throw er;
			rmdirSync(p, options, er);
		}
	}
	function rmdirSync(p, options, originalEr) {
		assert(p);
		assert(options);
		try {
			options.rmdirSync(p);
		} catch (er) {
			if (er.code === "ENOTDIR") throw originalEr;
			else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") rmkidsSync(p, options);
			else if (er.code !== "ENOENT") throw er;
		}
	}
	function rmkidsSync(p, options) {
		assert(p);
		assert(options);
		options.readdirSync(p).forEach((f) => rimrafSync(path$13.join(p, f), options));
		if (isWindows) {
			const startTime = Date.now();
			do
				try {
					return options.rmdirSync(p, options);
				} catch {}
			while (Date.now() - startTime < 500);
		} else return options.rmdirSync(p, options);
	}
	module.exports = rimraf$1;
	rimraf$1.sync = rimrafSync;
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/remove/index.js
var require_remove = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/remove/index.js": ((exports, module) => {
	const fs$13 = require_graceful_fs();
	const u$7 = require_universalify().fromCallback;
	const rimraf = require_rimraf();
	function remove$2(path$19, callback) {
		if (fs$13.rm) return fs$13.rm(path$19, {
			recursive: true,
			force: true
		}, callback);
		rimraf(path$19, callback);
	}
	function removeSync$1(path$19) {
		if (fs$13.rmSync) return fs$13.rmSync(path$19, {
			recursive: true,
			force: true
		});
		rimraf.sync(path$19);
	}
	module.exports = {
		remove: u$7(remove$2),
		removeSync: removeSync$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/empty/index.js
var require_empty = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/empty/index.js": ((exports, module) => {
	const u$6 = require_universalify().fromPromise;
	const fs$12 = require_fs();
	const path$12 = __require("path");
	const mkdir$3 = require_mkdirs();
	const remove$1 = require_remove();
	const emptyDir = u$6(async function emptyDir$1(dir) {
		let items;
		try {
			items = await fs$12.readdir(dir);
		} catch {
			return mkdir$3.mkdirs(dir);
		}
		return Promise.all(items.map((item) => remove$1.remove(path$12.join(dir, item))));
	});
	function emptyDirSync(dir) {
		let items;
		try {
			items = fs$12.readdirSync(dir);
		} catch {
			return mkdir$3.mkdirsSync(dir);
		}
		items.forEach((item) => {
			item = path$12.join(dir, item);
			remove$1.removeSync(item);
		});
	}
	module.exports = {
		emptyDirSync,
		emptydirSync: emptyDirSync,
		emptyDir,
		emptydir: emptyDir
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/file.js
var require_file = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/file.js": ((exports, module) => {
	const u$5 = require_universalify().fromCallback;
	const path$11 = __require("path");
	const fs$11 = require_graceful_fs();
	const mkdir$2 = require_mkdirs();
	function createFile$1(file, callback) {
		function makeFile() {
			fs$11.writeFile(file, "", (err) => {
				if (err) return callback(err);
				callback();
			});
		}
		fs$11.stat(file, (err, stats) => {
			if (!err && stats.isFile()) return callback();
			const dir = path$11.dirname(file);
			fs$11.stat(dir, (err$1, stats$1) => {
				if (err$1) {
					if (err$1.code === "ENOENT") return mkdir$2.mkdirs(dir, (err$2) => {
						if (err$2) return callback(err$2);
						makeFile();
					});
					return callback(err$1);
				}
				if (stats$1.isDirectory()) makeFile();
				else fs$11.readdir(dir, (err$2) => {
					if (err$2) return callback(err$2);
				});
			});
		});
	}
	function createFileSync$1(file) {
		let stats;
		try {
			stats = fs$11.statSync(file);
		} catch {}
		if (stats && stats.isFile()) return;
		const dir = path$11.dirname(file);
		try {
			if (!fs$11.statSync(dir).isDirectory()) fs$11.readdirSync(dir);
		} catch (err) {
			if (err && err.code === "ENOENT") mkdir$2.mkdirsSync(dir);
			else throw err;
		}
		fs$11.writeFileSync(file, "");
	}
	module.exports = {
		createFile: u$5(createFile$1),
		createFileSync: createFileSync$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/link.js
var require_link = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/link.js": ((exports, module) => {
	const u$4 = require_universalify().fromCallback;
	const path$10 = __require("path");
	const fs$10 = require_graceful_fs();
	const mkdir$1 = require_mkdirs();
	const pathExists$4 = require_path_exists().pathExists;
	const { areIdentical: areIdentical$1 } = require_stat();
	function createLink$1(srcpath, dstpath, callback) {
		function makeLink(srcpath$1, dstpath$1) {
			fs$10.link(srcpath$1, dstpath$1, (err) => {
				if (err) return callback(err);
				callback(null);
			});
		}
		fs$10.lstat(dstpath, (_, dstStat) => {
			fs$10.lstat(srcpath, (err, srcStat) => {
				if (err) {
					err.message = err.message.replace("lstat", "ensureLink");
					return callback(err);
				}
				if (dstStat && areIdentical$1(srcStat, dstStat)) return callback(null);
				const dir = path$10.dirname(dstpath);
				pathExists$4(dir, (err$1, dirExists) => {
					if (err$1) return callback(err$1);
					if (dirExists) return makeLink(srcpath, dstpath);
					mkdir$1.mkdirs(dir, (err$2) => {
						if (err$2) return callback(err$2);
						makeLink(srcpath, dstpath);
					});
				});
			});
		});
	}
	function createLinkSync$1(srcpath, dstpath) {
		let dstStat;
		try {
			dstStat = fs$10.lstatSync(dstpath);
		} catch {}
		try {
			const srcStat = fs$10.lstatSync(srcpath);
			if (dstStat && areIdentical$1(srcStat, dstStat)) return;
		} catch (err) {
			err.message = err.message.replace("lstat", "ensureLink");
			throw err;
		}
		const dir = path$10.dirname(dstpath);
		if (fs$10.existsSync(dir)) return fs$10.linkSync(srcpath, dstpath);
		mkdir$1.mkdirsSync(dir);
		return fs$10.linkSync(srcpath, dstpath);
	}
	module.exports = {
		createLink: u$4(createLink$1),
		createLinkSync: createLinkSync$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink-paths.js": ((exports, module) => {
	const path$9 = __require("path");
	const fs$9 = require_graceful_fs();
	const pathExists$3 = require_path_exists().pathExists;
	/**
	* Function that returns two types of paths, one relative to symlink, and one
	* relative to the current working directory. Checks if path is absolute or
	* relative. If the path is relative, this function checks if the path is
	* relative to symlink or relative to current working directory. This is an
	* initiative to find a smarter `srcpath` to supply when building symlinks.
	* This allows you to determine which path to use out of one of three possible
	* types of source paths. The first is an absolute path. This is detected by
	* `path.isAbsolute()`. When an absolute path is provided, it is checked to
	* see if it exists. If it does it's used, if not an error is returned
	* (callback)/ thrown (sync). The other two options for `srcpath` are a
	* relative url. By default Node's `fs.symlink` works by creating a symlink
	* using `dstpath` and expects the `srcpath` to be relative to the newly
	* created symlink. If you provide a `srcpath` that does not exist on the file
	* system it results in a broken symlink. To minimize this, the function
	* checks to see if the 'relative to symlink' source file exists, and if it
	* does it will use it. If it does not, it checks if there's a file that
	* exists that is relative to the current working directory, if does its used.
	* This preserves the expectations of the original fs.symlink spec and adds
	* the ability to pass in `relative to current working direcotry` paths.
	*/
	function symlinkPaths$1(srcpath, dstpath, callback) {
		if (path$9.isAbsolute(srcpath)) return fs$9.lstat(srcpath, (err) => {
			if (err) {
				err.message = err.message.replace("lstat", "ensureSymlink");
				return callback(err);
			}
			return callback(null, {
				toCwd: srcpath,
				toDst: srcpath
			});
		});
		else {
			const dstdir = path$9.dirname(dstpath);
			const relativeToDst = path$9.join(dstdir, srcpath);
			return pathExists$3(relativeToDst, (err, exists) => {
				if (err) return callback(err);
				if (exists) return callback(null, {
					toCwd: relativeToDst,
					toDst: srcpath
				});
				else return fs$9.lstat(srcpath, (err$1) => {
					if (err$1) {
						err$1.message = err$1.message.replace("lstat", "ensureSymlink");
						return callback(err$1);
					}
					return callback(null, {
						toCwd: srcpath,
						toDst: path$9.relative(dstdir, srcpath)
					});
				});
			});
		}
	}
	function symlinkPathsSync$1(srcpath, dstpath) {
		let exists;
		if (path$9.isAbsolute(srcpath)) {
			exists = fs$9.existsSync(srcpath);
			if (!exists) throw new Error("absolute srcpath does not exist");
			return {
				toCwd: srcpath,
				toDst: srcpath
			};
		} else {
			const dstdir = path$9.dirname(dstpath);
			const relativeToDst = path$9.join(dstdir, srcpath);
			exists = fs$9.existsSync(relativeToDst);
			if (exists) return {
				toCwd: relativeToDst,
				toDst: srcpath
			};
			else {
				exists = fs$9.existsSync(srcpath);
				if (!exists) throw new Error("relative srcpath does not exist");
				return {
					toCwd: srcpath,
					toDst: path$9.relative(dstdir, srcpath)
				};
			}
		}
	}
	module.exports = {
		symlinkPaths: symlinkPaths$1,
		symlinkPathsSync: symlinkPathsSync$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink-type.js": ((exports, module) => {
	const fs$8 = require_graceful_fs();
	function symlinkType$1(srcpath, type, callback) {
		callback = typeof type === "function" ? type : callback;
		type = typeof type === "function" ? false : type;
		if (type) return callback(null, type);
		fs$8.lstat(srcpath, (err, stats) => {
			if (err) return callback(null, "file");
			type = stats && stats.isDirectory() ? "dir" : "file";
			callback(null, type);
		});
	}
	function symlinkTypeSync$1(srcpath, type) {
		let stats;
		if (type) return type;
		try {
			stats = fs$8.lstatSync(srcpath);
		} catch {
			return "file";
		}
		return stats && stats.isDirectory() ? "dir" : "file";
	}
	module.exports = {
		symlinkType: symlinkType$1,
		symlinkTypeSync: symlinkTypeSync$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/symlink.js": ((exports, module) => {
	const u$3 = require_universalify().fromCallback;
	const path$8 = __require("path");
	const fs$7 = require_fs();
	const _mkdirs = require_mkdirs();
	const mkdirs = _mkdirs.mkdirs;
	const mkdirsSync = _mkdirs.mkdirsSync;
	const _symlinkPaths = require_symlink_paths();
	const symlinkPaths = _symlinkPaths.symlinkPaths;
	const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
	const _symlinkType = require_symlink_type();
	const symlinkType = _symlinkType.symlinkType;
	const symlinkTypeSync = _symlinkType.symlinkTypeSync;
	const pathExists$2 = require_path_exists().pathExists;
	const { areIdentical } = require_stat();
	function createSymlink$1(srcpath, dstpath, type, callback) {
		callback = typeof type === "function" ? type : callback;
		type = typeof type === "function" ? false : type;
		fs$7.lstat(dstpath, (err, stats) => {
			if (!err && stats.isSymbolicLink()) Promise.all([fs$7.stat(srcpath), fs$7.stat(dstpath)]).then(([srcStat, dstStat]) => {
				if (areIdentical(srcStat, dstStat)) return callback(null);
				_createSymlink(srcpath, dstpath, type, callback);
			});
			else _createSymlink(srcpath, dstpath, type, callback);
		});
	}
	function _createSymlink(srcpath, dstpath, type, callback) {
		symlinkPaths(srcpath, dstpath, (err, relative$1) => {
			if (err) return callback(err);
			srcpath = relative$1.toDst;
			symlinkType(relative$1.toCwd, type, (err$1, type$1) => {
				if (err$1) return callback(err$1);
				const dir = path$8.dirname(dstpath);
				pathExists$2(dir, (err$2, dirExists) => {
					if (err$2) return callback(err$2);
					if (dirExists) return fs$7.symlink(srcpath, dstpath, type$1, callback);
					mkdirs(dir, (err$3) => {
						if (err$3) return callback(err$3);
						fs$7.symlink(srcpath, dstpath, type$1, callback);
					});
				});
			});
		});
	}
	function createSymlinkSync$1(srcpath, dstpath, type) {
		let stats;
		try {
			stats = fs$7.lstatSync(dstpath);
		} catch {}
		if (stats && stats.isSymbolicLink()) {
			if (areIdentical(fs$7.statSync(srcpath), fs$7.statSync(dstpath))) return;
		}
		const relative$1 = symlinkPathsSync(srcpath, dstpath);
		srcpath = relative$1.toDst;
		type = symlinkTypeSync(relative$1.toCwd, type);
		const dir = path$8.dirname(dstpath);
		if (fs$7.existsSync(dir)) return fs$7.symlinkSync(srcpath, dstpath, type);
		mkdirsSync(dir);
		return fs$7.symlinkSync(srcpath, dstpath, type);
	}
	module.exports = {
		createSymlink: u$3(createSymlink$1),
		createSymlinkSync: createSymlinkSync$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/ensure/index.js": ((exports, module) => {
	const { createFile, createFileSync } = require_file();
	const { createLink, createLinkSync } = require_link();
	const { createSymlink, createSymlinkSync } = require_symlink();
	module.exports = {
		createFile,
		createFileSync,
		ensureFile: createFile,
		ensureFileSync: createFileSync,
		createLink,
		createLinkSync,
		ensureLink: createLink,
		ensureLinkSync: createLinkSync,
		createSymlink,
		createSymlinkSync,
		ensureSymlink: createSymlink,
		ensureSymlinkSync: createSymlinkSync
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/jsonfile@6.2.0/node_modules/jsonfile/utils.js
var require_utils$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/jsonfile@6.2.0/node_modules/jsonfile/utils.js": ((exports, module) => {
	function stringify$7(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
		const EOF = finalEOL ? EOL : "";
		return JSON.stringify(obj, replacer, spaces).replace(/\n/g, EOL) + EOF;
	}
	function stripBom$1(content) {
		if (Buffer.isBuffer(content)) content = content.toString("utf8");
		return content.replace(/^\uFEFF/, "");
	}
	module.exports = {
		stringify: stringify$7,
		stripBom: stripBom$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/jsonfile@6.2.0/node_modules/jsonfile/index.js
var require_jsonfile$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/jsonfile@6.2.0/node_modules/jsonfile/index.js": ((exports, module) => {
	let _fs;
	try {
		_fs = require_graceful_fs();
	} catch (_) {
		_fs = __require("fs");
	}
	const universalify = require_universalify();
	const { stringify: stringify$6, stripBom } = require_utils$2();
	async function _readFile(file, options = {}) {
		if (typeof options === "string") options = { encoding: options };
		const fs$26 = options.fs || _fs;
		const shouldThrow = "throws" in options ? options.throws : true;
		let data = await universalify.fromCallback(fs$26.readFile)(file, options);
		data = stripBom(data);
		let obj;
		try {
			obj = JSON.parse(data, options ? options.reviver : null);
		} catch (err) {
			if (shouldThrow) {
				err.message = `${file}: ${err.message}`;
				throw err;
			} else return null;
		}
		return obj;
	}
	const readFile$1 = universalify.fromPromise(_readFile);
	function readFileSync(file, options = {}) {
		if (typeof options === "string") options = { encoding: options };
		const fs$26 = options.fs || _fs;
		const shouldThrow = "throws" in options ? options.throws : true;
		try {
			let content = fs$26.readFileSync(file, options);
			content = stripBom(content);
			return JSON.parse(content, options.reviver);
		} catch (err) {
			if (shouldThrow) {
				err.message = `${file}: ${err.message}`;
				throw err;
			} else return null;
		}
	}
	async function _writeFile(file, obj, options = {}) {
		const fs$26 = options.fs || _fs;
		const str = stringify$6(obj, options);
		await universalify.fromCallback(fs$26.writeFile)(file, str, options);
	}
	const writeFile$1 = universalify.fromPromise(_writeFile);
	function writeFileSync(file, obj, options = {}) {
		const fs$26 = options.fs || _fs;
		const str = stringify$6(obj, options);
		return fs$26.writeFileSync(file, str, options);
	}
	module.exports = {
		readFile: readFile$1,
		readFileSync,
		writeFile: writeFile$1,
		writeFileSync
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/jsonfile.js": ((exports, module) => {
	const jsonFile$1 = require_jsonfile$1();
	module.exports = {
		readJson: jsonFile$1.readFile,
		readJsonSync: jsonFile$1.readFileSync,
		writeJson: jsonFile$1.writeFile,
		writeJsonSync: jsonFile$1.writeFileSync
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/output-file/index.js": ((exports, module) => {
	const u$2 = require_universalify().fromCallback;
	const fs$6 = require_graceful_fs();
	const path$7 = __require("path");
	const mkdir = require_mkdirs();
	const pathExists$1 = require_path_exists().pathExists;
	function outputFile$1(file, data, encoding, callback) {
		if (typeof encoding === "function") {
			callback = encoding;
			encoding = "utf8";
		}
		const dir = path$7.dirname(file);
		pathExists$1(dir, (err, itDoes) => {
			if (err) return callback(err);
			if (itDoes) return fs$6.writeFile(file, data, encoding, callback);
			mkdir.mkdirs(dir, (err$1) => {
				if (err$1) return callback(err$1);
				fs$6.writeFile(file, data, encoding, callback);
			});
		});
	}
	function outputFileSync$1(file, ...args) {
		const dir = path$7.dirname(file);
		if (fs$6.existsSync(dir)) return fs$6.writeFileSync(file, ...args);
		mkdir.mkdirsSync(dir);
		fs$6.writeFileSync(file, ...args);
	}
	module.exports = {
		outputFile: u$2(outputFile$1),
		outputFileSync: outputFileSync$1
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/output-json.js": ((exports, module) => {
	const { stringify: stringify$5 } = require_utils$2();
	const { outputFile } = require_output_file();
	async function outputJson(file, data, options = {}) {
		await outputFile(file, stringify$5(data, options), options);
	}
	module.exports = outputJson;
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/output-json-sync.js": ((exports, module) => {
	const { stringify: stringify$4 } = require_utils$2();
	const { outputFileSync } = require_output_file();
	function outputJsonSync(file, data, options) {
		outputFileSync(file, stringify$4(data, options), options);
	}
	module.exports = outputJsonSync;
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/index.js
var require_json$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/json/index.js": ((exports, module) => {
	const u$1 = require_universalify().fromPromise;
	const jsonFile = require_jsonfile();
	jsonFile.outputJson = u$1(require_output_json());
	jsonFile.outputJsonSync = require_output_json_sync();
	jsonFile.outputJSON = jsonFile.outputJson;
	jsonFile.outputJSONSync = jsonFile.outputJsonSync;
	jsonFile.writeJSON = jsonFile.writeJson;
	jsonFile.writeJSONSync = jsonFile.writeJsonSync;
	jsonFile.readJSON = jsonFile.readJson;
	jsonFile.readJSONSync = jsonFile.readJsonSync;
	module.exports = jsonFile;
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/move.js
var require_move$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/move.js": ((exports, module) => {
	const fs$5 = require_graceful_fs();
	const path$6 = __require("path");
	const copy = require_copy().copy;
	const remove = require_remove().remove;
	const mkdirp = require_mkdirs().mkdirp;
	const pathExists = require_path_exists().pathExists;
	const stat$1 = require_stat();
	function move(src$1, dest, opts, cb) {
		if (typeof opts === "function") {
			cb = opts;
			opts = {};
		}
		opts = opts || {};
		const overwrite = opts.overwrite || opts.clobber || false;
		stat$1.checkPaths(src$1, dest, "move", opts, (err, stats) => {
			if (err) return cb(err);
			const { srcStat, isChangingCase = false } = stats;
			stat$1.checkParentPaths(src$1, srcStat, dest, "move", (err$1) => {
				if (err$1) return cb(err$1);
				if (isParentRoot$1(dest)) return doRename$1(src$1, dest, overwrite, isChangingCase, cb);
				mkdirp(path$6.dirname(dest), (err$2) => {
					if (err$2) return cb(err$2);
					return doRename$1(src$1, dest, overwrite, isChangingCase, cb);
				});
			});
		});
	}
	function isParentRoot$1(dest) {
		const parent = path$6.dirname(dest);
		return path$6.parse(parent).root === parent;
	}
	function doRename$1(src$1, dest, overwrite, isChangingCase, cb) {
		if (isChangingCase) return rename$1(src$1, dest, overwrite, cb);
		if (overwrite) return remove(dest, (err) => {
			if (err) return cb(err);
			return rename$1(src$1, dest, overwrite, cb);
		});
		pathExists(dest, (err, destExists) => {
			if (err) return cb(err);
			if (destExists) return cb(/* @__PURE__ */ new Error("dest already exists."));
			return rename$1(src$1, dest, overwrite, cb);
		});
	}
	function rename$1(src$1, dest, overwrite, cb) {
		fs$5.rename(src$1, dest, (err) => {
			if (!err) return cb();
			if (err.code !== "EXDEV") return cb(err);
			return moveAcrossDevice$1(src$1, dest, overwrite, cb);
		});
	}
	function moveAcrossDevice$1(src$1, dest, overwrite, cb) {
		copy(src$1, dest, {
			overwrite,
			errorOnExist: true
		}, (err) => {
			if (err) return cb(err);
			return remove(src$1, cb);
		});
	}
	module.exports = move;
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/move-sync.js": ((exports, module) => {
	const fs$4 = require_graceful_fs();
	const path$5 = __require("path");
	const copySync = require_copy().copySync;
	const removeSync = require_remove().removeSync;
	const mkdirpSync = require_mkdirs().mkdirpSync;
	const stat = require_stat();
	function moveSync(src$1, dest, opts) {
		opts = opts || {};
		const overwrite = opts.overwrite || opts.clobber || false;
		const { srcStat, isChangingCase = false } = stat.checkPathsSync(src$1, dest, "move", opts);
		stat.checkParentPathsSync(src$1, srcStat, dest, "move");
		if (!isParentRoot(dest)) mkdirpSync(path$5.dirname(dest));
		return doRename(src$1, dest, overwrite, isChangingCase);
	}
	function isParentRoot(dest) {
		const parent = path$5.dirname(dest);
		return path$5.parse(parent).root === parent;
	}
	function doRename(src$1, dest, overwrite, isChangingCase) {
		if (isChangingCase) return rename(src$1, dest, overwrite);
		if (overwrite) {
			removeSync(dest);
			return rename(src$1, dest, overwrite);
		}
		if (fs$4.existsSync(dest)) throw new Error("dest already exists.");
		return rename(src$1, dest, overwrite);
	}
	function rename(src$1, dest, overwrite) {
		try {
			fs$4.renameSync(src$1, dest);
		} catch (err) {
			if (err.code !== "EXDEV") throw err;
			return moveAcrossDevice(src$1, dest, overwrite);
		}
	}
	function moveAcrossDevice(src$1, dest, overwrite) {
		copySync(src$1, dest, {
			overwrite,
			errorOnExist: true
		});
		return removeSync(src$1);
	}
	module.exports = moveSync;
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/index.js
var require_move = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/move/index.js": ((exports, module) => {
	const u = require_universalify().fromCallback;
	module.exports = {
		move: u(require_move$1()),
		moveSync: require_move_sync()
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/index.js
var require_lib$4 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fs-extra@10.1.0/node_modules/fs-extra/lib/index.js": ((exports, module) => {
	module.exports = {
		...require_fs(),
		...require_copy(),
		...require_empty(),
		...require_ensure(),
		...require_json$1(),
		...require_mkdirs(),
		...require_move(),
		...require_output_file(),
		...require_path_exists(),
		...require_remove()
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js
var require_object_assign = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js": ((exports, module) => {
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	function toObject(val) {
		if (val === null || val === void 0) throw new TypeError("Object.assign cannot be called with null or undefined");
		return Object(val);
	}
	function shouldUseNative() {
		try {
			if (!Object.assign) return false;
			var test1 = /* @__PURE__ */ new String("abc");
			test1[5] = "de";
			if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
			var test2 = {};
			for (var i$8 = 0; i$8 < 10; i$8++) test2["_" + String.fromCharCode(i$8)] = i$8;
			if (Object.getOwnPropertyNames(test2).map(function(n) {
				return test2[n];
			}).join("") !== "0123456789") return false;
			var test3 = {};
			"abcdefghijklmnopqrst".split("").forEach(function(letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
			return true;
		} catch (err) {
			return false;
		}
	}
	module.exports = shouldUseNative() ? Object.assign : function(target, source) {
		var from;
		var to = toObject(target);
		var symbols;
		for (var s$3 = 1; s$3 < arguments.length; s$3++) {
			from = Object(arguments[s$3]);
			for (var key$1 in from) if (hasOwnProperty$4.call(from, key$1)) to[key$1] = from[key$1];
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i$8 = 0; i$8 < symbols.length; i$8++) if (propIsEnumerable.call(from, symbols[i$8])) to[symbols[i$8]] = from[symbols[i$8]];
			}
		}
		return to;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js
var require_vary = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js": ((exports, module) => {
	/**
	* Module exports.
	*/
	module.exports = vary$1;
	module.exports.append = append;
	/**
	* RegExp to match field-name in RFC 7230 sec 3.2
	*
	* field-name    = token
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	*/
	var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
	/**
	* Append a field to a vary header.
	*
	* @param {String} header
	* @param {String|Array} field
	* @return {String}
	* @public
	*/
	function append(header, field) {
		if (typeof header !== "string") throw new TypeError("header argument is required");
		if (!field) throw new TypeError("field argument is required");
		var fields = !Array.isArray(field) ? parse$12(String(field)) : field;
		for (var j$7 = 0; j$7 < fields.length; j$7++) if (!FIELD_NAME_REGEXP.test(fields[j$7])) throw new TypeError("field argument contains an invalid header name");
		if (header === "*") return header;
		var val = header;
		var vals = parse$12(header.toLowerCase());
		if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) return "*";
		for (var i$8 = 0; i$8 < fields.length; i$8++) {
			var fld = fields[i$8].toLowerCase();
			if (vals.indexOf(fld) === -1) {
				vals.push(fld);
				val = val ? val + ", " + fields[i$8] : fields[i$8];
			}
		}
		return val;
	}
	/**
	* Parse a vary header into an array.
	*
	* @param {String} header
	* @return {Array}
	* @private
	*/
	function parse$12(header) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i$8 = 0, len$1 = header.length; i$8 < len$1; i$8++) switch (header.charCodeAt(i$8)) {
			case 32:
				if (start === end) start = end = i$8 + 1;
				break;
			case 44:
				list.push(header.substring(start, end));
				start = end = i$8 + 1;
				break;
			default:
				end = i$8 + 1;
				break;
		}
		list.push(header.substring(start, end));
		return list;
	}
	/**
	* Mark that a request is varied on a header field.
	*
	* @param {Object} res
	* @param {String|Array} field
	* @public
	*/
	function vary$1(res$2, field) {
		if (!res$2 || !res$2.getHeader || !res$2.setHeader) throw new TypeError("res argument is required");
		var val = res$2.getHeader("Vary") || "";
		if (val = append(Array.isArray(val) ? val.join(", ") : String(val), field)) res$2.setHeader("Vary", val);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js
var require_lib$3 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js": ((exports, module) => {
	(function() {
		var assign$3 = require_object_assign();
		var vary$2 = require_vary();
		var defaults$5 = {
			origin: "*",
			methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
			preflightContinue: false,
			optionsSuccessStatus: 204
		};
		function isString$1(s$3) {
			return typeof s$3 === "string" || s$3 instanceof String;
		}
		function isOriginAllowed(origin, allowedOrigin) {
			if (Array.isArray(allowedOrigin)) {
				for (var i$8 = 0; i$8 < allowedOrigin.length; ++i$8) if (isOriginAllowed(origin, allowedOrigin[i$8])) return true;
				return false;
			} else if (isString$1(allowedOrigin)) return origin === allowedOrigin;
			else if (allowedOrigin instanceof RegExp) return allowedOrigin.test(origin);
			else return !!allowedOrigin;
		}
		function configureOrigin(options, req$2) {
			var requestOrigin = req$2.headers.origin, headers$1 = [], isAllowed;
			if (!options.origin || options.origin === "*") headers$1.push([{
				key: "Access-Control-Allow-Origin",
				value: "*"
			}]);
			else if (isString$1(options.origin)) {
				headers$1.push([{
					key: "Access-Control-Allow-Origin",
					value: options.origin
				}]);
				headers$1.push([{
					key: "Vary",
					value: "Origin"
				}]);
			} else {
				isAllowed = isOriginAllowed(requestOrigin, options.origin);
				headers$1.push([{
					key: "Access-Control-Allow-Origin",
					value: isAllowed ? requestOrigin : false
				}]);
				headers$1.push([{
					key: "Vary",
					value: "Origin"
				}]);
			}
			return headers$1;
		}
		function configureMethods(options) {
			var methods$3 = options.methods;
			if (methods$3.join) methods$3 = options.methods.join(",");
			return {
				key: "Access-Control-Allow-Methods",
				value: methods$3
			};
		}
		function configureCredentials(options) {
			if (options.credentials === true) return {
				key: "Access-Control-Allow-Credentials",
				value: "true"
			};
			return null;
		}
		function configureAllowedHeaders(options, req$2) {
			var allowedHeaders = options.allowedHeaders || options.headers;
			var headers$1 = [];
			if (!allowedHeaders) {
				allowedHeaders = req$2.headers["access-control-request-headers"];
				headers$1.push([{
					key: "Vary",
					value: "Access-Control-Request-Headers"
				}]);
			} else if (allowedHeaders.join) allowedHeaders = allowedHeaders.join(",");
			if (allowedHeaders && allowedHeaders.length) headers$1.push([{
				key: "Access-Control-Allow-Headers",
				value: allowedHeaders
			}]);
			return headers$1;
		}
		function configureExposedHeaders(options) {
			var headers$1 = options.exposedHeaders;
			if (!headers$1) return null;
			else if (headers$1.join) headers$1 = headers$1.join(",");
			if (headers$1 && headers$1.length) return {
				key: "Access-Control-Expose-Headers",
				value: headers$1
			};
			return null;
		}
		function configureMaxAge(options) {
			var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
			if (maxAge && maxAge.length) return {
				key: "Access-Control-Max-Age",
				value: maxAge
			};
			return null;
		}
		function applyHeaders(headers$1, res$2) {
			for (var i$8 = 0, n = headers$1.length; i$8 < n; i$8++) {
				var header = headers$1[i$8];
				if (header) {
					if (Array.isArray(header)) applyHeaders(header, res$2);
					else if (header.key === "Vary" && header.value) vary$2(res$2, header.value);
					else if (header.value) res$2.setHeader(header.key, header.value);
				}
			}
		}
		function cors$1(options, req$2, res$2, next) {
			var headers$1 = [];
			if ((req$2.method && req$2.method.toUpperCase && req$2.method.toUpperCase()) === "OPTIONS") {
				headers$1.push(configureOrigin(options, req$2));
				headers$1.push(configureCredentials(options, req$2));
				headers$1.push(configureMethods(options, req$2));
				headers$1.push(configureAllowedHeaders(options, req$2));
				headers$1.push(configureMaxAge(options, req$2));
				headers$1.push(configureExposedHeaders(options, req$2));
				applyHeaders(headers$1, res$2);
				if (options.preflightContinue) next();
				else {
					res$2.statusCode = options.optionsSuccessStatus;
					res$2.setHeader("Content-Length", "0");
					res$2.end();
				}
			} else {
				headers$1.push(configureOrigin(options, req$2));
				headers$1.push(configureCredentials(options, req$2));
				headers$1.push(configureExposedHeaders(options, req$2));
				applyHeaders(headers$1, res$2);
				next();
			}
		}
		function middlewareWrapper(o) {
			var optionsCallback = null;
			if (typeof o === "function") optionsCallback = o;
			else optionsCallback = function(req$2, cb) {
				cb(null, o);
			};
			return function corsMiddleware(req$2, res$2, next) {
				optionsCallback(req$2, function(err, options) {
					if (err) next(err);
					else {
						var corsOptions = assign$3({}, defaults$5, options);
						var originCallback = null;
						if (corsOptions.origin && typeof corsOptions.origin === "function") originCallback = corsOptions.origin;
						else if (corsOptions.origin) originCallback = function(origin, cb) {
							cb(null, corsOptions.origin);
						};
						if (originCallback) originCallback(req$2.headers.origin, function(err2, origin) {
							if (err2 || !origin) next(err2);
							else {
								corsOptions.origin = origin;
								cors$1(corsOptions, req$2, res$2, next);
							}
						});
						else next();
					}
				});
			};
		}
		module.exports = middlewareWrapper;
	})();
}) });

//#endregion
//#region ../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js
var require_safe_buffer$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js": ((exports, module) => {
	var buffer$2 = __require("buffer");
	var Buffer$15 = buffer$2.Buffer;
	function copyProps$1(src$1, dst) {
		for (var key$1 in src$1) dst[key$1] = src$1[key$1];
	}
	if (Buffer$15.from && Buffer$15.alloc && Buffer$15.allocUnsafe && Buffer$15.allocUnsafeSlow) module.exports = buffer$2;
	else {
		copyProps$1(buffer$2, exports);
		exports.Buffer = SafeBuffer$1;
	}
	function SafeBuffer$1(arg, encodingOrOffset, length) {
		return Buffer$15(arg, encodingOrOffset, length);
	}
	copyProps$1(Buffer$15, SafeBuffer$1);
	SafeBuffer$1.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer$15(arg, encodingOrOffset, length);
	};
	SafeBuffer$1.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer$15(size);
		if (fill !== void 0) if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer$1.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer$15(size);
	};
	SafeBuffer$1.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer$2.SlowBuffer(size);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/basic-auth@2.0.1/node_modules/basic-auth/index.js
var require_basic_auth = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/basic-auth@2.0.1/node_modules/basic-auth/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Buffer$14 = require_safe_buffer$1().Buffer;
	/**
	* Module exports.
	* @public
	*/
	module.exports = auth$1;
	module.exports.parse = parse$11;
	/**
	* RegExp for basic auth credentials
	*
	* credentials = auth-scheme 1*SP token68
	* auth-scheme = "Basic" ; case insensitive
	* token68     = 1*( ALPHA / DIGIT / "-" / "." / "_" / "~" / "+" / "/" ) *"="
	* @private
	*/
	var CREDENTIALS_REGEXP = /^ *(?:[Bb][Aa][Ss][Ii][Cc]) +([A-Za-z0-9._~+/-]+=*) *$/;
	/**
	* RegExp for basic auth user/pass
	*
	* user-pass   = userid ":" password
	* userid      = *<TEXT excluding ":">
	* password    = *TEXT
	* @private
	*/
	var USER_PASS_REGEXP = /^([^:]*):(.*)$/;
	/**
	* Parse the Authorization header field of a request.
	*
	* @param {object} req
	* @return {object} with .name and .pass
	* @public
	*/
	function auth$1(req$2) {
		if (!req$2) throw new TypeError("argument req is required");
		if (typeof req$2 !== "object") throw new TypeError("argument req is required to be an object");
		return parse$11(getAuthorization(req$2));
	}
	/**
	* Decode base64 string.
	* @private
	*/
	function decodeBase64(str) {
		return Buffer$14.from(str, "base64").toString();
	}
	/**
	* Get the Authorization header from request object.
	* @private
	*/
	function getAuthorization(req$2) {
		if (!req$2.headers || typeof req$2.headers !== "object") throw new TypeError("argument req is required to have headers property");
		return req$2.headers.authorization;
	}
	/**
	* Parse basic auth to object.
	*
	* @param {string} string
	* @return {object}
	* @public
	*/
	function parse$11(string) {
		if (typeof string !== "string") return;
		var match$1 = CREDENTIALS_REGEXP.exec(string);
		if (!match$1) return;
		var userPass = USER_PASS_REGEXP.exec(decodeBase64(match$1[1]));
		if (!userPass) return;
		return new Credentials(userPass[1], userPass[2]);
	}
	/**
	* Object to represent user credentials.
	* @private
	*/
	function Credentials(name, pass) {
		this.name = name;
		this.pass = pass;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js
var require_ms = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js": ((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$10(val);
		else if (type === "number" && isNaN(val) === false) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$10(str) {
		str = String(str);
		if (str.length > 100) return;
		var match$1 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
		if (!match$1) return;
		var n = parseFloat(match$1[1]);
		switch ((match$1[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms$2) {
		if (ms$2 >= d) return Math.round(ms$2 / d) + "d";
		if (ms$2 >= h) return Math.round(ms$2 / h) + "h";
		if (ms$2 >= m) return Math.round(ms$2 / m) + "m";
		if (ms$2 >= s) return Math.round(ms$2 / s) + "s";
		return ms$2 + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms$2) {
		return plural(ms$2, d, "day") || plural(ms$2, h, "hour") || plural(ms$2, m, "minute") || plural(ms$2, s, "second") || ms$2 + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms$2, n, name) {
		if (ms$2 < n) return;
		if (ms$2 < n * 1.5) return Math.floor(ms$2 / n) + " " + name;
		return Math.ceil(ms$2 / n) + " " + name + "s";
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js
var require_debug = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js": ((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = require_ms();
	/**
	* The currently active debug mode names, and names to skip.
	*/
	exports.names = [];
	exports.skips = [];
	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	exports.formatters = {};
	/**
	* Previous log timestamp.
	*/
	var prevTime;
	/**
	* Select a color.
	* @param {String} namespace
	* @return {Number}
	* @api private
	*/
	function selectColor(namespace) {
		var hash = 0, i$8;
		for (i$8 in namespace) {
			hash = (hash << 5) - hash + namespace.charCodeAt(i$8);
			hash |= 0;
		}
		return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		function debug$23() {
			if (!debug$23.enabled) return;
			var self$1 = debug$23;
			var curr = +/* @__PURE__ */ new Date();
			self$1.diff = curr - (prevTime || curr);
			self$1.prev = prevTime;
			self$1.curr = curr;
			prevTime = curr;
			var args = new Array(arguments.length);
			for (var i$8 = 0; i$8 < args.length; i$8++) args[i$8] = arguments[i$8];
			args[0] = exports.coerce(args[0]);
			if ("string" !== typeof args[0]) args.unshift("%O");
			var index$1 = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match$1, format$6) {
				if (match$1 === "%%") return match$1;
				index$1++;
				var formatter = exports.formatters[format$6];
				if ("function" === typeof formatter) {
					var val = args[index$1];
					match$1 = formatter.call(self$1, val);
					args.splice(index$1, 1);
					index$1--;
				}
				return match$1;
			});
			exports.formatArgs.call(self$1, args);
			(debug$23.log || exports.log || console.log.bind(console)).apply(self$1, args);
		}
		debug$23.namespace = namespace;
		debug$23.enabled = exports.enabled(namespace);
		debug$23.useColors = exports.useColors();
		debug$23.color = selectColor(namespace);
		if ("function" === typeof exports.init) exports.init(debug$23);
		return debug$23;
	}
	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		exports.save(namespaces);
		exports.names = [];
		exports.skips = [];
		var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
		var len$1 = split.length;
		for (var i$8 = 0; i$8 < len$1; i$8++) {
			if (!split[i$8]) continue;
			namespaces = split[i$8].replace(/\*/g, ".*?");
			if (namespaces[0] === "-") exports.skips.push(/* @__PURE__ */ new RegExp("^" + namespaces.substr(1) + "$"));
			else exports.names.push(/* @__PURE__ */ new RegExp("^" + namespaces + "$"));
		}
	}
	/**
	* Disable debug output.
	*
	* @api public
	*/
	function disable() {
		exports.enable("");
	}
	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		var i$8, len$1;
		for (i$8 = 0, len$1 = exports.skips.length; i$8 < len$1; i$8++) if (exports.skips[i$8].test(name)) return false;
		for (i$8 = 0, len$1 = exports.names.length; i$8 < len$1; i$8++) if (exports.names[i$8].test(name)) return true;
		return false;
	}
	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) return val.stack || val.message;
		return val;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/browser.js
var require_browser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/browser.js": ((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug();
	exports.log = log$2;
	exports.formatArgs = formatArgs$1;
	exports.save = save$1;
	exports.load = load$1;
	exports.useColors = useColors$1;
	exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
	/**
	* Colors.
	*/
	exports.colors = [
		"lightseagreen",
		"forestgreen",
		"goldenrod",
		"dodgerblue",
		"darkorchid",
		"crimson"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors$1() {
		if (typeof window !== "undefined" && window.process && window.process.type === "renderer") return true;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	exports.formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (err) {
			return "[UnexpectedJSONParseError]: " + err.message;
		}
	};
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs$1(args) {
		var useColors$4 = this.useColors;
		args[0] = (useColors$4 ? "%c" : "") + this.namespace + (useColors$4 ? " %c" : " ") + args[0] + (useColors$4 ? "%c " : " ") + "+" + exports.humanize(this.diff);
		if (!useColors$4) return;
		var c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		var index$1 = 0;
		var lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, function(match$1) {
			if ("%%" === match$1) return;
			index$1++;
			if ("%c" === match$1) lastC = index$1;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.log()` when available.
	* No-op when `console.log` is not a "function".
	*
	* @api public
	*/
	function log$2() {
		return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save$1(namespaces) {
		try {
			if (null == namespaces) exports.storage.removeItem("debug");
			else exports.storage.debug = namespaces;
		} catch (e) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load$1() {
		var r;
		try {
			r = exports.storage.debug;
		} catch (e) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Enable namespaces listed in `localStorage.debug` initially.
	*/
	exports.enable(load$1());
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return window.localStorage;
		} catch (e) {}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js
var require_node = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	var tty = __require("tty");
	var util$2 = __require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*
	* Expose `debug()` as the module.
	*/
	exports = module.exports = require_debug();
	exports.init = init;
	exports.log = log$1;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter(function(key$1) {
		return /^debug_/i.test(key$1);
	}).reduce(function(obj, key$1) {
		var prop = key$1.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k$7) {
			return k$7.toUpperCase();
		});
		var val = process.env[key$1];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* The file descriptor to write the `debug()` calls to.
	* Set the `DEBUG_FD` env variable to override with another value. i.e.:
	*
	*   $ DEBUG_FD=3 node script.js 3>debug.log
	*/
	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	if (1 !== fd && 2 !== fd) util$2.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
	var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
	}
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	exports.formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
			return str.trim();
		}).join(" ");
	};
	/**
	* Map %o to `util.inspect()`, allowing multiple lines if needed.
	*/
	exports.formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$2.inspect(v, this.inspectOpts);
	};
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		var name = this.namespace;
		if (this.useColors) {
			var c = this.color;
			var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
	}
	/**
	* Invokes `util.format()` with the specified arguments and writes to `stream`.
	*/
	function log$1() {
		return stream.write(util$2.format.apply(util$2, arguments) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (null == namespaces) delete process.env.DEBUG;
		else process.env.DEBUG = namespaces;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Copied from `node/src/node.js`.
	*
	* XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	* relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	*/
	function createWritableStdioStream(fd$1) {
		var stream$3;
		switch (process.binding("tty_wrap").guessHandleType(fd$1)) {
			case "TTY":
				stream$3 = new tty.WriteStream(fd$1);
				stream$3._type = "tty";
				if (stream$3._handle && stream$3._handle.unref) stream$3._handle.unref();
				break;
			case "FILE":
				stream$3 = new (__require("fs")).SyncWriteStream(fd$1, { autoClose: false });
				stream$3._type = "fs";
				break;
			case "PIPE":
			case "TCP":
				stream$3 = new (__require("net")).Socket({
					fd: fd$1,
					readable: false,
					writable: true
				});
				stream$3.readable = false;
				stream$3.read = null;
				stream$3._type = "pipe";
				if (stream$3._handle && stream$3._handle.unref) stream$3._handle.unref();
				break;
			default: throw new Error("Implement me. Unknown stream file type!");
		}
		stream$3.fd = fd$1;
		stream$3._isStdio = true;
		return stream$3;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug$23) {
		debug$23.inspectOpts = {};
		var keys$6 = Object.keys(exports.inspectOpts);
		for (var i$8 = 0; i$8 < keys$6.length; i$8++) debug$23.inspectOpts[keys$6[i$8]] = exports.inspectOpts[keys$6[i$8]];
	}
	/**
	* Enable namespaces listed in `process.env.DEBUG` initially.
	*/
	exports.enable(load());
}) });

//#endregion
//#region ../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js
var require_src = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js": ((exports, module) => {
	/**
	* Detect Electron renderer process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process !== "undefined" && process.type === "renderer") module.exports = require_browser();
	else module.exports = require_node();
}) });

//#endregion
//#region ../../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js
var require_depd = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js": ((exports, module) => {
	/*!
	* depd
	* Copyright(c) 2014-2018 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module dependencies.
	*/
	var relative = __require("path").relative;
	/**
	* Module exports.
	*/
	module.exports = depd;
	/**
	* Get the path to base files on.
	*/
	var basePath = process.cwd();
	/**
	* Determine if namespace is contained in the string.
	*/
	function containsNamespace(str, namespace) {
		var vals = str.split(/[ ,]+/);
		var ns = String(namespace).toLowerCase();
		for (var i$8 = 0; i$8 < vals.length; i$8++) {
			var val = vals[i$8];
			if (val && (val === "*" || val.toLowerCase() === ns)) return true;
		}
		return false;
	}
	/**
	* Convert a data descriptor to accessor descriptor.
	*/
	function convertDataDescriptorToAccessor(obj, prop, message) {
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		var value = descriptor.value;
		descriptor.get = function getter() {
			return value;
		};
		if (descriptor.writable) descriptor.set = function setter$7(val) {
			return value = val;
		};
		delete descriptor.value;
		delete descriptor.writable;
		Object.defineProperty(obj, prop, descriptor);
		return descriptor;
	}
	/**
	* Create arguments string to keep arity.
	*/
	function createArgumentsString(arity) {
		var str = "";
		for (var i$8 = 0; i$8 < arity; i$8++) str += ", arg" + i$8;
		return str.substr(2);
	}
	/**
	* Create stack string from stack.
	*/
	function createStackString(stack) {
		var str = this.name + ": " + this.namespace;
		if (this.message) str += " deprecated " + this.message;
		for (var i$8 = 0; i$8 < stack.length; i$8++) str += "\n    at " + stack[i$8].toString();
		return str;
	}
	/**
	* Create deprecate for namespace in caller.
	*/
	function depd(namespace) {
		if (!namespace) throw new TypeError("argument namespace is required");
		var file = callSiteLocation(getStack()[1])[0];
		function deprecate$10(message) {
			log.call(deprecate$10, message);
		}
		deprecate$10._file = file;
		deprecate$10._ignored = isignored(namespace);
		deprecate$10._namespace = namespace;
		deprecate$10._traced = istraced(namespace);
		deprecate$10._warned = Object.create(null);
		deprecate$10.function = wrapfunction;
		deprecate$10.property = wrapproperty;
		return deprecate$10;
	}
	/**
	* Determine if event emitter has listeners of a given type.
	*
	* The way to do this check is done three different ways in Node.js >= 0.8
	* so this consolidates them into a minimal set using instance methods.
	*
	* @param {EventEmitter} emitter
	* @param {string} type
	* @returns {boolean}
	* @private
	*/
	function eehaslisteners(emitter$1, type) {
		return (typeof emitter$1.listenerCount !== "function" ? emitter$1.listeners(type).length : emitter$1.listenerCount(type)) > 0;
	}
	/**
	* Determine if namespace is ignored.
	*/
	function isignored(namespace) {
		if (process.noDeprecation) return true;
		return containsNamespace(process.env.NO_DEPRECATION || "", namespace);
	}
	/**
	* Determine if namespace is traced.
	*/
	function istraced(namespace) {
		if (process.traceDeprecation) return true;
		return containsNamespace(process.env.TRACE_DEPRECATION || "", namespace);
	}
	/**
	* Display deprecation message.
	*/
	function log(message, site) {
		var haslisteners = eehaslisteners(process, "deprecation");
		if (!haslisteners && this._ignored) return;
		var caller;
		var callFile;
		var callSite;
		var depSite;
		var i$8 = 0;
		var seen = false;
		var stack = getStack();
		var file = this._file;
		if (site) {
			depSite = site;
			callSite = callSiteLocation(stack[1]);
			callSite.name = depSite.name;
			file = callSite[0];
		} else {
			i$8 = 2;
			depSite = callSiteLocation(stack[i$8]);
			callSite = depSite;
		}
		for (; i$8 < stack.length; i$8++) {
			caller = callSiteLocation(stack[i$8]);
			callFile = caller[0];
			if (callFile === file) seen = true;
			else if (callFile === this._file) file = this._file;
			else if (seen) break;
		}
		var key$1 = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
		if (key$1 !== void 0 && key$1 in this._warned) return;
		this._warned[key$1] = true;
		var msg = message;
		if (!msg) msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
		if (haslisteners) {
			var err = DeprecationError(this._namespace, msg, stack.slice(i$8));
			process.emit("deprecation", err);
			return;
		}
		var output = (process.stderr.isTTY ? formatColor : formatPlain).call(this, msg, caller, stack.slice(i$8));
		process.stderr.write(output + "\n", "utf8");
	}
	/**
	* Get call site location as array.
	*/
	function callSiteLocation(callSite) {
		var file = callSite.getFileName() || "<anonymous>";
		var line = callSite.getLineNumber();
		var colm = callSite.getColumnNumber();
		if (callSite.isEval()) file = callSite.getEvalOrigin() + ", " + file;
		var site = [
			file,
			line,
			colm
		];
		site.callSite = callSite;
		site.name = callSite.getFunctionName();
		return site;
	}
	/**
	* Generate a default message from the site.
	*/
	function defaultMessage(site) {
		var callSite = site.callSite;
		var funcName = site.name;
		if (!funcName) funcName = "<anonymous@" + formatLocation(site) + ">";
		var context = callSite.getThis();
		var typeName = context && callSite.getTypeName();
		if (typeName === "Object") typeName = void 0;
		if (typeName === "Function") typeName = context.name || typeName;
		return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
	}
	/**
	* Format deprecation message without color.
	*/
	function formatPlain(msg, caller, stack) {
		var formatted = (/* @__PURE__ */ new Date()).toUTCString() + " " + this._namespace + " deprecated " + msg;
		if (this._traced) {
			for (var i$8 = 0; i$8 < stack.length; i$8++) formatted += "\n    at " + stack[i$8].toString();
			return formatted;
		}
		if (caller) formatted += " at " + formatLocation(caller);
		return formatted;
	}
	/**
	* Format deprecation message with color.
	*/
	function formatColor(msg, caller, stack) {
		var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
		if (this._traced) {
			for (var i$8 = 0; i$8 < stack.length; i$8++) formatted += "\n    \x1B[36mat " + stack[i$8].toString() + "\x1B[39m";
			return formatted;
		}
		if (caller) formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
		return formatted;
	}
	/**
	* Format call site location.
	*/
	function formatLocation(callSite) {
		return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
	}
	/**
	* Get the stack as array of call sites.
	*/
	function getStack() {
		var limit$2 = Error.stackTraceLimit;
		var obj = {};
		var prep = Error.prepareStackTrace;
		Error.prepareStackTrace = prepareObjectStackTrace;
		Error.stackTraceLimit = Math.max(10, limit$2);
		Error.captureStackTrace(obj);
		var stack = obj.stack.slice(1);
		Error.prepareStackTrace = prep;
		Error.stackTraceLimit = limit$2;
		return stack;
	}
	/**
	* Capture call site stack from v8.
	*/
	function prepareObjectStackTrace(obj, stack) {
		return stack;
	}
	/**
	* Return a wrapped function in a deprecation message.
	*/
	function wrapfunction(fn, message) {
		if (typeof fn !== "function") throw new TypeError("argument fn must be a function");
		var args = createArgumentsString(fn.length);
		var site = callSiteLocation(getStack()[1]);
		site.name = fn.name;
		return new Function("fn", "log", "deprecate", "message", "site", "\"use strict\"\nreturn function (" + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}")(fn, log, this, message, site);
	}
	/**
	* Wrap property in a deprecation message.
	*/
	function wrapproperty(obj, prop, message) {
		if (!obj || typeof obj !== "object" && typeof obj !== "function") throw new TypeError("argument obj must be object");
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		if (!descriptor) throw new TypeError("must call property on owner object");
		if (!descriptor.configurable) throw new TypeError("property must be configurable");
		var deprecate$10 = this;
		var site = callSiteLocation(getStack()[1]);
		site.name = prop;
		if ("value" in descriptor) descriptor = convertDataDescriptorToAccessor(obj, prop, message);
		var get$1 = descriptor.get;
		var set$3 = descriptor.set;
		if (typeof get$1 === "function") descriptor.get = function getter() {
			log.call(deprecate$10, message, site);
			return get$1.apply(this, arguments);
		};
		if (typeof set$3 === "function") descriptor.set = function setter$7() {
			log.call(deprecate$10, message, site);
			return set$3.apply(this, arguments);
		};
		Object.defineProperty(obj, prop, descriptor);
	}
	/**
	* Create DeprecationError for deprecation
	*/
	function DeprecationError(namespace, message, stack) {
		var error = /* @__PURE__ */ new Error();
		var stackString;
		Object.defineProperty(error, "constructor", { value: DeprecationError });
		Object.defineProperty(error, "message", {
			configurable: true,
			enumerable: false,
			value: message,
			writable: true
		});
		Object.defineProperty(error, "name", {
			enumerable: false,
			configurable: true,
			value: "DeprecationError",
			writable: true
		});
		Object.defineProperty(error, "namespace", {
			configurable: true,
			enumerable: false,
			value: namespace,
			writable: true
		});
		Object.defineProperty(error, "stack", {
			configurable: true,
			enumerable: false,
			get: function() {
				if (stackString !== void 0) return stackString;
				return stackString = createStackString.call(this, stack);
			},
			set: function setter$7(val) {
				stackString = val;
			}
		});
		return error;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js
var require_ee_first = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = first$2;
	/**
	* Get the first event in a set of event emitters and event pairs.
	*
	* @param {array} stuff
	* @param {function} done
	* @public
	*/
	function first$2(stuff, done) {
		if (!Array.isArray(stuff)) throw new TypeError("arg must be an array of [ee, events...] arrays");
		var cleanups = [];
		for (var i$8 = 0; i$8 < stuff.length; i$8++) {
			var arr = stuff[i$8];
			if (!Array.isArray(arr) || arr.length < 2) throw new TypeError("each array member must be [ee, events...]");
			var ee = arr[0];
			for (var j$7 = 1; j$7 < arr.length; j$7++) {
				var event = arr[j$7];
				var fn = listener(event, callback);
				ee.on(event, fn);
				cleanups.push({
					ee,
					event,
					fn
				});
			}
		}
		function callback() {
			cleanup();
			done.apply(null, arguments);
		}
		function cleanup() {
			var x;
			for (var i$9 = 0; i$9 < cleanups.length; i$9++) {
				x = cleanups[i$9];
				x.ee.removeListener(x.event, x.fn);
			}
		}
		function thunk(fn$1) {
			done = fn$1;
		}
		thunk.cancel = cleanup;
		return thunk;
	}
	/**
	* Create the event listener.
	* @private
	*/
	function listener(event, done) {
		return function onevent(arg1) {
			var args = new Array(arguments.length);
			var ee = this;
			var err = event === "error" ? arg1 : null;
			for (var i$8 = 0; i$8 < args.length; i$8++) args[i$8] = arguments[i$8];
			done(err, ee, event, args);
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/on-finished@2.3.0/node_modules/on-finished/index.js
var require_on_finished$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/on-finished@2.3.0/node_modules/on-finished/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = onFinished$6;
	module.exports.isFinished = isFinished$2;
	/**
	* Module dependencies.
	* @private
	*/
	var first$1 = require_ee_first();
	/**
	* Variables.
	* @private
	*/
	/* istanbul ignore next */
	var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	/**
	* Invoke callback when the response has finished, useful for
	* cleaning up resources afterwards.
	*
	* @param {object} msg
	* @param {function} listener
	* @return {object}
	* @public
	*/
	function onFinished$6(msg, listener$6) {
		if (isFinished$2(msg) !== false) {
			defer$2(listener$6, null, msg);
			return msg;
		}
		attachListener$1(msg, listener$6);
		return msg;
	}
	/**
	* Determine if message is already finished.
	*
	* @param {object} msg
	* @return {boolean}
	* @public
	*/
	function isFinished$2(msg) {
		var socket = msg.socket;
		if (typeof msg.finished === "boolean") return Boolean(msg.finished || socket && !socket.writable);
		if (typeof msg.complete === "boolean") return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
	}
	/**
	* Attach a finished listener to the message.
	*
	* @param {object} msg
	* @param {function} callback
	* @private
	*/
	function attachFinishedListener$1(msg, callback) {
		var eeMsg;
		var eeSocket;
		var finished = false;
		function onFinish(error) {
			eeMsg.cancel();
			eeSocket.cancel();
			finished = true;
			callback(error);
		}
		eeMsg = eeSocket = first$1([[
			msg,
			"end",
			"finish"
		]], onFinish);
		function onSocket(socket) {
			msg.removeListener("socket", onSocket);
			if (finished) return;
			if (eeMsg !== eeSocket) return;
			eeSocket = first$1([[
				socket,
				"error",
				"close"
			]], onFinish);
		}
		if (msg.socket) {
			onSocket(msg.socket);
			return;
		}
		msg.on("socket", onSocket);
		if (msg.socket === void 0) patchAssignSocket$1(msg, onSocket);
	}
	/**
	* Attach the listener to the message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function attachListener$1(msg, listener$6) {
		var attached = msg.__onFinished;
		if (!attached || !attached.queue) {
			attached = msg.__onFinished = createListener$1(msg);
			attachFinishedListener$1(msg, attached);
		}
		attached.queue.push(listener$6);
	}
	/**
	* Create listener on message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function createListener$1(msg) {
		function listener$6(err) {
			if (msg.__onFinished === listener$6) msg.__onFinished = null;
			if (!listener$6.queue) return;
			var queue$5 = listener$6.queue;
			listener$6.queue = null;
			for (var i$8 = 0; i$8 < queue$5.length; i$8++) queue$5[i$8](err, msg);
		}
		listener$6.queue = [];
		return listener$6;
	}
	/**
	* Patch ServerResponse.prototype.assignSocket for node.js 0.8.
	*
	* @param {ServerResponse} res
	* @param {function} callback
	* @private
	*/
	function patchAssignSocket$1(res$2, callback) {
		var assignSocket = res$2.assignSocket;
		if (typeof assignSocket !== "function") return;
		res$2.assignSocket = function _assignSocket(socket) {
			assignSocket.call(this, socket);
			callback(socket);
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/on-headers@1.1.0/node_modules/on-headers/index.js
var require_on_headers = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/on-headers@1.1.0/node_modules/on-headers/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = onHeaders$1;
	var set1dArray = typeof __require("http").ServerResponse.prototype.appendHeader === "function" ? set1dArrayWithAppend : set1dArrayWithSet;
	/**
	* Create a replacement writeHead method.
	*
	* @param {function} prevWriteHead
	* @param {function} listener
	* @private
	*/
	function createWriteHead(prevWriteHead, listener$6) {
		var fired = false;
		return function writeHead(statusCode) {
			var args = setWriteHeadHeaders.apply(this, arguments);
			if (!fired) {
				fired = true;
				listener$6.call(this);
				if (typeof args[0] === "number" && this.statusCode !== args[0]) {
					args[0] = this.statusCode;
					args.length = 1;
				}
			}
			return prevWriteHead.apply(this, args);
		};
	}
	/**
	* Execute a listener when a response is about to write headers.
	*
	* @param {object} res
	* @return {function} listener
	* @public
	*/
	function onHeaders$1(res$2, listener$6) {
		if (!res$2) throw new TypeError("argument res is required");
		if (typeof listener$6 !== "function") throw new TypeError("argument listener must be a function");
		res$2.writeHead = createWriteHead(res$2.writeHead, listener$6);
	}
	/**
	* Set headers contained in array on the response object.
	*
	* @param {object} res
	* @param {array} headers
	* @private
	*/
	function setHeadersFromArray(res$2, headers$1) {
		if (headers$1.length && Array.isArray(headers$1[0])) set2dArray(res$2, headers$1);
		else {
			if (headers$1.length % 2 !== 0) throw new TypeError("headers array is malformed");
			set1dArray(res$2, headers$1);
		}
	}
	/**
	* Set headers contained in object on the response object.
	*
	* @param {object} res
	* @param {object} headers
	* @private
	*/
	function setHeadersFromObject(res$2, headers$1) {
		var keys$6 = Object.keys(headers$1);
		for (var i$8 = 0; i$8 < keys$6.length; i$8++) {
			var k$7 = keys$6[i$8];
			if (k$7) res$2.setHeader(k$7, headers$1[k$7]);
		}
	}
	/**
	* Set headers and other properties on the response object.
	*
	* @param {number} statusCode
	* @private
	*/
	function setWriteHeadHeaders(statusCode) {
		var length = arguments.length;
		var headerIndex = length > 1 && typeof arguments[1] === "string" ? 2 : 1;
		var headers$1 = length >= headerIndex + 1 ? arguments[headerIndex] : void 0;
		this.statusCode = statusCode;
		if (Array.isArray(headers$1)) setHeadersFromArray(this, headers$1);
		else if (headers$1) setHeadersFromObject(this, headers$1);
		var args = new Array(Math.min(length, headerIndex));
		for (var i$8 = 0; i$8 < args.length; i$8++) args[i$8] = arguments[i$8];
		return args;
	}
	function set2dArray(res$2, headers$1) {
		var key$1;
		for (var i$8 = 0; i$8 < headers$1.length; i$8++) {
			key$1 = headers$1[i$8][0];
			if (key$1) res$2.setHeader(key$1, headers$1[i$8][1]);
		}
	}
	function set1dArrayWithAppend(res$2, headers$1) {
		for (var i$8 = 0; i$8 < headers$1.length; i$8 += 2) res$2.removeHeader(headers$1[i$8]);
		var key$1;
		for (var j$7 = 0; j$7 < headers$1.length; j$7 += 2) {
			key$1 = headers$1[j$7];
			if (key$1) res$2.appendHeader(key$1, headers$1[j$7 + 1]);
		}
	}
	function set1dArrayWithSet(res$2, headers$1) {
		var key$1;
		for (var i$8 = 0; i$8 < headers$1.length; i$8 += 2) {
			key$1 = headers$1[i$8];
			if (key$1) res$2.setHeader(key$1, headers$1[i$8 + 1]);
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/morgan@1.10.1/node_modules/morgan/index.js
var require_morgan = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/morgan@1.10.1/node_modules/morgan/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = morgan$1;
	module.exports.compile = compile$1;
	module.exports.format = format$4;
	module.exports.token = token;
	/**
	* Module dependencies.
	* @private
	*/
	var auth = require_basic_auth();
	var debug$12 = require_src()("morgan");
	var deprecate$9 = require_depd()("morgan");
	var onFinished$5 = require_on_finished$1();
	var onHeaders = require_on_headers();
	/**
	* Array of CLF month names.
	* @private
	*/
	var CLF_MONTH = [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	];
	/**
	* Default log buffer duration.
	* @private
	*/
	var DEFAULT_BUFFER_DURATION = 1e3;
	/**
	* Create a logger middleware.
	*
	* @public
	* @param {String|Function} format
	* @param {Object} [options]
	* @return {Function} middleware
	*/
	function morgan$1(format$6, options) {
		var fmt = format$6;
		var opts = options || {};
		if (format$6 && typeof format$6 === "object") {
			opts = format$6;
			fmt = opts.format || "default";
			deprecate$9("morgan(options): use morgan(" + (typeof fmt === "string" ? JSON.stringify(fmt) : "format") + ", options) instead");
		}
		if (fmt === void 0) deprecate$9("undefined format: specify a format");
		var immediate = opts.immediate;
		var skip = opts.skip || false;
		var formatLine = typeof fmt !== "function" ? getFormatFunction(fmt) : fmt;
		var buffer$5 = opts.buffer;
		var stream$3 = opts.stream || process.stdout;
		if (buffer$5) {
			deprecate$9("buffer option");
			stream$3 = createBufferStream(stream$3, typeof buffer$5 !== "number" ? DEFAULT_BUFFER_DURATION : buffer$5);
		}
		return function logger(req$2, res$2, next) {
			req$2._startAt = void 0;
			req$2._startTime = void 0;
			req$2._remoteAddress = getip(req$2);
			res$2._startAt = void 0;
			res$2._startTime = void 0;
			recordStartTime.call(req$2);
			function logRequest() {
				if (skip !== false && skip(req$2, res$2)) {
					debug$12("skip request");
					return;
				}
				var line = formatLine(morgan$1, req$2, res$2);
				if (line == null) {
					debug$12("skip line");
					return;
				}
				debug$12("log request");
				stream$3.write(line + "\n");
			}
			if (immediate) logRequest();
			else {
				onHeaders(res$2, recordStartTime);
				onFinished$5(res$2, logRequest);
			}
			next();
		};
	}
	/**
	* Apache combined log format.
	*/
	morgan$1.format("combined", ":remote-addr - :remote-user [:date[clf]] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"");
	/**
	* Apache common log format.
	*/
	morgan$1.format("common", ":remote-addr - :remote-user [:date[clf]] \":method :url HTTP/:http-version\" :status :res[content-length]");
	/**
	* Default format.
	*/
	morgan$1.format("default", ":remote-addr - :remote-user [:date] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"");
	deprecate$9.property(morgan$1, "default", "default format: use combined format");
	/**
	* Short format.
	*/
	morgan$1.format("short", ":remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms");
	/**
	* Tiny format.
	*/
	morgan$1.format("tiny", ":method :url :status :res[content-length] - :response-time ms");
	/**
	* dev (colored)
	*/
	morgan$1.format("dev", function developmentFormatLine(tokens, req$2, res$2) {
		var status$1 = headersSent$2(res$2) ? res$2.statusCode : void 0;
		var color = status$1 >= 500 ? 31 : status$1 >= 400 ? 33 : status$1 >= 300 ? 36 : status$1 >= 200 ? 32 : 0;
		var fn = developmentFormatLine[color];
		if (!fn) fn = developmentFormatLine[color] = compile$1("\x1B[0m:method :url \x1B[" + color + "m:status\x1B[0m :response-time ms - :res[content-length]\x1B[0m");
		return fn(tokens, req$2, res$2);
	});
	/**
	* request url
	*/
	morgan$1.token("url", function getUrlToken(req$2) {
		return req$2.originalUrl || req$2.url;
	});
	/**
	* request method
	*/
	morgan$1.token("method", function getMethodToken(req$2) {
		return req$2.method;
	});
	/**
	* response time in milliseconds
	*/
	morgan$1.token("response-time", function getResponseTimeToken(req$2, res$2, digits) {
		if (!req$2._startAt || !res$2._startAt) return;
		return ((res$2._startAt[0] - req$2._startAt[0]) * 1e3 + (res$2._startAt[1] - req$2._startAt[1]) * 1e-6).toFixed(digits === void 0 ? 3 : digits);
	});
	/**
	* total time in milliseconds
	*/
	morgan$1.token("total-time", function getTotalTimeToken(req$2, res$2, digits) {
		if (!req$2._startAt || !res$2._startAt) return;
		var elapsed = process.hrtime(req$2._startAt);
		return (elapsed[0] * 1e3 + elapsed[1] * 1e-6).toFixed(digits === void 0 ? 3 : digits);
	});
	/**
	* current date
	*/
	morgan$1.token("date", function getDateToken(req$2, res$2, format$6) {
		var date = /* @__PURE__ */ new Date();
		switch (format$6 || "web") {
			case "clf": return clfdate(date);
			case "iso": return date.toISOString();
			case "web": return date.toUTCString();
		}
	});
	/**
	* response status code
	*/
	morgan$1.token("status", function getStatusToken(req$2, res$2) {
		return headersSent$2(res$2) ? String(res$2.statusCode) : void 0;
	});
	/**
	* normalized referrer
	*/
	morgan$1.token("referrer", function getReferrerToken(req$2) {
		return req$2.headers.referer || req$2.headers.referrer;
	});
	/**
	* remote address
	*/
	morgan$1.token("remote-addr", getip);
	/**
	* remote user
	*/
	morgan$1.token("remote-user", function getRemoteUserToken(req$2) {
		var credentials = auth(req$2);
		return credentials ? credentials.name : void 0;
	});
	/**
	* HTTP version
	*/
	morgan$1.token("http-version", function getHttpVersionToken(req$2) {
		return req$2.httpVersionMajor + "." + req$2.httpVersionMinor;
	});
	/**
	* UA string
	*/
	morgan$1.token("user-agent", function getUserAgentToken(req$2) {
		return req$2.headers["user-agent"];
	});
	/**
	* request header
	*/
	morgan$1.token("req", function getRequestToken(req$2, res$2, field) {
		var header = req$2.headers[field.toLowerCase()];
		return Array.isArray(header) ? header.join(", ") : header;
	});
	/**
	* response header
	*/
	morgan$1.token("res", function getResponseHeader(req$2, res$2, field) {
		if (!headersSent$2(res$2)) return;
		var header = res$2.getHeader(field);
		return Array.isArray(header) ? header.join(", ") : header;
	});
	/**
	* Format a Date in the common log format.
	*
	* @private
	* @param {Date} dateTime
	* @return {string}
	*/
	function clfdate(dateTime) {
		var date = dateTime.getUTCDate();
		var hour = dateTime.getUTCHours();
		var mins = dateTime.getUTCMinutes();
		var secs = dateTime.getUTCSeconds();
		var year = dateTime.getUTCFullYear();
		var month = CLF_MONTH[dateTime.getUTCMonth()];
		return pad2(date) + "/" + month + "/" + year + ":" + pad2(hour) + ":" + pad2(mins) + ":" + pad2(secs) + " +0000";
	}
	/**
	* Compile a format string into a function.
	*
	* @param {string} format
	* @return {function}
	* @public
	*/
	function compile$1(format$6) {
		if (typeof format$6 !== "string") throw new TypeError("argument format must be a string");
		var js = "  \"use strict\"\n  return " + String(JSON.stringify(format$6)).replace(/:([-\w]{2,})(?:\[([^\]]+)\])?/g, function(_, name, arg) {
			var tokenArguments = "req, res";
			var tokenFunction = "tokens[" + String(JSON.stringify(name)) + "]";
			if (arg !== void 0) tokenArguments += ", " + String(JSON.stringify(arg));
			return "\" +\n    (" + tokenFunction + "(" + tokenArguments + ") || \"-\") + \"";
		});
		return new Function("tokens, req, res", js);
	}
	/**
	* Create a basic buffering stream.
	*
	* @param {object} stream
	* @param {number} interval
	* @public
	*/
	function createBufferStream(stream$3, interval) {
		var buf = [];
		var timer = null;
		function flush() {
			timer = null;
			stream$3.write(buf.join(""));
			buf.length = 0;
		}
		function write$1(str) {
			if (timer === null) timer = setTimeout(flush, interval);
			buf.push(str);
		}
		return { write: write$1 };
	}
	/**
	* Define a format with the given name.
	*
	* @param {string} name
	* @param {string|function} fmt
	* @public
	*/
	function format$4(name, fmt) {
		morgan$1[name] = fmt;
		return this;
	}
	/**
	* Lookup and compile a named format function.
	*
	* @param {string} name
	* @return {function}
	* @public
	*/
	function getFormatFunction(name) {
		var fmt = morgan$1[name] || name || morgan$1.default;
		return typeof fmt !== "function" ? compile$1(fmt) : fmt;
	}
	/**
	* Get request IP address.
	*
	* @private
	* @param {IncomingMessage} req
	* @return {string}
	*/
	function getip(req$2) {
		return req$2.ip || req$2._remoteAddress || req$2.connection && req$2.connection.remoteAddress || void 0;
	}
	/**
	* Determine if the response headers have been sent.
	*
	* @param {object} res
	* @returns {boolean}
	* @private
	*/
	function headersSent$2(res$2) {
		// istanbul ignore next: node.js 0.8 support
		return typeof res$2.headersSent !== "boolean" ? Boolean(res$2._header) : res$2.headersSent;
	}
	/**
	* Pad number to two digits.
	*
	* @private
	* @param {number} num
	* @return {string}
	*/
	function pad2(num) {
		var str = String(num);
		// istanbul ignore next: num is current datetime
		return (str.length === 1 ? "0" : "") + str;
	}
	/**
	* Record the start time.
	* @private
	*/
	function recordStartTime() {
		this._startAt = process.hrtime();
		this._startTime = /* @__PURE__ */ new Date();
	}
	/**
	* Define a token function with the given name,
	* and callback fn(req, res).
	*
	* @param {string} name
	* @param {function} fn
	* @public
	*/
	function token(name, fn) {
		morgan$1[name] = fn;
		return this;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js
var require_bytes = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = bytes$5;
	module.exports.format = format$3;
	module.exports.parse = parse$9;
	/**
	* Module variables.
	* @private
	*/
	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
	var map = {
		b: 1,
		kb: 1024,
		mb: 1 << 20,
		gb: 1 << 30,
		tb: Math.pow(1024, 4),
		pb: Math.pow(1024, 5)
	};
	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
	/**
	* Convert the given value in bytes into a string or parse to string to an integer in bytes.
	*
	* @param {string|number} value
	* @param {{
	*  case: [string],
	*  decimalPlaces: [number]
	*  fixedDecimals: [boolean]
	*  thousandsSeparator: [string]
	*  unitSeparator: [string]
	*  }} [options] bytes options.
	*
	* @returns {string|number|null}
	*/
	function bytes$5(value, options) {
		if (typeof value === "string") return parse$9(value);
		if (typeof value === "number") return format$3(value, options);
		return null;
	}
	/**
	* Format the given value in bytes into a string.
	*
	* If the value is negative, it is kept as such. If it is a float,
	* it is rounded.
	*
	* @param {number} value
	* @param {object} [options]
	* @param {number} [options.decimalPlaces=2]
	* @param {number} [options.fixedDecimals=false]
	* @param {string} [options.thousandsSeparator=]
	* @param {string} [options.unit=]
	* @param {string} [options.unitSeparator=]
	*
	* @returns {string|null}
	* @public
	*/
	function format$3(value, options) {
		if (!Number.isFinite(value)) return null;
		var mag = Math.abs(value);
		var thousandsSeparator = options && options.thousandsSeparator || "";
		var unitSeparator = options && options.unitSeparator || "";
		var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
		var fixedDecimals = Boolean(options && options.fixedDecimals);
		var unit = options && options.unit || "";
		if (!unit || !map[unit.toLowerCase()]) if (mag >= map.pb) unit = "PB";
		else if (mag >= map.tb) unit = "TB";
		else if (mag >= map.gb) unit = "GB";
		else if (mag >= map.mb) unit = "MB";
		else if (mag >= map.kb) unit = "KB";
		else unit = "B";
		var str = (value / map[unit.toLowerCase()]).toFixed(decimalPlaces);
		if (!fixedDecimals) str = str.replace(formatDecimalsRegExp, "$1");
		if (thousandsSeparator) str = str.split(".").map(function(s$3, i$8) {
			return i$8 === 0 ? s$3.replace(formatThousandsRegExp, thousandsSeparator) : s$3;
		}).join(".");
		return str + unitSeparator + unit;
	}
	/**
	* Parse the string value into an integer in bytes.
	*
	* If no unit is given, it is assumed the value is in bytes.
	*
	* @param {number|string} val
	*
	* @returns {number|null}
	* @public
	*/
	function parse$9(val) {
		if (typeof val === "number" && !isNaN(val)) return val;
		if (typeof val !== "string") return null;
		var results = parseRegExp.exec(val);
		var floatValue;
		var unit = "b";
		if (!results) {
			floatValue = parseInt(val, 10);
			unit = "b";
		} else {
			floatValue = parseFloat(results[1]);
			unit = results[4].toLowerCase();
		}
		if (isNaN(floatValue)) return null;
		return Math.floor(map[unit] * floatValue);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js
var require_content_type = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js": ((exports) => {
	/**
	* RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	*
	* parameter     = token "=" ( token / quoted-string )
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	* quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	* qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	* obs-text      = %x80-FF
	* quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	*/
	var PARAM_REGEXP$1 = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
	var TEXT_REGEXP$1 = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
	var TOKEN_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	/**
	* RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	*
	* quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	* obs-text    = %x80-FF
	*/
	var QESC_REGEXP$1 = /\\([\u000b\u0020-\u00ff])/g;
	/**
	* RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
	*/
	var QUOTE_REGEXP$1 = /([\\"])/g;
	/**
	* RegExp to match type in RFC 7231 sec 3.1.1.1
	*
	* media-type = type "/" subtype
	* type       = token
	* subtype    = token
	*/
	var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	/**
	* Module exports.
	* @public
	*/
	exports.format = format$2;
	exports.parse = parse$8;
	/**
	* Format object to media type.
	*
	* @param {object} obj
	* @return {string}
	* @public
	*/
	function format$2(obj) {
		if (!obj || typeof obj !== "object") throw new TypeError("argument obj is required");
		var parameters = obj.parameters;
		var type = obj.type;
		if (!type || !TYPE_REGEXP.test(type)) throw new TypeError("invalid type");
		var string = type;
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i$8 = 0; i$8 < params.length; i$8++) {
				param = params[i$8];
				if (!TOKEN_REGEXP$1.test(param)) throw new TypeError("invalid parameter name");
				string += "; " + param + "=" + qstring$2(parameters[param]);
			}
		}
		return string;
	}
	/**
	* Parse media type to object.
	*
	* @param {string|object} string
	* @return {Object}
	* @public
	*/
	function parse$8(string) {
		if (!string) throw new TypeError("argument string is required");
		var header = typeof string === "object" ? getcontenttype$1(string) : string;
		if (typeof header !== "string") throw new TypeError("argument string is required to be a string");
		var index$1 = header.indexOf(";");
		var type = index$1 !== -1 ? header.slice(0, index$1).trim() : header.trim();
		if (!TYPE_REGEXP.test(type)) throw new TypeError("invalid media type");
		var obj = new ContentType(type.toLowerCase());
		if (index$1 !== -1) {
			var key$1;
			var match$1;
			var value;
			PARAM_REGEXP$1.lastIndex = index$1;
			while (match$1 = PARAM_REGEXP$1.exec(header)) {
				if (match$1.index !== index$1) throw new TypeError("invalid parameter format");
				index$1 += match$1[0].length;
				key$1 = match$1[1].toLowerCase();
				value = match$1[2];
				if (value.charCodeAt(0) === 34) {
					value = value.slice(1, -1);
					if (value.indexOf("\\") !== -1) value = value.replace(QESC_REGEXP$1, "$1");
				}
				obj.parameters[key$1] = value;
			}
			if (index$1 !== header.length) throw new TypeError("invalid parameter format");
		}
		return obj;
	}
	/**
	* Get content-type from req/res objects.
	*
	* @param {object}
	* @return {Object}
	* @private
	*/
	function getcontenttype$1(obj) {
		var header;
		if (typeof obj.getHeader === "function") header = obj.getHeader("content-type");
		else if (typeof obj.headers === "object") header = obj.headers && obj.headers["content-type"];
		if (typeof header !== "string") throw new TypeError("content-type header is missing from object");
		return header;
	}
	/**
	* Quote a string if necessary.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function qstring$2(val) {
		var str = String(val);
		if (TOKEN_REGEXP$1.test(str)) return str;
		if (str.length > 0 && !TEXT_REGEXP$1.test(str)) throw new TypeError("invalid parameter value");
		return "\"" + str.replace(QUOTE_REGEXP$1, "\\$1") + "\"";
	}
	/**
	* Class to represent a content type.
	* @private
	*/
	function ContentType(type) {
		this.parameters = Object.create(null);
		this.type = type;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js
var require_setprototypeof = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js": ((exports, module) => {
	module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
	function setProtoOf(obj, proto$7) {
		obj.__proto__ = proto$7;
		return obj;
	}
	function mixinProperties(obj, proto$7) {
		for (var prop in proto$7) if (!Object.prototype.hasOwnProperty.call(obj, prop)) obj[prop] = proto$7[prop];
		return obj;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json
var require_codes = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json": ((exports, module) => {
	module.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a Teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Too Early",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js
var require_statuses = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var codes = require_codes();
	/**
	* Module exports.
	* @public
	*/
	module.exports = status;
	status.message = codes;
	status.code = createMessageToStatusCodeMap(codes);
	status.codes = createStatusCodeList(codes);
	status.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status.empty = {
		204: true,
		205: true,
		304: true
	};
	status.retry = {
		502: true,
		503: true,
		504: true
	};
	/**
	* Create a map of message to status code.
	* @private
	*/
	function createMessageToStatusCodeMap(codes$1) {
		var map$2 = {};
		Object.keys(codes$1).forEach(function forEachCode(code$1) {
			var message = codes$1[code$1];
			var status$1 = Number(code$1);
			map$2[message.toLowerCase()] = status$1;
		});
		return map$2;
	}
	/**
	* Create a list of all status codes.
	* @private
	*/
	function createStatusCodeList(codes$1) {
		return Object.keys(codes$1).map(function mapCode(code$1) {
			return Number(code$1);
		});
	}
	/**
	* Get the status code for given message.
	* @private
	*/
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status.code[msg];
	}
	/**
	* Get the status message for given code.
	* @private
	*/
	function getStatusMessage(code$1) {
		if (!Object.prototype.hasOwnProperty.call(status.message, code$1)) throw new Error("invalid status code: " + code$1);
		return status.message[code$1];
	}
	/**
	* Get the status code.
	*
	* Given a number, this will throw if it is not a known status
	* code, otherwise the code will be returned. Given a string,
	* the string will be parsed for a number and return the code
	* if valid, otherwise will lookup the code assuming this is
	* the status message.
	*
	* @param {string|number} code
	* @returns {number}
	* @public
	*/
	function status(code$1) {
		if (typeof code$1 === "number") return getStatusMessage(code$1);
		if (typeof code$1 !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code$1, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code$1);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js": ((exports, module) => {
	if (typeof Object.create === "function") module.exports = function inherits$2(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else module.exports = function inherits$2(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js": ((exports, module) => {
	try {
		var util$1 = __require("util");
		/* istanbul ignore next */
		if (typeof util$1.inherits !== "function") throw "";
		module.exports = util$1.inherits;
	} catch (e) {
		/* istanbul ignore next */
		module.exports = require_inherits_browser();
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js
var require_toidentifier = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = toIdentifier$1;
	/**
	* Trasform the given string into a JavaScript identifier
	*
	* @param {string} str
	* @returns {string}
	* @public
	*/
	function toIdentifier$1(str) {
		return str.split(" ").map(function(token$1) {
			return token$1.slice(0, 1).toUpperCase() + token$1.slice(1);
		}).join("").replace(/[^ _0-9a-z]/gi, "");
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js
var require_http_errors = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var deprecate$8 = require_depd()("http-errors");
	var setPrototypeOf$3 = require_setprototypeof();
	var statuses$3 = require_statuses();
	var inherits = require_inherits();
	var toIdentifier = require_toidentifier();
	/**
	* Module exports.
	* @public
	*/
	module.exports = createError$6;
	module.exports.HttpError = createHttpErrorConstructor();
	module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
	populateConstructorExports(module.exports, statuses$3.codes, module.exports.HttpError);
	/**
	* Get the code class of a status code.
	* @private
	*/
	function codeClass(status$1) {
		return Number(String(status$1).charAt(0) + "00");
	}
	/**
	* Create a new HTTP Error.
	*
	* @returns {Error}
	* @public
	*/
	function createError$6() {
		var err;
		var msg;
		var status$1 = 500;
		var props = {};
		for (var i$8 = 0; i$8 < arguments.length; i$8++) {
			var arg = arguments[i$8];
			var type = typeof arg;
			if (type === "object" && arg instanceof Error) {
				err = arg;
				status$1 = err.status || err.statusCode || status$1;
			} else if (type === "number" && i$8 === 0) status$1 = arg;
			else if (type === "string") msg = arg;
			else if (type === "object") props = arg;
			else throw new TypeError("argument #" + (i$8 + 1) + " unsupported type " + type);
		}
		if (typeof status$1 === "number" && (status$1 < 400 || status$1 >= 600)) deprecate$8("non-error status code; use only 4xx or 5xx status codes");
		if (typeof status$1 !== "number" || !statuses$3.message[status$1] && (status$1 < 400 || status$1 >= 600)) status$1 = 500;
		var HttpError = createError$6[status$1] || createError$6[codeClass(status$1)];
		if (!err) {
			err = HttpError ? new HttpError(msg) : new Error(msg || statuses$3.message[status$1]);
			Error.captureStackTrace(err, createError$6);
		}
		if (!HttpError || !(err instanceof HttpError) || err.status !== status$1) {
			err.expose = status$1 < 500;
			err.status = err.statusCode = status$1;
		}
		for (var key$1 in props) if (key$1 !== "status" && key$1 !== "statusCode") err[key$1] = props[key$1];
		return err;
	}
	/**
	* Create HTTP error abstract base class.
	* @private
	*/
	function createHttpErrorConstructor() {
		function HttpError() {
			throw new TypeError("cannot construct abstract class");
		}
		inherits(HttpError, Error);
		return HttpError;
	}
	/**
	* Create a constructor for a client error.
	* @private
	*/
	function createClientErrorConstructor(HttpError, name, code$1) {
		var className = toClassName(name);
		function ClientError(message) {
			var msg = message != null ? message : statuses$3.message[code$1];
			var err = new Error(msg);
			Error.captureStackTrace(err, ClientError);
			setPrototypeOf$3(err, ClientError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ClientError, HttpError);
		nameFunc(ClientError, className);
		ClientError.prototype.status = code$1;
		ClientError.prototype.statusCode = code$1;
		ClientError.prototype.expose = true;
		return ClientError;
	}
	/**
	* Create function to test is a value is a HttpError.
	* @private
	*/
	function createIsHttpErrorFunction(HttpError) {
		return function isHttpError(val) {
			if (!val || typeof val !== "object") return false;
			if (val instanceof HttpError) return true;
			return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
		};
	}
	/**
	* Create a constructor for a server error.
	* @private
	*/
	function createServerErrorConstructor(HttpError, name, code$1) {
		var className = toClassName(name);
		function ServerError(message) {
			var msg = message != null ? message : statuses$3.message[code$1];
			var err = new Error(msg);
			Error.captureStackTrace(err, ServerError);
			setPrototypeOf$3(err, ServerError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ServerError, HttpError);
		nameFunc(ServerError, className);
		ServerError.prototype.status = code$1;
		ServerError.prototype.statusCode = code$1;
		ServerError.prototype.expose = false;
		return ServerError;
	}
	/**
	* Set the name of a function, if possible.
	* @private
	*/
	function nameFunc(func, name) {
		var desc$1 = Object.getOwnPropertyDescriptor(func, "name");
		if (desc$1 && desc$1.configurable) {
			desc$1.value = name;
			Object.defineProperty(func, "name", desc$1);
		}
	}
	/**
	* Populate the exports object with constructors for every error class.
	* @private
	*/
	function populateConstructorExports(exports$1, codes$1, HttpError) {
		codes$1.forEach(function forEachCode(code$1) {
			var CodeError;
			var name = toIdentifier(statuses$3.message[code$1]);
			switch (codeClass(code$1)) {
				case 400:
					CodeError = createClientErrorConstructor(HttpError, name, code$1);
					break;
				case 500:
					CodeError = createServerErrorConstructor(HttpError, name, code$1);
					break;
			}
			if (CodeError) {
				exports$1[code$1] = CodeError;
				exports$1[name] = CodeError;
			}
		});
	}
	/**
	* Get a class name from a name identifier.
	* @private
	*/
	function toClassName(name) {
		return name.substr(-5) !== "Error" ? name + "Error" : name;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/destroy@1.2.0/node_modules/destroy/index.js
var require_destroy = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/destroy@1.2.0/node_modules/destroy/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var EventEmitter$1 = __require("events").EventEmitter;
	var ReadStream = __require("fs").ReadStream;
	var Stream$1 = __require("stream");
	var Zlib = __require("zlib");
	/**
	* Module exports.
	* @public
	*/
	module.exports = destroy$2;
	/**
	* Destroy the given stream, and optionally suppress any future `error` events.
	*
	* @param {object} stream
	* @param {boolean} suppress
	* @public
	*/
	function destroy$2(stream$3, suppress) {
		if (isFsReadStream(stream$3)) destroyReadStream(stream$3);
		else if (isZlibStream(stream$3)) destroyZlibStream(stream$3);
		else if (hasDestroy(stream$3)) stream$3.destroy();
		if (isEventEmitter(stream$3) && suppress) {
			stream$3.removeAllListeners("error");
			stream$3.addListener("error", noop);
		}
		return stream$3;
	}
	/**
	* Destroy a ReadStream.
	*
	* @param {object} stream
	* @private
	*/
	function destroyReadStream(stream$3) {
		stream$3.destroy();
		if (typeof stream$3.close === "function") stream$3.on("open", onOpenClose);
	}
	/**
	* Close a Zlib stream.
	*
	* Zlib streams below Node.js 4.5.5 have a buggy implementation
	* of .close() when zlib encountered an error.
	*
	* @param {object} stream
	* @private
	*/
	function closeZlibStream(stream$3) {
		if (stream$3._hadError === true) {
			var prop = stream$3._binding === null ? "_binding" : "_handle";
			stream$3[prop] = { close: function() {
				this[prop] = null;
			} };
		}
		stream$3.close();
	}
	/**
	* Destroy a Zlib stream.
	*
	* Zlib streams don't have a destroy function in Node.js 6. On top of that
	* simply calling destroy on a zlib stream in Node.js 8+ will result in a
	* memory leak. So until that is fixed, we need to call both close AND destroy.
	*
	* PR to fix memory leak: https://github.com/nodejs/node/pull/23734
	*
	* In Node.js 6+8, it's important that destroy is called before close as the
	* stream would otherwise emit the error 'zlib binding closed'.
	*
	* @param {object} stream
	* @private
	*/
	function destroyZlibStream(stream$3) {
		if (typeof stream$3.destroy === "function")
 // istanbul ignore if: node.js 0.8
		if (stream$3._binding) {
			stream$3.destroy();
			if (stream$3._processing) {
				stream$3._needDrain = true;
				stream$3.once("drain", onDrainClearBinding);
			} else stream$3._binding.clear();
		} else if (stream$3._destroy && stream$3._destroy !== Stream$1.Transform.prototype._destroy) stream$3.destroy();
		else if (stream$3._destroy && typeof stream$3.close === "function") {
			stream$3.destroyed = true;
			stream$3.close();
		} else
 // istanbul ignore next
		stream$3.destroy();
		else if (typeof stream$3.close === "function") closeZlibStream(stream$3);
	}
	/**
	* Determine if stream has destroy.
	* @private
	*/
	function hasDestroy(stream$3) {
		return stream$3 instanceof Stream$1 && typeof stream$3.destroy === "function";
	}
	/**
	* Determine if val is EventEmitter.
	* @private
	*/
	function isEventEmitter(val) {
		return val instanceof EventEmitter$1;
	}
	/**
	* Determine if stream is fs.ReadStream stream.
	* @private
	*/
	function isFsReadStream(stream$3) {
		return stream$3 instanceof ReadStream;
	}
	/**
	* Determine if stream is Zlib stream.
	* @private
	*/
	function isZlibStream(stream$3) {
		return stream$3 instanceof Zlib.Gzip || stream$3 instanceof Zlib.Gunzip || stream$3 instanceof Zlib.Deflate || stream$3 instanceof Zlib.DeflateRaw || stream$3 instanceof Zlib.Inflate || stream$3 instanceof Zlib.InflateRaw || stream$3 instanceof Zlib.Unzip;
	}
	/**
	* No-op function.
	* @private
	*/
	function noop() {}
	/**
	* On drain handler to clear binding.
	* @private
	*/
	// istanbul ignore next: node.js 0.8
	function onDrainClearBinding() {
		this._binding.clear();
	}
	/**
	* On open handler to close stream.
	* @private
	*/
	function onOpenClose() {
		if (typeof this.fd === "number") this.close();
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js
var require_safer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js": ((exports, module) => {
	var buffer$1 = __require("buffer");
	var Buffer$13 = buffer$1.Buffer;
	var safer = {};
	var key;
	for (key in buffer$1) {
		if (!buffer$1.hasOwnProperty(key)) continue;
		if (key === "SlowBuffer" || key === "Buffer") continue;
		safer[key] = buffer$1[key];
	}
	var Safer = safer.Buffer = {};
	for (key in Buffer$13) {
		if (!Buffer$13.hasOwnProperty(key)) continue;
		if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
		Safer[key] = Buffer$13[key];
	}
	safer.Buffer.prototype = Buffer$13.prototype;
	if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
		if (typeof value === "number") throw new TypeError("The \"value\" argument must not be of type number. Received type " + typeof value);
		if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
		return Buffer$13(value, encodingOrOffset, length);
	};
	if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("The \"size\" argument must be of type number. Received type " + typeof size);
		if (size < 0 || size >= 2 * (1 << 30)) throw new RangeError("The value \"" + size + "\" is invalid for option \"size\"");
		var buf = Buffer$13(size);
		if (!fill || fill.length === 0) buf.fill(0);
		else if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		return buf;
	};
	if (!safer.kStringMaxLength) try {
		safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
	} catch (e) {}
	if (!safer.constants) {
		safer.constants = { MAX_LENGTH: safer.kMaxLength };
		if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	}
	module.exports = safer;
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/bom-handling.js": ((exports) => {
	var BOMChar = "";
	exports.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
		this.encoder = encoder;
		this.addBOM = true;
	}
	PrependBOMWrapper.prototype.write = function(str) {
		if (this.addBOM) {
			str = BOMChar + str;
			this.addBOM = false;
		}
		return this.encoder.write(str);
	};
	PrependBOMWrapper.prototype.end = function() {
		return this.encoder.end();
	};
	exports.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
		this.decoder = decoder;
		this.pass = false;
		this.options = options || {};
	}
	StripBOMWrapper.prototype.write = function(buf) {
		var res$2 = this.decoder.write(buf);
		if (this.pass || !res$2) return res$2;
		if (res$2[0] === BOMChar) {
			res$2 = res$2.slice(1);
			if (typeof this.options.stripBOM === "function") this.options.stripBOM();
		}
		this.pass = true;
		return res$2;
	};
	StripBOMWrapper.prototype.end = function() {
		return this.decoder.end();
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/internal.js
var require_internal = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/internal.js": ((exports, module) => {
	var Buffer$12 = require_safer().Buffer;
	module.exports = {
		utf8: {
			type: "_internal",
			bomAware: true
		},
		cesu8: {
			type: "_internal",
			bomAware: true
		},
		unicode11utf8: "utf8",
		ucs2: {
			type: "_internal",
			bomAware: true
		},
		utf16le: "ucs2",
		binary: { type: "_internal" },
		base64: { type: "_internal" },
		hex: { type: "_internal" },
		_internal: InternalCodec
	};
	function InternalCodec(codecOptions, iconv$3) {
		this.enc = codecOptions.encodingName;
		this.bomAware = codecOptions.bomAware;
		if (this.enc === "base64") this.encoder = InternalEncoderBase64;
		else if (this.enc === "cesu8") {
			this.enc = "utf8";
			this.encoder = InternalEncoderCesu8;
			if (Buffer$12.from("eda0bdedb2a9", "hex").toString() !== "") {
				this.decoder = InternalDecoderCesu8;
				this.defaultCharUnicode = iconv$3.defaultCharUnicode;
			}
		}
	}
	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;
	var StringDecoder = __require("string_decoder").StringDecoder;
	if (!StringDecoder.prototype.end) StringDecoder.prototype.end = function() {};
	function InternalDecoder(options, codec) {
		StringDecoder.call(this, codec.enc);
	}
	InternalDecoder.prototype = StringDecoder.prototype;
	function InternalEncoder(options, codec) {
		this.enc = codec.enc;
	}
	InternalEncoder.prototype.write = function(str) {
		return Buffer$12.from(str, this.enc);
	};
	InternalEncoder.prototype.end = function() {};
	function InternalEncoderBase64(options, codec) {
		this.prevStr = "";
	}
	InternalEncoderBase64.prototype.write = function(str) {
		str = this.prevStr + str;
		var completeQuads = str.length - str.length % 4;
		this.prevStr = str.slice(completeQuads);
		str = str.slice(0, completeQuads);
		return Buffer$12.from(str, "base64");
	};
	InternalEncoderBase64.prototype.end = function() {
		return Buffer$12.from(this.prevStr, "base64");
	};
	function InternalEncoderCesu8(options, codec) {}
	InternalEncoderCesu8.prototype.write = function(str) {
		var buf = Buffer$12.alloc(str.length * 3), bufIdx = 0;
		for (var i$8 = 0; i$8 < str.length; i$8++) {
			var charCode = str.charCodeAt(i$8);
			if (charCode < 128) buf[bufIdx++] = charCode;
			else if (charCode < 2048) {
				buf[bufIdx++] = 192 + (charCode >>> 6);
				buf[bufIdx++] = 128 + (charCode & 63);
			} else {
				buf[bufIdx++] = 224 + (charCode >>> 12);
				buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
				buf[bufIdx++] = 128 + (charCode & 63);
			}
		}
		return buf.slice(0, bufIdx);
	};
	InternalEncoderCesu8.prototype.end = function() {};
	function InternalDecoderCesu8(options, codec) {
		this.acc = 0;
		this.contBytes = 0;
		this.accBytes = 0;
		this.defaultCharUnicode = codec.defaultCharUnicode;
	}
	InternalDecoderCesu8.prototype.write = function(buf) {
		var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res$2 = "";
		for (var i$8 = 0; i$8 < buf.length; i$8++) {
			var curByte = buf[i$8];
			if ((curByte & 192) !== 128) {
				if (contBytes > 0) {
					res$2 += this.defaultCharUnicode;
					contBytes = 0;
				}
				if (curByte < 128) res$2 += String.fromCharCode(curByte);
				else if (curByte < 224) {
					acc = curByte & 31;
					contBytes = 1;
					accBytes = 1;
				} else if (curByte < 240) {
					acc = curByte & 15;
					contBytes = 2;
					accBytes = 1;
				} else res$2 += this.defaultCharUnicode;
			} else if (contBytes > 0) {
				acc = acc << 6 | curByte & 63;
				contBytes--;
				accBytes++;
				if (contBytes === 0) if (accBytes === 2 && acc < 128 && acc > 0) res$2 += this.defaultCharUnicode;
				else if (accBytes === 3 && acc < 2048) res$2 += this.defaultCharUnicode;
				else res$2 += String.fromCharCode(acc);
			} else res$2 += this.defaultCharUnicode;
		}
		this.acc = acc;
		this.contBytes = contBytes;
		this.accBytes = accBytes;
		return res$2;
	};
	InternalDecoderCesu8.prototype.end = function() {
		var res$2 = 0;
		if (this.contBytes > 0) res$2 += this.defaultCharUnicode;
		return res$2;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf16.js": ((exports) => {
	var Buffer$11 = require_safer().Buffer;
	exports.utf16be = Utf16BECodec;
	function Utf16BECodec() {}
	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;
	function Utf16BEEncoder() {}
	Utf16BEEncoder.prototype.write = function(str) {
		var buf = Buffer$11.from(str, "ucs2");
		for (var i$8 = 0; i$8 < buf.length; i$8 += 2) {
			var tmp = buf[i$8];
			buf[i$8] = buf[i$8 + 1];
			buf[i$8 + 1] = tmp;
		}
		return buf;
	};
	Utf16BEEncoder.prototype.end = function() {};
	function Utf16BEDecoder() {
		this.overflowByte = -1;
	}
	Utf16BEDecoder.prototype.write = function(buf) {
		if (buf.length == 0) return "";
		var buf2 = Buffer$11.alloc(buf.length + 1), i$8 = 0, j$7 = 0;
		if (this.overflowByte !== -1) {
			buf2[0] = buf[0];
			buf2[1] = this.overflowByte;
			i$8 = 1;
			j$7 = 2;
		}
		for (; i$8 < buf.length - 1; i$8 += 2, j$7 += 2) {
			buf2[j$7] = buf[i$8 + 1];
			buf2[j$7 + 1] = buf[i$8];
		}
		this.overflowByte = i$8 == buf.length - 1 ? buf[buf.length - 1] : -1;
		return buf2.slice(0, j$7).toString("ucs2");
	};
	Utf16BEDecoder.prototype.end = function() {};
	exports.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv$3) {
		this.iconv = iconv$3;
	}
	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;
	function Utf16Encoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder("utf-16le", options);
	}
	Utf16Encoder.prototype.write = function(str) {
		return this.encoder.write(str);
	};
	Utf16Encoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf16Decoder(options, codec) {
		this.decoder = null;
		this.initialBytes = [];
		this.initialBytesLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf16Decoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBytes.push(buf);
			this.initialBytesLen += buf.length;
			if (this.initialBytesLen < 16) return "";
			var buf = Buffer$11.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			this.initialBytes.length = this.initialBytesLen = 0;
		}
		return this.decoder.write(buf);
	};
	Utf16Decoder.prototype.end = function() {
		if (!this.decoder) {
			var buf = Buffer$11.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var res$2 = this.decoder.write(buf), trail = this.decoder.end();
			return trail ? res$2 + trail : res$2;
		}
		return this.decoder.end();
	};
	function detectEncoding(buf, defaultEncoding) {
		var enc$1 = defaultEncoding || "utf-16le";
		if (buf.length >= 2) if (buf[0] == 254 && buf[1] == 255) enc$1 = "utf-16be";
		else if (buf[0] == 255 && buf[1] == 254) enc$1 = "utf-16le";
		else {
			var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
			for (var i$8 = 0; i$8 < _len; i$8 += 2) {
				if (buf[i$8] === 0 && buf[i$8 + 1] !== 0) asciiCharsBE++;
				if (buf[i$8] !== 0 && buf[i$8 + 1] === 0) asciiCharsLE++;
			}
			if (asciiCharsBE > asciiCharsLE) enc$1 = "utf-16be";
			else if (asciiCharsBE < asciiCharsLE) enc$1 = "utf-16le";
		}
		return enc$1;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf7.js": ((exports) => {
	var Buffer$10 = require_safer().Buffer;
	exports.utf7 = Utf7Codec;
	exports.unicode11utf7 = "utf7";
	function Utf7Codec(codecOptions, iconv$3) {
		this.iconv = iconv$3;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;
	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
	function Utf7Encoder(options, codec) {
		this.iconv = codec.iconv;
	}
	Utf7Encoder.prototype.write = function(str) {
		return Buffer$10.from(str.replace(nonDirectChars, function(chunk) {
			return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
		}.bind(this)));
	};
	Utf7Encoder.prototype.end = function() {};
	function Utf7Decoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i$2 = 0; i$2 < 256; i$2++) base64Chars[i$2] = base64Regex.test(String.fromCharCode(i$2));
	var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
	Utf7Decoder.prototype.write = function(buf) {
		var res$2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i$8 = 0; i$8 < buf.length; i$8++) if (!inBase64) {
			if (buf[i$8] == plusChar) {
				res$2 += this.iconv.decode(buf.slice(lastI, i$8), "ascii");
				lastI = i$8 + 1;
				inBase64 = true;
			}
		} else if (!base64Chars[buf[i$8]]) {
			if (i$8 == lastI && buf[i$8] == minusChar) res$2 += "+";
			else {
				var b64str = base64Accum + buf.slice(lastI, i$8).toString();
				res$2 += this.iconv.decode(Buffer$10.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i$8] != minusChar) i$8--;
			lastI = i$8 + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res$2 += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + buf.slice(lastI).toString();
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res$2 += this.iconv.decode(Buffer$10.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res$2;
	};
	Utf7Decoder.prototype.end = function() {
		var res$2 = "";
		if (this.inBase64 && this.base64Accum.length > 0) res$2 = this.iconv.decode(Buffer$10.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res$2;
	};
	exports.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv$3) {
		this.iconv = iconv$3;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;
	function Utf7IMAPEncoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = Buffer$10.alloc(6);
		this.base64AccumIdx = 0;
	}
	Utf7IMAPEncoder.prototype.write = function(str) {
		var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer$10.alloc(str.length * 5 + 10), bufIdx = 0;
		for (var i$8 = 0; i$8 < str.length; i$8++) {
			var uChar = str.charCodeAt(i$8);
			if (32 <= uChar && uChar <= 126) {
				if (inBase64) {
					if (base64AccumIdx > 0) {
						bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
						base64AccumIdx = 0;
					}
					buf[bufIdx++] = minusChar;
					inBase64 = false;
				}
				if (!inBase64) {
					buf[bufIdx++] = uChar;
					if (uChar === andChar) buf[bufIdx++] = minusChar;
				}
			} else {
				if (!inBase64) {
					buf[bufIdx++] = andChar;
					inBase64 = true;
				}
				if (inBase64) {
					base64Accum[base64AccumIdx++] = uChar >> 8;
					base64Accum[base64AccumIdx++] = uChar & 255;
					if (base64AccumIdx == base64Accum.length) {
						bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
						base64AccumIdx = 0;
					}
				}
			}
		}
		this.inBase64 = inBase64;
		this.base64AccumIdx = base64AccumIdx;
		return buf.slice(0, bufIdx);
	};
	Utf7IMAPEncoder.prototype.end = function() {
		var buf = Buffer$10.alloc(10), bufIdx = 0;
		if (this.inBase64) {
			if (this.base64AccumIdx > 0) {
				bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
				this.base64AccumIdx = 0;
			}
			buf[bufIdx++] = minusChar;
			this.inBase64 = false;
		}
		return buf.slice(0, bufIdx);
	};
	function Utf7IMAPDecoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[",".charCodeAt(0)] = true;
	Utf7IMAPDecoder.prototype.write = function(buf) {
		var res$2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
		for (var i$8 = 0; i$8 < buf.length; i$8++) if (!inBase64) {
			if (buf[i$8] == andChar) {
				res$2 += this.iconv.decode(buf.slice(lastI, i$8), "ascii");
				lastI = i$8 + 1;
				inBase64 = true;
			}
		} else if (!base64IMAPChars[buf[i$8]]) {
			if (i$8 == lastI && buf[i$8] == minusChar) res$2 += "&";
			else {
				var b64str = base64Accum + buf.slice(lastI, i$8).toString().replace(/,/g, "/");
				res$2 += this.iconv.decode(Buffer$10.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i$8] != minusChar) i$8--;
			lastI = i$8 + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res$2 += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res$2 += this.iconv.decode(Buffer$10.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res$2;
	};
	Utf7IMAPDecoder.prototype.end = function() {
		var res$2 = "";
		if (this.inBase64 && this.base64Accum.length > 0) res$2 = this.iconv.decode(Buffer$10.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res$2;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-codec.js": ((exports) => {
	var Buffer$9 = require_safer().Buffer;
	exports._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv$3) {
		if (!codecOptions) throw new Error("SBCS codec is called without the data.");
		if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
		if (codecOptions.chars.length === 128) {
			var asciiString = "";
			for (var i$8 = 0; i$8 < 128; i$8++) asciiString += String.fromCharCode(i$8);
			codecOptions.chars = asciiString + codecOptions.chars;
		}
		this.decodeBuf = Buffer$9.from(codecOptions.chars, "ucs2");
		var encodeBuf = Buffer$9.alloc(65536, iconv$3.defaultCharSingleByte.charCodeAt(0));
		for (var i$8 = 0; i$8 < codecOptions.chars.length; i$8++) encodeBuf[codecOptions.chars.charCodeAt(i$8)] = i$8;
		this.encodeBuf = encodeBuf;
	}
	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;
	function SBCSEncoder(options, codec) {
		this.encodeBuf = codec.encodeBuf;
	}
	SBCSEncoder.prototype.write = function(str) {
		var buf = Buffer$9.alloc(str.length);
		for (var i$8 = 0; i$8 < str.length; i$8++) buf[i$8] = this.encodeBuf[str.charCodeAt(i$8)];
		return buf;
	};
	SBCSEncoder.prototype.end = function() {};
	function SBCSDecoder(options, codec) {
		this.decodeBuf = codec.decodeBuf;
	}
	SBCSDecoder.prototype.write = function(buf) {
		var decodeBuf = this.decodeBuf;
		var newBuf = Buffer$9.alloc(buf.length * 2);
		var idx1 = 0, idx2 = 0;
		for (var i$8 = 0; i$8 < buf.length; i$8++) {
			idx1 = buf[i$8] * 2;
			idx2 = i$8 * 2;
			newBuf[idx2] = decodeBuf[idx1];
			newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
		}
		return newBuf.toString("ucs2");
	};
	SBCSDecoder.prototype.end = function() {};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data.js": ((exports, module) => {
	module.exports = {
		"10029": "maccenteuro",
		"maccenteuro": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"808": "cp808",
		"ibm808": "cp808",
		"cp808": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"mik": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii8bit": "ascii",
		"usascii": "ascii",
		"ansix34": "ascii",
		"ansix341968": "ascii",
		"ansix341986": "ascii",
		"csascii": "ascii",
		"cp367": "ascii",
		"ibm367": "ascii",
		"isoir6": "ascii",
		"iso646us": "ascii",
		"iso646irv": "ascii",
		"us": "ascii",
		"latin1": "iso88591",
		"latin2": "iso88592",
		"latin3": "iso88593",
		"latin4": "iso88594",
		"latin5": "iso88599",
		"latin6": "iso885910",
		"latin7": "iso885913",
		"latin8": "iso885914",
		"latin9": "iso885915",
		"latin10": "iso885916",
		"csisolatin1": "iso88591",
		"csisolatin2": "iso88592",
		"csisolatin3": "iso88593",
		"csisolatin4": "iso88594",
		"csisolatincyrillic": "iso88595",
		"csisolatinarabic": "iso88596",
		"csisolatingreek": "iso88597",
		"csisolatinhebrew": "iso88598",
		"csisolatin5": "iso88599",
		"csisolatin6": "iso885910",
		"l1": "iso88591",
		"l2": "iso88592",
		"l3": "iso88593",
		"l4": "iso88594",
		"l5": "iso88599",
		"l6": "iso885910",
		"l7": "iso885913",
		"l8": "iso885914",
		"l9": "iso885915",
		"l10": "iso885916",
		"isoir14": "iso646jp",
		"isoir57": "iso646cn",
		"isoir100": "iso88591",
		"isoir101": "iso88592",
		"isoir109": "iso88593",
		"isoir110": "iso88594",
		"isoir144": "iso88595",
		"isoir127": "iso88596",
		"isoir126": "iso88597",
		"isoir138": "iso88598",
		"isoir148": "iso88599",
		"isoir157": "iso885910",
		"isoir166": "tis620",
		"isoir179": "iso885913",
		"isoir199": "iso885914",
		"isoir203": "iso885915",
		"isoir226": "iso885916",
		"cp819": "iso88591",
		"ibm819": "iso88591",
		"cyrillic": "iso88595",
		"arabic": "iso88596",
		"arabic8": "iso88596",
		"ecma114": "iso88596",
		"asmo708": "iso88596",
		"greek": "iso88597",
		"greek8": "iso88597",
		"ecma118": "iso88597",
		"elot928": "iso88597",
		"hebrew": "iso88598",
		"hebrew8": "iso88598",
		"turkish": "iso88599",
		"turkish8": "iso88599",
		"thai": "iso885911",
		"thai8": "iso885911",
		"celtic": "iso885914",
		"celtic8": "iso885914",
		"isoceltic": "iso885914",
		"tis6200": "tis620",
		"tis62025291": "tis620",
		"tis62025330": "tis620",
		"10000": "macroman",
		"10006": "macgreek",
		"10007": "maccyrillic",
		"10079": "maciceland",
		"10081": "macturkish",
		"cspc8codepage437": "cp437",
		"cspc775baltic": "cp775",
		"cspc850multilingual": "cp850",
		"cspcp852": "cp852",
		"cspc862latinhebrew": "cp862",
		"cpgr": "cp869",
		"msee": "cp1250",
		"mscyrl": "cp1251",
		"msansi": "cp1252",
		"msgreek": "cp1253",
		"msturk": "cp1254",
		"mshebr": "cp1255",
		"msarab": "cp1256",
		"winbaltrim": "cp1257",
		"cp20866": "koi8r",
		"20866": "koi8r",
		"ibm878": "koi8r",
		"cskoi8r": "koi8r",
		"cp21866": "koi8u",
		"21866": "koi8u",
		"ibm1168": "koi8u",
		"strk10482002": "rk1048",
		"tcvn5712": "tcvn",
		"tcvn57121": "tcvn",
		"gb198880": "iso646cn",
		"cn": "iso646cn",
		"csiso14jisc6220ro": "iso646jp",
		"jisc62201969ro": "iso646jp",
		"jp": "iso646jp",
		"cshproman8": "hproman8",
		"r8": "hproman8",
		"roman8": "hproman8",
		"xroman8": "hproman8",
		"ibm1051": "hproman8",
		"mac": "macintosh",
		"csmacintosh": "macintosh"
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data-generated.js": ((exports, module) => {
	module.exports = {
		"437": "cp437",
		"737": "cp737",
		"775": "cp775",
		"850": "cp850",
		"852": "cp852",
		"855": "cp855",
		"856": "cp856",
		"857": "cp857",
		"858": "cp858",
		"860": "cp860",
		"861": "cp861",
		"862": "cp862",
		"863": "cp863",
		"864": "cp864",
		"865": "cp865",
		"866": "cp866",
		"869": "cp869",
		"874": "windows874",
		"922": "cp922",
		"1046": "cp1046",
		"1124": "cp1124",
		"1125": "cp1125",
		"1129": "cp1129",
		"1133": "cp1133",
		"1161": "cp1161",
		"1162": "cp1162",
		"1163": "cp1163",
		"1250": "windows1250",
		"1251": "windows1251",
		"1252": "windows1252",
		"1253": "windows1253",
		"1254": "windows1254",
		"1255": "windows1255",
		"1256": "windows1256",
		"1257": "windows1257",
		"1258": "windows1258",
		"28591": "iso88591",
		"28592": "iso88592",
		"28593": "iso88593",
		"28594": "iso88594",
		"28595": "iso88595",
		"28596": "iso88596",
		"28597": "iso88597",
		"28598": "iso88598",
		"28599": "iso88599",
		"28600": "iso885910",
		"28601": "iso885911",
		"28603": "iso885913",
		"28604": "iso885914",
		"28605": "iso885915",
		"28606": "iso885916",
		"windows874": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win874": "windows874",
		"cp874": "windows874",
		"windows1250": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1250": "windows1250",
		"cp1250": "windows1250",
		"windows1251": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1251": "windows1251",
		"cp1251": "windows1251",
		"windows1252": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1252": "windows1252",
		"cp1252": "windows1252",
		"windows1253": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1253": "windows1253",
		"cp1253": "windows1253",
		"windows1254": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1254": "windows1254",
		"cp1254": "windows1254",
		"windows1255": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1255": "windows1255",
		"cp1255": "windows1255",
		"windows1256": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1256": "windows1256",
		"cp1256": "windows1256",
		"windows1257": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1257": "windows1257",
		"cp1257": "windows1257",
		"windows1258": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1258": "windows1258",
		"cp1258": "windows1258",
		"iso88591": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28591": "iso88591",
		"iso88592": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28592": "iso88592",
		"iso88593": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28593": "iso88593",
		"iso88594": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28594": "iso88594",
		"iso88595": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28595": "iso88595",
		"iso88596": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28596": "iso88596",
		"iso88597": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28597": "iso88597",
		"iso88598": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28598": "iso88598",
		"iso88599": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28599": "iso88599",
		"iso885910": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28600": "iso885910",
		"iso885911": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28601": "iso885911",
		"iso885913": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28603": "iso885913",
		"iso885914": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28604": "iso885914",
		"iso885915": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28605": "iso885915",
		"iso885916": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28606": "iso885916",
		"cp437": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm437": "cp437",
		"csibm437": "cp437",
		"cp737": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm737": "cp737",
		"csibm737": "cp737",
		"cp775": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm775": "cp775",
		"csibm775": "cp775",
		"cp850": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm850": "cp850",
		"csibm850": "cp850",
		"cp852": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm852": "cp852",
		"csibm852": "cp852",
		"cp855": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm855": "cp855",
		"csibm855": "cp855",
		"cp856": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm856": "cp856",
		"csibm856": "cp856",
		"cp857": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm857": "cp857",
		"csibm857": "cp857",
		"cp858": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm858": "cp858",
		"csibm858": "cp858",
		"cp860": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm860": "cp860",
		"csibm860": "cp860",
		"cp861": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm861": "cp861",
		"csibm861": "cp861",
		"cp862": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm862": "cp862",
		"csibm862": "cp862",
		"cp863": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm863": "cp863",
		"csibm863": "cp863",
		"cp864": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"ibm864": "cp864",
		"csibm864": "cp864",
		"cp865": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm865": "cp865",
		"csibm865": "cp865",
		"cp866": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm866": "cp866",
		"csibm866": "cp866",
		"cp869": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm869": "cp869",
		"csibm869": "cp869",
		"cp922": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm922": "cp922",
		"csibm922": "cp922",
		"cp1046": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1046": "cp1046",
		"csibm1046": "cp1046",
		"cp1124": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1124": "cp1124",
		"csibm1124": "cp1124",
		"cp1125": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1125": "cp1125",
		"csibm1125": "cp1125",
		"cp1129": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1129": "cp1129",
		"csibm1129": "cp1129",
		"cp1133": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1133": "cp1133",
		"csibm1133": "cp1133",
		"cp1161": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1161": "cp1161",
		"csibm1161": "cp1161",
		"cp1162": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1162": "cp1162",
		"csibm1162": "cp1162",
		"cp1163": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1163": "cp1163",
		"csibm1163": "cp1163",
		"maccroatian": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maccyrillic": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macgreek": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maciceland": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macroman": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macromania": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macthai": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macturkish": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macukraine": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8r": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8u": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8ru": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8t": {
			"type": "_sbcs",
			"chars": ""
		},
		"armscii8": {
			"type": "_sbcs",
			"chars": "\xA0)(.,-"
		},
		"rk1048": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"tcvn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"georgianacademy": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"georgianps": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"pt154": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"viscii": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		},
		"iso646cn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"iso646jp": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"hproman8": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macintosh": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii": {
			"type": "_sbcs",
			"chars": ""
		},
		"tis620": {
			"type": "_sbcs",
			"chars": ""
		}
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-codec.js": ((exports) => {
	var Buffer$8 = require_safer().Buffer;
	exports._dbcs = DBCSCodec;
	var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
	for (var i$1 = 0; i$1 < 256; i$1++) UNASSIGNED_NODE[i$1] = UNASSIGNED;
	function DBCSCodec(codecOptions, iconv$3) {
		this.encodingName = codecOptions.encodingName;
		if (!codecOptions) throw new Error("DBCS codec is called without the data.");
		if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
		var mappingTable = codecOptions.table();
		this.decodeTables = [];
		this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
		this.decodeTableSeq = [];
		for (var i$8 = 0; i$8 < mappingTable.length; i$8++) this._addDecodeChunk(mappingTable[i$8]);
		this.defaultCharUnicode = iconv$3.defaultCharUnicode;
		this.encodeTable = [];
		this.encodeTableSeq = [];
		var skipEncodeChars = {};
		if (codecOptions.encodeSkipVals) for (var i$8 = 0; i$8 < codecOptions.encodeSkipVals.length; i$8++) {
			var val = codecOptions.encodeSkipVals[i$8];
			if (typeof val === "number") skipEncodeChars[val] = true;
			else for (var j$7 = val.from; j$7 <= val.to; j$7++) skipEncodeChars[j$7] = true;
		}
		this._fillEncodeTable(0, 0, skipEncodeChars);
		if (codecOptions.encodeAdd) {
			for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
		}
		this.defCharSB = this.encodeTable[0][iconv$3.defaultCharSingleByte.charCodeAt(0)];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
		if (typeof codecOptions.gb18030 === "function") {
			this.gb18030 = codecOptions.gb18030();
			var thirdByteNodeIdx = this.decodeTables.length;
			var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
			var fourthByteNodeIdx = this.decodeTables.length;
			var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
			for (var i$8 = 129; i$8 <= 254; i$8++) {
				var secondByteNodeIdx = NODE_START - this.decodeTables[0][i$8];
				var secondByteNode = this.decodeTables[secondByteNodeIdx];
				for (var j$7 = 48; j$7 <= 57; j$7++) secondByteNode[j$7] = NODE_START - thirdByteNodeIdx;
			}
			for (var i$8 = 129; i$8 <= 254; i$8++) thirdByteNode[i$8] = NODE_START - fourthByteNodeIdx;
			for (var i$8 = 48; i$8 <= 57; i$8++) fourthByteNode[i$8] = GB18030_CODE;
		}
	}
	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
		var bytes$6 = [];
		for (; addr > 0; addr >>= 8) bytes$6.push(addr & 255);
		if (bytes$6.length == 0) bytes$6.push(0);
		var node$1 = this.decodeTables[0];
		for (var i$8 = bytes$6.length - 1; i$8 > 0; i$8--) {
			var val = node$1[bytes$6[i$8]];
			if (val == UNASSIGNED) {
				node$1[bytes$6[i$8]] = NODE_START - this.decodeTables.length;
				this.decodeTables.push(node$1 = UNASSIGNED_NODE.slice(0));
			} else if (val <= NODE_START) node$1 = this.decodeTables[NODE_START - val];
			else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
		}
		return node$1;
	};
	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
		var curAddr = parseInt(chunk[0], 16);
		var writeTable = this._getDecodeTrieNode(curAddr);
		curAddr = curAddr & 255;
		for (var k$7 = 1; k$7 < chunk.length; k$7++) {
			var part = chunk[k$7];
			if (typeof part === "string") for (var l = 0; l < part.length;) {
				var code$1 = part.charCodeAt(l++);
				if (55296 <= code$1 && code$1 < 56320) {
					var codeTrail = part.charCodeAt(l++);
					if (56320 <= codeTrail && codeTrail < 57344) writeTable[curAddr++] = 65536 + (code$1 - 55296) * 1024 + (codeTrail - 56320);
					else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
				} else if (4080 < code$1 && code$1 <= 4095) {
					var len$1 = 4095 - code$1 + 2;
					var seq = [];
					for (var m$3 = 0; m$3 < len$1; m$3++) seq.push(part.charCodeAt(l++));
					writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
					this.decodeTableSeq.push(seq);
				} else writeTable[curAddr++] = code$1;
			}
			else if (typeof part === "number") {
				var charCode = writeTable[curAddr - 1] + 1;
				for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
			} else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
		}
		if (curAddr > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
		var high = uCode >> 8;
		if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
		return this.encodeTable[high];
	};
	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
		else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
	};
	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
		var uCode = seq[0];
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		var node$1;
		if (bucket[low] <= SEQ_START) node$1 = this.encodeTableSeq[SEQ_START - bucket[low]];
		else {
			node$1 = {};
			if (bucket[low] !== UNASSIGNED) node$1[DEF_CHAR] = bucket[low];
			bucket[low] = SEQ_START - this.encodeTableSeq.length;
			this.encodeTableSeq.push(node$1);
		}
		for (var j$7 = 1; j$7 < seq.length - 1; j$7++) {
			var oldVal = node$1[uCode];
			if (typeof oldVal === "object") node$1 = oldVal;
			else {
				node$1 = node$1[uCode] = {};
				if (oldVal !== void 0) node$1[DEF_CHAR] = oldVal;
			}
		}
		uCode = seq[seq.length - 1];
		node$1[uCode] = dbcsCode;
	};
	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
		var node$1 = this.decodeTables[nodeIdx];
		for (var i$8 = 0; i$8 < 256; i$8++) {
			var uCode = node$1[i$8];
			var mbCode = prefix + i$8;
			if (skipEncodeChars[mbCode]) continue;
			if (uCode >= 0) this._setEncodeChar(uCode, mbCode);
			else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
			else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
		}
	};
	function DBCSEncoder(options, codec) {
		this.leadSurrogate = -1;
		this.seqObj = void 0;
		this.encodeTable = codec.encodeTable;
		this.encodeTableSeq = codec.encodeTableSeq;
		this.defaultCharSingleByte = codec.defCharSB;
		this.gb18030 = codec.gb18030;
	}
	DBCSEncoder.prototype.write = function(str) {
		var newBuf = Buffer$8.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i$8 = 0, j$7 = 0;
		while (true) {
			if (nextChar === -1) {
				if (i$8 == str.length) break;
				var uCode = str.charCodeAt(i$8++);
			} else {
				var uCode = nextChar;
				nextChar = -1;
			}
			if (55296 <= uCode && uCode < 57344) if (uCode < 56320) if (leadSurrogate === -1) {
				leadSurrogate = uCode;
				continue;
			} else {
				leadSurrogate = uCode;
				uCode = UNASSIGNED;
			}
			else if (leadSurrogate !== -1) {
				uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
				leadSurrogate = -1;
			} else uCode = UNASSIGNED;
			else if (leadSurrogate !== -1) {
				nextChar = uCode;
				uCode = UNASSIGNED;
				leadSurrogate = -1;
			}
			var dbcsCode = UNASSIGNED;
			if (seqObj !== void 0 && uCode != UNASSIGNED) {
				var resCode = seqObj[uCode];
				if (typeof resCode === "object") {
					seqObj = resCode;
					continue;
				} else if (typeof resCode == "number") dbcsCode = resCode;
				else if (resCode == void 0) {
					resCode = seqObj[DEF_CHAR];
					if (resCode !== void 0) {
						dbcsCode = resCode;
						nextChar = uCode;
					}
				}
				seqObj = void 0;
			} else if (uCode >= 0) {
				var subtable = this.encodeTable[uCode >> 8];
				if (subtable !== void 0) dbcsCode = subtable[uCode & 255];
				if (dbcsCode <= SEQ_START) {
					seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
					continue;
				}
				if (dbcsCode == UNASSIGNED && this.gb18030) {
					var idx = findIdx(this.gb18030.uChars, uCode);
					if (idx != -1) {
						var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
						newBuf[j$7++] = 129 + Math.floor(dbcsCode / 12600);
						dbcsCode = dbcsCode % 12600;
						newBuf[j$7++] = 48 + Math.floor(dbcsCode / 1260);
						dbcsCode = dbcsCode % 1260;
						newBuf[j$7++] = 129 + Math.floor(dbcsCode / 10);
						dbcsCode = dbcsCode % 10;
						newBuf[j$7++] = 48 + dbcsCode;
						continue;
					}
				}
			}
			if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
			if (dbcsCode < 256) newBuf[j$7++] = dbcsCode;
			else if (dbcsCode < 65536) {
				newBuf[j$7++] = dbcsCode >> 8;
				newBuf[j$7++] = dbcsCode & 255;
			} else {
				newBuf[j$7++] = dbcsCode >> 16;
				newBuf[j$7++] = dbcsCode >> 8 & 255;
				newBuf[j$7++] = dbcsCode & 255;
			}
		}
		this.seqObj = seqObj;
		this.leadSurrogate = leadSurrogate;
		return newBuf.slice(0, j$7);
	};
	DBCSEncoder.prototype.end = function() {
		if (this.leadSurrogate === -1 && this.seqObj === void 0) return;
		var newBuf = Buffer$8.alloc(10), j$7 = 0;
		if (this.seqObj) {
			var dbcsCode = this.seqObj[DEF_CHAR];
			if (dbcsCode !== void 0) if (dbcsCode < 256) newBuf[j$7++] = dbcsCode;
			else {
				newBuf[j$7++] = dbcsCode >> 8;
				newBuf[j$7++] = dbcsCode & 255;
			}
			this.seqObj = void 0;
		}
		if (this.leadSurrogate !== -1) {
			newBuf[j$7++] = this.defaultCharSingleByte;
			this.leadSurrogate = -1;
		}
		return newBuf.slice(0, j$7);
	};
	DBCSEncoder.prototype.findIdx = findIdx;
	function DBCSDecoder(options, codec) {
		this.nodeIdx = 0;
		this.prevBuf = Buffer$8.alloc(0);
		this.decodeTables = codec.decodeTables;
		this.decodeTableSeq = codec.decodeTableSeq;
		this.defaultCharUnicode = codec.defaultCharUnicode;
		this.gb18030 = codec.gb18030;
	}
	DBCSDecoder.prototype.write = function(buf) {
		var newBuf = Buffer$8.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
		if (prevBufOffset > 0) prevBuf = Buffer$8.concat([prevBuf, buf.slice(0, 10)]);
		for (var i$8 = 0, j$7 = 0; i$8 < buf.length; i$8++) {
			var curByte = i$8 >= 0 ? buf[i$8] : prevBuf[i$8 + prevBufOffset];
			var uCode = this.decodeTables[nodeIdx][curByte];
			if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
				i$8 = seqStart;
				uCode = this.defaultCharUnicode.charCodeAt(0);
			} else if (uCode === GB18030_CODE) {
				var curSeq = seqStart >= 0 ? buf.slice(seqStart, i$8 + 1) : prevBuf.slice(seqStart + prevBufOffset, i$8 + 1 + prevBufOffset);
				var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
				var idx = findIdx(this.gb18030.gbChars, ptr);
				uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
			} else if (uCode <= NODE_START) {
				nodeIdx = NODE_START - uCode;
				continue;
			} else if (uCode <= SEQ_START) {
				var seq = this.decodeTableSeq[SEQ_START - uCode];
				for (var k$7 = 0; k$7 < seq.length - 1; k$7++) {
					uCode = seq[k$7];
					newBuf[j$7++] = uCode & 255;
					newBuf[j$7++] = uCode >> 8;
				}
				uCode = seq[seq.length - 1];
			} else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
			if (uCode > 65535) {
				uCode -= 65536;
				var uCodeLead = 55296 + Math.floor(uCode / 1024);
				newBuf[j$7++] = uCodeLead & 255;
				newBuf[j$7++] = uCodeLead >> 8;
				uCode = 56320 + uCode % 1024;
			}
			newBuf[j$7++] = uCode & 255;
			newBuf[j$7++] = uCode >> 8;
			nodeIdx = 0;
			seqStart = i$8 + 1;
		}
		this.nodeIdx = nodeIdx;
		this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
		return newBuf.slice(0, j$7).toString("ucs2");
	};
	DBCSDecoder.prototype.end = function() {
		var ret = "";
		while (this.prevBuf.length > 0) {
			ret += this.defaultCharUnicode;
			var buf = this.prevBuf.slice(1);
			this.prevBuf = Buffer$8.alloc(0);
			this.nodeIdx = 0;
			if (buf.length > 0) ret += this.write(buf);
		}
		this.nodeIdx = 0;
		return ret;
	};
	function findIdx(table, val) {
		if (table[0] > val) return -1;
		var l = 0, r = table.length;
		while (l < r - 1) {
			var mid = l + Math.floor((r - l + 1) / 2);
			if (table[mid] <= val) l = mid;
			else r = mid;
		}
		return l;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/shiftjis.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			128
		],
		[
			"a1",
			"",
			62
		],
		[
			"8140",
			"",
			9,
			""
		],
		["8180", ""],
		["81b8", ""],
		["81c8", ""],
		["81da", ""],
		["81f0", ""],
		["81fc", ""],
		[
			"824f",
			"",
			9
		],
		[
			"8260",
			"",
			25
		],
		[
			"8281",
			"",
			25
		],
		[
			"829f",
			"",
			82
		],
		[
			"8340",
			"",
			62
		],
		[
			"8380",
			"",
			22
		],
		[
			"839f",
			"",
			16,
			"",
			6
		],
		[
			"83bf",
			"",
			16,
			"",
			6
		],
		[
			"8440",
			"",
			5,
			"",
			25
		],
		[
			"8470",
			"",
			5,
			"",
			7
		],
		[
			"8480",
			"",
			17
		],
		["849f", ""],
		[
			"8740",
			"",
			19,
			"",
			9
		],
		["875f", ""],
		["877e", ""],
		[
			"8780",
			"",
			4,
			""
		],
		["889f", ""],
		["8940", ""],
		["8980", ""],
		["8a40", ""],
		["8a80", ""],
		["8b40", ""],
		["8b80", ""],
		["8c40", ""],
		["8c80", ""],
		["8d40", ""],
		["8d80", ""],
		["8e40", ""],
		["8e80", ""],
		["8f40", ""],
		["8f80", ""],
		["9040", ""],
		["9080", ""],
		["9140", ""],
		["9180", ""],
		["9240", ""],
		["9280", ""],
		["9340", ""],
		["9380", ""],
		["9440", ""],
		["9480", ""],
		["9540", ""],
		["9580", ""],
		["9640", ""],
		["9680", ""],
		["9740", ""],
		["9780", ""],
		["9840", ""],
		["989f", ""],
		["9940", ""],
		["9980", ""],
		["9a40", ""],
		["9a80", ""],
		["9b40", ""],
		["9b80", ""],
		["9c40", ""],
		["9c80", ""],
		["9d40", ""],
		["9d80", ""],
		["9e40", ""],
		["9e80", ""],
		["9f40", ""],
		["9f80", ""],
		["e040", ""],
		["e080", ""],
		["e140", ""],
		["e180", ""],
		["e240", ""],
		["e280", ""],
		["e340", ""],
		["e380", ""],
		["e440", ""],
		["e480", ""],
		["e540", ""],
		["e580", ""],
		["e640", ""],
		["e680", ""],
		["e740", ""],
		["e780", ""],
		["e840", ""],
		["e880", ""],
		["e940", ""],
		["e980", ""],
		["ea40", ""],
		["ea80", ""],
		["ed40", ""],
		["ed80", ""],
		["ee40", ""],
		["ee80", ""],
		[
			"eeef",
			"",
			9,
			""
		],
		[
			"f040",
			"",
			62
		],
		[
			"f080",
			"",
			124
		],
		[
			"f140",
			"",
			62
		],
		[
			"f180",
			"",
			124
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			124
		],
		[
			"f340",
			"",
			62
		],
		[
			"f380",
			"",
			124
		],
		[
			"f440",
			"",
			62
		],
		[
			"f480",
			"",
			124
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			124
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			124
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			124
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			124
		],
		["f940", ""],
		[
			"fa40",
			"",
			9,
			"",
			9,
			""
		],
		["fa80", ""],
		["fb40", ""],
		["fb80", ""],
		["fc40", ""]
	];
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/eucjp.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8ea1",
			"",
			62
		],
		[
			"a1a1",
			"",
			9,
			""
		],
		["a2a1", ""],
		["a2ba", ""],
		["a2ca", ""],
		["a2dc", ""],
		["a2f2", ""],
		["a2fe", ""],
		[
			"a3b0",
			"",
			9
		],
		[
			"a3c1",
			"",
			25
		],
		[
			"a3e1",
			"",
			25
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		["a8a1", ""],
		[
			"ada1",
			"",
			19,
			"",
			9
		],
		["adc0", ""],
		[
			"addf",
			"",
			4,
			""
		],
		["b0a1", ""],
		["b1a1", ""],
		["b2a1", ""],
		["b3a1", ""],
		["b4a1", ""],
		["b5a1", ""],
		["b6a1", ""],
		["b7a1", ""],
		["b8a1", ""],
		["b9a1", ""],
		["baa1", ""],
		["bba1", ""],
		["bca1", ""],
		["bda1", ""],
		["bea1", ""],
		["bfa1", ""],
		["c0a1", ""],
		["c1a1", ""],
		["c2a1", ""],
		["c3a1", ""],
		["c4a1", ""],
		["c5a1", ""],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["c9a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		["d1a1", ""],
		["d2a1", ""],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		[
			"fcf1",
			"",
			9,
			""
		],
		["8fa2af", ""],
		["8fa2c2", ""],
		["8fa2eb", ""],
		["8fa6e1", ""],
		["8fa6e7", ""],
		["8fa6e9", ""],
		["8fa6ec", ""],
		["8fa6f1", ""],
		[
			"8fa7c2",
			"",
			10,
			""
		],
		[
			"8fa7f2",
			"",
			10,
			""
		],
		["8fa9a1", ""],
		["8fa9a4", ""],
		["8fa9a6", ""],
		["8fa9a8", ""],
		["8fa9ab", ""],
		["8fa9af", ""],
		["8fa9c1", ""],
		["8faaa1", ""],
		["8faaba", ""],
		["8faba1", ""],
		["8fabbd", ""],
		["8fabc5", ""],
		["8fb0a1", ""],
		["8fb1a1", ""],
		[
			"8fb2a1",
			"",
			4,
			""
		],
		["8fb3a1", ""],
		["8fb4a1", ""],
		["8fb5a1", ""],
		[
			"8fb6a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fb7a1",
			"",
			4,
			""
		],
		["8fb8a1", ""],
		["8fb9a1", ""],
		[
			"8fbaa1",
			"",
			4,
			""
		],
		["8fbba1", ""],
		[
			"8fbca1",
			"",
			4,
			""
		],
		[
			"8fbda1",
			"",
			4,
			""
		],
		[
			"8fbea1",
			"",
			4,
			""
		],
		["8fbfa1", ""],
		["8fc0a1", ""],
		["8fc1a1", ""],
		["8fc2a1", ""],
		[
			"8fc3a1",
			"",
			4,
			""
		],
		["8fc4a1", ""],
		["8fc5a1", ""],
		["8fc6a1", ""],
		["8fc7a1", ""],
		["8fc8a1", ""],
		[
			"8fc9a1",
			"",
			4,
			"",
			4,
			""
		],
		["8fcaa1", ""],
		["8fcba1", ""],
		[
			"8fcca1",
			"",
			9,
			""
		],
		[
			"8fcda1",
			"",
			5,
			""
		],
		[
			"8fcea1",
			"",
			6,
			""
		],
		["8fcfa1", ""],
		["8fd0a1", ""],
		["8fd1a1", ""],
		[
			"8fd2a1",
			"",
			5
		],
		["8fd3a1", ""],
		[
			"8fd4a1",
			"",
			4,
			""
		],
		["8fd5a1", ""],
		["8fd6a1", ""],
		["8fd7a1", ""],
		["8fd8a1", ""],
		[
			"8fd9a1",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8fdaa1",
			"",
			4,
			""
		],
		[
			"8fdba1",
			"",
			6,
			""
		],
		[
			"8fdca1",
			"",
			4,
			""
		],
		[
			"8fdda1",
			"",
			4,
			""
		],
		[
			"8fdea1",
			"",
			4,
			""
		],
		["8fdfa1", ""],
		["8fe0a1", ""],
		[
			"8fe1a1",
			"",
			4,
			""
		],
		["8fe2a1", ""],
		[
			"8fe3a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fe4a1",
			"",
			4,
			""
		],
		[
			"8fe5a1",
			"",
			4,
			""
		],
		["8fe6a1", ""],
		["8fe7a1", ""],
		[
			"8fe8a1",
			"",
			4,
			""
		],
		[
			"8fe9a1",
			"",
			4
		],
		[
			"8feaa1",
			"",
			4,
			""
		],
		[
			"8feba1",
			"",
			4,
			""
		],
		["8feca1", ""],
		[
			"8feda1",
			"",
			4,
			"",
			4,
			""
		]
	];
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127,
			""
		],
		[
			"8140",
			"",
			5,
			"",
			9,
			"",
			6,
			""
		],
		[
			"8180",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8240",
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			11
		],
		[
			"8280",
			"",
			10,
			"",
			4,
			"",
			7,
			"",
			5,
			"",
			8,
			"",
			20,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8340",
			"",
			17,
			"",
			5,
			"",
			10,
			"",
			4,
			"",
			9,
			""
		],
		[
			"8380",
			"",
			5,
			"",
			13,
			"",
			28,
			"",
			4,
			"",
			4,
			"",
			5
		],
		[
			"8440",
			"",
			5,
			"",
			5,
			""
		],
		[
			"8480",
			"",
			9,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			5,
			"",
			10,
			"",
			7,
			""
		],
		[
			"8540",
			"",
			9,
			""
		],
		[
			"8580",
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			""
		],
		[
			"8640",
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8680",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8740",
			"",
			7,
			"",
			11,
			"",
			4,
			"",
			4
		],
		[
			"8780",
			"",
			7,
			"",
			6,
			"",
			14,
			"",
			10,
			"",
			6,
			"",
			12,
			"",
			8,
			"",
			5,
			"",
			6
		],
		[
			"8840",
			"",
			9,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8880",
			"",
			4,
			"",
			6,
			"",
			8,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			7
		],
		[
			"8940",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			16,
			""
		],
		[
			"8980",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			17,
			"",
			10,
			"",
			13,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"8a40",
			"",
			4,
			"",
			12,
			""
		],
		[
			"8a80",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			9,
			"",
			5
		],
		[
			"8b40",
			"",
			8,
			"",
			17,
			"",
			6,
			"",
			13,
			""
		],
		[
			"8b80",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			22,
			"",
			11,
			"",
			25,
			"",
			7,
			"",
			6
		],
		[
			"8c40",
			"",
			7,
			""
		],
		[
			"8c80",
			"",
			8,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			4
		],
		[
			"8d40",
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			9,
			"",
			4
		],
		[
			"8d80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			10,
			"",
			12,
			"",
			21,
			""
		],
		[
			"8e40",
			"",
			21,
			"",
			12,
			"",
			6,
			"",
			12,
			""
		],
		[
			"8e80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			4,
			"",
			6
		],
		[
			"8f40",
			"",
			5,
			"",
			11,
			"",
			8,
			""
		],
		[
			"8f80",
			"",
			6,
			"",
			14,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9040",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9080",
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			18,
			"",
			6
		],
		[
			"9140",
			"",
			6,
			"",
			6,
			"",
			18,
			"",
			4,
			""
		],
		[
			"9180",
			"",
			6,
			"",
			8,
			"",
			9,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			16,
			"",
			13,
			"",
			8,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9280",
			"",
			5,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9340",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9380",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			9,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9440",
			"",
			24,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			8
		],
		[
			"9480",
			"",
			4,
			"",
			4,
			"",
			14,
			"",
			7,
			"",
			7,
			""
		],
		[
			"9540",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9580",
			"",
			4,
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			25,
			"",
			7,
			"",
			5,
			""
		],
		[
			"9640",
			"",
			5,
			"",
			4,
			""
		],
		[
			"9680",
			"",
			7,
			"",
			9,
			"",
			7,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			5
		],
		[
			"9740",
			"",
			7,
			"",
			8,
			"",
			7,
			"",
			9,
			""
		],
		[
			"9780",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			9,
			"",
			4,
			"",
			11,
			"",
			7,
			"",
			16,
			""
		],
		[
			"9840",
			"",
			4,
			"",
			5,
			"",
			9,
			""
		],
		[
			"9880",
			"",
			7,
			"",
			5,
			"",
			11,
			"",
			9,
			"",
			9,
			"",
			11,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9940",
			"",
			4,
			"",
			10,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			7,
			"",
			5
		],
		[
			"9980",
			"",
			114,
			"",
			6
		],
		[
			"9a40",
			"",
			11,
			"",
			7,
			"",
			13,
			""
		],
		[
			"9a80",
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"9b40",
			"",
			4,
			""
		],
		[
			"9b80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9c40",
			"",
			7,
			""
		],
		[
			"9c80",
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			14,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"9d40",
			"",
			7,
			"",
			4,
			"",
			9,
			"",
			6,
			""
		],
		[
			"9d80",
			"",
			9,
			"",
			5,
			"",
			6,
			"",
			12,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			10,
			""
		],
		[
			"9e40",
			"",
			7,
			"",
			32,
			"",
			7,
			"",
			6,
			"",
			6
		],
		[
			"9e80",
			"",
			9,
			"",
			17,
			"",
			13,
			"",
			11,
			"",
			12,
			"",
			12,
			""
		],
		[
			"9f40",
			"",
			6,
			"",
			10,
			"",
			4,
			"",
			10,
			"",
			7,
			""
		],
		[
			"9f80",
			"",
			13,
			"",
			12,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			8,
			"",
			9,
			"",
			4
		],
		[
			"a040",
			"",
			9,
			"",
			5,
			"",
			9,
			"",
			11,
			"",
			19
		],
		[
			"a080",
			"",
			9,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			11,
			"",
			6,
			""
		],
		[
			"a1a1",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9
		],
		[
			"a2b1",
			"",
			19,
			"",
			19,
			"",
			9
		],
		[
			"a2e5",
			"",
			9
		],
		[
			"a2f1",
			"",
			11
		],
		[
			"a3a1",
			"",
			88,
			""
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		["a6e0", ""],
		["a6ee", ""],
		["a6f4", ""],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		[
			"a840",
			"",
			35,
			"",
			6
		],
		[
			"a880",
			"",
			7,
			""
		],
		["a8a1", ""],
		["a8bd", ""],
		["a8c0", ""],
		[
			"a8c5",
			"",
			36
		],
		[
			"a940",
			"",
			8,
			""
		],
		["a959", ""],
		["a95c", ""],
		[
			"a960",
			"",
			9,
			"",
			8
		],
		[
			"a980",
			"",
			4,
			""
		],
		["a996", ""],
		[
			"a9a4",
			"",
			75
		],
		[
			"aa40",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"aa80",
			"",
			7,
			"",
			10,
			""
		],
		[
			"ab40",
			"",
			11,
			"",
			4,
			"",
			5,
			"",
			4
		],
		[
			"ab80",
			"",
			6,
			"",
			4
		],
		[
			"ac40",
			"",
			10,
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11
		],
		[
			"ac80",
			"",
			6,
			"",
			12,
			"",
			4,
			""
		],
		[
			"ad40",
			"",
			10,
			"",
			7,
			"",
			15,
			"",
			12
		],
		[
			"ad80",
			"",
			9,
			"",
			8,
			"",
			6,
			""
		],
		[
			"ae40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"ae80",
			"",
			7,
			"",
			6,
			"",
			4,
			""
		],
		[
			"af40",
			"",
			4,
			""
		],
		["af80", ""],
		[
			"b040",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			7,
			""
		],
		[
			"b080",
			"",
			7,
			"",
			8,
			"",
			9,
			""
		],
		[
			"b140",
			"",
			4,
			"",
			7,
			"",
			10,
			""
		],
		[
			"b180",
			"",
			4,
			"",
			7,
			"",
			7,
			""
		],
		[
			"b240",
			"",
			11,
			"",
			5,
			"",
			11,
			"",
			4
		],
		[
			"b280",
			"",
			12,
			"",
			8,
			"",
			4,
			""
		],
		[
			"b340",
			"",
			5,
			""
		],
		[
			"b380",
			"",
			11,
			"",
			7,
			"",
			6,
			""
		],
		[
			"b440",
			"",
			7,
			"",
			9
		],
		[
			"b480",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"b540",
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			8,
			""
		],
		[
			"b580",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b640",
			"",
			6,
			"",
			11,
			"",
			10,
			"",
			4,
			"",
			5,
			""
		],
		[
			"b680",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b740",
			"",
			14,
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			16
		],
		[
			"b780",
			"",
			6,
			""
		],
		[
			"b840",
			"",
			4,
			"",
			10,
			"",
			10,
			"",
			9,
			"",
			5,
			""
		],
		[
			"b880",
			"",
			4,
			""
		],
		[
			"b940",
			"",
			5,
			"",
			10,
			"",
			6,
			""
		],
		[
			"b980",
			"",
			7,
			""
		],
		[
			"ba40",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			5,
			""
		],
		[
			"ba80",
			"",
			4,
			"",
			5,
			"",
			12,
			"",
			5,
			""
		],
		[
			"bb40",
			"",
			9,
			"",
			36,
			"",
			5,
			"",
			9
		],
		[
			"bb80",
			"",
			6,
			"",
			4,
			""
		],
		[
			"bc40",
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			13,
			"",
			5
		],
		[
			"bc80",
			"",
			14,
			"",
			6,
			""
		],
		[
			"bd40",
			"",
			54,
			"",
			7
		],
		[
			"bd80",
			"",
			32,
			""
		],
		[
			"be40",
			"",
			12,
			"",
			6,
			"",
			42
		],
		[
			"be80",
			"",
			32,
			""
		],
		[
			"bf40",
			"",
			62
		],
		[
			"bf80",
			"",
			4,
			"",
			4,
			"",
			21,
			""
		],
		[
			"c040",
			"",
			35,
			"",
			23,
			""
		],
		[
			"c080",
			"",
			6,
			"",
			9,
			""
		],
		[
			"c140",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c180",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c280",
			"",
			13,
			"",
			5,
			"",
			11,
			""
		],
		[
			"c340",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c380",
			"",
			12,
			"",
			4,
			""
		],
		[
			"c440",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"c480",
			"",
			7,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c540",
			"",
			14,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c580",
			"",
			7,
			"",
			7,
			""
		],
		["c640", ""],
		[
			"c680",
			"",
			4,
			"",
			9,
			""
		],
		[
			"c740",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		["c780", ""],
		[
			"c840",
			"",
			4,
			"",
			5,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c880",
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"c940",
			"",
			4,
			"",
			7,
			"",
			12,
			""
		],
		[
			"c980",
			"",
			4,
			"",
			4,
			"",
			10,
			""
		],
		[
			"ca40",
			"",
			8,
			"",
			8,
			"",
			9,
			"",
			4,
			"",
			10
		],
		[
			"ca80",
			"",
			4,
			"",
			8,
			""
		],
		[
			"cb40",
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cb80",
			"",
			5,
			"",
			6,
			"",
			14,
			""
		],
		[
			"cc40",
			"",
			4,
			"",
			10,
			"",
			15,
			"",
			13,
			""
		],
		[
			"cc80",
			"",
			11,
			"",
			4,
			"",
			7,
			""
		],
		[
			"cd40",
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			""
		],
		["cd80", ""],
		[
			"ce40",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"ce80",
			"",
			4,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cf40",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			9
		],
		[
			"cf80",
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"d040",
			"",
			13,
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"d080",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"d140",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"d180",
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"d240",
			"",
			8,
			"",
			24,
			"",
			5,
			"",
			19,
			""
		],
		[
			"d280",
			"",
			26,
			""
		],
		[
			"d340",
			"",
			30,
			"",
			6
		],
		[
			"d380",
			"",
			4,
			"",
			5,
			"",
			21,
			""
		],
		[
			"d440",
			"",
			31,
			"",
			8,
			"",
			21
		],
		[
			"d480",
			"",
			25,
			"",
			6,
			""
		],
		[
			"d540",
			"",
			7,
			"",
			7,
			"",
			46
		],
		[
			"d580",
			"",
			32,
			""
		],
		[
			"d640",
			"",
			34,
			"",
			27
		],
		[
			"d680",
			"",
			30,
			""
		],
		[
			"d740",
			"",
			31,
			"",
			4,
			"",
			25
		],
		[
			"d780",
			"",
			24,
			""
		],
		[
			"d840",
			"",
			8,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		[
			"d880",
			"",
			6,
			"",
			20,
			""
		],
		[
			"d940",
			"",
			62
		],
		[
			"d980",
			"",
			32,
			""
		],
		[
			"da40",
			"",
			14,
			"",
			8,
			"",
			4,
			"",
			9,
			""
		],
		[
			"da80",
			"",
			12,
			""
		],
		[
			"db40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"db80",
			"",
			4,
			"",
			5,
			"",
			11,
			""
		],
		[
			"dc40",
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			11,
			"",
			6,
			"",
			7
		],
		[
			"dc80",
			"",
			10,
			"",
			21,
			""
		],
		[
			"dd40",
			"",
			62
		],
		[
			"dd80",
			"",
			32,
			""
		],
		[
			"de40",
			"",
			32,
			""
		],
		[
			"de80",
			"",
			4,
			""
		],
		[
			"df40",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"df80",
			"",
			4,
			""
		],
		[
			"e040",
			"",
			19,
			""
		],
		[
			"e080",
			"",
			10,
			"",
			6,
			"",
			8,
			""
		],
		[
			"e140",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			""
		],
		[
			"e180",
			"",
			10,
			"",
			9,
			"",
			8,
			""
		],
		[
			"e240",
			"",
			62
		],
		[
			"e280",
			"",
			32,
			"",
			5,
			""
		],
		[
			"e340",
			"",
			45,
			"",
			16
		],
		[
			"e380",
			"",
			7,
			"",
			24,
			""
		],
		[
			"e440",
			"",
			5,
			"",
			24,
			"",
			31
		],
		[
			"e480",
			"",
			32,
			""
		],
		[
			"e540",
			"",
			51,
			"",
			10
		],
		[
			"e580",
			"",
			31,
			""
		],
		[
			"e640",
			"",
			34,
			"",
			27
		],
		[
			"e680",
			"",
			29,
			""
		],
		[
			"e740",
			"",
			7,
			"",
			54
		],
		[
			"e780",
			"",
			32,
			"",
			6,
			"",
			4,
			""
		],
		[
			"e840",
			"",
			14,
			"",
			43,
			""
		],
		[
			"e880",
			"",
			20,
			""
		],
		[
			"e940",
			"",
			7,
			"",
			42
		],
		[
			"e980",
			"",
			32,
			""
		],
		[
			"ea40",
			"",
			27,
			"",
			6,
			""
		],
		[
			"ea80",
			"",
			4,
			"",
			12,
			""
		],
		[
			"eb40",
			"",
			9,
			"",
			7,
			"",
			9,
			"",
			6,
			""
		],
		[
			"eb80",
			"",
			4,
			""
		],
		[
			"ec40",
			"",
			8,
			"",
			4,
			"",
			18,
			"",
			7
		],
		[
			"ec80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ed40",
			"",
			6,
			"",
			46
		],
		[
			"ed80",
			"",
			4,
			"",
			23,
			""
		],
		[
			"ee40",
			"",
			62
		],
		[
			"ee80",
			"",
			32,
			"",
			4,
			"",
			6,
			""
		],
		[
			"ef40",
			"",
			5,
			"",
			37,
			"",
			4
		],
		[
			"ef80",
			"",
			30,
			"",
			4,
			"",
			8,
			""
		],
		[
			"f040",
			"",
			4,
			"",
			28,
			"",
			26
		],
		[
			"f080",
			"",
			9,
			"",
			12,
			"",
			4,
			"",
			6,
			""
		],
		[
			"f140",
			"",
			10,
			"",
			47
		],
		[
			"f180",
			"",
			32,
			""
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			32,
			""
		],
		[
			"f340",
			"",
			17,
			"",
			6,
			"",
			4,
			""
		],
		[
			"f380",
			"",
			8,
			"",
			6,
			""
		],
		[
			"f440",
			"",
			5,
			"",
			10,
			"",
			10,
			"",
			7,
			"",
			5
		],
		[
			"f480",
			"",
			32,
			""
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			32,
			""
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			32,
			"",
			5,
			"",
			5,
			"",
			4,
			"",
			7,
			""
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			4,
			"",
			4,
			""
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			32
		],
		[
			"f940",
			"",
			62
		],
		[
			"f980",
			"",
			32
		],
		[
			"fa40",
			"",
			62
		],
		[
			"fa80",
			"",
			32
		],
		[
			"fb40",
			"",
			27,
			"",
			9,
			""
		],
		[
			"fb80",
			"",
			5,
			"",
			8,
			"",
			5,
			""
		],
		[
			"fc40",
			"",
			8,
			"",
			4,
			"",
			8,
			"",
			6
		],
		[
			"fc80",
			"",
			4,
			"",
			5,
			"",
			8,
			""
		],
		[
			"fd40",
			"",
			4,
			"",
			4,
			"",
			10,
			"",
			38
		],
		[
			"fd80",
			"",
			5,
			"",
			11,
			"",
			4,
			""
		],
		["fe40", ""]
	];
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json": ((exports, module) => {
	module.exports = [
		[
			"a140",
			"",
			62
		],
		[
			"a180",
			"",
			32
		],
		[
			"a240",
			"",
			62
		],
		[
			"a280",
			"",
			32
		],
		[
			"a2ab",
			"",
			5
		],
		["a2e3", ""],
		["a2ef", ""],
		["a2fd", ""],
		[
			"a340",
			"",
			62
		],
		[
			"a380",
			"",
			31,
			""
		],
		[
			"a440",
			"",
			62
		],
		[
			"a480",
			"",
			32
		],
		[
			"a4f4",
			"",
			10
		],
		[
			"a540",
			"",
			62
		],
		[
			"a580",
			"",
			32
		],
		[
			"a5f7",
			"",
			7
		],
		[
			"a640",
			"",
			62
		],
		[
			"a680",
			"",
			32
		],
		[
			"a6b9",
			"",
			7
		],
		[
			"a6d9",
			"",
			6
		],
		["a6ec", ""],
		["a6f3", ""],
		[
			"a6f6",
			"",
			8
		],
		[
			"a740",
			"",
			62
		],
		[
			"a780",
			"",
			32
		],
		[
			"a7c2",
			"",
			14
		],
		[
			"a7f2",
			"",
			12
		],
		[
			"a896",
			"",
			10
		],
		["a8bc", ""],
		["a8bf", ""],
		["a8c1", ""],
		[
			"a8ea",
			"",
			20
		],
		["a958", ""],
		["a95b", ""],
		["a95d", ""],
		[
			"a989",
			"",
			11
		],
		[
			"a997",
			"",
			12
		],
		[
			"a9f0",
			"",
			14
		],
		[
			"aaa1",
			"",
			93
		],
		[
			"aba1",
			"",
			93
		],
		[
			"aca1",
			"",
			93
		],
		[
			"ada1",
			"",
			93
		],
		[
			"aea1",
			"",
			93
		],
		[
			"afa1",
			"",
			93
		],
		[
			"d7fa",
			"",
			4
		],
		[
			"f8a1",
			"",
			93
		],
		[
			"f9a1",
			"",
			93
		],
		[
			"faa1",
			"",
			93
		],
		[
			"fba1",
			"",
			93
		],
		[
			"fca1",
			"",
			93
		],
		[
			"fda1",
			"",
			93
		],
		["fe50", ""],
		[
			"fe80",
			"",
			6,
			"",
			93
		]
	];
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json": ((exports, module) => {
	module.exports = {
		"uChars": [
			128,
			165,
			169,
			178,
			184,
			216,
			226,
			235,
			238,
			244,
			248,
			251,
			253,
			258,
			276,
			284,
			300,
			325,
			329,
			334,
			364,
			463,
			465,
			467,
			469,
			471,
			473,
			475,
			477,
			506,
			594,
			610,
			712,
			716,
			730,
			930,
			938,
			962,
			970,
			1026,
			1104,
			1106,
			8209,
			8215,
			8218,
			8222,
			8231,
			8241,
			8244,
			8246,
			8252,
			8365,
			8452,
			8454,
			8458,
			8471,
			8482,
			8556,
			8570,
			8596,
			8602,
			8713,
			8720,
			8722,
			8726,
			8731,
			8737,
			8740,
			8742,
			8748,
			8751,
			8760,
			8766,
			8777,
			8781,
			8787,
			8802,
			8808,
			8816,
			8854,
			8858,
			8870,
			8896,
			8979,
			9322,
			9372,
			9548,
			9588,
			9616,
			9622,
			9634,
			9652,
			9662,
			9672,
			9676,
			9680,
			9702,
			9735,
			9738,
			9793,
			9795,
			11906,
			11909,
			11913,
			11917,
			11928,
			11944,
			11947,
			11951,
			11956,
			11960,
			11964,
			11979,
			12284,
			12292,
			12312,
			12319,
			12330,
			12351,
			12436,
			12447,
			12535,
			12543,
			12586,
			12842,
			12850,
			12964,
			13200,
			13215,
			13218,
			13253,
			13263,
			13267,
			13270,
			13384,
			13428,
			13727,
			13839,
			13851,
			14617,
			14703,
			14801,
			14816,
			14964,
			15183,
			15471,
			15585,
			16471,
			16736,
			17208,
			17325,
			17330,
			17374,
			17623,
			17997,
			18018,
			18212,
			18218,
			18301,
			18318,
			18760,
			18811,
			18814,
			18820,
			18823,
			18844,
			18848,
			18872,
			19576,
			19620,
			19738,
			19887,
			40870,
			59244,
			59336,
			59367,
			59413,
			59417,
			59423,
			59431,
			59437,
			59443,
			59452,
			59460,
			59478,
			59493,
			63789,
			63866,
			63894,
			63976,
			63986,
			64016,
			64018,
			64021,
			64025,
			64034,
			64037,
			64042,
			65074,
			65093,
			65107,
			65112,
			65127,
			65132,
			65375,
			65510,
			65536
		],
		"gbChars": [
			0,
			36,
			38,
			45,
			50,
			81,
			89,
			95,
			96,
			100,
			103,
			104,
			105,
			109,
			126,
			133,
			148,
			172,
			175,
			179,
			208,
			306,
			307,
			308,
			309,
			310,
			311,
			312,
			313,
			341,
			428,
			443,
			544,
			545,
			558,
			741,
			742,
			749,
			750,
			805,
			819,
			820,
			7922,
			7924,
			7925,
			7927,
			7934,
			7943,
			7944,
			7945,
			7950,
			8062,
			8148,
			8149,
			8152,
			8164,
			8174,
			8236,
			8240,
			8262,
			8264,
			8374,
			8380,
			8381,
			8384,
			8388,
			8390,
			8392,
			8393,
			8394,
			8396,
			8401,
			8406,
			8416,
			8419,
			8424,
			8437,
			8439,
			8445,
			8482,
			8485,
			8496,
			8521,
			8603,
			8936,
			8946,
			9046,
			9050,
			9063,
			9066,
			9076,
			9092,
			9100,
			9108,
			9111,
			9113,
			9131,
			9162,
			9164,
			9218,
			9219,
			11329,
			11331,
			11334,
			11336,
			11346,
			11361,
			11363,
			11366,
			11370,
			11372,
			11375,
			11389,
			11682,
			11686,
			11687,
			11692,
			11694,
			11714,
			11716,
			11723,
			11725,
			11730,
			11736,
			11982,
			11989,
			12102,
			12336,
			12348,
			12350,
			12384,
			12393,
			12395,
			12397,
			12510,
			12553,
			12851,
			12962,
			12973,
			13738,
			13823,
			13919,
			13933,
			14080,
			14298,
			14585,
			14698,
			15583,
			15847,
			16318,
			16434,
			16438,
			16481,
			16729,
			17102,
			17122,
			17315,
			17320,
			17402,
			17418,
			17859,
			17909,
			17911,
			17915,
			17916,
			17936,
			17939,
			17961,
			18664,
			18703,
			18814,
			18962,
			19043,
			33469,
			33470,
			33471,
			33484,
			33485,
			33490,
			33497,
			33501,
			33505,
			33513,
			33520,
			33536,
			33550,
			37845,
			37921,
			37948,
			38029,
			38038,
			38064,
			38065,
			38066,
			38069,
			38075,
			38076,
			38078,
			39108,
			39109,
			39113,
			39114,
			39115,
			39116,
			39265,
			39394,
			189e3
		]
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp949.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8141",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8161",
			"",
			9,
			"",
			5,
			""
		],
		[
			"8181",
			"",
			18,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8241",
			"",
			7,
			"",
			5
		],
		[
			"8261",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8281",
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			17,
			"",
			7,
			"",
			6,
			"",
			7,
			"",
			18
		],
		[
			"8341",
			"",
			5,
			"",
			5,
			"",
			7
		],
		[
			"8361",
			"",
			18,
			""
		],
		[
			"8381",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			46,
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8441",
			"",
			5,
			"",
			8
		],
		[
			"8461",
			"",
			18
		],
		[
			"8481",
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			18,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8541",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4
		],
		[
			"8561",
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8581",
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			29,
			"",
			6,
			"",
			5,
			""
		],
		[
			"8641",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8661",
			"",
			6,
			"",
			10
		],
		[
			"8681",
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			22,
			"",
			4,
			""
		],
		[
			"8741",
			"",
			9,
			"",
			15
		],
		[
			"8761",
			"",
			18,
			""
		],
		[
			"8781",
			"",
			5,
			"",
			7,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			4
		],
		[
			"8841",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"8861",
			"",
			4,
			""
		],
		[
			"8881",
			"",
			15,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			54,
			""
		],
		[
			"8941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8961",
			"",
			10,
			"",
			5,
			""
		],
		[
			"8981",
			"",
			21,
			"",
			18,
			"",
			18,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			15
		],
		[
			"8a41",
			"",
			10,
			"",
			6,
			""
		],
		[
			"8a61",
			"",
			4,
			"",
			18,
			""
		],
		[
			"8a81",
			"",
			4,
			"",
			19,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8b41",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8b61",
			"",
			6,
			"",
			8
		],
		[
			"8b81",
			"",
			52,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			18
		],
		[
			"8c41",
			"",
			15,
			"",
			4
		],
		[
			"8c61",
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"8c81",
			"",
			12,
			"",
			26,
			"",
			50,
			"",
			5,
			"",
			16
		],
		[
			"8d41",
			"",
			16,
			"",
			8
		],
		[
			"8d61",
			"",
			17,
			""
		],
		[
			"8d81",
			"",
			4,
			"",
			33,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			9,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8e41",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8e61",
			"",
			4,
			"",
			19
		],
		[
			"8e81",
			"",
			13,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			11,
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"8f41",
			"",
			7,
			"",
			17
		],
		[
			"8f61",
			"",
			7,
			"",
			6,
			"",
			4
		],
		[
			"8f81",
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			5
		],
		[
			"9041",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9061",
			"",
			5,
			"",
			15
		],
		[
			"9081",
			"",
			12,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			11,
			"",
			33,
			""
		],
		[
			"9141",
			"",
			6,
			"",
			5
		],
		[
			"9161",
			"",
			9,
			"",
			5
		],
		[
			"9181",
			"",
			20,
			"",
			4,
			"",
			5,
			"",
			14,
			"",
			33,
			"",
			7,
			"",
			5,
			"",
			6
		],
		[
			"9241",
			"",
			7,
			"",
			4,
			""
		],
		[
			"9261",
			"",
			7,
			"",
			7,
			"",
			4
		],
		[
			"9281",
			"",
			21,
			"",
			18,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			35,
			""
		],
		[
			"9341",
			"",
			4,
			""
		],
		[
			"9361",
			"",
			6,
			"",
			8
		],
		[
			"9381",
			"",
			37,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			22,
			""
		],
		[
			"9441",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"9461",
			"",
			5,
			"",
			6,
			"",
			12
		],
		[
			"9481",
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			24
		],
		[
			"9541",
			"",
			11,
			"",
			5,
			""
		],
		[
			"9561",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9581",
			"",
			6,
			"",
			35,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			13,
			"",
			14
		],
		[
			"9641",
			"",
			23,
			""
		],
		[
			"9661",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"9681",
			"",
			10,
			"",
			5,
			"",
			13,
			"",
			33,
			"",
			6,
			"",
			44
		],
		[
			"9741",
			"",
			16,
			"",
			8
		],
		[
			"9761",
			"",
			17,
			"",
			7
		],
		[
			"9781",
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			89,
			""
		],
		[
			"9841",
			"",
			16,
			"",
			5,
			""
		],
		[
			"9861",
			"",
			6,
			"",
			15
		],
		[
			"9881",
			"",
			21,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9961",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9981",
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9a41",
			"",
			16
		],
		[
			"9a61",
			"",
			6,
			"",
			6,
			""
		],
		[
			"9a81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			33,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9b41",
			"",
			6,
			"",
			8
		],
		[
			"9b61",
			"",
			17,
			"",
			7
		],
		[
			"9b81",
			"",
			25,
			"",
			4,
			"",
			5,
			"",
			50,
			"",
			22,
			""
		],
		[
			"9c41",
			"",
			4,
			"",
			5,
			"",
			5
		],
		[
			"9c61",
			"",
			8,
			"",
			6,
			"",
			9
		],
		[
			"9c81",
			"",
			8,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			12
		],
		[
			"9d41",
			"",
			13,
			"",
			8
		],
		[
			"9d61",
			"",
			25
		],
		[
			"9d81",
			"",
			8,
			"",
			5,
			"",
			9,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9e41",
			"",
			7,
			"",
			9,
			""
		],
		[
			"9e61",
			"",
			4,
			"",
			6,
			""
		],
		[
			"9e81",
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9f41",
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9f61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9f81",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"a041",
			"",
			5,
			"",
			6,
			""
		],
		[
			"a061",
			"",
			5,
			"",
			13
		],
		[
			"a081",
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			"",
			4,
			"",
			5,
			"",
			7,
			""
		],
		[
			"a141",
			"",
			18,
			""
		],
		[
			"a161",
			"",
			6,
			"",
			5,
			""
		],
		[
			"a181",
			"",
			14,
			"",
			5,
			"",
			4,
			"",
			9,
			""
		],
		[
			"a241",
			"",
			5,
			"",
			18
		],
		[
			"a261",
			"",
			6,
			"",
			18
		],
		[
			"a281",
			"",
			7,
			"",
			6,
			"",
			7,
			""
		],
		[
			"a341",
			"",
			6,
			"",
			10,
			""
		],
		[
			"a361",
			"",
			6,
			"",
			16
		],
		[
			"a381",
			"",
			16,
			"",
			4,
			"",
			58,
			"",
			32,
			""
		],
		[
			"a441",
			"",
			5,
			""
		],
		[
			"a461",
			"",
			5,
			"",
			12
		],
		[
			"a481",
			"",
			28,
			"",
			93
		],
		[
			"a541",
			"",
			4,
			"",
			6,
			"",
			5,
			""
		],
		[
			"a561",
			"",
			17,
			"",
			5,
			""
		],
		[
			"a581",
			"",
			16,
			"",
			14,
			"",
			9
		],
		[
			"a5b0",
			"",
			9
		],
		[
			"a5c1",
			"",
			16,
			"",
			6
		],
		[
			"a5e1",
			"",
			16,
			"",
			6
		],
		[
			"a641",
			"",
			19,
			""
		],
		[
			"a661",
			"",
			5,
			"",
			5,
			"",
			6
		],
		[
			"a681",
			"",
			6,
			"",
			18,
			"",
			7
		],
		[
			"a741",
			"",
			4,
			"",
			6,
			"",
			7
		],
		[
			"a761",
			"",
			22,
			""
		],
		[
			"a781",
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			9,
			"",
			9,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"a841",
			"",
			10,
			"",
			14
		],
		[
			"a861",
			"",
			18,
			"",
			6
		],
		[
			"a881",
			"",
			19,
			"",
			11,
			""
		],
		["a8a6", ""],
		["a8a8", ""],
		[
			"a8b1",
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"a941",
			"",
			14,
			"",
			10
		],
		[
			"a961",
			"",
			18
		],
		[
			"a981",
			"",
			14,
			"",
			6,
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"aa41",
			"",
			6,
			"",
			4,
			""
		],
		[
			"aa61",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"aa81",
			"",
			29,
			"",
			82
		],
		[
			"ab41",
			"",
			6,
			"",
			5,
			""
		],
		[
			"ab61",
			"",
			6,
			"",
			5,
			"",
			5
		],
		[
			"ab81",
			"",
			8,
			"",
			6,
			"",
			12,
			"",
			85
		],
		[
			"ac41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ac61",
			"",
			11,
			"",
			4
		],
		[
			"ac81",
			"",
			28,
			"",
			5,
			"",
			25
		],
		[
			"acd1",
			"",
			5,
			"",
			25
		],
		[
			"ad41",
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"ad61",
			"",
			6,
			"",
			10,
			""
		],
		[
			"ad81",
			"",
			5,
			"",
			18,
			""
		],
		[
			"ae41",
			"",
			5,
			"",
			16
		],
		[
			"ae61",
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"ae81",
			"",
			6,
			"",
			5,
			""
		],
		[
			"af41",
			"",
			19
		],
		[
			"af61",
			"",
			13,
			"",
			5,
			""
		],
		[
			"af81",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b041",
			"",
			5,
			"",
			5,
			"",
			12
		],
		[
			"b061",
			"",
			5,
			"",
			19
		],
		[
			"b081",
			"",
			13,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"b141",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b161",
			"",
			6,
			"",
			5,
			"",
			11
		],
		[
			"b181",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b241",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b261",
			"",
			18,
			"",
			5,
			""
		],
		[
			"b281",
			"",
			5,
			"",
			18,
			"",
			6,
			""
		],
		[
			"b341",
			"",
			19,
			""
		],
		[
			"b361",
			"",
			5,
			"",
			5,
			"",
			5
		],
		[
			"b381",
			"",
			5,
			"",
			5,
			"",
			19,
			"",
			4,
			""
		],
		[
			"b441",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"b461",
			"",
			6,
			"",
			10,
			""
		],
		[
			"b481",
			"",
			6,
			"",
			18,
			"",
			4,
			"",
			4,
			""
		],
		[
			"b541",
			"",
			14,
			"",
			5
		],
		[
			"b561",
			"",
			5,
			"",
			5,
			"",
			4
		],
		[
			"b581",
			"",
			6,
			"",
			5,
			"",
			11,
			""
		],
		[
			"b641",
			"",
			7,
			"",
			17
		],
		[
			"b661",
			"",
			15,
			""
		],
		[
			"b681",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b741",
			"",
			13,
			"",
			6,
			""
		],
		[
			"b761",
			"",
			20,
			""
		],
		[
			"b781",
			"",
			6,
			"",
			14,
			""
		],
		[
			"b841",
			"",
			7,
			"",
			17
		],
		[
			"b861",
			"",
			8,
			"",
			13
		],
		[
			"b881",
			"",
			5,
			"",
			24,
			"",
			4,
			""
		],
		[
			"b941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b961",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b981",
			"",
			22,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ba41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ba61",
			"",
			5,
			"",
			4,
			"",
			5
		],
		[
			"ba81",
			"",
			6,
			"",
			9,
			""
		],
		[
			"bb41",
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bb61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"bb81",
			"",
			31,
			""
		],
		[
			"bc41",
			"",
			17,
			""
		],
		[
			"bc61",
			"",
			5,
			"",
			6,
			""
		],
		[
			"bc81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bd41",
			"",
			7,
			"",
			7,
			""
		],
		[
			"bd61",
			"",
			5,
			"",
			13
		],
		[
			"bd81",
			"",
			5,
			"",
			25,
			""
		],
		[
			"be41",
			"",
			7,
			"",
			14
		],
		[
			"be61",
			"",
			7,
			"",
			7,
			""
		],
		[
			"be81",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			8,
			"",
			6,
			""
		],
		[
			"bf41",
			"",
			10,
			"",
			14
		],
		[
			"bf61",
			"",
			18,
			""
		],
		[
			"bf81",
			"",
			5,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"c041",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"c061",
			"",
			25
		],
		[
			"c081",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c141",
			"",
			5,
			"",
			6,
			""
		],
		[
			"c161",
			"",
			19,
			""
		],
		[
			"c181",
			"",
			31,
			""
		],
		[
			"c241",
			"",
			4,
			"",
			5,
			""
		],
		[
			"c261",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c281",
			"",
			5,
			"",
			7,
			"",
			9,
			""
		],
		[
			"c341",
			"",
			4
		],
		[
			"c361",
			"",
			4,
			"",
			5,
			"",
			11
		],
		[
			"c381",
			"",
			5,
			"",
			7,
			"",
			5,
			""
		],
		[
			"c441",
			"",
			7,
			"",
			7,
			""
		],
		[
			"c461",
			"",
			5,
			"",
			4
		],
		[
			"c481",
			"",
			5,
			"",
			11,
			""
		],
		[
			"c541",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c561",
			"",
			6,
			"",
			5,
			"",
			4
		],
		[
			"c581",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c641",
			"",
			6,
			"",
			5
		],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		[
			"d1a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"d2a1",
			"",
			4,
			"",
			5,
			"",
			10,
			"",
			7,
			"",
			5,
			""
		],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f5a1", ""],
		["f6a1", ""],
		["f7a1", ""],
		["f8a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		["fda1", ""]
	];
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		["a140", ""],
		[
			"a1a1",
			"",
			4,
			""
		],
		[
			"a240",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9,
			"",
			9,
			"",
			8,
			"",
			25,
			"",
			21
		],
		[
			"a340",
			"",
			16,
			"",
			6,
			"",
			16,
			"",
			6,
			"",
			10
		],
		[
			"a3a1",
			"",
			25,
			""
		],
		["a3e1", ""],
		["a440", ""],
		["a4a1", ""],
		["a540", ""],
		["a5a1", ""],
		["a640", ""],
		["a6a1", ""],
		["a740", ""],
		["a7a1", ""],
		["a840", ""],
		["a8a1", ""],
		["a940", ""],
		["a9a1", ""],
		["aa40", ""],
		["aaa1", ""],
		["ab40", ""],
		["aba1", ""],
		["ac40", ""],
		["aca1", ""],
		["ad40", ""],
		["ada1", ""],
		["ae40", ""],
		["aea1", ""],
		["af40", ""],
		["afa1", ""],
		["b040", ""],
		["b0a1", ""],
		["b140", ""],
		["b1a1", ""],
		["b240", ""],
		["b2a1", ""],
		["b340", ""],
		["b3a1", ""],
		["b440", ""],
		["b4a1", ""],
		["b540", ""],
		["b5a1", ""],
		["b640", ""],
		["b6a1", ""],
		["b740", ""],
		["b7a1", ""],
		["b840", ""],
		["b8a1", ""],
		["b940", ""],
		["b9a1", ""],
		["ba40", ""],
		["baa1", ""],
		["bb40", ""],
		["bba1", ""],
		["bc40", ""],
		["bca1", ""],
		["bd40", ""],
		["bda1", ""],
		["be40", ""],
		["bea1", ""],
		["bf40", ""],
		["bfa1", ""],
		["c040", ""],
		["c0a1", ""],
		["c140", ""],
		["c1a1", ""],
		["c240", ""],
		["c2a1", ""],
		["c340", ""],
		["c3a1", ""],
		["c440", ""],
		["c4a1", ""],
		["c540", ""],
		["c5a1", ""],
		["c640", ""],
		["c940", ""],
		["c9a1", ""],
		["ca40", ""],
		["caa1", ""],
		["cb40", ""],
		["cba1", ""],
		["cc40", ""],
		["cca1", ""],
		["cd40", ""],
		["cda1", ""],
		["ce40", ""],
		["cea1", ""],
		["cf40", ""],
		["cfa1", ""],
		["d040", ""],
		["d0a1", ""],
		["d140", ""],
		["d1a1", ""],
		["d240", ""],
		["d2a1", ""],
		["d340", ""],
		["d3a1", ""],
		["d440", ""],
		["d4a1", ""],
		["d540", ""],
		["d5a1", ""],
		["d640", ""],
		["d6a1", ""],
		["d740", ""],
		["d7a1", ""],
		["d840", ""],
		["d8a1", ""],
		["d940", ""],
		["d9a1", ""],
		["da40", ""],
		["daa1", ""],
		["db40", ""],
		["dba1", ""],
		["dc40", ""],
		["dca1", ""],
		["dd40", ""],
		["dda1", ""],
		["de40", ""],
		["dea1", ""],
		["df40", ""],
		["dfa1", ""],
		["e040", ""],
		["e0a1", ""],
		["e140", ""],
		["e1a1", ""],
		["e240", ""],
		["e2a1", ""],
		["e340", ""],
		["e3a1", ""],
		["e440", ""],
		["e4a1", ""],
		["e540", ""],
		["e5a1", ""],
		["e640", ""],
		["e6a1", ""],
		["e740", ""],
		["e7a1", ""],
		["e840", ""],
		["e8a1", ""],
		["e940", ""],
		["e9a1", ""],
		["ea40", ""],
		["eaa1", ""],
		["eb40", ""],
		["eba1", ""],
		["ec40", ""],
		["eca1", ""],
		["ed40", ""],
		["eda1", ""],
		["ee40", ""],
		["eea1", ""],
		["ef40", ""],
		["efa1", ""],
		["f040", ""],
		["f0a1", ""],
		["f140", ""],
		["f1a1", ""],
		["f240", ""],
		["f2a1", ""],
		["f340", ""],
		["f3a1", ""],
		["f440", ""],
		["f4a1", ""],
		["f540", ""],
		["f5a1", ""],
		["f640", ""],
		["f6a1", ""],
		["f740", ""],
		["f7a1", ""],
		["f840", ""],
		["f8a1", ""],
		["f940", ""],
		["f9a1", ""]
	];
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/big5-added.json": ((exports, module) => {
	module.exports = [
		["8740", ""],
		["8767", ""],
		["87a1", ""],
		[
			"8840",
			"",
			4,
			""
		],
		["88a1", ""],
		["8940", ""],
		["8943", ""],
		["8946", ""],
		["894c", ""],
		["89a1", ""],
		["89ab", ""],
		["89b0", ""],
		["89b5", ""],
		["89c1", ""],
		["89c5", ""],
		["8a40", ""],
		["8a43", ""],
		["8a64", ""],
		["8a76", ""],
		["8aa1", ""],
		["8aac", ""],
		["8ab2", ""],
		["8abb", ""],
		["8ac9", ""],
		["8ace", ""],
		["8adf", ""],
		["8af6", ""],
		["8b40", ""],
		["8b55", ""],
		["8ba1", ""],
		["8bde", ""],
		["8c40", ""],
		["8ca1", ""],
		["8ca7", ""],
		["8cc9", ""],
		["8cce", ""],
		["8ce6", ""],
		["8d40", ""],
		["8d42", ""],
		["8da1", ""],
		["8e40", ""],
		["8ea1", ""],
		["8f40", ""],
		["8fa1", ""],
		["9040", ""],
		["90a1", ""],
		["9140", ""],
		["91a1", ""],
		["9240", ""],
		["92a1", ""],
		["9340", ""],
		["93a1", ""],
		["9440", ""],
		["94a1", ""],
		["9540", ""],
		["95a1", ""],
		["9640", ""],
		["96a1", ""],
		["9740", ""],
		["97a1", ""],
		["9840", ""],
		["98a1", ""],
		["9940", ""],
		["99a1", ""],
		["9a40", ""],
		["9aa1", ""],
		["9b40", ""],
		["9b62", ""],
		["9ba1", ""],
		["9c40", ""],
		["9ca1", ""],
		["9d40", ""],
		["9da1", ""],
		["9e40", ""],
		["9ea1", ""],
		["9ead", ""],
		["9ec5", ""],
		["9ef5", ""],
		["9f40", ""],
		["9f4f", ""],
		["9fa1", ""],
		["9fae", ""],
		["9fb2", ""],
		["9fc1", ""],
		["9fc9", ""],
		["9fdb", ""],
		["9fe7", ""],
		["9feb", ""],
		["9ff0", ""],
		["a040", ""],
		["a055", ""],
		["a058", ""],
		["a05b", ""],
		["a063", ""],
		["a073", ""],
		["a0a1", ""],
		["a0a6", ""],
		["a0ae", ""],
		["a0b0", ""],
		["a0d4", ""],
		["a0e2", ""],
		[
			"a3c0",
			"",
			31,
			""
		],
		[
			"c6a1",
			"",
			9,
			"",
			9,
			"",
			9,
			"",
			23
		],
		[
			"c740",
			"",
			58,
			""
		],
		[
			"c7a1",
			"",
			81,
			"",
			5,
			"",
			4
		],
		[
			"c840",
			"",
			26,
			"",
			25,
			""
		],
		["c8a1", ""],
		["c8cd", ""],
		["c8f5", ""],
		["f9fe", ""],
		["fa40", ""],
		["faa1", ""],
		["fb40", ""],
		["fba1", ""],
		["fc40", ""],
		["fca1", ""],
		["fd40", ""],
		["fda1", ""],
		["fe40", ""],
		["fea1", ""]
	];
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-data.js": ((exports, module) => {
	module.exports = {
		"shiftjis": {
			type: "_dbcs",
			table: function() {
				return require_shiftjis();
			},
			encodeAdd: {
				"": 92,
				"": 126
			},
			encodeSkipVals: [{
				from: 60736,
				to: 63808
			}]
		},
		"csshiftjis": "shiftjis",
		"mskanji": "shiftjis",
		"sjis": "shiftjis",
		"windows31j": "shiftjis",
		"ms31j": "shiftjis",
		"xsjis": "shiftjis",
		"windows932": "shiftjis",
		"ms932": "shiftjis",
		"932": "shiftjis",
		"cp932": "shiftjis",
		"eucjp": {
			type: "_dbcs",
			table: function() {
				return require_eucjp();
			},
			encodeAdd: {
				"": 92,
				"": 126
			}
		},
		"gb2312": "cp936",
		"gb231280": "cp936",
		"gb23121980": "cp936",
		"csgb2312": "cp936",
		"csiso58gb231280": "cp936",
		"euccn": "cp936",
		"windows936": "cp936",
		"ms936": "cp936",
		"936": "cp936",
		"cp936": {
			type: "_dbcs",
			table: function() {
				return require_cp936();
			}
		},
		"gbk": {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			}
		},
		"xgbk": "gbk",
		"isoir58": "gbk",
		"gb18030": {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			},
			gb18030: function() {
				return require_gb18030_ranges();
			},
			encodeSkipVals: [128],
			encodeAdd: { "": 41699 }
		},
		"chinese": "gb18030",
		"windows949": "cp949",
		"ms949": "cp949",
		"949": "cp949",
		"cp949": {
			type: "_dbcs",
			table: function() {
				return require_cp949();
			}
		},
		"cseuckr": "cp949",
		"csksc56011987": "cp949",
		"euckr": "cp949",
		"isoir149": "cp949",
		"korean": "cp949",
		"ksc56011987": "cp949",
		"ksc56011989": "cp949",
		"ksc5601": "cp949",
		"windows950": "cp950",
		"ms950": "cp950",
		"950": "cp950",
		"cp950": {
			type: "_dbcs",
			table: function() {
				return require_cp950();
			}
		},
		"big5": "big5hkscs",
		"big5hkscs": {
			type: "_dbcs",
			table: function() {
				return require_cp950().concat(require_big5_added());
			},
			encodeSkipVals: [41676]
		},
		"cnbig5": "big5hkscs",
		"csbig5": "big5hkscs",
		"xxbig5": "big5hkscs"
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/index.js
var require_encodings = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/index.js": ((exports) => {
	var modules = [
		require_internal(),
		require_utf16(),
		require_utf7(),
		require_sbcs_codec(),
		require_sbcs_data(),
		require_sbcs_data_generated(),
		require_dbcs_codec(),
		require_dbcs_data()
	];
	for (var i = 0; i < modules.length; i++) {
		var module$1 = modules[i];
		for (var enc in module$1) if (Object.prototype.hasOwnProperty.call(module$1, enc)) exports[enc] = module$1[enc];
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/streams.js
var require_streams = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/streams.js": ((exports, module) => {
	var Buffer$7 = __require("buffer").Buffer, Transform = __require("stream").Transform;
	module.exports = function(iconv$3) {
		iconv$3.encodeStream = function encodeStream(encoding, options) {
			return new IconvLiteEncoderStream(iconv$3.getEncoder(encoding, options), options);
		};
		iconv$3.decodeStream = function decodeStream(encoding, options) {
			return new IconvLiteDecoderStream(iconv$3.getDecoder(encoding, options), options);
		};
		iconv$3.supportsStreams = true;
		iconv$3.IconvLiteEncoderStream = IconvLiteEncoderStream;
		iconv$3.IconvLiteDecoderStream = IconvLiteDecoderStream;
		iconv$3._collect = IconvLiteDecoderStream.prototype.collect;
	};
	function IconvLiteEncoderStream(conv, options) {
		this.conv = conv;
		options = options || {};
		options.decodeStrings = false;
		Transform.call(this, options);
	}
	IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteEncoderStream } });
	IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
		if (typeof chunk != "string") return done(/* @__PURE__ */ new Error("Iconv encoding stream needs strings as its input."));
		try {
			var res$2 = this.conv.write(chunk);
			if (res$2 && res$2.length) this.push(res$2);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteEncoderStream.prototype._flush = function(done) {
		try {
			var res$2 = this.conv.end();
			if (res$2 && res$2.length) this.push(res$2);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteEncoderStream.prototype.collect = function(cb) {
		var chunks = [];
		this.on("error", cb);
		this.on("data", function(chunk) {
			chunks.push(chunk);
		});
		this.on("end", function() {
			cb(null, Buffer$7.concat(chunks));
		});
		return this;
	};
	function IconvLiteDecoderStream(conv, options) {
		this.conv = conv;
		options = options || {};
		options.encoding = this.encoding = "utf8";
		Transform.call(this, options);
	}
	IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteDecoderStream } });
	IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
		if (!Buffer$7.isBuffer(chunk)) return done(/* @__PURE__ */ new Error("Iconv decoding stream needs buffers as its input."));
		try {
			var res$2 = this.conv.write(chunk);
			if (res$2 && res$2.length) this.push(res$2, this.encoding);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteDecoderStream.prototype._flush = function(done) {
		try {
			var res$2 = this.conv.end();
			if (res$2 && res$2.length) this.push(res$2, this.encoding);
			done();
		} catch (e) {
			done(e);
		}
	};
	IconvLiteDecoderStream.prototype.collect = function(cb) {
		var res$2 = "";
		this.on("error", cb);
		this.on("data", function(chunk) {
			res$2 += chunk;
		});
		this.on("end", function() {
			cb(null, res$2);
		});
		return this;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/extend-node.js
var require_extend_node = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/extend-node.js": ((exports, module) => {
	var Buffer$6 = __require("buffer").Buffer;
	module.exports = function(iconv$3) {
		var original = void 0;
		iconv$3.supportsNodeEncodingsExtension = !(Buffer$6.from || new Buffer$6(0) instanceof Uint8Array);
		iconv$3.extendNodeEncodings = function extendNodeEncodings() {
			if (original) return;
			original = {};
			if (!iconv$3.supportsNodeEncodingsExtension) {
				console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
				console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
				return;
			}
			var nodeNativeEncodings = {
				"hex": true,
				"utf8": true,
				"utf-8": true,
				"ascii": true,
				"binary": true,
				"base64": true,
				"ucs2": true,
				"ucs-2": true,
				"utf16le": true,
				"utf-16le": true
			};
			Buffer$6.isNativeEncoding = function(enc$1) {
				return enc$1 && nodeNativeEncodings[enc$1.toLowerCase()];
			};
			var SlowBuffer = __require("buffer").SlowBuffer;
			original.SlowBufferToString = SlowBuffer.prototype.toString;
			SlowBuffer.prototype.toString = function(encoding, start, end) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$6.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);
				if (typeof start == "undefined") start = 0;
				if (typeof end == "undefined") end = this.length;
				return iconv$3.decode(this.slice(start, end), encoding);
			};
			original.SlowBufferWrite = SlowBuffer.prototype.write;
			SlowBuffer.prototype.write = function(string, offset, length, encoding) {
				if (isFinite(offset)) {
					if (!isFinite(length)) {
						encoding = length;
						length = void 0;
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length;
					length = swap;
				}
				offset = +offset || 0;
				var remaining = this.length - offset;
				if (!length) length = remaining;
				else {
					length = +length;
					if (length > remaining) length = remaining;
				}
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$6.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);
				if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
				var buf = iconv$3.encode(string, encoding);
				if (buf.length < length) length = buf.length;
				buf.copy(this, offset, 0, length);
				return length;
			};
			original.BufferIsEncoding = Buffer$6.isEncoding;
			Buffer$6.isEncoding = function(encoding) {
				return Buffer$6.isNativeEncoding(encoding) || iconv$3.encodingExists(encoding);
			};
			original.BufferByteLength = Buffer$6.byteLength;
			Buffer$6.byteLength = SlowBuffer.byteLength = function(str, encoding) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$6.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);
				return iconv$3.encode(str, encoding).length;
			};
			original.BufferToString = Buffer$6.prototype.toString;
			Buffer$6.prototype.toString = function(encoding, start, end) {
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$6.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);
				if (typeof start == "undefined") start = 0;
				if (typeof end == "undefined") end = this.length;
				return iconv$3.decode(this.slice(start, end), encoding);
			};
			original.BufferWrite = Buffer$6.prototype.write;
			Buffer$6.prototype.write = function(string, offset, length, encoding) {
				var _offset = offset, _length = length, _encoding = encoding;
				if (isFinite(offset)) {
					if (!isFinite(length)) {
						encoding = length;
						length = void 0;
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length;
					length = swap;
				}
				encoding = String(encoding || "utf8").toLowerCase();
				if (Buffer$6.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);
				offset = +offset || 0;
				var remaining = this.length - offset;
				if (!length) length = remaining;
				else {
					length = +length;
					if (length > remaining) length = remaining;
				}
				if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError("attempt to write beyond buffer bounds");
				var buf = iconv$3.encode(string, encoding);
				if (buf.length < length) length = buf.length;
				buf.copy(this, offset, 0, length);
				return length;
			};
			if (iconv$3.supportsStreams) {
				var Readable = __require("stream").Readable;
				original.ReadableSetEncoding = Readable.prototype.setEncoding;
				Readable.prototype.setEncoding = function setEncoding(enc$1, options) {
					this._readableState.decoder = iconv$3.getDecoder(enc$1, options);
					this._readableState.encoding = enc$1;
				};
				Readable.prototype.collect = iconv$3._collect;
			}
		};
		iconv$3.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
			if (!iconv$3.supportsNodeEncodingsExtension) return;
			if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
			delete Buffer$6.isNativeEncoding;
			var SlowBuffer = __require("buffer").SlowBuffer;
			SlowBuffer.prototype.toString = original.SlowBufferToString;
			SlowBuffer.prototype.write = original.SlowBufferWrite;
			Buffer$6.isEncoding = original.BufferIsEncoding;
			Buffer$6.byteLength = original.BufferByteLength;
			Buffer$6.prototype.toString = original.BufferToString;
			Buffer$6.prototype.write = original.BufferWrite;
			if (iconv$3.supportsStreams) {
				var Readable = __require("stream").Readable;
				Readable.prototype.setEncoding = original.ReadableSetEncoding;
				delete Readable.prototype.collect;
			}
			original = void 0;
		};
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js
var require_lib$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js": ((exports, module) => {
	var Buffer$5 = require_safer().Buffer;
	var bomHandling = require_bom_handling(), iconv$2 = module.exports;
	iconv$2.encodings = null;
	iconv$2.defaultCharUnicode = "";
	iconv$2.defaultCharSingleByte = "?";
	iconv$2.encode = function encode$3(str, encoding, options) {
		str = "" + (str || "");
		var encoder = iconv$2.getEncoder(encoding, options);
		var res$2 = encoder.write(str);
		var trail = encoder.end();
		return trail && trail.length > 0 ? Buffer$5.concat([res$2, trail]) : res$2;
	};
	iconv$2.decode = function decode$5(buf, encoding, options) {
		if (typeof buf === "string") {
			if (!iconv$2.skipDecodeWarning) {
				console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
				iconv$2.skipDecodeWarning = true;
			}
			buf = Buffer$5.from("" + (buf || ""), "binary");
		}
		var decoder = iconv$2.getDecoder(encoding, options);
		var res$2 = decoder.write(buf);
		var trail = decoder.end();
		return trail ? res$2 + trail : res$2;
	};
	iconv$2.encodingExists = function encodingExists(enc$1) {
		try {
			iconv$2.getCodec(enc$1);
			return true;
		} catch (e) {
			return false;
		}
	};
	iconv$2.toEncoding = iconv$2.encode;
	iconv$2.fromEncoding = iconv$2.decode;
	iconv$2._codecDataCache = {};
	iconv$2.getCodec = function getCodec(encoding) {
		if (!iconv$2.encodings) iconv$2.encodings = require_encodings();
		var enc$1 = iconv$2._canonicalizeEncoding(encoding);
		var codecOptions = {};
		while (true) {
			var codec = iconv$2._codecDataCache[enc$1];
			if (codec) return codec;
			var codecDef = iconv$2.encodings[enc$1];
			switch (typeof codecDef) {
				case "string":
					enc$1 = codecDef;
					break;
				case "object":
					for (var key$1 in codecDef) codecOptions[key$1] = codecDef[key$1];
					if (!codecOptions.encodingName) codecOptions.encodingName = enc$1;
					enc$1 = codecDef.type;
					break;
				case "function":
					if (!codecOptions.encodingName) codecOptions.encodingName = enc$1;
					codec = new codecDef(codecOptions, iconv$2);
					iconv$2._codecDataCache[codecOptions.encodingName] = codec;
					return codec;
				default: throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc$1 + "')");
			}
		}
	};
	iconv$2._canonicalizeEncoding = function(encoding) {
		return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
	};
	iconv$2.getEncoder = function getEncoder(encoding, options) {
		var codec = iconv$2.getCodec(encoding), encoder = new codec.encoder(options, codec);
		if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
		return encoder;
	};
	iconv$2.getDecoder = function getDecoder$1(encoding, options) {
		var codec = iconv$2.getCodec(encoding), decoder = new codec.decoder(options, codec);
		if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
		return decoder;
	};
	var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
	if (nodeVer) {
		var nodeVerArr = nodeVer.split(".").map(Number);
		if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) require_streams()(iconv$2);
		require_extend_node()(iconv$2);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js
var require_unpipe = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = unpipe$3;
	/**
	* Determine if there are Node.js pipe-like data listeners.
	* @private
	*/
	function hasPipeDataListeners(stream$3) {
		var listeners = stream$3.listeners("data");
		for (var i$8 = 0; i$8 < listeners.length; i$8++) if (listeners[i$8].name === "ondata") return true;
		return false;
	}
	/**
	* Unpipe a stream from all destinations.
	*
	* @param {object} stream
	* @public
	*/
	function unpipe$3(stream$3) {
		if (!stream$3) throw new TypeError("argument stream is required");
		if (typeof stream$3.unpipe === "function") {
			stream$3.unpipe();
			return;
		}
		if (!hasPipeDataListeners(stream$3)) return;
		var listener$6;
		var listeners = stream$3.listeners("close");
		for (var i$8 = 0; i$8 < listeners.length; i$8++) {
			listener$6 = listeners[i$8];
			if (listener$6.name !== "cleanup" && listener$6.name !== "onclose") continue;
			listener$6.call(stream$3);
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/raw-body@2.5.2/node_modules/raw-body/index.js
var require_raw_body = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/raw-body@2.5.2/node_modules/raw-body/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var asyncHooks$1 = tryRequireAsyncHooks$1();
	var bytes$4 = require_bytes();
	var createError$5 = require_http_errors();
	var iconv$1 = require_lib$2();
	var unpipe$2 = require_unpipe();
	/**
	* Module exports.
	* @public
	*/
	module.exports = getRawBody;
	/**
	* Module variables.
	* @private
	*/
	var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
	/**
	* Get the decoder for a given encoding.
	*
	* @param {string} encoding
	* @private
	*/
	function getDecoder(encoding) {
		if (!encoding) return null;
		try {
			return iconv$1.getDecoder(encoding);
		} catch (e) {
			if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
			throw createError$5(415, "specified encoding unsupported", {
				encoding,
				type: "encoding.unsupported"
			});
		}
	}
	/**
	* Get the raw body of a stream (typically HTTP).
	*
	* @param {object} stream
	* @param {object|string|function} [options]
	* @param {function} [callback]
	* @public
	*/
	function getRawBody(stream$3, options, callback) {
		var done = callback;
		var opts = options || {};
		if (stream$3 === void 0) throw new TypeError("argument stream is required");
		else if (typeof stream$3 !== "object" || stream$3 === null || typeof stream$3.on !== "function") throw new TypeError("argument stream must be a stream");
		if (options === true || typeof options === "string") opts = { encoding: options };
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (done !== void 0 && typeof done !== "function") throw new TypeError("argument callback must be a function");
		if (!done && !global.Promise) throw new TypeError("argument callback is required");
		var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
		var limit$2 = bytes$4.parse(opts.limit);
		var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
		if (done) return readStream(stream$3, encoding, length, limit$2, wrap$3(done));
		return new Promise(function executor(resolve$6, reject) {
			readStream(stream$3, encoding, length, limit$2, function onRead(err, buf) {
				if (err) return reject(err);
				resolve$6(buf);
			});
		});
	}
	/**
	* Halt a stream.
	*
	* @param {Object} stream
	* @private
	*/
	function halt(stream$3) {
		unpipe$2(stream$3);
		if (typeof stream$3.pause === "function") stream$3.pause();
	}
	/**
	* Read the data from the stream.
	*
	* @param {object} stream
	* @param {string} encoding
	* @param {number} length
	* @param {number} limit
	* @param {function} callback
	* @public
	*/
	function readStream(stream$3, encoding, length, limit$2, callback) {
		var complete = false;
		var sync = true;
		if (limit$2 !== null && length !== null && length > limit$2) return done(createError$5(413, "request entity too large", {
			expected: length,
			length,
			limit: limit$2,
			type: "entity.too.large"
		}));
		var state = stream$3._readableState;
		if (stream$3._decoder || state && (state.encoding || state.decoder)) return done(createError$5(500, "stream encoding should not be set", { type: "stream.encoding.set" }));
		if (typeof stream$3.readable !== "undefined" && !stream$3.readable) return done(createError$5(500, "stream is not readable", { type: "stream.not.readable" }));
		var received = 0;
		var decoder;
		try {
			decoder = getDecoder(encoding);
		} catch (err) {
			return done(err);
		}
		var buffer$5 = decoder ? "" : [];
		stream$3.on("aborted", onAborted);
		stream$3.on("close", cleanup);
		stream$3.on("data", onData);
		stream$3.on("end", onEnd);
		stream$3.on("error", onEnd);
		sync = false;
		function done() {
			var args = new Array(arguments.length);
			for (var i$8 = 0; i$8 < args.length; i$8++) args[i$8] = arguments[i$8];
			complete = true;
			if (sync) process.nextTick(invokeCallback);
			else invokeCallback();
			function invokeCallback() {
				cleanup();
				if (args[0]) halt(stream$3);
				callback.apply(null, args);
			}
		}
		function onAborted() {
			if (complete) return;
			done(createError$5(400, "request aborted", {
				code: "ECONNABORTED",
				expected: length,
				length,
				received,
				type: "request.aborted"
			}));
		}
		function onData(chunk) {
			if (complete) return;
			received += chunk.length;
			if (limit$2 !== null && received > limit$2) done(createError$5(413, "request entity too large", {
				limit: limit$2,
				received,
				type: "entity.too.large"
			}));
			else if (decoder) buffer$5 += decoder.write(chunk);
			else buffer$5.push(chunk);
		}
		function onEnd(err) {
			if (complete) return;
			if (err) return done(err);
			if (length !== null && received !== length) done(createError$5(400, "request size did not match content length", {
				expected: length,
				length,
				received,
				type: "request.size.invalid"
			}));
			else done(null, decoder ? buffer$5 + (decoder.end() || "") : Buffer.concat(buffer$5));
		}
		function cleanup() {
			buffer$5 = null;
			stream$3.removeListener("aborted", onAborted);
			stream$3.removeListener("data", onData);
			stream$3.removeListener("end", onEnd);
			stream$3.removeListener("error", onEnd);
			stream$3.removeListener("close", cleanup);
		}
	}
	/**
	* Try to require async_hooks
	* @private
	*/
	function tryRequireAsyncHooks$1() {
		try {
			return __require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	/**
	* Wrap function with async resource, if possible.
	* AsyncResource.bind static method backported.
	* @private
	*/
	function wrap$3(fn) {
		var res$2;
		if (asyncHooks$1.AsyncResource) res$2 = new asyncHooks$1.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res$2 || !res$2.runInAsyncScope) return fn;
		return res$2.runInAsyncScope.bind(res$2, fn, null);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js
var require_on_finished = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = onFinished$4;
	module.exports.isFinished = isFinished$1;
	/**
	* Module dependencies.
	* @private
	*/
	var asyncHooks = tryRequireAsyncHooks();
	var first = require_ee_first();
	/**
	* Variables.
	* @private
	*/
	/* istanbul ignore next */
	var defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	/**
	* Invoke callback when the response has finished, useful for
	* cleaning up resources afterwards.
	*
	* @param {object} msg
	* @param {function} listener
	* @return {object}
	* @public
	*/
	function onFinished$4(msg, listener$6) {
		if (isFinished$1(msg) !== false) {
			defer$1(listener$6, null, msg);
			return msg;
		}
		attachListener(msg, wrap$2(listener$6));
		return msg;
	}
	/**
	* Determine if message is already finished.
	*
	* @param {object} msg
	* @return {boolean}
	* @public
	*/
	function isFinished$1(msg) {
		var socket = msg.socket;
		if (typeof msg.finished === "boolean") return Boolean(msg.finished || socket && !socket.writable);
		if (typeof msg.complete === "boolean") return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
	}
	/**
	* Attach a finished listener to the message.
	*
	* @param {object} msg
	* @param {function} callback
	* @private
	*/
	function attachFinishedListener(msg, callback) {
		var eeMsg;
		var eeSocket;
		var finished = false;
		function onFinish(error) {
			eeMsg.cancel();
			eeSocket.cancel();
			finished = true;
			callback(error);
		}
		eeMsg = eeSocket = first([[
			msg,
			"end",
			"finish"
		]], onFinish);
		function onSocket(socket) {
			msg.removeListener("socket", onSocket);
			if (finished) return;
			if (eeMsg !== eeSocket) return;
			eeSocket = first([[
				socket,
				"error",
				"close"
			]], onFinish);
		}
		if (msg.socket) {
			onSocket(msg.socket);
			return;
		}
		msg.on("socket", onSocket);
		if (msg.socket === void 0)
 // istanbul ignore next: node.js 0.8 patch
		patchAssignSocket(msg, onSocket);
	}
	/**
	* Attach the listener to the message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function attachListener(msg, listener$6) {
		var attached = msg.__onFinished;
		if (!attached || !attached.queue) {
			attached = msg.__onFinished = createListener(msg);
			attachFinishedListener(msg, attached);
		}
		attached.queue.push(listener$6);
	}
	/**
	* Create listener on message.
	*
	* @param {object} msg
	* @return {function}
	* @private
	*/
	function createListener(msg) {
		function listener$6(err) {
			if (msg.__onFinished === listener$6) msg.__onFinished = null;
			if (!listener$6.queue) return;
			var queue$5 = listener$6.queue;
			listener$6.queue = null;
			for (var i$8 = 0; i$8 < queue$5.length; i$8++) queue$5[i$8](err, msg);
		}
		listener$6.queue = [];
		return listener$6;
	}
	/**
	* Patch ServerResponse.prototype.assignSocket for node.js 0.8.
	*
	* @param {ServerResponse} res
	* @param {function} callback
	* @private
	*/
	// istanbul ignore next: node.js 0.8 patch
	function patchAssignSocket(res$2, callback) {
		var assignSocket = res$2.assignSocket;
		if (typeof assignSocket !== "function") return;
		res$2.assignSocket = function _assignSocket(socket) {
			assignSocket.call(this, socket);
			callback(socket);
		};
	}
	/**
	* Try to require async_hooks
	* @private
	*/
	function tryRequireAsyncHooks() {
		try {
			return __require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	/**
	* Wrap function with async resource, if possible.
	* AsyncResource.bind static method backported.
	* @private
	*/
	function wrap$2(fn) {
		var res$2;
		if (asyncHooks.AsyncResource) res$2 = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res$2 || !res$2.runInAsyncScope) return fn;
		return res$2.runInAsyncScope.bind(res$2, fn, null);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js
var require_read = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var createError$4 = require_http_errors();
	var destroy$1 = require_destroy();
	var getBody = require_raw_body();
	var iconv = require_lib$2();
	var onFinished$3 = require_on_finished();
	var unpipe$1 = require_unpipe();
	var zlib = __require("zlib");
	/**
	* Module exports.
	*/
	module.exports = read$4;
	/**
	* Read a request into a buffer and parse.
	*
	* @param {object} req
	* @param {object} res
	* @param {function} next
	* @param {function} parse
	* @param {function} debug
	* @param {object} options
	* @private
	*/
	function read$4(req$2, res$2, next, parse$18, debug$23, options) {
		var length;
		var opts = options;
		var stream$3;
		req$2._body = true;
		var encoding = opts.encoding !== null ? opts.encoding : null;
		var verify = opts.verify;
		try {
			stream$3 = contentstream(req$2, debug$23, opts.inflate);
			length = stream$3.length;
			stream$3.length = void 0;
		} catch (err) {
			return next(err);
		}
		opts.length = length;
		opts.encoding = verify ? null : encoding;
		if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) return next(createError$4(415, "unsupported charset \"" + encoding.toUpperCase() + "\"", {
			charset: encoding.toLowerCase(),
			type: "charset.unsupported"
		}));
		debug$23("read body");
		getBody(stream$3, opts, function(error, body$1) {
			if (error) {
				var _error;
				if (error.type === "encoding.unsupported") _error = createError$4(415, "unsupported charset \"" + encoding.toUpperCase() + "\"", {
					charset: encoding.toLowerCase(),
					type: "charset.unsupported"
				});
				else _error = createError$4(400, error);
				if (stream$3 !== req$2) {
					unpipe$1(req$2);
					destroy$1(stream$3, true);
				}
				dump(req$2, function onfinished() {
					next(createError$4(400, _error));
				});
				return;
			}
			if (verify) try {
				debug$23("verify body");
				verify(req$2, res$2, body$1, encoding);
			} catch (err) {
				next(createError$4(403, err, {
					body: body$1,
					type: err.type || "entity.verify.failed"
				}));
				return;
			}
			var str = body$1;
			try {
				debug$23("parse body");
				str = typeof body$1 !== "string" && encoding !== null ? iconv.decode(body$1, encoding) : body$1;
				req$2.body = parse$18(str);
			} catch (err) {
				next(createError$4(400, err, {
					body: str,
					type: err.type || "entity.parse.failed"
				}));
				return;
			}
			next();
		});
	}
	/**
	* Get the content stream of the request.
	*
	* @param {object} req
	* @param {function} debug
	* @param {boolean} [inflate=true]
	* @return {object}
	* @api private
	*/
	function contentstream(req$2, debug$23, inflate) {
		var encoding = (req$2.headers["content-encoding"] || "identity").toLowerCase();
		var length = req$2.headers["content-length"];
		var stream$3;
		debug$23("content-encoding \"%s\"", encoding);
		if (inflate === false && encoding !== "identity") throw createError$4(415, "content encoding unsupported", {
			encoding,
			type: "encoding.unsupported"
		});
		switch (encoding) {
			case "deflate":
				stream$3 = zlib.createInflate();
				debug$23("inflate body");
				req$2.pipe(stream$3);
				break;
			case "gzip":
				stream$3 = zlib.createGunzip();
				debug$23("gunzip body");
				req$2.pipe(stream$3);
				break;
			case "identity":
				stream$3 = req$2;
				stream$3.length = length;
				break;
			default: throw createError$4(415, "unsupported content encoding \"" + encoding + "\"", {
				encoding,
				type: "encoding.unsupported"
			});
		}
		return stream$3;
	}
	/**
	* Dump the contents of a request.
	*
	* @param {object} req
	* @param {function} callback
	* @api private
	*/
	function dump(req$2, callback) {
		if (onFinished$3.isFinished(req$2)) callback(null);
		else {
			onFinished$3(req$2, callback);
			req$2.resume();
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/media-typer@0.3.0/node_modules/media-typer/index.js
var require_media_typer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/media-typer@0.3.0/node_modules/media-typer/index.js": ((exports) => {
	/*!
	* media-typer
	* Copyright(c) 2014 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	*
	* parameter     = token "=" ( token | quoted-string )
	* token         = 1*<any CHAR except CTLs or separators>
	* separators    = "(" | ")" | "<" | ">" | "@"
	*               | "," | ";" | ":" | "\" | <">
	*               | "/" | "[" | "]" | "?" | "="
	*               | "{" | "}" | SP | HT
	* quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	* qdtext        = <any TEXT except <">>
	* quoted-pair   = "\" CHAR
	* CHAR          = <any US-ASCII character (octets 0 - 127)>
	* TEXT          = <any OCTET except CTLs, but including LWS>
	* LWS           = [CRLF] 1*( SP | HT )
	* CRLF          = CR LF
	* CR            = <US-ASCII CR, carriage return (13)>
	* LF            = <US-ASCII LF, linefeed (10)>
	* SP            = <US-ASCII SP, space (32)>
	* SHT           = <US-ASCII HT, horizontal-tab (9)>
	* CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	* OCTET         = <any 8-bit sequence of data>
	*/
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
	/**
	* RegExp to match quoted-pair in RFC 2616
	*
	* quoted-pair = "\" CHAR
	* CHAR        = <any US-ASCII character (octets 0 - 127)>
	*/
	var qescRegExp = /\\([\u0000-\u007f])/g;
	/**
	* RegExp to match chars that must be quoted-pair in RFC 2616
	*/
	var quoteRegExp = /([\\"])/g;
	/**
	* RegExp to match type in RFC 6838
	*
	* type-name = restricted-name
	* subtype-name = restricted-name
	* restricted-name = restricted-name-first *126restricted-name-chars
	* restricted-name-first  = ALPHA / DIGIT
	* restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	*                          "$" / "&" / "-" / "^" / "_"
	* restricted-name-chars =/ "." ; Characters before first dot always
	*                              ; specify a facet name
	* restricted-name-chars =/ "+" ; Characters after last plus always
	*                              ; specify a structured syntax suffix
	* ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	* DIGIT =  %x30-39             ; 0-9
	*/
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
	/**
	* Module exports.
	*/
	exports.format = format$1;
	exports.parse = parse$7;
	/**
	* Format object to media type.
	*
	* @param {object} obj
	* @return {string}
	* @api public
	*/
	function format$1(obj) {
		if (!obj || typeof obj !== "object") throw new TypeError("argument obj is required");
		var parameters = obj.parameters;
		var subtype = obj.subtype;
		var suffix = obj.suffix;
		var type = obj.type;
		if (!type || !typeNameRegExp.test(type)) throw new TypeError("invalid type");
		if (!subtype || !subtypeNameRegExp.test(subtype)) throw new TypeError("invalid subtype");
		var string = type + "/" + subtype;
		if (suffix) {
			if (!typeNameRegExp.test(suffix)) throw new TypeError("invalid suffix");
			string += "+" + suffix;
		}
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i$8 = 0; i$8 < params.length; i$8++) {
				param = params[i$8];
				if (!tokenRegExp.test(param)) throw new TypeError("invalid parameter name");
				string += "; " + param + "=" + qstring$1(parameters[param]);
			}
		}
		return string;
	}
	/**
	* Parse media type to object.
	*
	* @param {string|object} string
	* @return {Object}
	* @api public
	*/
	function parse$7(string) {
		if (!string) throw new TypeError("argument string is required");
		if (typeof string === "object") string = getcontenttype(string);
		if (typeof string !== "string") throw new TypeError("argument string is required to be a string");
		var index$1 = string.indexOf(";");
		var type = index$1 !== -1 ? string.substr(0, index$1) : string;
		var key$1;
		var match$1;
		var obj = splitType(type);
		var params = {};
		var value;
		paramRegExp.lastIndex = index$1;
		while (match$1 = paramRegExp.exec(string)) {
			if (match$1.index !== index$1) throw new TypeError("invalid parameter format");
			index$1 += match$1[0].length;
			key$1 = match$1[1].toLowerCase();
			value = match$1[2];
			if (value[0] === "\"") value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
			params[key$1] = value;
		}
		if (index$1 !== -1 && index$1 !== string.length) throw new TypeError("invalid parameter format");
		obj.parameters = params;
		return obj;
	}
	/**
	* Get content-type from req/res objects.
	*
	* @param {object}
	* @return {Object}
	* @api private
	*/
	function getcontenttype(obj) {
		if (typeof obj.getHeader === "function") return obj.getHeader("content-type");
		if (typeof obj.headers === "object") return obj.headers && obj.headers["content-type"];
	}
	/**
	* Quote a string if necessary.
	*
	* @param {string} val
	* @return {string}
	* @api private
	*/
	function qstring$1(val) {
		var str = String(val);
		if (tokenRegExp.test(str)) return str;
		if (str.length > 0 && !textRegExp.test(str)) throw new TypeError("invalid parameter value");
		return "\"" + str.replace(quoteRegExp, "\\$1") + "\"";
	}
	/**
	* Simply "type/subtype+siffx" into parts.
	*
	* @param {string} string
	* @return {Object}
	* @api private
	*/
	function splitType(string) {
		var match$1 = typeRegExp.exec(string.toLowerCase());
		if (!match$1) throw new TypeError("invalid media type");
		var type = match$1[1];
		var subtype = match$1[2];
		var suffix;
		var index$1 = subtype.lastIndexOf("+");
		if (index$1 !== -1) {
			suffix = subtype.substr(index$1 + 1);
			subtype = subtype.substr(0, index$1);
		}
		return {
			type,
			subtype,
			suffix
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json": ((exports, module) => {
	module.exports = {
		"application/1d-interleaved-parityfec": { "source": "iana" },
		"application/3gpdash-qoe-report+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/3gpp-ims+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/3gpphalforms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/a2l": { "source": "iana" },
		"application/ace+cbor": { "source": "iana" },
		"application/activemessage": { "source": "iana" },
		"application/activity+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-directory+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcost+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcostparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointprop+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointpropparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-error+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamcontrol+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-updatestreamparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/aml": { "source": "iana" },
		"application/andrew-inset": {
			"source": "iana",
			"extensions": ["ez"]
		},
		"application/applefile": { "source": "iana" },
		"application/applixware": {
			"source": "apache",
			"extensions": ["aw"]
		},
		"application/at+jwt": { "source": "iana" },
		"application/atf": { "source": "iana" },
		"application/atfx": { "source": "iana" },
		"application/atom+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atom"]
		},
		"application/atomcat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomcat"]
		},
		"application/atomdeleted+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomdeleted"]
		},
		"application/atomicmail": { "source": "iana" },
		"application/atomsvc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["atomsvc"]
		},
		"application/atsc-dwd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dwd"]
		},
		"application/atsc-dynamic-event-message": { "source": "iana" },
		"application/atsc-held+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["held"]
		},
		"application/atsc-rdt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/atsc-rsat+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsat"]
		},
		"application/atxml": { "source": "iana" },
		"application/auth-policy+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/bacnet-xdd+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/batch-smtp": { "source": "iana" },
		"application/bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/beep+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/calendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/calendar+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xcs"]
		},
		"application/call-completion": { "source": "iana" },
		"application/cals-1840": { "source": "iana" },
		"application/captive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cbor": { "source": "iana" },
		"application/cbor-seq": { "source": "iana" },
		"application/cccex": { "source": "iana" },
		"application/ccmp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ccxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ccxml"]
		},
		"application/cdfx+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdfx"]
		},
		"application/cdmi-capability": {
			"source": "iana",
			"extensions": ["cdmia"]
		},
		"application/cdmi-container": {
			"source": "iana",
			"extensions": ["cdmic"]
		},
		"application/cdmi-domain": {
			"source": "iana",
			"extensions": ["cdmid"]
		},
		"application/cdmi-object": {
			"source": "iana",
			"extensions": ["cdmio"]
		},
		"application/cdmi-queue": {
			"source": "iana",
			"extensions": ["cdmiq"]
		},
		"application/cdni": { "source": "iana" },
		"application/cea": { "source": "iana" },
		"application/cea-2018+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cellml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cfw": { "source": "iana" },
		"application/city+json": {
			"source": "iana",
			"compressible": true
		},
		"application/clr": { "source": "iana" },
		"application/clue+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/clue_info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cms": { "source": "iana" },
		"application/cnrp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-group+json": {
			"source": "iana",
			"compressible": true
		},
		"application/coap-payload": { "source": "iana" },
		"application/commonground": { "source": "iana" },
		"application/conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cose": { "source": "iana" },
		"application/cose-key": { "source": "iana" },
		"application/cose-key-set": { "source": "iana" },
		"application/cpl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cpl"]
		},
		"application/csrattrs": { "source": "iana" },
		"application/csta+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/cstadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/csvm+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cu-seeme": {
			"source": "apache",
			"extensions": ["cu"]
		},
		"application/cwt": { "source": "iana" },
		"application/cybercash": { "source": "iana" },
		"application/dart": { "compressible": true },
		"application/dash+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpd"]
		},
		"application/dash-patch+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpp"]
		},
		"application/dashdelta": { "source": "iana" },
		"application/davmount+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["davmount"]
		},
		"application/dca-rft": { "source": "iana" },
		"application/dcd": { "source": "iana" },
		"application/dec-dx": { "source": "iana" },
		"application/dialog-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom": { "source": "iana" },
		"application/dicom+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dicom+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dii": { "source": "iana" },
		"application/dit": { "source": "iana" },
		"application/dns": { "source": "iana" },
		"application/dns+json": {
			"source": "iana",
			"compressible": true
		},
		"application/dns-message": { "source": "iana" },
		"application/docbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dbk"]
		},
		"application/dots+cbor": { "source": "iana" },
		"application/dskpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/dssc+der": {
			"source": "iana",
			"extensions": ["dssc"]
		},
		"application/dssc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdssc"]
		},
		"application/dvcs": { "source": "iana" },
		"application/ecmascript": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es", "ecma"]
		},
		"application/edi-consent": { "source": "iana" },
		"application/edi-x12": {
			"source": "iana",
			"compressible": false
		},
		"application/edifact": {
			"source": "iana",
			"compressible": false
		},
		"application/efi": { "source": "iana" },
		"application/elm+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/elm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.cap+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/emergencycalldata.comment+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.deviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.ecall.msd": { "source": "iana" },
		"application/emergencycalldata.providerinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.serviceinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.subscriberinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emergencycalldata.veds+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/emma+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emma"]
		},
		"application/emotionml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["emotionml"]
		},
		"application/encaprtp": { "source": "iana" },
		"application/epp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/epub+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["epub"]
		},
		"application/eshop": { "source": "iana" },
		"application/exi": {
			"source": "iana",
			"extensions": ["exi"]
		},
		"application/expect-ct-report+json": {
			"source": "iana",
			"compressible": true
		},
		"application/express": {
			"source": "iana",
			"extensions": ["exp"]
		},
		"application/fastinfoset": { "source": "iana" },
		"application/fastsoap": { "source": "iana" },
		"application/fdt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fdt"]
		},
		"application/fhir+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fhir+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/fido.trusted-apps+json": { "compressible": true },
		"application/fits": { "source": "iana" },
		"application/flexfec": { "source": "iana" },
		"application/font-sfnt": { "source": "iana" },
		"application/font-tdpfr": {
			"source": "iana",
			"extensions": ["pfr"]
		},
		"application/font-woff": {
			"source": "iana",
			"compressible": false
		},
		"application/framework-attributes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/geo+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["geojson"]
		},
		"application/geo+json-seq": { "source": "iana" },
		"application/geopackage+sqlite3": { "source": "iana" },
		"application/geoxacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/gltf-buffer": { "source": "iana" },
		"application/gml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gml"]
		},
		"application/gpx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["gpx"]
		},
		"application/gxf": {
			"source": "apache",
			"extensions": ["gxf"]
		},
		"application/gzip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gz"]
		},
		"application/h224": { "source": "iana" },
		"application/held+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/hjson": { "extensions": ["hjson"] },
		"application/http": { "source": "iana" },
		"application/hyperstudio": {
			"source": "iana",
			"extensions": ["stk"]
		},
		"application/ibe-key-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pkg-reply+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ibe-pp-data": { "source": "iana" },
		"application/iges": { "source": "iana" },
		"application/im-iscomposing+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/index": { "source": "iana" },
		"application/index.cmd": { "source": "iana" },
		"application/index.obj": { "source": "iana" },
		"application/index.response": { "source": "iana" },
		"application/index.vnd": { "source": "iana" },
		"application/inkml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ink", "inkml"]
		},
		"application/iotp": { "source": "iana" },
		"application/ipfix": {
			"source": "iana",
			"extensions": ["ipfix"]
		},
		"application/ipp": { "source": "iana" },
		"application/isup": { "source": "iana" },
		"application/its+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["its"]
		},
		"application/java-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jar",
				"war",
				"ear"
			]
		},
		"application/java-serialized-object": {
			"source": "apache",
			"compressible": false,
			"extensions": ["ser"]
		},
		"application/java-vm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["class"]
		},
		"application/javascript": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["js", "mjs"]
		},
		"application/jf2feed+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jose": { "source": "iana" },
		"application/jose+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jrd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jscalendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["json", "map"]
		},
		"application/json-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json-seq": { "source": "iana" },
		"application/json5": { "extensions": ["json5"] },
		"application/jsonml+json": {
			"source": "apache",
			"compressible": true,
			"extensions": ["jsonml"]
		},
		"application/jwk+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwk-set+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwt": { "source": "iana" },
		"application/kpml-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/kpml-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/ld+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["jsonld"]
		},
		"application/lgr+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lgr"]
		},
		"application/link-format": { "source": "iana" },
		"application/load-control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lost+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lostxml"]
		},
		"application/lostsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/lpf+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/lxf": { "source": "iana" },
		"application/mac-binhex40": {
			"source": "iana",
			"extensions": ["hqx"]
		},
		"application/mac-compactpro": {
			"source": "apache",
			"extensions": ["cpt"]
		},
		"application/macwriteii": { "source": "iana" },
		"application/mads+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mads"]
		},
		"application/manifest+json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["webmanifest"]
		},
		"application/marc": {
			"source": "iana",
			"extensions": ["mrc"]
		},
		"application/marcxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mrcx"]
		},
		"application/mathematica": {
			"source": "iana",
			"extensions": [
				"ma",
				"nb",
				"mb"
			]
		},
		"application/mathml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mathml"]
		},
		"application/mathml-content+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mathml-presentation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-associated-procedure-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-deregister+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-envelope+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-msk-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-protection-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-reception-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-register-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-schedule+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbms-user-service-description+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mbox": {
			"source": "iana",
			"extensions": ["mbox"]
		},
		"application/media-policy-dataset+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpf"]
		},
		"application/media_control+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mediaservercontrol+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mscml"]
		},
		"application/merge-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/metalink+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["metalink"]
		},
		"application/metalink4+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["meta4"]
		},
		"application/mets+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mets"]
		},
		"application/mf4": { "source": "iana" },
		"application/mikey": { "source": "iana" },
		"application/mipc": { "source": "iana" },
		"application/missing-blocks+cbor-seq": { "source": "iana" },
		"application/mmt-aei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["maei"]
		},
		"application/mmt-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musd"]
		},
		"application/mods+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mods"]
		},
		"application/moss-keys": { "source": "iana" },
		"application/moss-signature": { "source": "iana" },
		"application/mosskey-data": { "source": "iana" },
		"application/mosskey-request": { "source": "iana" },
		"application/mp21": {
			"source": "iana",
			"extensions": ["m21", "mp21"]
		},
		"application/mp4": {
			"source": "iana",
			"extensions": ["mp4s", "m4p"]
		},
		"application/mpeg4-generic": { "source": "iana" },
		"application/mpeg4-iod": { "source": "iana" },
		"application/mpeg4-iod-xmt": { "source": "iana" },
		"application/mrb-consumer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/mrb-publish+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/msc-ivr+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msc-mixer+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/msword": {
			"source": "iana",
			"compressible": false,
			"extensions": ["doc", "dot"]
		},
		"application/mud+json": {
			"source": "iana",
			"compressible": true
		},
		"application/multipart-core": { "source": "iana" },
		"application/mxf": {
			"source": "iana",
			"extensions": ["mxf"]
		},
		"application/n-quads": {
			"source": "iana",
			"extensions": ["nq"]
		},
		"application/n-triples": {
			"source": "iana",
			"extensions": ["nt"]
		},
		"application/nasdata": { "source": "iana" },
		"application/news-checkgroups": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-groupinfo": {
			"source": "iana",
			"charset": "US-ASCII"
		},
		"application/news-transmission": { "source": "iana" },
		"application/nlsml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/node": {
			"source": "iana",
			"extensions": ["cjs"]
		},
		"application/nss": { "source": "iana" },
		"application/oauth-authz-req+jwt": { "source": "iana" },
		"application/oblivious-dns-message": { "source": "iana" },
		"application/ocsp-request": { "source": "iana" },
		"application/ocsp-response": { "source": "iana" },
		"application/octet-stream": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"bin",
				"dms",
				"lrf",
				"mar",
				"so",
				"dist",
				"distz",
				"pkg",
				"bpk",
				"dump",
				"elc",
				"deploy",
				"exe",
				"dll",
				"deb",
				"dmg",
				"iso",
				"img",
				"msi",
				"msp",
				"msm",
				"buffer"
			]
		},
		"application/oda": {
			"source": "iana",
			"extensions": ["oda"]
		},
		"application/odm+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/odx": { "source": "iana" },
		"application/oebps-package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["opf"]
		},
		"application/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogx"]
		},
		"application/omdoc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["omdoc"]
		},
		"application/onenote": {
			"source": "apache",
			"extensions": [
				"onetoc",
				"onetoc2",
				"onetmp",
				"onepkg"
			]
		},
		"application/opc-nodeset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/oscore": { "source": "iana" },
		"application/oxps": {
			"source": "iana",
			"extensions": ["oxps"]
		},
		"application/p21": { "source": "iana" },
		"application/p21+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/p2p-overlay+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["relo"]
		},
		"application/parityfec": { "source": "iana" },
		"application/passport": { "source": "iana" },
		"application/patch-ops-error+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xer"]
		},
		"application/pdf": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pdf"]
		},
		"application/pdx": { "source": "iana" },
		"application/pem-certificate-chain": { "source": "iana" },
		"application/pgp-encrypted": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pgp"]
		},
		"application/pgp-keys": {
			"source": "iana",
			"extensions": ["asc"]
		},
		"application/pgp-signature": {
			"source": "iana",
			"extensions": ["asc", "sig"]
		},
		"application/pics-rules": {
			"source": "apache",
			"extensions": ["prf"]
		},
		"application/pidf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pidf-diff+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/pkcs10": {
			"source": "iana",
			"extensions": ["p10"]
		},
		"application/pkcs12": { "source": "iana" },
		"application/pkcs7-mime": {
			"source": "iana",
			"extensions": ["p7m", "p7c"]
		},
		"application/pkcs7-signature": {
			"source": "iana",
			"extensions": ["p7s"]
		},
		"application/pkcs8": {
			"source": "iana",
			"extensions": ["p8"]
		},
		"application/pkcs8-encrypted": { "source": "iana" },
		"application/pkix-attr-cert": {
			"source": "iana",
			"extensions": ["ac"]
		},
		"application/pkix-cert": {
			"source": "iana",
			"extensions": ["cer"]
		},
		"application/pkix-crl": {
			"source": "iana",
			"extensions": ["crl"]
		},
		"application/pkix-pkipath": {
			"source": "iana",
			"extensions": ["pkipath"]
		},
		"application/pkixcmp": {
			"source": "iana",
			"extensions": ["pki"]
		},
		"application/pls+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pls"]
		},
		"application/poc-settings+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/postscript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ai",
				"eps",
				"ps"
			]
		},
		"application/ppsp-tracker+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/provenance+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["provx"]
		},
		"application/prs.alvestrand.titrax-sheet": { "source": "iana" },
		"application/prs.cww": {
			"source": "iana",
			"extensions": ["cww"]
		},
		"application/prs.cyn": {
			"source": "iana",
			"charset": "7-BIT"
		},
		"application/prs.hpub+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/prs.nprend": { "source": "iana" },
		"application/prs.plucker": { "source": "iana" },
		"application/prs.rdf-xml-crypt": { "source": "iana" },
		"application/prs.xsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/pskc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["pskcxml"]
		},
		"application/pvd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/qsig": { "source": "iana" },
		"application/raml+yaml": {
			"compressible": true,
			"extensions": ["raml"]
		},
		"application/raptorfec": { "source": "iana" },
		"application/rdap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/rdf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rdf", "owl"]
		},
		"application/reginfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rif"]
		},
		"application/relax-ng-compact-syntax": {
			"source": "iana",
			"extensions": ["rnc"]
		},
		"application/remote-printing": { "source": "iana" },
		"application/reputon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/resource-lists+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rl"]
		},
		"application/resource-lists-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rld"]
		},
		"application/rfc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/riscos": { "source": "iana" },
		"application/rlmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/rls-services+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rs"]
		},
		"application/route-apd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rapd"]
		},
		"application/route-s-tsid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sls"]
		},
		"application/route-usd+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rusd"]
		},
		"application/rpki-ghostbusters": {
			"source": "iana",
			"extensions": ["gbr"]
		},
		"application/rpki-manifest": {
			"source": "iana",
			"extensions": ["mft"]
		},
		"application/rpki-publication": { "source": "iana" },
		"application/rpki-roa": {
			"source": "iana",
			"extensions": ["roa"]
		},
		"application/rpki-updown": { "source": "iana" },
		"application/rsd+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rsd"]
		},
		"application/rss+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["rss"]
		},
		"application/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"application/rtploopback": { "source": "iana" },
		"application/rtx": { "source": "iana" },
		"application/samlassertion+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/samlmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sarif-external-properties+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sbe": { "source": "iana" },
		"application/sbml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sbml"]
		},
		"application/scaip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/scim+json": {
			"source": "iana",
			"compressible": true
		},
		"application/scvp-cv-request": {
			"source": "iana",
			"extensions": ["scq"]
		},
		"application/scvp-cv-response": {
			"source": "iana",
			"extensions": ["scs"]
		},
		"application/scvp-vp-request": {
			"source": "iana",
			"extensions": ["spq"]
		},
		"application/scvp-vp-response": {
			"source": "iana",
			"extensions": ["spp"]
		},
		"application/sdp": {
			"source": "iana",
			"extensions": ["sdp"]
		},
		"application/secevent+jwt": { "source": "iana" },
		"application/senml+cbor": { "source": "iana" },
		"application/senml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["senmlx"]
		},
		"application/senml-etch+cbor": { "source": "iana" },
		"application/senml-etch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/senml-exi": { "source": "iana" },
		"application/sensml+cbor": { "source": "iana" },
		"application/sensml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/sensml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sensmlx"]
		},
		"application/sensml-exi": { "source": "iana" },
		"application/sep+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sep-exi": { "source": "iana" },
		"application/session-info": { "source": "iana" },
		"application/set-payment": { "source": "iana" },
		"application/set-payment-initiation": {
			"source": "iana",
			"extensions": ["setpay"]
		},
		"application/set-registration": { "source": "iana" },
		"application/set-registration-initiation": {
			"source": "iana",
			"extensions": ["setreg"]
		},
		"application/sgml": { "source": "iana" },
		"application/sgml-open-catalog": { "source": "iana" },
		"application/shf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["shf"]
		},
		"application/sieve": {
			"source": "iana",
			"extensions": ["siv", "sieve"]
		},
		"application/simple-filter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/simple-message-summary": { "source": "iana" },
		"application/simplesymbolcontainer": { "source": "iana" },
		"application/sipc": { "source": "iana" },
		"application/slate": { "source": "iana" },
		"application/smil": { "source": "iana" },
		"application/smil+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["smi", "smil"]
		},
		"application/smpte336m": { "source": "iana" },
		"application/soap+fastinfoset": { "source": "iana" },
		"application/soap+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sparql-query": {
			"source": "iana",
			"extensions": ["rq"]
		},
		"application/sparql-results+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["srx"]
		},
		"application/spdx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/spirits-event+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sql": { "source": "iana" },
		"application/srgs": {
			"source": "iana",
			"extensions": ["gram"]
		},
		"application/srgs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["grxml"]
		},
		"application/sru+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sru"]
		},
		"application/ssdl+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ssdl"]
		},
		"application/ssml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ssml"]
		},
		"application/stix+json": {
			"source": "iana",
			"compressible": true
		},
		"application/swid+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["swidtag"]
		},
		"application/tamp-apex-update": { "source": "iana" },
		"application/tamp-apex-update-confirm": { "source": "iana" },
		"application/tamp-community-update": { "source": "iana" },
		"application/tamp-community-update-confirm": { "source": "iana" },
		"application/tamp-error": { "source": "iana" },
		"application/tamp-sequence-adjust": { "source": "iana" },
		"application/tamp-sequence-adjust-confirm": { "source": "iana" },
		"application/tamp-status-query": { "source": "iana" },
		"application/tamp-status-response": { "source": "iana" },
		"application/tamp-update": { "source": "iana" },
		"application/tamp-update-confirm": { "source": "iana" },
		"application/tar": { "compressible": true },
		"application/taxii+json": {
			"source": "iana",
			"compressible": true
		},
		"application/td+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tei+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tei", "teicorpus"]
		},
		"application/tetra_isi": { "source": "iana" },
		"application/thraud+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tfi"]
		},
		"application/timestamp-query": { "source": "iana" },
		"application/timestamp-reply": { "source": "iana" },
		"application/timestamped-data": {
			"source": "iana",
			"extensions": ["tsd"]
		},
		"application/tlsrpt+gzip": { "source": "iana" },
		"application/tlsrpt+json": {
			"source": "iana",
			"compressible": true
		},
		"application/tnauthlist": { "source": "iana" },
		"application/token-introspection+jwt": { "source": "iana" },
		"application/toml": {
			"compressible": true,
			"extensions": ["toml"]
		},
		"application/trickle-ice-sdpfrag": { "source": "iana" },
		"application/trig": {
			"source": "iana",
			"extensions": ["trig"]
		},
		"application/ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttml"]
		},
		"application/tve-trigger": { "source": "iana" },
		"application/tzif": { "source": "iana" },
		"application/tzif-leap": { "source": "iana" },
		"application/ubjson": {
			"compressible": false,
			"extensions": ["ubj"]
		},
		"application/ulpfec": { "source": "iana" },
		"application/urc-grpsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/urc-ressheet+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rsheet"]
		},
		"application/urc-targetdesc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["td"]
		},
		"application/urc-uisocketdesc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vemmi": { "source": "iana" },
		"application/vividence.scriptfile": { "source": "apache" },
		"application/vnd.1000minds.decision-model+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["1km"]
		},
		"application/vnd.3gpp-prose+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-prose-pc3ch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
		"application/vnd.3gpp.5gnas": { "source": "iana" },
		"application/vnd.3gpp.access-transfer-events+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.bsf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gmop+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.gtpc": { "source": "iana" },
		"application/vnd.3gpp.interworking-data": { "source": "iana" },
		"application/vnd.3gpp.lpp": { "source": "iana" },
		"application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
		"application/vnd.3gpp.mcdata-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-payload": { "source": "iana" },
		"application/vnd.3gpp.mcdata-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
		"application/vnd.3gpp.mcdata-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcdata-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-floor-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-signed+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-ue-init-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcptt-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-location-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-service-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-transmission-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-ue-config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mcvideo-user-profile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.mid-call+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ngap": { "source": "iana" },
		"application/vnd.3gpp.pfcp": { "source": "iana" },
		"application/vnd.3gpp.pic-bw-large": {
			"source": "iana",
			"extensions": ["plb"]
		},
		"application/vnd.3gpp.pic-bw-small": {
			"source": "iana",
			"extensions": ["psb"]
		},
		"application/vnd.3gpp.pic-bw-var": {
			"source": "iana",
			"extensions": ["pvb"]
		},
		"application/vnd.3gpp.s1ap": { "source": "iana" },
		"application/vnd.3gpp.sms": { "source": "iana" },
		"application/vnd.3gpp.sms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-ext+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.srvcc-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.state-and-event-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp.ussd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.3gpp2.sms": { "source": "iana" },
		"application/vnd.3gpp2.tcap": {
			"source": "iana",
			"extensions": ["tcap"]
		},
		"application/vnd.3lightssoftware.imagescal": { "source": "iana" },
		"application/vnd.3m.post-it-notes": {
			"source": "iana",
			"extensions": ["pwn"]
		},
		"application/vnd.accpac.simply.aso": {
			"source": "iana",
			"extensions": ["aso"]
		},
		"application/vnd.accpac.simply.imp": {
			"source": "iana",
			"extensions": ["imp"]
		},
		"application/vnd.acucobol": {
			"source": "iana",
			"extensions": ["acu"]
		},
		"application/vnd.acucorp": {
			"source": "iana",
			"extensions": ["atc", "acutc"]
		},
		"application/vnd.adobe.air-application-installer-package+zip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["air"]
		},
		"application/vnd.adobe.flash.movie": { "source": "iana" },
		"application/vnd.adobe.formscentral.fcdt": {
			"source": "iana",
			"extensions": ["fcdt"]
		},
		"application/vnd.adobe.fxp": {
			"source": "iana",
			"extensions": ["fxp", "fxpl"]
		},
		"application/vnd.adobe.partial-upload": { "source": "iana" },
		"application/vnd.adobe.xdp+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdp"]
		},
		"application/vnd.adobe.xfdf": {
			"source": "iana",
			"extensions": ["xfdf"]
		},
		"application/vnd.aether.imp": { "source": "iana" },
		"application/vnd.afpc.afplinedata": { "source": "iana" },
		"application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
		"application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
		"application/vnd.afpc.foca-charset": { "source": "iana" },
		"application/vnd.afpc.foca-codedfont": { "source": "iana" },
		"application/vnd.afpc.foca-codepage": { "source": "iana" },
		"application/vnd.afpc.modca": { "source": "iana" },
		"application/vnd.afpc.modca-cmtable": { "source": "iana" },
		"application/vnd.afpc.modca-formdef": { "source": "iana" },
		"application/vnd.afpc.modca-mediummap": { "source": "iana" },
		"application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
		"application/vnd.afpc.modca-overlay": { "source": "iana" },
		"application/vnd.afpc.modca-pagesegment": { "source": "iana" },
		"application/vnd.age": {
			"source": "iana",
			"extensions": ["age"]
		},
		"application/vnd.ah-barcode": { "source": "iana" },
		"application/vnd.ahead.space": {
			"source": "iana",
			"extensions": ["ahead"]
		},
		"application/vnd.airzip.filesecure.azf": {
			"source": "iana",
			"extensions": ["azf"]
		},
		"application/vnd.airzip.filesecure.azs": {
			"source": "iana",
			"extensions": ["azs"]
		},
		"application/vnd.amadeus+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.amazon.ebook": {
			"source": "apache",
			"extensions": ["azw"]
		},
		"application/vnd.amazon.mobi8-ebook": { "source": "iana" },
		"application/vnd.americandynamics.acc": {
			"source": "iana",
			"extensions": ["acc"]
		},
		"application/vnd.amiga.ami": {
			"source": "iana",
			"extensions": ["ami"]
		},
		"application/vnd.amundsen.maze+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.android.ota": { "source": "iana" },
		"application/vnd.android.package-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": ["apk"]
		},
		"application/vnd.anki": { "source": "iana" },
		"application/vnd.anser-web-certificate-issue-initiation": {
			"source": "iana",
			"extensions": ["cii"]
		},
		"application/vnd.anser-web-funds-transfer-initiation": {
			"source": "apache",
			"extensions": ["fti"]
		},
		"application/vnd.antix.game-component": {
			"source": "iana",
			"extensions": ["atx"]
		},
		"application/vnd.apache.arrow.file": { "source": "iana" },
		"application/vnd.apache.arrow.stream": { "source": "iana" },
		"application/vnd.apache.thrift.binary": { "source": "iana" },
		"application/vnd.apache.thrift.compact": { "source": "iana" },
		"application/vnd.apache.thrift.json": { "source": "iana" },
		"application/vnd.api+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.aplextor.warrp+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apothekende.reservation+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apple.installer+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["mpkg"]
		},
		"application/vnd.apple.keynote": {
			"source": "iana",
			"extensions": ["key"]
		},
		"application/vnd.apple.mpegurl": {
			"source": "iana",
			"extensions": ["m3u8"]
		},
		"application/vnd.apple.numbers": {
			"source": "iana",
			"extensions": ["numbers"]
		},
		"application/vnd.apple.pages": {
			"source": "iana",
			"extensions": ["pages"]
		},
		"application/vnd.apple.pkpass": {
			"compressible": false,
			"extensions": ["pkpass"]
		},
		"application/vnd.arastra.swi": { "source": "iana" },
		"application/vnd.aristanetworks.swi": {
			"source": "iana",
			"extensions": ["swi"]
		},
		"application/vnd.artisan+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.artsquare": { "source": "iana" },
		"application/vnd.astraea-software.iota": {
			"source": "iana",
			"extensions": ["iota"]
		},
		"application/vnd.audiograph": {
			"source": "iana",
			"extensions": ["aep"]
		},
		"application/vnd.autopackage": { "source": "iana" },
		"application/vnd.avalon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.avistar+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.balsamiq.bmml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmml"]
		},
		"application/vnd.balsamiq.bmpr": { "source": "iana" },
		"application/vnd.banana-accounting": { "source": "iana" },
		"application/vnd.bbf.usp.error": { "source": "iana" },
		"application/vnd.bbf.usp.msg": { "source": "iana" },
		"application/vnd.bbf.usp.msg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bekitzur-stech+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.bint.med-content": { "source": "iana" },
		"application/vnd.biopax.rdf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.blink-idb-value-wrapper": { "source": "iana" },
		"application/vnd.blueice.multipass": {
			"source": "iana",
			"extensions": ["mpm"]
		},
		"application/vnd.bluetooth.ep.oob": { "source": "iana" },
		"application/vnd.bluetooth.le.oob": { "source": "iana" },
		"application/vnd.bmi": {
			"source": "iana",
			"extensions": ["bmi"]
		},
		"application/vnd.bpf": { "source": "iana" },
		"application/vnd.bpf3": { "source": "iana" },
		"application/vnd.businessobjects": {
			"source": "iana",
			"extensions": ["rep"]
		},
		"application/vnd.byu.uapi+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cab-jscript": { "source": "iana" },
		"application/vnd.canon-cpdl": { "source": "iana" },
		"application/vnd.canon-lips": { "source": "iana" },
		"application/vnd.capasystems-pg+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
		"application/vnd.century-systems.tcp_stream": { "source": "iana" },
		"application/vnd.chemdraw+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["cdxml"]
		},
		"application/vnd.chess-pgn": { "source": "iana" },
		"application/vnd.chipnuts.karaoke-mmd": {
			"source": "iana",
			"extensions": ["mmd"]
		},
		"application/vnd.ciedi": { "source": "iana" },
		"application/vnd.cinderella": {
			"source": "iana",
			"extensions": ["cdy"]
		},
		"application/vnd.cirpack.isdn-ext": { "source": "iana" },
		"application/vnd.citationstyles.style+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csl"]
		},
		"application/vnd.claymore": {
			"source": "iana",
			"extensions": ["cla"]
		},
		"application/vnd.cloanto.rp9": {
			"source": "iana",
			"extensions": ["rp9"]
		},
		"application/vnd.clonk.c4group": {
			"source": "iana",
			"extensions": [
				"c4g",
				"c4d",
				"c4f",
				"c4p",
				"c4u"
			]
		},
		"application/vnd.cluetrust.cartomobile-config": {
			"source": "iana",
			"extensions": ["c11amc"]
		},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
			"source": "iana",
			"extensions": ["c11amz"]
		},
		"application/vnd.coffeescript": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document": { "source": "iana" },
		"application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
		"application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
		"application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
		"application/vnd.collection+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.doc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.next+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.comicbook+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.comicbook-rar": { "source": "iana" },
		"application/vnd.commerce-battelle": { "source": "iana" },
		"application/vnd.commonspace": {
			"source": "iana",
			"extensions": ["csp"]
		},
		"application/vnd.contact.cmsg": {
			"source": "iana",
			"extensions": ["cdbcmsg"]
		},
		"application/vnd.coreos.ignition+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cosmocaller": {
			"source": "iana",
			"extensions": ["cmc"]
		},
		"application/vnd.crick.clicker": {
			"source": "iana",
			"extensions": ["clkx"]
		},
		"application/vnd.crick.clicker.keyboard": {
			"source": "iana",
			"extensions": ["clkk"]
		},
		"application/vnd.crick.clicker.palette": {
			"source": "iana",
			"extensions": ["clkp"]
		},
		"application/vnd.crick.clicker.template": {
			"source": "iana",
			"extensions": ["clkt"]
		},
		"application/vnd.crick.clicker.wordbank": {
			"source": "iana",
			"extensions": ["clkw"]
		},
		"application/vnd.criticaltools.wbs+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wbs"]
		},
		"application/vnd.cryptii.pipe+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.crypto-shade-file": { "source": "iana" },
		"application/vnd.cryptomator.encrypted": { "source": "iana" },
		"application/vnd.cryptomator.vault": { "source": "iana" },
		"application/vnd.ctc-posml": {
			"source": "iana",
			"extensions": ["pml"]
		},
		"application/vnd.ctct.ws+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cups-pdf": { "source": "iana" },
		"application/vnd.cups-postscript": { "source": "iana" },
		"application/vnd.cups-ppd": {
			"source": "iana",
			"extensions": ["ppd"]
		},
		"application/vnd.cups-raster": { "source": "iana" },
		"application/vnd.cups-raw": { "source": "iana" },
		"application/vnd.curl": { "source": "iana" },
		"application/vnd.curl.car": {
			"source": "apache",
			"extensions": ["car"]
		},
		"application/vnd.curl.pcurl": {
			"source": "apache",
			"extensions": ["pcurl"]
		},
		"application/vnd.cyan.dean.root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cybank": { "source": "iana" },
		"application/vnd.cyclonedx+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cyclonedx+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.d2l.coursepackage1p0+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.d3m-dataset": { "source": "iana" },
		"application/vnd.d3m-problem": { "source": "iana" },
		"application/vnd.dart": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dart"]
		},
		"application/vnd.data-vision.rdz": {
			"source": "iana",
			"extensions": ["rdz"]
		},
		"application/vnd.datapackage+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dataresource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dbf": {
			"source": "iana",
			"extensions": ["dbf"]
		},
		"application/vnd.debian.binary-package": { "source": "iana" },
		"application/vnd.dece.data": {
			"source": "iana",
			"extensions": [
				"uvf",
				"uvvf",
				"uvd",
				"uvvd"
			]
		},
		"application/vnd.dece.ttml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uvt", "uvvt"]
		},
		"application/vnd.dece.unspecified": {
			"source": "iana",
			"extensions": ["uvx", "uvvx"]
		},
		"application/vnd.dece.zip": {
			"source": "iana",
			"extensions": ["uvz", "uvvz"]
		},
		"application/vnd.denovo.fcselayout-link": {
			"source": "iana",
			"extensions": ["fe_launch"]
		},
		"application/vnd.desmume.movie": { "source": "iana" },
		"application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
		"application/vnd.dm.delegation+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dna": {
			"source": "iana",
			"extensions": ["dna"]
		},
		"application/vnd.document+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dolby.mlp": {
			"source": "apache",
			"extensions": ["mlp"]
		},
		"application/vnd.dolby.mobile.1": { "source": "iana" },
		"application/vnd.dolby.mobile.2": { "source": "iana" },
		"application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
		"application/vnd.dpgraph": {
			"source": "iana",
			"extensions": ["dpg"]
		},
		"application/vnd.dreamfactory": {
			"source": "iana",
			"extensions": ["dfac"]
		},
		"application/vnd.drive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ds-keypoint": {
			"source": "apache",
			"extensions": ["kpxx"]
		},
		"application/vnd.dtg.local": { "source": "iana" },
		"application/vnd.dtg.local.flash": { "source": "iana" },
		"application/vnd.dtg.local.html": { "source": "iana" },
		"application/vnd.dvb.ait": {
			"source": "iana",
			"extensions": ["ait"]
		},
		"application/vnd.dvb.dvbisl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.dvbj": { "source": "iana" },
		"application/vnd.dvb.esgcontainer": { "source": "iana" },
		"application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
		"application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
		"application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
		"application/vnd.dvb.ipdcroaming": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
		"application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
		"application/vnd.dvb.notif-aggregate-root+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-container+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-generic+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-msglist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.notif-init+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dvb.pfr": { "source": "iana" },
		"application/vnd.dvb.service": {
			"source": "iana",
			"extensions": ["svc"]
		},
		"application/vnd.dxr": { "source": "iana" },
		"application/vnd.dynageo": {
			"source": "iana",
			"extensions": ["geo"]
		},
		"application/vnd.dzr": { "source": "iana" },
		"application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
		"application/vnd.ecdis-update": { "source": "iana" },
		"application/vnd.ecip.rlp": { "source": "iana" },
		"application/vnd.eclipse.ditto+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ecowin.chart": {
			"source": "iana",
			"extensions": ["mag"]
		},
		"application/vnd.ecowin.filerequest": { "source": "iana" },
		"application/vnd.ecowin.fileupdate": { "source": "iana" },
		"application/vnd.ecowin.series": { "source": "iana" },
		"application/vnd.ecowin.seriesrequest": { "source": "iana" },
		"application/vnd.ecowin.seriesupdate": { "source": "iana" },
		"application/vnd.efi.img": { "source": "iana" },
		"application/vnd.efi.iso": { "source": "iana" },
		"application/vnd.emclient.accessrequest+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.enliven": {
			"source": "iana",
			"extensions": ["nml"]
		},
		"application/vnd.enphase.envoy": { "source": "iana" },
		"application/vnd.eprints.data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.epson.esf": {
			"source": "iana",
			"extensions": ["esf"]
		},
		"application/vnd.epson.msf": {
			"source": "iana",
			"extensions": ["msf"]
		},
		"application/vnd.epson.quickanime": {
			"source": "iana",
			"extensions": ["qam"]
		},
		"application/vnd.epson.salt": {
			"source": "iana",
			"extensions": ["slt"]
		},
		"application/vnd.epson.ssf": {
			"source": "iana",
			"extensions": ["ssf"]
		},
		"application/vnd.ericsson.quickcall": { "source": "iana" },
		"application/vnd.espass-espass+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.eszigno3+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["es3", "et3"]
		},
		"application/vnd.etsi.aoc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.asic-e+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.asic-s+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.etsi.cug+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvcommand+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-bc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-cod+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsad-npvr+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvservice+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvsync+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.iptvueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mcid+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.mheg5": { "source": "iana" },
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.pstn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.sci+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.simservs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.timestamp-token": { "source": "iana" },
		"application/vnd.etsi.tsl+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.etsi.tsl.der": { "source": "iana" },
		"application/vnd.eu.kasparian.car+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.eudora.data": { "source": "iana" },
		"application/vnd.evolv.ecig.profile": { "source": "iana" },
		"application/vnd.evolv.ecig.settings": { "source": "iana" },
		"application/vnd.evolv.ecig.theme": { "source": "iana" },
		"application/vnd.exstream-empower+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.exstream-package": { "source": "iana" },
		"application/vnd.ezpix-album": {
			"source": "iana",
			"extensions": ["ez2"]
		},
		"application/vnd.ezpix-package": {
			"source": "iana",
			"extensions": ["ez3"]
		},
		"application/vnd.f-secure.mobile": { "source": "iana" },
		"application/vnd.familysearch.gedcom+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.fastcopy-disk-image": { "source": "iana" },
		"application/vnd.fdf": {
			"source": "iana",
			"extensions": ["fdf"]
		},
		"application/vnd.fdsn.mseed": {
			"source": "iana",
			"extensions": ["mseed"]
		},
		"application/vnd.fdsn.seed": {
			"source": "iana",
			"extensions": ["seed", "dataless"]
		},
		"application/vnd.ffsns": { "source": "iana" },
		"application/vnd.ficlab.flb+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.filmit.zfc": { "source": "iana" },
		"application/vnd.fints": { "source": "iana" },
		"application/vnd.firemonkeys.cloudcell": { "source": "iana" },
		"application/vnd.flographit": {
			"source": "iana",
			"extensions": ["gph"]
		},
		"application/vnd.fluxtime.clip": {
			"source": "iana",
			"extensions": ["ftc"]
		},
		"application/vnd.font-fontforge-sfd": { "source": "iana" },
		"application/vnd.framemaker": {
			"source": "iana",
			"extensions": [
				"fm",
				"frame",
				"maker",
				"book"
			]
		},
		"application/vnd.frogans.fnc": {
			"source": "iana",
			"extensions": ["fnc"]
		},
		"application/vnd.frogans.ltf": {
			"source": "iana",
			"extensions": ["ltf"]
		},
		"application/vnd.fsc.weblaunch": {
			"source": "iana",
			"extensions": ["fsc"]
		},
		"application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
		"application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
		"application/vnd.fujifilm.fb.jfi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fujitsu.oasys": {
			"source": "iana",
			"extensions": ["oas"]
		},
		"application/vnd.fujitsu.oasys2": {
			"source": "iana",
			"extensions": ["oa2"]
		},
		"application/vnd.fujitsu.oasys3": {
			"source": "iana",
			"extensions": ["oa3"]
		},
		"application/vnd.fujitsu.oasysgp": {
			"source": "iana",
			"extensions": ["fg5"]
		},
		"application/vnd.fujitsu.oasysprs": {
			"source": "iana",
			"extensions": ["bh2"]
		},
		"application/vnd.fujixerox.art-ex": { "source": "iana" },
		"application/vnd.fujixerox.art4": { "source": "iana" },
		"application/vnd.fujixerox.ddd": {
			"source": "iana",
			"extensions": ["ddd"]
		},
		"application/vnd.fujixerox.docuworks": {
			"source": "iana",
			"extensions": ["xdw"]
		},
		"application/vnd.fujixerox.docuworks.binder": {
			"source": "iana",
			"extensions": ["xbd"]
		},
		"application/vnd.fujixerox.docuworks.container": { "source": "iana" },
		"application/vnd.fujixerox.hbpl": { "source": "iana" },
		"application/vnd.fut-misnet": { "source": "iana" },
		"application/vnd.futoin+cbor": { "source": "iana" },
		"application/vnd.futoin+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.fuzzysheet": {
			"source": "iana",
			"extensions": ["fzs"]
		},
		"application/vnd.genomatix.tuxedo": {
			"source": "iana",
			"extensions": ["txd"]
		},
		"application/vnd.gentics.grd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geo+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geocube+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geogebra.file": {
			"source": "iana",
			"extensions": ["ggb"]
		},
		"application/vnd.geogebra.slides": { "source": "iana" },
		"application/vnd.geogebra.tool": {
			"source": "iana",
			"extensions": ["ggt"]
		},
		"application/vnd.geometry-explorer": {
			"source": "iana",
			"extensions": ["gex", "gre"]
		},
		"application/vnd.geonext": {
			"source": "iana",
			"extensions": ["gxt"]
		},
		"application/vnd.geoplan": {
			"source": "iana",
			"extensions": ["g2w"]
		},
		"application/vnd.geospace": {
			"source": "iana",
			"extensions": ["g3w"]
		},
		"application/vnd.gerber": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
		"application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
		"application/vnd.gmx": {
			"source": "iana",
			"extensions": ["gmx"]
		},
		"application/vnd.google-apps.document": {
			"compressible": false,
			"extensions": ["gdoc"]
		},
		"application/vnd.google-apps.presentation": {
			"compressible": false,
			"extensions": ["gslides"]
		},
		"application/vnd.google-apps.spreadsheet": {
			"compressible": false,
			"extensions": ["gsheet"]
		},
		"application/vnd.google-earth.kml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["kml"]
		},
		"application/vnd.google-earth.kmz": {
			"source": "iana",
			"compressible": false,
			"extensions": ["kmz"]
		},
		"application/vnd.gov.sk.e-form+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.gov.sk.e-form+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.grafeq": {
			"source": "iana",
			"extensions": ["gqf", "gqs"]
		},
		"application/vnd.gridmp": { "source": "iana" },
		"application/vnd.groove-account": {
			"source": "iana",
			"extensions": ["gac"]
		},
		"application/vnd.groove-help": {
			"source": "iana",
			"extensions": ["ghf"]
		},
		"application/vnd.groove-identity-message": {
			"source": "iana",
			"extensions": ["gim"]
		},
		"application/vnd.groove-injector": {
			"source": "iana",
			"extensions": ["grv"]
		},
		"application/vnd.groove-tool-message": {
			"source": "iana",
			"extensions": ["gtm"]
		},
		"application/vnd.groove-tool-template": {
			"source": "iana",
			"extensions": ["tpl"]
		},
		"application/vnd.groove-vcard": {
			"source": "iana",
			"extensions": ["vcg"]
		},
		"application/vnd.hal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hal+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["hal"]
		},
		"application/vnd.handheld-entertainment+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zmm"]
		},
		"application/vnd.hbci": {
			"source": "iana",
			"extensions": ["hbci"]
		},
		"application/vnd.hc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hcl-bireports": { "source": "iana" },
		"application/vnd.hdt": { "source": "iana" },
		"application/vnd.heroku+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hhe.lesson-player": {
			"source": "iana",
			"extensions": ["les"]
		},
		"application/vnd.hl7cda+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hl7v2+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.hp-hpgl": {
			"source": "iana",
			"extensions": ["hpgl"]
		},
		"application/vnd.hp-hpid": {
			"source": "iana",
			"extensions": ["hpid"]
		},
		"application/vnd.hp-hps": {
			"source": "iana",
			"extensions": ["hps"]
		},
		"application/vnd.hp-jlyt": {
			"source": "iana",
			"extensions": ["jlt"]
		},
		"application/vnd.hp-pcl": {
			"source": "iana",
			"extensions": ["pcl"]
		},
		"application/vnd.hp-pclxl": {
			"source": "iana",
			"extensions": ["pclxl"]
		},
		"application/vnd.httphone": { "source": "iana" },
		"application/vnd.hydrostatix.sof-data": {
			"source": "iana",
			"extensions": ["sfd-hdstx"]
		},
		"application/vnd.hyper+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyper-item+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hyperdrive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hzn-3d-crossword": { "source": "iana" },
		"application/vnd.ibm.afplinedata": { "source": "iana" },
		"application/vnd.ibm.electronic-media": { "source": "iana" },
		"application/vnd.ibm.minipay": {
			"source": "iana",
			"extensions": ["mpy"]
		},
		"application/vnd.ibm.modcap": {
			"source": "iana",
			"extensions": [
				"afp",
				"listafp",
				"list3820"
			]
		},
		"application/vnd.ibm.rights-management": {
			"source": "iana",
			"extensions": ["irm"]
		},
		"application/vnd.ibm.secure-container": {
			"source": "iana",
			"extensions": ["sc"]
		},
		"application/vnd.iccprofile": {
			"source": "iana",
			"extensions": ["icc", "icm"]
		},
		"application/vnd.ieee.1905": { "source": "iana" },
		"application/vnd.igloader": {
			"source": "iana",
			"extensions": ["igl"]
		},
		"application/vnd.imagemeter.folder+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.imagemeter.image+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.immervision-ivp": {
			"source": "iana",
			"extensions": ["ivp"]
		},
		"application/vnd.immervision-ivu": {
			"source": "iana",
			"extensions": ["ivu"]
		},
		"application/vnd.ims.imsccv1p1": { "source": "iana" },
		"application/vnd.ims.imsccv1p2": { "source": "iana" },
		"application/vnd.ims.imsccv1p3": { "source": "iana" },
		"application/vnd.ims.lis.v2.result+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informedcontrol.rms+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informix-visionary": { "source": "iana" },
		"application/vnd.infotech.project": { "source": "iana" },
		"application/vnd.infotech.project+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.innopath.wamp.notification": { "source": "iana" },
		"application/vnd.insors.igm": {
			"source": "iana",
			"extensions": ["igm"]
		},
		"application/vnd.intercon.formnet": {
			"source": "iana",
			"extensions": ["xpw", "xpx"]
		},
		"application/vnd.intergeo": {
			"source": "iana",
			"extensions": ["i2g"]
		},
		"application/vnd.intertrust.digibox": { "source": "iana" },
		"application/vnd.intertrust.nncp": { "source": "iana" },
		"application/vnd.intu.qbo": {
			"source": "iana",
			"extensions": ["qbo"]
		},
		"application/vnd.intu.qfx": {
			"source": "iana",
			"extensions": ["qfx"]
		},
		"application/vnd.iptc.g2.catalogitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.conceptitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.newsmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.packageitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.iptc.g2.planningitem+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ipunplugged.rcprofile": {
			"source": "iana",
			"extensions": ["rcprofile"]
		},
		"application/vnd.irepository.package+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["irp"]
		},
		"application/vnd.is-xpr": {
			"source": "iana",
			"extensions": ["xpr"]
		},
		"application/vnd.isac.fcs": {
			"source": "iana",
			"extensions": ["fcs"]
		},
		"application/vnd.iso11783-10+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.jam": {
			"source": "iana",
			"extensions": ["jam"]
		},
		"application/vnd.japannet-directory-service": { "source": "iana" },
		"application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-payment-wakeup": { "source": "iana" },
		"application/vnd.japannet-registration": { "source": "iana" },
		"application/vnd.japannet-registration-wakeup": { "source": "iana" },
		"application/vnd.japannet-setstore-wakeup": { "source": "iana" },
		"application/vnd.japannet-verification": { "source": "iana" },
		"application/vnd.japannet-verification-wakeup": { "source": "iana" },
		"application/vnd.jcp.javame.midlet-rms": {
			"source": "iana",
			"extensions": ["rms"]
		},
		"application/vnd.jisp": {
			"source": "iana",
			"extensions": ["jisp"]
		},
		"application/vnd.joost.joda-archive": {
			"source": "iana",
			"extensions": ["joda"]
		},
		"application/vnd.jsk.isdn-ngn": { "source": "iana" },
		"application/vnd.kahootz": {
			"source": "iana",
			"extensions": ["ktz", "ktr"]
		},
		"application/vnd.kde.karbon": {
			"source": "iana",
			"extensions": ["karbon"]
		},
		"application/vnd.kde.kchart": {
			"source": "iana",
			"extensions": ["chrt"]
		},
		"application/vnd.kde.kformula": {
			"source": "iana",
			"extensions": ["kfo"]
		},
		"application/vnd.kde.kivio": {
			"source": "iana",
			"extensions": ["flw"]
		},
		"application/vnd.kde.kontour": {
			"source": "iana",
			"extensions": ["kon"]
		},
		"application/vnd.kde.kpresenter": {
			"source": "iana",
			"extensions": ["kpr", "kpt"]
		},
		"application/vnd.kde.kspread": {
			"source": "iana",
			"extensions": ["ksp"]
		},
		"application/vnd.kde.kword": {
			"source": "iana",
			"extensions": ["kwd", "kwt"]
		},
		"application/vnd.kenameaapp": {
			"source": "iana",
			"extensions": ["htke"]
		},
		"application/vnd.kidspiration": {
			"source": "iana",
			"extensions": ["kia"]
		},
		"application/vnd.kinar": {
			"source": "iana",
			"extensions": ["kne", "knp"]
		},
		"application/vnd.koan": {
			"source": "iana",
			"extensions": [
				"skp",
				"skd",
				"skt",
				"skm"
			]
		},
		"application/vnd.kodak-descriptor": {
			"source": "iana",
			"extensions": ["sse"]
		},
		"application/vnd.las": { "source": "iana" },
		"application/vnd.las.las+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.las.las+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lasxml"]
		},
		"application/vnd.laszip": { "source": "iana" },
		"application/vnd.leap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.liberty-request+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.llamagraphics.life-balance.desktop": {
			"source": "iana",
			"extensions": ["lbd"]
		},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["lbe"]
		},
		"application/vnd.logipipe.circuit+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.loom": { "source": "iana" },
		"application/vnd.lotus-1-2-3": {
			"source": "iana",
			"extensions": ["123"]
		},
		"application/vnd.lotus-approach": {
			"source": "iana",
			"extensions": ["apr"]
		},
		"application/vnd.lotus-freelance": {
			"source": "iana",
			"extensions": ["pre"]
		},
		"application/vnd.lotus-notes": {
			"source": "iana",
			"extensions": ["nsf"]
		},
		"application/vnd.lotus-organizer": {
			"source": "iana",
			"extensions": ["org"]
		},
		"application/vnd.lotus-screencam": {
			"source": "iana",
			"extensions": ["scm"]
		},
		"application/vnd.lotus-wordpro": {
			"source": "iana",
			"extensions": ["lwp"]
		},
		"application/vnd.macports.portpkg": {
			"source": "iana",
			"extensions": ["portpkg"]
		},
		"application/vnd.mapbox-vector-tile": {
			"source": "iana",
			"extensions": ["mvt"]
		},
		"application/vnd.marlin.drm.actiontoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.conftoken+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.license+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.marlin.drm.mdcf": { "source": "iana" },
		"application/vnd.mason+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.maxar.archive.3tz+zip": {
			"source": "iana",
			"compressible": false
		},
		"application/vnd.maxmind.maxmind-db": { "source": "iana" },
		"application/vnd.mcd": {
			"source": "iana",
			"extensions": ["mcd"]
		},
		"application/vnd.medcalcdata": {
			"source": "iana",
			"extensions": ["mc1"]
		},
		"application/vnd.mediastation.cdkey": {
			"source": "iana",
			"extensions": ["cdkey"]
		},
		"application/vnd.meridian-slingshot": { "source": "iana" },
		"application/vnd.mfer": {
			"source": "iana",
			"extensions": ["mwf"]
		},
		"application/vnd.mfmp": {
			"source": "iana",
			"extensions": ["mfm"]
		},
		"application/vnd.micro+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.micrografx.flo": {
			"source": "iana",
			"extensions": ["flo"]
		},
		"application/vnd.micrografx.igx": {
			"source": "iana",
			"extensions": ["igx"]
		},
		"application/vnd.microsoft.portable-executable": { "source": "iana" },
		"application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
		"application/vnd.miele+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.mif": {
			"source": "iana",
			"extensions": ["mif"]
		},
		"application/vnd.minisoft-hp3000-save": { "source": "iana" },
		"application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
		"application/vnd.mobius.daf": {
			"source": "iana",
			"extensions": ["daf"]
		},
		"application/vnd.mobius.dis": {
			"source": "iana",
			"extensions": ["dis"]
		},
		"application/vnd.mobius.mbk": {
			"source": "iana",
			"extensions": ["mbk"]
		},
		"application/vnd.mobius.mqy": {
			"source": "iana",
			"extensions": ["mqy"]
		},
		"application/vnd.mobius.msl": {
			"source": "iana",
			"extensions": ["msl"]
		},
		"application/vnd.mobius.plc": {
			"source": "iana",
			"extensions": ["plc"]
		},
		"application/vnd.mobius.txf": {
			"source": "iana",
			"extensions": ["txf"]
		},
		"application/vnd.mophun.application": {
			"source": "iana",
			"extensions": ["mpn"]
		},
		"application/vnd.mophun.certificate": {
			"source": "iana",
			"extensions": ["mpc"]
		},
		"application/vnd.motorola.flexsuite": { "source": "iana" },
		"application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
		"application/vnd.motorola.flexsuite.fis": { "source": "iana" },
		"application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
		"application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
		"application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
		"application/vnd.motorola.flexsuite.wem": { "source": "iana" },
		"application/vnd.motorola.iprm": { "source": "iana" },
		"application/vnd.mozilla.xul+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xul"]
		},
		"application/vnd.ms-3mfdocument": { "source": "iana" },
		"application/vnd.ms-artgalry": {
			"source": "iana",
			"extensions": ["cil"]
		},
		"application/vnd.ms-asf": { "source": "iana" },
		"application/vnd.ms-cab-compressed": {
			"source": "iana",
			"extensions": ["cab"]
		},
		"application/vnd.ms-color.iccprofile": { "source": "apache" },
		"application/vnd.ms-excel": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xls",
				"xlm",
				"xla",
				"xlc",
				"xlt",
				"xlw"
			]
		},
		"application/vnd.ms-excel.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlam"]
		},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsb"]
		},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
			"source": "iana",
			"extensions": ["xlsm"]
		},
		"application/vnd.ms-excel.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["xltm"]
		},
		"application/vnd.ms-fontobject": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eot"]
		},
		"application/vnd.ms-htmlhelp": {
			"source": "iana",
			"extensions": ["chm"]
		},
		"application/vnd.ms-ims": {
			"source": "iana",
			"extensions": ["ims"]
		},
		"application/vnd.ms-lrm": {
			"source": "iana",
			"extensions": ["lrm"]
		},
		"application/vnd.ms-office.activex+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-officetheme": {
			"source": "iana",
			"extensions": ["thmx"]
		},
		"application/vnd.ms-opentype": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-outlook": {
			"compressible": false,
			"extensions": ["msg"]
		},
		"application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
		"application/vnd.ms-pki.seccat": {
			"source": "apache",
			"extensions": ["cat"]
		},
		"application/vnd.ms-pki.stl": {
			"source": "apache",
			"extensions": ["stl"]
		},
		"application/vnd.ms-playready.initiator+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-powerpoint": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ppt",
				"pps",
				"pot"
			]
		},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppam"]
		},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
			"source": "iana",
			"extensions": ["pptm"]
		},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
			"source": "iana",
			"extensions": ["sldm"]
		},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
			"source": "iana",
			"extensions": ["ppsm"]
		},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["potm"]
		},
		"application/vnd.ms-printdevicecapabilities+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-printing.printticket+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-printschematicket+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ms-project": {
			"source": "iana",
			"extensions": ["mpp", "mpt"]
		},
		"application/vnd.ms-tnef": { "source": "iana" },
		"application/vnd.ms-windows.devicepairing": { "source": "iana" },
		"application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
		"application/vnd.ms-windows.printerpairing": { "source": "iana" },
		"application/vnd.ms-windows.wsd.oob": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
		"application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
		"application/vnd.ms-word.document.macroenabled.12": {
			"source": "iana",
			"extensions": ["docm"]
		},
		"application/vnd.ms-word.template.macroenabled.12": {
			"source": "iana",
			"extensions": ["dotm"]
		},
		"application/vnd.ms-works": {
			"source": "iana",
			"extensions": [
				"wps",
				"wks",
				"wcm",
				"wdb"
			]
		},
		"application/vnd.ms-wpl": {
			"source": "iana",
			"extensions": ["wpl"]
		},
		"application/vnd.ms-xpsdocument": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xps"]
		},
		"application/vnd.msa-disk-image": { "source": "iana" },
		"application/vnd.mseq": {
			"source": "iana",
			"extensions": ["mseq"]
		},
		"application/vnd.msign": { "source": "iana" },
		"application/vnd.multiad.creator": { "source": "iana" },
		"application/vnd.multiad.creator.cif": { "source": "iana" },
		"application/vnd.music-niff": { "source": "iana" },
		"application/vnd.musician": {
			"source": "iana",
			"extensions": ["mus"]
		},
		"application/vnd.muvee.style": {
			"source": "iana",
			"extensions": ["msty"]
		},
		"application/vnd.mynfc": {
			"source": "iana",
			"extensions": ["taglet"]
		},
		"application/vnd.nacamar.ybrid+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ncd.control": { "source": "iana" },
		"application/vnd.ncd.reference": { "source": "iana" },
		"application/vnd.nearst.inv+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nebumind.line": { "source": "iana" },
		"application/vnd.nervana": { "source": "iana" },
		"application/vnd.netfpx": { "source": "iana" },
		"application/vnd.neurolanguage.nlu": {
			"source": "iana",
			"extensions": ["nlu"]
		},
		"application/vnd.nimn": { "source": "iana" },
		"application/vnd.nintendo.nitro.rom": { "source": "iana" },
		"application/vnd.nintendo.snes.rom": { "source": "iana" },
		"application/vnd.nitf": {
			"source": "iana",
			"extensions": ["ntf", "nitf"]
		},
		"application/vnd.noblenet-directory": {
			"source": "iana",
			"extensions": ["nnd"]
		},
		"application/vnd.noblenet-sealer": {
			"source": "iana",
			"extensions": ["nns"]
		},
		"application/vnd.noblenet-web": {
			"source": "iana",
			"extensions": ["nnw"]
		},
		"application/vnd.nokia.catalogs": { "source": "iana" },
		"application/vnd.nokia.conml+wbxml": { "source": "iana" },
		"application/vnd.nokia.conml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.iptv.config+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.isds-radio-presets": { "source": "iana" },
		"application/vnd.nokia.landmark+wbxml": { "source": "iana" },
		"application/vnd.nokia.landmark+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.landmarkcollection+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.n-gage.ac+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ac"]
		},
		"application/vnd.nokia.n-gage.data": {
			"source": "iana",
			"extensions": ["ngdat"]
		},
		"application/vnd.nokia.n-gage.symbian.install": {
			"source": "iana",
			"extensions": ["n-gage"]
		},
		"application/vnd.nokia.ncd": { "source": "iana" },
		"application/vnd.nokia.pcd+wbxml": { "source": "iana" },
		"application/vnd.nokia.pcd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.nokia.radio-preset": {
			"source": "iana",
			"extensions": ["rpst"]
		},
		"application/vnd.nokia.radio-presets": {
			"source": "iana",
			"extensions": ["rpss"]
		},
		"application/vnd.novadigm.edm": {
			"source": "iana",
			"extensions": ["edm"]
		},
		"application/vnd.novadigm.edx": {
			"source": "iana",
			"extensions": ["edx"]
		},
		"application/vnd.novadigm.ext": {
			"source": "iana",
			"extensions": ["ext"]
		},
		"application/vnd.ntt-local.content-share": { "source": "iana" },
		"application/vnd.ntt-local.file-transfer": { "source": "iana" },
		"application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
		"application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
		"application/vnd.oasis.opendocument.chart": {
			"source": "iana",
			"extensions": ["odc"]
		},
		"application/vnd.oasis.opendocument.chart-template": {
			"source": "iana",
			"extensions": ["otc"]
		},
		"application/vnd.oasis.opendocument.database": {
			"source": "iana",
			"extensions": ["odb"]
		},
		"application/vnd.oasis.opendocument.formula": {
			"source": "iana",
			"extensions": ["odf"]
		},
		"application/vnd.oasis.opendocument.formula-template": {
			"source": "iana",
			"extensions": ["odft"]
		},
		"application/vnd.oasis.opendocument.graphics": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odg"]
		},
		"application/vnd.oasis.opendocument.graphics-template": {
			"source": "iana",
			"extensions": ["otg"]
		},
		"application/vnd.oasis.opendocument.image": {
			"source": "iana",
			"extensions": ["odi"]
		},
		"application/vnd.oasis.opendocument.image-template": {
			"source": "iana",
			"extensions": ["oti"]
		},
		"application/vnd.oasis.opendocument.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odp"]
		},
		"application/vnd.oasis.opendocument.presentation-template": {
			"source": "iana",
			"extensions": ["otp"]
		},
		"application/vnd.oasis.opendocument.spreadsheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ods"]
		},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
			"source": "iana",
			"extensions": ["ots"]
		},
		"application/vnd.oasis.opendocument.text": {
			"source": "iana",
			"compressible": false,
			"extensions": ["odt"]
		},
		"application/vnd.oasis.opendocument.text-master": {
			"source": "iana",
			"extensions": ["odm"]
		},
		"application/vnd.oasis.opendocument.text-template": {
			"source": "iana",
			"extensions": ["ott"]
		},
		"application/vnd.oasis.opendocument.text-web": {
			"source": "iana",
			"extensions": ["oth"]
		},
		"application/vnd.obn": { "source": "iana" },
		"application/vnd.ocf+cbor": { "source": "iana" },
		"application/vnd.oci.image.manifest.v1+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oftn.l10n+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessdownload+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessstreaming+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
		"application/vnd.oipf.dae.svg+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.dae.xhtml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.pae.gem": { "source": "iana" },
		"application/vnd.oipf.spdiscovery+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.spdlist+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.ueprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.userprofile+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.olpc-sugar": {
			"source": "iana",
			"extensions": ["xo"]
		},
		"application/vnd.oma-scws-config": { "source": "iana" },
		"application/vnd.oma-scws-http-request": { "source": "iana" },
		"application/vnd.oma-scws-http-response": { "source": "iana" },
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.drm-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.imd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.ltkm": { "source": "iana" },
		"application/vnd.oma.bcast.notification+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
		"application/vnd.oma.bcast.sgboot": { "source": "iana" },
		"application/vnd.oma.bcast.sgdd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sgdu": { "source": "iana" },
		"application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.sprov+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.bcast.stkm": { "source": "iana" },
		"application/vnd.oma.cab-address-book+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-feature-handler+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-pcc+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-subs-invite+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.cab-user-prefs+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.dcd": { "source": "iana" },
		"application/vnd.oma.dcdc": { "source": "iana" },
		"application/vnd.oma.dd2+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dd2"]
		},
		"application/vnd.oma.drm.risd+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.group-usage-list+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+cbor": { "source": "iana" },
		"application/vnd.oma.lwm2m+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.lwm2m+tlv": { "source": "iana" },
		"application/vnd.oma.pal+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.final-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.groups+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.push": { "source": "iana" },
		"application/vnd.oma.scidm.messages+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oma.xcap-directory+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.omads-email+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-file+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omads-folder+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.omaloc-supl-init": { "source": "iana" },
		"application/vnd.onepager": { "source": "iana" },
		"application/vnd.onepagertamp": { "source": "iana" },
		"application/vnd.onepagertamx": { "source": "iana" },
		"application/vnd.onepagertat": { "source": "iana" },
		"application/vnd.onepagertatp": { "source": "iana" },
		"application/vnd.onepagertatx": { "source": "iana" },
		"application/vnd.openblox.game+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["obgx"]
		},
		"application/vnd.openblox.game-binary": { "source": "iana" },
		"application/vnd.openeye.oeb": { "source": "iana" },
		"application/vnd.openofficeorg.extension": {
			"source": "apache",
			"extensions": ["oxt"]
		},
		"application/vnd.openstreetmap.data+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osm"]
		},
		"application/vnd.opentimestamps.ots": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": ["pptx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
			"source": "iana",
			"extensions": ["sldx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
			"source": "iana",
			"extensions": ["ppsx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
			"source": "iana",
			"extensions": ["potx"]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
			"source": "iana",
			"compressible": false,
			"extensions": ["xlsx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
			"source": "iana",
			"extensions": ["xltx"]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
			"source": "iana",
			"compressible": false,
			"extensions": ["docx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
			"source": "iana",
			"extensions": ["dotx"]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.core-properties+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.openxmlformats-package.relationships+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oracle.resource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.orange.indata": { "source": "iana" },
		"application/vnd.osa.netdeploy": { "source": "iana" },
		"application/vnd.osgeo.mapguide.package": {
			"source": "iana",
			"extensions": ["mgp"]
		},
		"application/vnd.osgi.bundle": { "source": "iana" },
		"application/vnd.osgi.dp": {
			"source": "iana",
			"extensions": ["dp"]
		},
		"application/vnd.osgi.subsystem": {
			"source": "iana",
			"extensions": ["esa"]
		},
		"application/vnd.otps.ct-kip+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oxli.countgraph": { "source": "iana" },
		"application/vnd.pagerduty+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.palm": {
			"source": "iana",
			"extensions": [
				"pdb",
				"pqa",
				"oprc"
			]
		},
		"application/vnd.panoply": { "source": "iana" },
		"application/vnd.paos.xml": { "source": "iana" },
		"application/vnd.patentdive": { "source": "iana" },
		"application/vnd.patientecommsdoc": { "source": "iana" },
		"application/vnd.pawaafile": {
			"source": "iana",
			"extensions": ["paw"]
		},
		"application/vnd.pcos": { "source": "iana" },
		"application/vnd.pg.format": {
			"source": "iana",
			"extensions": ["str"]
		},
		"application/vnd.pg.osasli": {
			"source": "iana",
			"extensions": ["ei6"]
		},
		"application/vnd.piaccess.application-licence": { "source": "iana" },
		"application/vnd.picsel": {
			"source": "iana",
			"extensions": ["efif"]
		},
		"application/vnd.pmi.widget": {
			"source": "iana",
			"extensions": ["wg"]
		},
		"application/vnd.poc.group-advertisement+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.pocketlearn": {
			"source": "iana",
			"extensions": ["plf"]
		},
		"application/vnd.powerbuilder6": {
			"source": "iana",
			"extensions": ["pbd"]
		},
		"application/vnd.powerbuilder6-s": { "source": "iana" },
		"application/vnd.powerbuilder7": { "source": "iana" },
		"application/vnd.powerbuilder7-s": { "source": "iana" },
		"application/vnd.powerbuilder75": { "source": "iana" },
		"application/vnd.powerbuilder75-s": { "source": "iana" },
		"application/vnd.preminet": { "source": "iana" },
		"application/vnd.previewsystems.box": {
			"source": "iana",
			"extensions": ["box"]
		},
		"application/vnd.proteus.magazine": {
			"source": "iana",
			"extensions": ["mgz"]
		},
		"application/vnd.psfs": { "source": "iana" },
		"application/vnd.publishare-delta-tree": {
			"source": "iana",
			"extensions": ["qps"]
		},
		"application/vnd.pvi.ptid1": {
			"source": "iana",
			"extensions": ["ptid"]
		},
		"application/vnd.pwg-multiplexed": { "source": "iana" },
		"application/vnd.pwg-xhtml-print+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.qualcomm.brew-app-res": { "source": "iana" },
		"application/vnd.quarantainenet": { "source": "iana" },
		"application/vnd.quark.quarkxpress": {
			"source": "iana",
			"extensions": [
				"qxd",
				"qxt",
				"qwd",
				"qwt",
				"qxl",
				"qxb"
			]
		},
		"application/vnd.quobject-quoxdocument": { "source": "iana" },
		"application/vnd.radisys.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-conn+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-audit-stream+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-conf+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-base+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-group+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-speech+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.radisys.msml-dialog-transform+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rainstor.data": { "source": "iana" },
		"application/vnd.rapid": { "source": "iana" },
		"application/vnd.rar": {
			"source": "iana",
			"extensions": ["rar"]
		},
		"application/vnd.realvnc.bed": {
			"source": "iana",
			"extensions": ["bed"]
		},
		"application/vnd.recordare.musicxml": {
			"source": "iana",
			"extensions": ["mxl"]
		},
		"application/vnd.recordare.musicxml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["musicxml"]
		},
		"application/vnd.renlearn.rlprint": { "source": "iana" },
		"application/vnd.resilient.logic": { "source": "iana" },
		"application/vnd.restful+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.rig.cryptonote": {
			"source": "iana",
			"extensions": ["cryptonote"]
		},
		"application/vnd.rim.cod": {
			"source": "apache",
			"extensions": ["cod"]
		},
		"application/vnd.rn-realmedia": {
			"source": "apache",
			"extensions": ["rm"]
		},
		"application/vnd.rn-realmedia-vbr": {
			"source": "apache",
			"extensions": ["rmvb"]
		},
		"application/vnd.route66.link66+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["link66"]
		},
		"application/vnd.rs-274x": { "source": "iana" },
		"application/vnd.ruckus.download": { "source": "iana" },
		"application/vnd.s3sms": { "source": "iana" },
		"application/vnd.sailingtracker.track": {
			"source": "iana",
			"extensions": ["st"]
		},
		"application/vnd.sar": { "source": "iana" },
		"application/vnd.sbm.cid": { "source": "iana" },
		"application/vnd.sbm.mid2": { "source": "iana" },
		"application/vnd.scribus": { "source": "iana" },
		"application/vnd.sealed.3df": { "source": "iana" },
		"application/vnd.sealed.csf": { "source": "iana" },
		"application/vnd.sealed.doc": { "source": "iana" },
		"application/vnd.sealed.eml": { "source": "iana" },
		"application/vnd.sealed.mht": { "source": "iana" },
		"application/vnd.sealed.net": { "source": "iana" },
		"application/vnd.sealed.ppt": { "source": "iana" },
		"application/vnd.sealed.tiff": { "source": "iana" },
		"application/vnd.sealed.xls": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.html": { "source": "iana" },
		"application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
		"application/vnd.seemail": {
			"source": "iana",
			"extensions": ["see"]
		},
		"application/vnd.seis+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.sema": {
			"source": "iana",
			"extensions": ["sema"]
		},
		"application/vnd.semd": {
			"source": "iana",
			"extensions": ["semd"]
		},
		"application/vnd.semf": {
			"source": "iana",
			"extensions": ["semf"]
		},
		"application/vnd.shade-save-file": { "source": "iana" },
		"application/vnd.shana.informed.formdata": {
			"source": "iana",
			"extensions": ["ifm"]
		},
		"application/vnd.shana.informed.formtemplate": {
			"source": "iana",
			"extensions": ["itp"]
		},
		"application/vnd.shana.informed.interchange": {
			"source": "iana",
			"extensions": ["iif"]
		},
		"application/vnd.shana.informed.package": {
			"source": "iana",
			"extensions": ["ipk"]
		},
		"application/vnd.shootproof+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shopkick+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.shp": { "source": "iana" },
		"application/vnd.shx": { "source": "iana" },
		"application/vnd.sigrok.session": { "source": "iana" },
		"application/vnd.simtech-mindmapper": {
			"source": "iana",
			"extensions": ["twd", "twds"]
		},
		"application/vnd.siren+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.smaf": {
			"source": "iana",
			"extensions": ["mmf"]
		},
		"application/vnd.smart.notebook": { "source": "iana" },
		"application/vnd.smart.teacher": {
			"source": "iana",
			"extensions": ["teacher"]
		},
		"application/vnd.snesdev-page-table": { "source": "iana" },
		"application/vnd.software602.filler.form+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["fo"]
		},
		"application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
		"application/vnd.solent.sdkm+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["sdkm", "sdkd"]
		},
		"application/vnd.spotfire.dxp": {
			"source": "iana",
			"extensions": ["dxp"]
		},
		"application/vnd.spotfire.sfs": {
			"source": "iana",
			"extensions": ["sfs"]
		},
		"application/vnd.sqlite3": { "source": "iana" },
		"application/vnd.sss-cod": { "source": "iana" },
		"application/vnd.sss-dtf": { "source": "iana" },
		"application/vnd.sss-ntf": { "source": "iana" },
		"application/vnd.stardivision.calc": {
			"source": "apache",
			"extensions": ["sdc"]
		},
		"application/vnd.stardivision.draw": {
			"source": "apache",
			"extensions": ["sda"]
		},
		"application/vnd.stardivision.impress": {
			"source": "apache",
			"extensions": ["sdd"]
		},
		"application/vnd.stardivision.math": {
			"source": "apache",
			"extensions": ["smf"]
		},
		"application/vnd.stardivision.writer": {
			"source": "apache",
			"extensions": ["sdw", "vor"]
		},
		"application/vnd.stardivision.writer-global": {
			"source": "apache",
			"extensions": ["sgl"]
		},
		"application/vnd.stepmania.package": {
			"source": "iana",
			"extensions": ["smzip"]
		},
		"application/vnd.stepmania.stepchart": {
			"source": "iana",
			"extensions": ["sm"]
		},
		"application/vnd.street-stream": { "source": "iana" },
		"application/vnd.sun.wadl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wadl"]
		},
		"application/vnd.sun.xml.calc": {
			"source": "apache",
			"extensions": ["sxc"]
		},
		"application/vnd.sun.xml.calc.template": {
			"source": "apache",
			"extensions": ["stc"]
		},
		"application/vnd.sun.xml.draw": {
			"source": "apache",
			"extensions": ["sxd"]
		},
		"application/vnd.sun.xml.draw.template": {
			"source": "apache",
			"extensions": ["std"]
		},
		"application/vnd.sun.xml.impress": {
			"source": "apache",
			"extensions": ["sxi"]
		},
		"application/vnd.sun.xml.impress.template": {
			"source": "apache",
			"extensions": ["sti"]
		},
		"application/vnd.sun.xml.math": {
			"source": "apache",
			"extensions": ["sxm"]
		},
		"application/vnd.sun.xml.writer": {
			"source": "apache",
			"extensions": ["sxw"]
		},
		"application/vnd.sun.xml.writer.global": {
			"source": "apache",
			"extensions": ["sxg"]
		},
		"application/vnd.sun.xml.writer.template": {
			"source": "apache",
			"extensions": ["stw"]
		},
		"application/vnd.sus-calendar": {
			"source": "iana",
			"extensions": ["sus", "susp"]
		},
		"application/vnd.svd": {
			"source": "iana",
			"extensions": ["svd"]
		},
		"application/vnd.swiftview-ics": { "source": "iana" },
		"application/vnd.sycle+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.syft+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.symbian.install": {
			"source": "apache",
			"extensions": ["sis", "sisx"]
		},
		"application/vnd.syncml+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xsm"]
		},
		"application/vnd.syncml.dm+wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["bdm"]
		},
		"application/vnd.syncml.dm+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["xdm"]
		},
		"application/vnd.syncml.dm.notification": { "source": "iana" },
		"application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmddf+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["ddf"]
		},
		"application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
		"application/vnd.syncml.dmtnds+xml": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true
		},
		"application/vnd.syncml.ds.notification": { "source": "iana" },
		"application/vnd.tableschema+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tao.intent-module-archive": {
			"source": "iana",
			"extensions": ["tao"]
		},
		"application/vnd.tcpdump.pcap": {
			"source": "iana",
			"extensions": [
				"pcap",
				"cap",
				"dmp"
			]
		},
		"application/vnd.think-cell.ppttc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tmd.mediaflex.api+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.tml": { "source": "iana" },
		"application/vnd.tmobile-livetv": {
			"source": "iana",
			"extensions": ["tmo"]
		},
		"application/vnd.tri.onesource": { "source": "iana" },
		"application/vnd.trid.tpt": {
			"source": "iana",
			"extensions": ["tpt"]
		},
		"application/vnd.triscape.mxs": {
			"source": "iana",
			"extensions": ["mxs"]
		},
		"application/vnd.trueapp": {
			"source": "iana",
			"extensions": ["tra"]
		},
		"application/vnd.truedoc": { "source": "iana" },
		"application/vnd.ubisoft.webplayer": { "source": "iana" },
		"application/vnd.ufdl": {
			"source": "iana",
			"extensions": ["ufd", "ufdl"]
		},
		"application/vnd.uiq.theme": {
			"source": "iana",
			"extensions": ["utz"]
		},
		"application/vnd.umajin": {
			"source": "iana",
			"extensions": ["umj"]
		},
		"application/vnd.unity": {
			"source": "iana",
			"extensions": ["unityweb"]
		},
		"application/vnd.uoml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["uoml"]
		},
		"application/vnd.uplanet.alert": { "source": "iana" },
		"application/vnd.uplanet.alert-wbxml": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice": { "source": "iana" },
		"application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
		"application/vnd.uplanet.cacheop": { "source": "iana" },
		"application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
		"application/vnd.uplanet.channel": { "source": "iana" },
		"application/vnd.uplanet.channel-wbxml": { "source": "iana" },
		"application/vnd.uplanet.list": { "source": "iana" },
		"application/vnd.uplanet.list-wbxml": { "source": "iana" },
		"application/vnd.uplanet.listcmd": { "source": "iana" },
		"application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
		"application/vnd.uplanet.signal": { "source": "iana" },
		"application/vnd.uri-map": { "source": "iana" },
		"application/vnd.valve.source.material": { "source": "iana" },
		"application/vnd.vcx": {
			"source": "iana",
			"extensions": ["vcx"]
		},
		"application/vnd.vd-study": { "source": "iana" },
		"application/vnd.vectorworks": { "source": "iana" },
		"application/vnd.vel+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.verimatrix.vcas": { "source": "iana" },
		"application/vnd.veritone.aion+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.veryant.thin": { "source": "iana" },
		"application/vnd.ves.encrypted": { "source": "iana" },
		"application/vnd.vidsoft.vidconference": { "source": "iana" },
		"application/vnd.visio": {
			"source": "iana",
			"extensions": [
				"vsd",
				"vst",
				"vss",
				"vsw"
			]
		},
		"application/vnd.visionary": {
			"source": "iana",
			"extensions": ["vis"]
		},
		"application/vnd.vividence.scriptfile": { "source": "iana" },
		"application/vnd.vsf": {
			"source": "iana",
			"extensions": ["vsf"]
		},
		"application/vnd.wap.sic": { "source": "iana" },
		"application/vnd.wap.slc": { "source": "iana" },
		"application/vnd.wap.wbxml": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["wbxml"]
		},
		"application/vnd.wap.wmlc": {
			"source": "iana",
			"extensions": ["wmlc"]
		},
		"application/vnd.wap.wmlscriptc": {
			"source": "iana",
			"extensions": ["wmlsc"]
		},
		"application/vnd.webturbo": {
			"source": "iana",
			"extensions": ["wtb"]
		},
		"application/vnd.wfa.dpp": { "source": "iana" },
		"application/vnd.wfa.p2p": { "source": "iana" },
		"application/vnd.wfa.wsc": { "source": "iana" },
		"application/vnd.windows.devicepairing": { "source": "iana" },
		"application/vnd.wmc": { "source": "iana" },
		"application/vnd.wmf.bootstrap": { "source": "iana" },
		"application/vnd.wolfram.mathematica": { "source": "iana" },
		"application/vnd.wolfram.mathematica.package": { "source": "iana" },
		"application/vnd.wolfram.player": {
			"source": "iana",
			"extensions": ["nbp"]
		},
		"application/vnd.wordperfect": {
			"source": "iana",
			"extensions": ["wpd"]
		},
		"application/vnd.wqd": {
			"source": "iana",
			"extensions": ["wqd"]
		},
		"application/vnd.wrq-hp3000-labelled": { "source": "iana" },
		"application/vnd.wt.stf": {
			"source": "iana",
			"extensions": ["stf"]
		},
		"application/vnd.wv.csp+wbxml": { "source": "iana" },
		"application/vnd.wv.csp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.wv.ssp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xacml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xara": {
			"source": "iana",
			"extensions": ["xar"]
		},
		"application/vnd.xfdl": {
			"source": "iana",
			"extensions": ["xfdl"]
		},
		"application/vnd.xfdl.webform": { "source": "iana" },
		"application/vnd.xmi+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xmpie.cpkg": { "source": "iana" },
		"application/vnd.xmpie.dpkg": { "source": "iana" },
		"application/vnd.xmpie.plan": { "source": "iana" },
		"application/vnd.xmpie.ppkg": { "source": "iana" },
		"application/vnd.xmpie.xlim": { "source": "iana" },
		"application/vnd.yamaha.hv-dic": {
			"source": "iana",
			"extensions": ["hvd"]
		},
		"application/vnd.yamaha.hv-script": {
			"source": "iana",
			"extensions": ["hvs"]
		},
		"application/vnd.yamaha.hv-voice": {
			"source": "iana",
			"extensions": ["hvp"]
		},
		"application/vnd.yamaha.openscoreformat": {
			"source": "iana",
			"extensions": ["osf"]
		},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["osfpvg"]
		},
		"application/vnd.yamaha.remote-setup": { "source": "iana" },
		"application/vnd.yamaha.smaf-audio": {
			"source": "iana",
			"extensions": ["saf"]
		},
		"application/vnd.yamaha.smaf-phrase": {
			"source": "iana",
			"extensions": ["spf"]
		},
		"application/vnd.yamaha.through-ngn": { "source": "iana" },
		"application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
		"application/vnd.yaoweme": { "source": "iana" },
		"application/vnd.yellowriver-custom-menu": {
			"source": "iana",
			"extensions": ["cmp"]
		},
		"application/vnd.youtube.yt": { "source": "iana" },
		"application/vnd.zul": {
			"source": "iana",
			"extensions": ["zir", "zirz"]
		},
		"application/vnd.zzazz.deck+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["zaz"]
		},
		"application/voicexml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vxml"]
		},
		"application/voucher-cms+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vq-rtcpxr": { "source": "iana" },
		"application/wasm": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wasm"]
		},
		"application/watcherinfo+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wif"]
		},
		"application/webpush-options+json": {
			"source": "iana",
			"compressible": true
		},
		"application/whoispp-query": { "source": "iana" },
		"application/whoispp-response": { "source": "iana" },
		"application/widget": {
			"source": "iana",
			"extensions": ["wgt"]
		},
		"application/winhlp": {
			"source": "apache",
			"extensions": ["hlp"]
		},
		"application/wita": { "source": "iana" },
		"application/wordperfect5.1": { "source": "iana" },
		"application/wsdl+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wsdl"]
		},
		"application/wspolicy+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["wspolicy"]
		},
		"application/x-7z-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["7z"]
		},
		"application/x-abiword": {
			"source": "apache",
			"extensions": ["abw"]
		},
		"application/x-ace-compressed": {
			"source": "apache",
			"extensions": ["ace"]
		},
		"application/x-amf": { "source": "apache" },
		"application/x-apple-diskimage": {
			"source": "apache",
			"extensions": ["dmg"]
		},
		"application/x-arj": {
			"compressible": false,
			"extensions": ["arj"]
		},
		"application/x-authorware-bin": {
			"source": "apache",
			"extensions": [
				"aab",
				"x32",
				"u32",
				"vox"
			]
		},
		"application/x-authorware-map": {
			"source": "apache",
			"extensions": ["aam"]
		},
		"application/x-authorware-seg": {
			"source": "apache",
			"extensions": ["aas"]
		},
		"application/x-bcpio": {
			"source": "apache",
			"extensions": ["bcpio"]
		},
		"application/x-bdoc": {
			"compressible": false,
			"extensions": ["bdoc"]
		},
		"application/x-bittorrent": {
			"source": "apache",
			"extensions": ["torrent"]
		},
		"application/x-blorb": {
			"source": "apache",
			"extensions": ["blb", "blorb"]
		},
		"application/x-bzip": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz"]
		},
		"application/x-bzip2": {
			"source": "apache",
			"compressible": false,
			"extensions": ["bz2", "boz"]
		},
		"application/x-cbr": {
			"source": "apache",
			"extensions": [
				"cbr",
				"cba",
				"cbt",
				"cbz",
				"cb7"
			]
		},
		"application/x-cdlink": {
			"source": "apache",
			"extensions": ["vcd"]
		},
		"application/x-cfs-compressed": {
			"source": "apache",
			"extensions": ["cfs"]
		},
		"application/x-chat": {
			"source": "apache",
			"extensions": ["chat"]
		},
		"application/x-chess-pgn": {
			"source": "apache",
			"extensions": ["pgn"]
		},
		"application/x-chrome-extension": { "extensions": ["crx"] },
		"application/x-cocoa": {
			"source": "nginx",
			"extensions": ["cco"]
		},
		"application/x-compress": { "source": "apache" },
		"application/x-conference": {
			"source": "apache",
			"extensions": ["nsc"]
		},
		"application/x-cpio": {
			"source": "apache",
			"extensions": ["cpio"]
		},
		"application/x-csh": {
			"source": "apache",
			"extensions": ["csh"]
		},
		"application/x-deb": { "compressible": false },
		"application/x-debian-package": {
			"source": "apache",
			"extensions": ["deb", "udeb"]
		},
		"application/x-dgc-compressed": {
			"source": "apache",
			"extensions": ["dgc"]
		},
		"application/x-director": {
			"source": "apache",
			"extensions": [
				"dir",
				"dcr",
				"dxr",
				"cst",
				"cct",
				"cxt",
				"w3d",
				"fgd",
				"swa"
			]
		},
		"application/x-doom": {
			"source": "apache",
			"extensions": ["wad"]
		},
		"application/x-dtbncx+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ncx"]
		},
		"application/x-dtbook+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["dtb"]
		},
		"application/x-dtbresource+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["res"]
		},
		"application/x-dvi": {
			"source": "apache",
			"compressible": false,
			"extensions": ["dvi"]
		},
		"application/x-envoy": {
			"source": "apache",
			"extensions": ["evy"]
		},
		"application/x-eva": {
			"source": "apache",
			"extensions": ["eva"]
		},
		"application/x-font-bdf": {
			"source": "apache",
			"extensions": ["bdf"]
		},
		"application/x-font-dos": { "source": "apache" },
		"application/x-font-framemaker": { "source": "apache" },
		"application/x-font-ghostscript": {
			"source": "apache",
			"extensions": ["gsf"]
		},
		"application/x-font-libgrx": { "source": "apache" },
		"application/x-font-linux-psf": {
			"source": "apache",
			"extensions": ["psf"]
		},
		"application/x-font-pcf": {
			"source": "apache",
			"extensions": ["pcf"]
		},
		"application/x-font-snf": {
			"source": "apache",
			"extensions": ["snf"]
		},
		"application/x-font-speedo": { "source": "apache" },
		"application/x-font-sunos-news": { "source": "apache" },
		"application/x-font-type1": {
			"source": "apache",
			"extensions": [
				"pfa",
				"pfb",
				"pfm",
				"afm"
			]
		},
		"application/x-font-vfont": { "source": "apache" },
		"application/x-freearc": {
			"source": "apache",
			"extensions": ["arc"]
		},
		"application/x-futuresplash": {
			"source": "apache",
			"extensions": ["spl"]
		},
		"application/x-gca-compressed": {
			"source": "apache",
			"extensions": ["gca"]
		},
		"application/x-glulx": {
			"source": "apache",
			"extensions": ["ulx"]
		},
		"application/x-gnumeric": {
			"source": "apache",
			"extensions": ["gnumeric"]
		},
		"application/x-gramps-xml": {
			"source": "apache",
			"extensions": ["gramps"]
		},
		"application/x-gtar": {
			"source": "apache",
			"extensions": ["gtar"]
		},
		"application/x-gzip": { "source": "apache" },
		"application/x-hdf": {
			"source": "apache",
			"extensions": ["hdf"]
		},
		"application/x-httpd-php": {
			"compressible": true,
			"extensions": ["php"]
		},
		"application/x-install-instructions": {
			"source": "apache",
			"extensions": ["install"]
		},
		"application/x-iso9660-image": {
			"source": "apache",
			"extensions": ["iso"]
		},
		"application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
		"application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
		"application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
		"application/x-java-archive-diff": {
			"source": "nginx",
			"extensions": ["jardiff"]
		},
		"application/x-java-jnlp-file": {
			"source": "apache",
			"compressible": false,
			"extensions": ["jnlp"]
		},
		"application/x-javascript": { "compressible": true },
		"application/x-keepass2": { "extensions": ["kdbx"] },
		"application/x-latex": {
			"source": "apache",
			"compressible": false,
			"extensions": ["latex"]
		},
		"application/x-lua-bytecode": { "extensions": ["luac"] },
		"application/x-lzh-compressed": {
			"source": "apache",
			"extensions": ["lzh", "lha"]
		},
		"application/x-makeself": {
			"source": "nginx",
			"extensions": ["run"]
		},
		"application/x-mie": {
			"source": "apache",
			"extensions": ["mie"]
		},
		"application/x-mobipocket-ebook": {
			"source": "apache",
			"extensions": ["prc", "mobi"]
		},
		"application/x-mpegurl": { "compressible": false },
		"application/x-ms-application": {
			"source": "apache",
			"extensions": ["application"]
		},
		"application/x-ms-shortcut": {
			"source": "apache",
			"extensions": ["lnk"]
		},
		"application/x-ms-wmd": {
			"source": "apache",
			"extensions": ["wmd"]
		},
		"application/x-ms-wmz": {
			"source": "apache",
			"extensions": ["wmz"]
		},
		"application/x-ms-xbap": {
			"source": "apache",
			"extensions": ["xbap"]
		},
		"application/x-msaccess": {
			"source": "apache",
			"extensions": ["mdb"]
		},
		"application/x-msbinder": {
			"source": "apache",
			"extensions": ["obd"]
		},
		"application/x-mscardfile": {
			"source": "apache",
			"extensions": ["crd"]
		},
		"application/x-msclip": {
			"source": "apache",
			"extensions": ["clp"]
		},
		"application/x-msdos-program": { "extensions": ["exe"] },
		"application/x-msdownload": {
			"source": "apache",
			"extensions": [
				"exe",
				"dll",
				"com",
				"bat",
				"msi"
			]
		},
		"application/x-msmediaview": {
			"source": "apache",
			"extensions": [
				"mvb",
				"m13",
				"m14"
			]
		},
		"application/x-msmetafile": {
			"source": "apache",
			"extensions": [
				"wmf",
				"wmz",
				"emf",
				"emz"
			]
		},
		"application/x-msmoney": {
			"source": "apache",
			"extensions": ["mny"]
		},
		"application/x-mspublisher": {
			"source": "apache",
			"extensions": ["pub"]
		},
		"application/x-msschedule": {
			"source": "apache",
			"extensions": ["scd"]
		},
		"application/x-msterminal": {
			"source": "apache",
			"extensions": ["trm"]
		},
		"application/x-mswrite": {
			"source": "apache",
			"extensions": ["wri"]
		},
		"application/x-netcdf": {
			"source": "apache",
			"extensions": ["nc", "cdf"]
		},
		"application/x-ns-proxy-autoconfig": {
			"compressible": true,
			"extensions": ["pac"]
		},
		"application/x-nzb": {
			"source": "apache",
			"extensions": ["nzb"]
		},
		"application/x-perl": {
			"source": "nginx",
			"extensions": ["pl", "pm"]
		},
		"application/x-pilot": {
			"source": "nginx",
			"extensions": ["prc", "pdb"]
		},
		"application/x-pkcs12": {
			"source": "apache",
			"compressible": false,
			"extensions": ["p12", "pfx"]
		},
		"application/x-pkcs7-certificates": {
			"source": "apache",
			"extensions": ["p7b", "spc"]
		},
		"application/x-pkcs7-certreqresp": {
			"source": "apache",
			"extensions": ["p7r"]
		},
		"application/x-pki-message": { "source": "iana" },
		"application/x-rar-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": ["rar"]
		},
		"application/x-redhat-package-manager": {
			"source": "nginx",
			"extensions": ["rpm"]
		},
		"application/x-research-info-systems": {
			"source": "apache",
			"extensions": ["ris"]
		},
		"application/x-sea": {
			"source": "nginx",
			"extensions": ["sea"]
		},
		"application/x-sh": {
			"source": "apache",
			"compressible": true,
			"extensions": ["sh"]
		},
		"application/x-shar": {
			"source": "apache",
			"extensions": ["shar"]
		},
		"application/x-shockwave-flash": {
			"source": "apache",
			"compressible": false,
			"extensions": ["swf"]
		},
		"application/x-silverlight-app": {
			"source": "apache",
			"extensions": ["xap"]
		},
		"application/x-sql": {
			"source": "apache",
			"extensions": ["sql"]
		},
		"application/x-stuffit": {
			"source": "apache",
			"compressible": false,
			"extensions": ["sit"]
		},
		"application/x-stuffitx": {
			"source": "apache",
			"extensions": ["sitx"]
		},
		"application/x-subrip": {
			"source": "apache",
			"extensions": ["srt"]
		},
		"application/x-sv4cpio": {
			"source": "apache",
			"extensions": ["sv4cpio"]
		},
		"application/x-sv4crc": {
			"source": "apache",
			"extensions": ["sv4crc"]
		},
		"application/x-t3vm-image": {
			"source": "apache",
			"extensions": ["t3"]
		},
		"application/x-tads": {
			"source": "apache",
			"extensions": ["gam"]
		},
		"application/x-tar": {
			"source": "apache",
			"compressible": true,
			"extensions": ["tar"]
		},
		"application/x-tcl": {
			"source": "apache",
			"extensions": ["tcl", "tk"]
		},
		"application/x-tex": {
			"source": "apache",
			"extensions": ["tex"]
		},
		"application/x-tex-tfm": {
			"source": "apache",
			"extensions": ["tfm"]
		},
		"application/x-texinfo": {
			"source": "apache",
			"extensions": ["texinfo", "texi"]
		},
		"application/x-tgif": {
			"source": "apache",
			"extensions": ["obj"]
		},
		"application/x-ustar": {
			"source": "apache",
			"extensions": ["ustar"]
		},
		"application/x-virtualbox-hdd": {
			"compressible": true,
			"extensions": ["hdd"]
		},
		"application/x-virtualbox-ova": {
			"compressible": true,
			"extensions": ["ova"]
		},
		"application/x-virtualbox-ovf": {
			"compressible": true,
			"extensions": ["ovf"]
		},
		"application/x-virtualbox-vbox": {
			"compressible": true,
			"extensions": ["vbox"]
		},
		"application/x-virtualbox-vbox-extpack": {
			"compressible": false,
			"extensions": ["vbox-extpack"]
		},
		"application/x-virtualbox-vdi": {
			"compressible": true,
			"extensions": ["vdi"]
		},
		"application/x-virtualbox-vhd": {
			"compressible": true,
			"extensions": ["vhd"]
		},
		"application/x-virtualbox-vmdk": {
			"compressible": true,
			"extensions": ["vmdk"]
		},
		"application/x-wais-source": {
			"source": "apache",
			"extensions": ["src"]
		},
		"application/x-web-app-manifest+json": {
			"compressible": true,
			"extensions": ["webapp"]
		},
		"application/x-www-form-urlencoded": {
			"source": "iana",
			"compressible": true
		},
		"application/x-x509-ca-cert": {
			"source": "iana",
			"extensions": [
				"der",
				"crt",
				"pem"
			]
		},
		"application/x-x509-ca-ra-cert": { "source": "iana" },
		"application/x-x509-next-ca-cert": { "source": "iana" },
		"application/x-xfig": {
			"source": "apache",
			"extensions": ["fig"]
		},
		"application/x-xliff+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/x-xpinstall": {
			"source": "apache",
			"compressible": false,
			"extensions": ["xpi"]
		},
		"application/x-xz": {
			"source": "apache",
			"extensions": ["xz"]
		},
		"application/x-zmachine": {
			"source": "apache",
			"extensions": [
				"z1",
				"z2",
				"z3",
				"z4",
				"z5",
				"z6",
				"z7",
				"z8"
			]
		},
		"application/x400-bp": { "source": "iana" },
		"application/xacml+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xaml+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xaml"]
		},
		"application/xcap-att+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xav"]
		},
		"application/xcap-caps+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xca"]
		},
		"application/xcap-diff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xdf"]
		},
		"application/xcap-el+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xel"]
		},
		"application/xcap-error+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcap-ns+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xns"]
		},
		"application/xcon-conference-info+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xcon-conference-info-diff+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xenc+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xenc"]
		},
		"application/xhtml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xhtml", "xht"]
		},
		"application/xhtml-voice+xml": {
			"source": "apache",
			"compressible": true
		},
		"application/xliff+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xlf"]
		},
		"application/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml",
				"xsl",
				"xsd",
				"rng"
			]
		},
		"application/xml-dtd": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dtd"]
		},
		"application/xml-external-parsed-entity": { "source": "iana" },
		"application/xml-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xmpp+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/xop+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xop"]
		},
		"application/xproc+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xpl"]
		},
		"application/xslt+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xsl", "xslt"]
		},
		"application/xspf+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": ["xspf"]
		},
		"application/xv+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"mxml",
				"xhvml",
				"xvml",
				"xvm"
			]
		},
		"application/yang": {
			"source": "iana",
			"extensions": ["yang"]
		},
		"application/yang-data+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-data+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/yang-patch+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/yin+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["yin"]
		},
		"application/zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["zip"]
		},
		"application/zlib": { "source": "iana" },
		"application/zstd": { "source": "iana" },
		"audio/1d-interleaved-parityfec": { "source": "iana" },
		"audio/32kadpcm": { "source": "iana" },
		"audio/3gpp": {
			"source": "iana",
			"compressible": false,
			"extensions": ["3gpp"]
		},
		"audio/3gpp2": { "source": "iana" },
		"audio/aac": { "source": "iana" },
		"audio/ac3": { "source": "iana" },
		"audio/adpcm": {
			"source": "apache",
			"extensions": ["adp"]
		},
		"audio/amr": {
			"source": "iana",
			"extensions": ["amr"]
		},
		"audio/amr-wb": { "source": "iana" },
		"audio/amr-wb+": { "source": "iana" },
		"audio/aptx": { "source": "iana" },
		"audio/asc": { "source": "iana" },
		"audio/atrac-advanced-lossless": { "source": "iana" },
		"audio/atrac-x": { "source": "iana" },
		"audio/atrac3": { "source": "iana" },
		"audio/basic": {
			"source": "iana",
			"compressible": false,
			"extensions": ["au", "snd"]
		},
		"audio/bv16": { "source": "iana" },
		"audio/bv32": { "source": "iana" },
		"audio/clearmode": { "source": "iana" },
		"audio/cn": { "source": "iana" },
		"audio/dat12": { "source": "iana" },
		"audio/dls": { "source": "iana" },
		"audio/dsr-es201108": { "source": "iana" },
		"audio/dsr-es202050": { "source": "iana" },
		"audio/dsr-es202211": { "source": "iana" },
		"audio/dsr-es202212": { "source": "iana" },
		"audio/dv": { "source": "iana" },
		"audio/dvi4": { "source": "iana" },
		"audio/eac3": { "source": "iana" },
		"audio/encaprtp": { "source": "iana" },
		"audio/evrc": { "source": "iana" },
		"audio/evrc-qcp": { "source": "iana" },
		"audio/evrc0": { "source": "iana" },
		"audio/evrc1": { "source": "iana" },
		"audio/evrcb": { "source": "iana" },
		"audio/evrcb0": { "source": "iana" },
		"audio/evrcb1": { "source": "iana" },
		"audio/evrcnw": { "source": "iana" },
		"audio/evrcnw0": { "source": "iana" },
		"audio/evrcnw1": { "source": "iana" },
		"audio/evrcwb": { "source": "iana" },
		"audio/evrcwb0": { "source": "iana" },
		"audio/evrcwb1": { "source": "iana" },
		"audio/evs": { "source": "iana" },
		"audio/flexfec": { "source": "iana" },
		"audio/fwdred": { "source": "iana" },
		"audio/g711-0": { "source": "iana" },
		"audio/g719": { "source": "iana" },
		"audio/g722": { "source": "iana" },
		"audio/g7221": { "source": "iana" },
		"audio/g723": { "source": "iana" },
		"audio/g726-16": { "source": "iana" },
		"audio/g726-24": { "source": "iana" },
		"audio/g726-32": { "source": "iana" },
		"audio/g726-40": { "source": "iana" },
		"audio/g728": { "source": "iana" },
		"audio/g729": { "source": "iana" },
		"audio/g7291": { "source": "iana" },
		"audio/g729d": { "source": "iana" },
		"audio/g729e": { "source": "iana" },
		"audio/gsm": { "source": "iana" },
		"audio/gsm-efr": { "source": "iana" },
		"audio/gsm-hr-08": { "source": "iana" },
		"audio/ilbc": { "source": "iana" },
		"audio/ip-mr_v2.5": { "source": "iana" },
		"audio/isac": { "source": "apache" },
		"audio/l16": { "source": "iana" },
		"audio/l20": { "source": "iana" },
		"audio/l24": {
			"source": "iana",
			"compressible": false
		},
		"audio/l8": { "source": "iana" },
		"audio/lpc": { "source": "iana" },
		"audio/melp": { "source": "iana" },
		"audio/melp1200": { "source": "iana" },
		"audio/melp2400": { "source": "iana" },
		"audio/melp600": { "source": "iana" },
		"audio/mhas": { "source": "iana" },
		"audio/midi": {
			"source": "apache",
			"extensions": [
				"mid",
				"midi",
				"kar",
				"rmi"
			]
		},
		"audio/mobile-xmf": {
			"source": "iana",
			"extensions": ["mxmf"]
		},
		"audio/mp3": {
			"compressible": false,
			"extensions": ["mp3"]
		},
		"audio/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": ["m4a", "mp4a"]
		},
		"audio/mp4a-latm": { "source": "iana" },
		"audio/mpa": { "source": "iana" },
		"audio/mpa-robust": { "source": "iana" },
		"audio/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpga",
				"mp2",
				"mp2a",
				"mp3",
				"m2a",
				"m3a"
			]
		},
		"audio/mpeg4-generic": { "source": "iana" },
		"audio/musepack": { "source": "apache" },
		"audio/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"oga",
				"ogg",
				"spx",
				"opus"
			]
		},
		"audio/opus": { "source": "iana" },
		"audio/parityfec": { "source": "iana" },
		"audio/pcma": { "source": "iana" },
		"audio/pcma-wb": { "source": "iana" },
		"audio/pcmu": { "source": "iana" },
		"audio/pcmu-wb": { "source": "iana" },
		"audio/prs.sid": { "source": "iana" },
		"audio/qcelp": { "source": "iana" },
		"audio/raptorfec": { "source": "iana" },
		"audio/red": { "source": "iana" },
		"audio/rtp-enc-aescm128": { "source": "iana" },
		"audio/rtp-midi": { "source": "iana" },
		"audio/rtploopback": { "source": "iana" },
		"audio/rtx": { "source": "iana" },
		"audio/s3m": {
			"source": "apache",
			"extensions": ["s3m"]
		},
		"audio/scip": { "source": "iana" },
		"audio/silk": {
			"source": "apache",
			"extensions": ["sil"]
		},
		"audio/smv": { "source": "iana" },
		"audio/smv-qcp": { "source": "iana" },
		"audio/smv0": { "source": "iana" },
		"audio/sofa": { "source": "iana" },
		"audio/sp-midi": { "source": "iana" },
		"audio/speex": { "source": "iana" },
		"audio/t140c": { "source": "iana" },
		"audio/t38": { "source": "iana" },
		"audio/telephone-event": { "source": "iana" },
		"audio/tetra_acelp": { "source": "iana" },
		"audio/tetra_acelp_bb": { "source": "iana" },
		"audio/tone": { "source": "iana" },
		"audio/tsvcis": { "source": "iana" },
		"audio/uemclip": { "source": "iana" },
		"audio/ulpfec": { "source": "iana" },
		"audio/usac": { "source": "iana" },
		"audio/vdvi": { "source": "iana" },
		"audio/vmr-wb": { "source": "iana" },
		"audio/vnd.3gpp.iufp": { "source": "iana" },
		"audio/vnd.4sb": { "source": "iana" },
		"audio/vnd.audiokoz": { "source": "iana" },
		"audio/vnd.celp": { "source": "iana" },
		"audio/vnd.cisco.nse": { "source": "iana" },
		"audio/vnd.cmles.radio-events": { "source": "iana" },
		"audio/vnd.cns.anp1": { "source": "iana" },
		"audio/vnd.cns.inf1": { "source": "iana" },
		"audio/vnd.dece.audio": {
			"source": "iana",
			"extensions": ["uva", "uvva"]
		},
		"audio/vnd.digital-winds": {
			"source": "iana",
			"extensions": ["eol"]
		},
		"audio/vnd.dlna.adts": { "source": "iana" },
		"audio/vnd.dolby.heaac.1": { "source": "iana" },
		"audio/vnd.dolby.heaac.2": { "source": "iana" },
		"audio/vnd.dolby.mlp": { "source": "iana" },
		"audio/vnd.dolby.mps": { "source": "iana" },
		"audio/vnd.dolby.pl2": { "source": "iana" },
		"audio/vnd.dolby.pl2x": { "source": "iana" },
		"audio/vnd.dolby.pl2z": { "source": "iana" },
		"audio/vnd.dolby.pulse.1": { "source": "iana" },
		"audio/vnd.dra": {
			"source": "iana",
			"extensions": ["dra"]
		},
		"audio/vnd.dts": {
			"source": "iana",
			"extensions": ["dts"]
		},
		"audio/vnd.dts.hd": {
			"source": "iana",
			"extensions": ["dtshd"]
		},
		"audio/vnd.dts.uhd": { "source": "iana" },
		"audio/vnd.dvb.file": { "source": "iana" },
		"audio/vnd.everad.plj": { "source": "iana" },
		"audio/vnd.hns.audio": { "source": "iana" },
		"audio/vnd.lucent.voice": {
			"source": "iana",
			"extensions": ["lvp"]
		},
		"audio/vnd.ms-playready.media.pya": {
			"source": "iana",
			"extensions": ["pya"]
		},
		"audio/vnd.nokia.mobile-xmf": { "source": "iana" },
		"audio/vnd.nortel.vbk": { "source": "iana" },
		"audio/vnd.nuera.ecelp4800": {
			"source": "iana",
			"extensions": ["ecelp4800"]
		},
		"audio/vnd.nuera.ecelp7470": {
			"source": "iana",
			"extensions": ["ecelp7470"]
		},
		"audio/vnd.nuera.ecelp9600": {
			"source": "iana",
			"extensions": ["ecelp9600"]
		},
		"audio/vnd.octel.sbc": { "source": "iana" },
		"audio/vnd.presonus.multitrack": { "source": "iana" },
		"audio/vnd.qcelp": { "source": "iana" },
		"audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
		"audio/vnd.rip": {
			"source": "iana",
			"extensions": ["rip"]
		},
		"audio/vnd.rn-realaudio": { "compressible": false },
		"audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
		"audio/vnd.vmx.cvsd": { "source": "iana" },
		"audio/vnd.wave": { "compressible": false },
		"audio/vorbis": {
			"source": "iana",
			"compressible": false
		},
		"audio/vorbis-config": { "source": "iana" },
		"audio/wav": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/wave": {
			"compressible": false,
			"extensions": ["wav"]
		},
		"audio/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["weba"]
		},
		"audio/x-aac": {
			"source": "apache",
			"compressible": false,
			"extensions": ["aac"]
		},
		"audio/x-aiff": {
			"source": "apache",
			"extensions": [
				"aif",
				"aiff",
				"aifc"
			]
		},
		"audio/x-caf": {
			"source": "apache",
			"compressible": false,
			"extensions": ["caf"]
		},
		"audio/x-flac": {
			"source": "apache",
			"extensions": ["flac"]
		},
		"audio/x-m4a": {
			"source": "nginx",
			"extensions": ["m4a"]
		},
		"audio/x-matroska": {
			"source": "apache",
			"extensions": ["mka"]
		},
		"audio/x-mpegurl": {
			"source": "apache",
			"extensions": ["m3u"]
		},
		"audio/x-ms-wax": {
			"source": "apache",
			"extensions": ["wax"]
		},
		"audio/x-ms-wma": {
			"source": "apache",
			"extensions": ["wma"]
		},
		"audio/x-pn-realaudio": {
			"source": "apache",
			"extensions": ["ram", "ra"]
		},
		"audio/x-pn-realaudio-plugin": {
			"source": "apache",
			"extensions": ["rmp"]
		},
		"audio/x-realaudio": {
			"source": "nginx",
			"extensions": ["ra"]
		},
		"audio/x-tta": { "source": "apache" },
		"audio/x-wav": {
			"source": "apache",
			"extensions": ["wav"]
		},
		"audio/xm": {
			"source": "apache",
			"extensions": ["xm"]
		},
		"chemical/x-cdx": {
			"source": "apache",
			"extensions": ["cdx"]
		},
		"chemical/x-cif": {
			"source": "apache",
			"extensions": ["cif"]
		},
		"chemical/x-cmdf": {
			"source": "apache",
			"extensions": ["cmdf"]
		},
		"chemical/x-cml": {
			"source": "apache",
			"extensions": ["cml"]
		},
		"chemical/x-csml": {
			"source": "apache",
			"extensions": ["csml"]
		},
		"chemical/x-pdb": { "source": "apache" },
		"chemical/x-xyz": {
			"source": "apache",
			"extensions": ["xyz"]
		},
		"font/collection": {
			"source": "iana",
			"extensions": ["ttc"]
		},
		"font/otf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["otf"]
		},
		"font/sfnt": { "source": "iana" },
		"font/ttf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ttf"]
		},
		"font/woff": {
			"source": "iana",
			"extensions": ["woff"]
		},
		"font/woff2": {
			"source": "iana",
			"extensions": ["woff2"]
		},
		"image/aces": {
			"source": "iana",
			"extensions": ["exr"]
		},
		"image/apng": {
			"compressible": false,
			"extensions": ["apng"]
		},
		"image/avci": {
			"source": "iana",
			"extensions": ["avci"]
		},
		"image/avcs": {
			"source": "iana",
			"extensions": ["avcs"]
		},
		"image/avif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["avif"]
		},
		"image/bmp": {
			"source": "iana",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/cgm": {
			"source": "iana",
			"extensions": ["cgm"]
		},
		"image/dicom-rle": {
			"source": "iana",
			"extensions": ["drle"]
		},
		"image/emf": {
			"source": "iana",
			"extensions": ["emf"]
		},
		"image/fits": {
			"source": "iana",
			"extensions": ["fits"]
		},
		"image/g3fax": {
			"source": "iana",
			"extensions": ["g3"]
		},
		"image/gif": {
			"source": "iana",
			"compressible": false,
			"extensions": ["gif"]
		},
		"image/heic": {
			"source": "iana",
			"extensions": ["heic"]
		},
		"image/heic-sequence": {
			"source": "iana",
			"extensions": ["heics"]
		},
		"image/heif": {
			"source": "iana",
			"extensions": ["heif"]
		},
		"image/heif-sequence": {
			"source": "iana",
			"extensions": ["heifs"]
		},
		"image/hej2k": {
			"source": "iana",
			"extensions": ["hej2"]
		},
		"image/hsj2": {
			"source": "iana",
			"extensions": ["hsj2"]
		},
		"image/ief": {
			"source": "iana",
			"extensions": ["ief"]
		},
		"image/jls": {
			"source": "iana",
			"extensions": ["jls"]
		},
		"image/jp2": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jp2", "jpg2"]
		},
		"image/jpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"jpeg",
				"jpg",
				"jpe"
			]
		},
		"image/jph": {
			"source": "iana",
			"extensions": ["jph"]
		},
		"image/jphc": {
			"source": "iana",
			"extensions": ["jhc"]
		},
		"image/jpm": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpm"]
		},
		"image/jpx": {
			"source": "iana",
			"compressible": false,
			"extensions": ["jpx", "jpf"]
		},
		"image/jxr": {
			"source": "iana",
			"extensions": ["jxr"]
		},
		"image/jxra": {
			"source": "iana",
			"extensions": ["jxra"]
		},
		"image/jxrs": {
			"source": "iana",
			"extensions": ["jxrs"]
		},
		"image/jxs": {
			"source": "iana",
			"extensions": ["jxs"]
		},
		"image/jxsc": {
			"source": "iana",
			"extensions": ["jxsc"]
		},
		"image/jxsi": {
			"source": "iana",
			"extensions": ["jxsi"]
		},
		"image/jxss": {
			"source": "iana",
			"extensions": ["jxss"]
		},
		"image/ktx": {
			"source": "iana",
			"extensions": ["ktx"]
		},
		"image/ktx2": {
			"source": "iana",
			"extensions": ["ktx2"]
		},
		"image/naplps": { "source": "iana" },
		"image/pjpeg": { "compressible": false },
		"image/png": {
			"source": "iana",
			"compressible": false,
			"extensions": ["png"]
		},
		"image/prs.btif": {
			"source": "iana",
			"extensions": ["btif"]
		},
		"image/prs.pti": {
			"source": "iana",
			"extensions": ["pti"]
		},
		"image/pwg-raster": { "source": "iana" },
		"image/sgi": {
			"source": "apache",
			"extensions": ["sgi"]
		},
		"image/svg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["svg", "svgz"]
		},
		"image/t38": {
			"source": "iana",
			"extensions": ["t38"]
		},
		"image/tiff": {
			"source": "iana",
			"compressible": false,
			"extensions": ["tif", "tiff"]
		},
		"image/tiff-fx": {
			"source": "iana",
			"extensions": ["tfx"]
		},
		"image/vnd.adobe.photoshop": {
			"source": "iana",
			"compressible": true,
			"extensions": ["psd"]
		},
		"image/vnd.airzip.accelerator.azv": {
			"source": "iana",
			"extensions": ["azv"]
		},
		"image/vnd.cns.inf2": { "source": "iana" },
		"image/vnd.dece.graphic": {
			"source": "iana",
			"extensions": [
				"uvi",
				"uvvi",
				"uvg",
				"uvvg"
			]
		},
		"image/vnd.djvu": {
			"source": "iana",
			"extensions": ["djvu", "djv"]
		},
		"image/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"image/vnd.dwg": {
			"source": "iana",
			"extensions": ["dwg"]
		},
		"image/vnd.dxf": {
			"source": "iana",
			"extensions": ["dxf"]
		},
		"image/vnd.fastbidsheet": {
			"source": "iana",
			"extensions": ["fbs"]
		},
		"image/vnd.fpx": {
			"source": "iana",
			"extensions": ["fpx"]
		},
		"image/vnd.fst": {
			"source": "iana",
			"extensions": ["fst"]
		},
		"image/vnd.fujixerox.edmics-mmr": {
			"source": "iana",
			"extensions": ["mmr"]
		},
		"image/vnd.fujixerox.edmics-rlc": {
			"source": "iana",
			"extensions": ["rlc"]
		},
		"image/vnd.globalgraphics.pgb": { "source": "iana" },
		"image/vnd.microsoft.icon": {
			"source": "iana",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/vnd.mix": { "source": "iana" },
		"image/vnd.mozilla.apng": { "source": "iana" },
		"image/vnd.ms-dds": {
			"compressible": true,
			"extensions": ["dds"]
		},
		"image/vnd.ms-modi": {
			"source": "iana",
			"extensions": ["mdi"]
		},
		"image/vnd.ms-photo": {
			"source": "apache",
			"extensions": ["wdp"]
		},
		"image/vnd.net-fpx": {
			"source": "iana",
			"extensions": ["npx"]
		},
		"image/vnd.pco.b16": {
			"source": "iana",
			"extensions": ["b16"]
		},
		"image/vnd.radiance": { "source": "iana" },
		"image/vnd.sealed.png": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
		"image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
		"image/vnd.svf": { "source": "iana" },
		"image/vnd.tencent.tap": {
			"source": "iana",
			"extensions": ["tap"]
		},
		"image/vnd.valve.source.texture": {
			"source": "iana",
			"extensions": ["vtf"]
		},
		"image/vnd.wap.wbmp": {
			"source": "iana",
			"extensions": ["wbmp"]
		},
		"image/vnd.xiff": {
			"source": "iana",
			"extensions": ["xif"]
		},
		"image/vnd.zbrush.pcx": {
			"source": "iana",
			"extensions": ["pcx"]
		},
		"image/webp": {
			"source": "apache",
			"extensions": ["webp"]
		},
		"image/wmf": {
			"source": "iana",
			"extensions": ["wmf"]
		},
		"image/x-3ds": {
			"source": "apache",
			"extensions": ["3ds"]
		},
		"image/x-cmu-raster": {
			"source": "apache",
			"extensions": ["ras"]
		},
		"image/x-cmx": {
			"source": "apache",
			"extensions": ["cmx"]
		},
		"image/x-freehand": {
			"source": "apache",
			"extensions": [
				"fh",
				"fhc",
				"fh4",
				"fh5",
				"fh7"
			]
		},
		"image/x-icon": {
			"source": "apache",
			"compressible": true,
			"extensions": ["ico"]
		},
		"image/x-jng": {
			"source": "nginx",
			"extensions": ["jng"]
		},
		"image/x-mrsid-image": {
			"source": "apache",
			"extensions": ["sid"]
		},
		"image/x-ms-bmp": {
			"source": "nginx",
			"compressible": true,
			"extensions": ["bmp"]
		},
		"image/x-pcx": {
			"source": "apache",
			"extensions": ["pcx"]
		},
		"image/x-pict": {
			"source": "apache",
			"extensions": ["pic", "pct"]
		},
		"image/x-portable-anymap": {
			"source": "apache",
			"extensions": ["pnm"]
		},
		"image/x-portable-bitmap": {
			"source": "apache",
			"extensions": ["pbm"]
		},
		"image/x-portable-graymap": {
			"source": "apache",
			"extensions": ["pgm"]
		},
		"image/x-portable-pixmap": {
			"source": "apache",
			"extensions": ["ppm"]
		},
		"image/x-rgb": {
			"source": "apache",
			"extensions": ["rgb"]
		},
		"image/x-tga": {
			"source": "apache",
			"extensions": ["tga"]
		},
		"image/x-xbitmap": {
			"source": "apache",
			"extensions": ["xbm"]
		},
		"image/x-xcf": { "compressible": false },
		"image/x-xpixmap": {
			"source": "apache",
			"extensions": ["xpm"]
		},
		"image/x-xwindowdump": {
			"source": "apache",
			"extensions": ["xwd"]
		},
		"message/cpim": { "source": "iana" },
		"message/delivery-status": { "source": "iana" },
		"message/disposition-notification": {
			"source": "iana",
			"extensions": ["disposition-notification"]
		},
		"message/external-body": { "source": "iana" },
		"message/feedback-report": { "source": "iana" },
		"message/global": {
			"source": "iana",
			"extensions": ["u8msg"]
		},
		"message/global-delivery-status": {
			"source": "iana",
			"extensions": ["u8dsn"]
		},
		"message/global-disposition-notification": {
			"source": "iana",
			"extensions": ["u8mdn"]
		},
		"message/global-headers": {
			"source": "iana",
			"extensions": ["u8hdr"]
		},
		"message/http": {
			"source": "iana",
			"compressible": false
		},
		"message/imdn+xml": {
			"source": "iana",
			"compressible": true
		},
		"message/news": { "source": "iana" },
		"message/partial": {
			"source": "iana",
			"compressible": false
		},
		"message/rfc822": {
			"source": "iana",
			"compressible": true,
			"extensions": ["eml", "mime"]
		},
		"message/s-http": { "source": "iana" },
		"message/sip": { "source": "iana" },
		"message/sipfrag": { "source": "iana" },
		"message/tracking-status": { "source": "iana" },
		"message/vnd.si.simp": { "source": "iana" },
		"message/vnd.wfa.wsc": {
			"source": "iana",
			"extensions": ["wsc"]
		},
		"model/3mf": {
			"source": "iana",
			"extensions": ["3mf"]
		},
		"model/e57": { "source": "iana" },
		"model/gltf+json": {
			"source": "iana",
			"compressible": true,
			"extensions": ["gltf"]
		},
		"model/gltf-binary": {
			"source": "iana",
			"compressible": true,
			"extensions": ["glb"]
		},
		"model/iges": {
			"source": "iana",
			"compressible": false,
			"extensions": ["igs", "iges"]
		},
		"model/mesh": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"msh",
				"mesh",
				"silo"
			]
		},
		"model/mtl": {
			"source": "iana",
			"extensions": ["mtl"]
		},
		"model/obj": {
			"source": "iana",
			"extensions": ["obj"]
		},
		"model/step": { "source": "iana" },
		"model/step+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["stpx"]
		},
		"model/step+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpz"]
		},
		"model/step-xml+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["stpxz"]
		},
		"model/stl": {
			"source": "iana",
			"extensions": ["stl"]
		},
		"model/vnd.collada+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["dae"]
		},
		"model/vnd.dwf": {
			"source": "iana",
			"extensions": ["dwf"]
		},
		"model/vnd.flatland.3dml": { "source": "iana" },
		"model/vnd.gdl": {
			"source": "iana",
			"extensions": ["gdl"]
		},
		"model/vnd.gs-gdl": { "source": "apache" },
		"model/vnd.gs.gdl": { "source": "iana" },
		"model/vnd.gtw": {
			"source": "iana",
			"extensions": ["gtw"]
		},
		"model/vnd.moml+xml": {
			"source": "iana",
			"compressible": true
		},
		"model/vnd.mts": {
			"source": "iana",
			"extensions": ["mts"]
		},
		"model/vnd.opengex": {
			"source": "iana",
			"extensions": ["ogex"]
		},
		"model/vnd.parasolid.transmit.binary": {
			"source": "iana",
			"extensions": ["x_b"]
		},
		"model/vnd.parasolid.transmit.text": {
			"source": "iana",
			"extensions": ["x_t"]
		},
		"model/vnd.pytha.pyox": { "source": "iana" },
		"model/vnd.rosette.annotated-data-model": { "source": "iana" },
		"model/vnd.sap.vds": {
			"source": "iana",
			"extensions": ["vds"]
		},
		"model/vnd.usdz+zip": {
			"source": "iana",
			"compressible": false,
			"extensions": ["usdz"]
		},
		"model/vnd.valve.source.compiled-map": {
			"source": "iana",
			"extensions": ["bsp"]
		},
		"model/vnd.vtu": {
			"source": "iana",
			"extensions": ["vtu"]
		},
		"model/vrml": {
			"source": "iana",
			"compressible": false,
			"extensions": ["wrl", "vrml"]
		},
		"model/x3d+binary": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3db", "x3dbz"]
		},
		"model/x3d+fastinfoset": {
			"source": "iana",
			"extensions": ["x3db"]
		},
		"model/x3d+vrml": {
			"source": "apache",
			"compressible": false,
			"extensions": ["x3dv", "x3dvz"]
		},
		"model/x3d+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["x3d", "x3dz"]
		},
		"model/x3d-vrml": {
			"source": "iana",
			"extensions": ["x3dv"]
		},
		"multipart/alternative": {
			"source": "iana",
			"compressible": false
		},
		"multipart/appledouble": { "source": "iana" },
		"multipart/byteranges": { "source": "iana" },
		"multipart/digest": { "source": "iana" },
		"multipart/encrypted": {
			"source": "iana",
			"compressible": false
		},
		"multipart/form-data": {
			"source": "iana",
			"compressible": false
		},
		"multipart/header-set": { "source": "iana" },
		"multipart/mixed": { "source": "iana" },
		"multipart/multilingual": { "source": "iana" },
		"multipart/parallel": { "source": "iana" },
		"multipart/related": {
			"source": "iana",
			"compressible": false
		},
		"multipart/report": { "source": "iana" },
		"multipart/signed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/vnd.bint.med-plus": { "source": "iana" },
		"multipart/voice-message": { "source": "iana" },
		"multipart/x-mixed-replace": { "source": "iana" },
		"text/1d-interleaved-parityfec": { "source": "iana" },
		"text/cache-manifest": {
			"source": "iana",
			"compressible": true,
			"extensions": ["appcache", "manifest"]
		},
		"text/calendar": {
			"source": "iana",
			"extensions": ["ics", "ifb"]
		},
		"text/calender": { "compressible": true },
		"text/cmd": { "compressible": true },
		"text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
		"text/cql": { "source": "iana" },
		"text/cql-expression": { "source": "iana" },
		"text/cql-identifier": { "source": "iana" },
		"text/css": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["css"]
		},
		"text/csv": {
			"source": "iana",
			"compressible": true,
			"extensions": ["csv"]
		},
		"text/csv-schema": { "source": "iana" },
		"text/directory": { "source": "iana" },
		"text/dns": { "source": "iana" },
		"text/ecmascript": { "source": "iana" },
		"text/encaprtp": { "source": "iana" },
		"text/enriched": { "source": "iana" },
		"text/fhirpath": { "source": "iana" },
		"text/flexfec": { "source": "iana" },
		"text/fwdred": { "source": "iana" },
		"text/gff3": { "source": "iana" },
		"text/grammar-ref-list": { "source": "iana" },
		"text/html": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"html",
				"htm",
				"shtml"
			]
		},
		"text/jade": { "extensions": ["jade"] },
		"text/javascript": {
			"source": "iana",
			"compressible": true
		},
		"text/jcr-cnd": { "source": "iana" },
		"text/jsx": {
			"compressible": true,
			"extensions": ["jsx"]
		},
		"text/less": {
			"compressible": true,
			"extensions": ["less"]
		},
		"text/markdown": {
			"source": "iana",
			"compressible": true,
			"extensions": ["markdown", "md"]
		},
		"text/mathml": {
			"source": "nginx",
			"extensions": ["mml"]
		},
		"text/mdx": {
			"compressible": true,
			"extensions": ["mdx"]
		},
		"text/mizar": { "source": "iana" },
		"text/n3": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["n3"]
		},
		"text/parameters": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/parityfec": { "source": "iana" },
		"text/plain": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"txt",
				"text",
				"conf",
				"def",
				"list",
				"log",
				"in",
				"ini"
			]
		},
		"text/provenance-notation": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/prs.fallenstein.rst": { "source": "iana" },
		"text/prs.lines.tag": {
			"source": "iana",
			"extensions": ["dsc"]
		},
		"text/prs.prop.logic": { "source": "iana" },
		"text/raptorfec": { "source": "iana" },
		"text/red": { "source": "iana" },
		"text/rfc822-headers": { "source": "iana" },
		"text/richtext": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtx"]
		},
		"text/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": ["rtf"]
		},
		"text/rtp-enc-aescm128": { "source": "iana" },
		"text/rtploopback": { "source": "iana" },
		"text/rtx": { "source": "iana" },
		"text/sgml": {
			"source": "iana",
			"extensions": ["sgml", "sgm"]
		},
		"text/shaclc": { "source": "iana" },
		"text/shex": {
			"source": "iana",
			"extensions": ["shex"]
		},
		"text/slim": { "extensions": ["slim", "slm"] },
		"text/spdx": {
			"source": "iana",
			"extensions": ["spdx"]
		},
		"text/strings": { "source": "iana" },
		"text/stylus": { "extensions": ["stylus", "styl"] },
		"text/t140": { "source": "iana" },
		"text/tab-separated-values": {
			"source": "iana",
			"compressible": true,
			"extensions": ["tsv"]
		},
		"text/troff": {
			"source": "iana",
			"extensions": [
				"t",
				"tr",
				"roff",
				"man",
				"me",
				"ms"
			]
		},
		"text/turtle": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["ttl"]
		},
		"text/ulpfec": { "source": "iana" },
		"text/uri-list": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"uri",
				"uris",
				"urls"
			]
		},
		"text/vcard": {
			"source": "iana",
			"compressible": true,
			"extensions": ["vcard"]
		},
		"text/vnd.a": { "source": "iana" },
		"text/vnd.abc": { "source": "iana" },
		"text/vnd.ascii-art": { "source": "iana" },
		"text/vnd.curl": {
			"source": "iana",
			"extensions": ["curl"]
		},
		"text/vnd.curl.dcurl": {
			"source": "apache",
			"extensions": ["dcurl"]
		},
		"text/vnd.curl.mcurl": {
			"source": "apache",
			"extensions": ["mcurl"]
		},
		"text/vnd.curl.scurl": {
			"source": "apache",
			"extensions": ["scurl"]
		},
		"text/vnd.debian.copyright": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.dmclientscript": { "source": "iana" },
		"text/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": ["sub"]
		},
		"text/vnd.esmertec.theme-descriptor": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.familysearch.gedcom": {
			"source": "iana",
			"extensions": ["ged"]
		},
		"text/vnd.ficlab.flt": { "source": "iana" },
		"text/vnd.fly": {
			"source": "iana",
			"extensions": ["fly"]
		},
		"text/vnd.fmi.flexstor": {
			"source": "iana",
			"extensions": ["flx"]
		},
		"text/vnd.gml": { "source": "iana" },
		"text/vnd.graphviz": {
			"source": "iana",
			"extensions": ["gv"]
		},
		"text/vnd.hans": { "source": "iana" },
		"text/vnd.hgl": { "source": "iana" },
		"text/vnd.in3d.3dml": {
			"source": "iana",
			"extensions": ["3dml"]
		},
		"text/vnd.in3d.spot": {
			"source": "iana",
			"extensions": ["spot"]
		},
		"text/vnd.iptc.newsml": { "source": "iana" },
		"text/vnd.iptc.nitf": { "source": "iana" },
		"text/vnd.latex-z": { "source": "iana" },
		"text/vnd.motorola.reflex": { "source": "iana" },
		"text/vnd.ms-mediapackage": { "source": "iana" },
		"text/vnd.net2phone.commcenter.command": { "source": "iana" },
		"text/vnd.radisys.msml-basic-layout": { "source": "iana" },
		"text/vnd.senx.warpscript": { "source": "iana" },
		"text/vnd.si.uricatalogue": { "source": "iana" },
		"text/vnd.sosi": { "source": "iana" },
		"text/vnd.sun.j2me.app-descriptor": {
			"source": "iana",
			"charset": "UTF-8",
			"extensions": ["jad"]
		},
		"text/vnd.trolltech.linguist": {
			"source": "iana",
			"charset": "UTF-8"
		},
		"text/vnd.wap.si": { "source": "iana" },
		"text/vnd.wap.sl": { "source": "iana" },
		"text/vnd.wap.wml": {
			"source": "iana",
			"extensions": ["wml"]
		},
		"text/vnd.wap.wmlscript": {
			"source": "iana",
			"extensions": ["wmls"]
		},
		"text/vtt": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": ["vtt"]
		},
		"text/x-asm": {
			"source": "apache",
			"extensions": ["s", "asm"]
		},
		"text/x-c": {
			"source": "apache",
			"extensions": [
				"c",
				"cc",
				"cxx",
				"cpp",
				"h",
				"hh",
				"dic"
			]
		},
		"text/x-component": {
			"source": "nginx",
			"extensions": ["htc"]
		},
		"text/x-fortran": {
			"source": "apache",
			"extensions": [
				"f",
				"for",
				"f77",
				"f90"
			]
		},
		"text/x-gwt-rpc": { "compressible": true },
		"text/x-handlebars-template": { "extensions": ["hbs"] },
		"text/x-java-source": {
			"source": "apache",
			"extensions": ["java"]
		},
		"text/x-jquery-tmpl": { "compressible": true },
		"text/x-lua": { "extensions": ["lua"] },
		"text/x-markdown": {
			"compressible": true,
			"extensions": ["mkd"]
		},
		"text/x-nfo": {
			"source": "apache",
			"extensions": ["nfo"]
		},
		"text/x-opml": {
			"source": "apache",
			"extensions": ["opml"]
		},
		"text/x-org": {
			"compressible": true,
			"extensions": ["org"]
		},
		"text/x-pascal": {
			"source": "apache",
			"extensions": ["p", "pas"]
		},
		"text/x-processing": {
			"compressible": true,
			"extensions": ["pde"]
		},
		"text/x-sass": { "extensions": ["sass"] },
		"text/x-scss": { "extensions": ["scss"] },
		"text/x-setext": {
			"source": "apache",
			"extensions": ["etx"]
		},
		"text/x-sfv": {
			"source": "apache",
			"extensions": ["sfv"]
		},
		"text/x-suse-ymp": {
			"compressible": true,
			"extensions": ["ymp"]
		},
		"text/x-uuencode": {
			"source": "apache",
			"extensions": ["uu"]
		},
		"text/x-vcalendar": {
			"source": "apache",
			"extensions": ["vcs"]
		},
		"text/x-vcard": {
			"source": "apache",
			"extensions": ["vcf"]
		},
		"text/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": ["xml"]
		},
		"text/xml-external-parsed-entity": { "source": "iana" },
		"text/yaml": {
			"compressible": true,
			"extensions": ["yaml", "yml"]
		},
		"video/1d-interleaved-parityfec": { "source": "iana" },
		"video/3gpp": {
			"source": "iana",
			"extensions": ["3gp", "3gpp"]
		},
		"video/3gpp-tt": { "source": "iana" },
		"video/3gpp2": {
			"source": "iana",
			"extensions": ["3g2"]
		},
		"video/av1": { "source": "iana" },
		"video/bmpeg": { "source": "iana" },
		"video/bt656": { "source": "iana" },
		"video/celb": { "source": "iana" },
		"video/dv": { "source": "iana" },
		"video/encaprtp": { "source": "iana" },
		"video/ffv1": { "source": "iana" },
		"video/flexfec": { "source": "iana" },
		"video/h261": {
			"source": "iana",
			"extensions": ["h261"]
		},
		"video/h263": {
			"source": "iana",
			"extensions": ["h263"]
		},
		"video/h263-1998": { "source": "iana" },
		"video/h263-2000": { "source": "iana" },
		"video/h264": {
			"source": "iana",
			"extensions": ["h264"]
		},
		"video/h264-rcdo": { "source": "iana" },
		"video/h264-svc": { "source": "iana" },
		"video/h265": { "source": "iana" },
		"video/iso.segment": {
			"source": "iana",
			"extensions": ["m4s"]
		},
		"video/jpeg": {
			"source": "iana",
			"extensions": ["jpgv"]
		},
		"video/jpeg2000": { "source": "iana" },
		"video/jpm": {
			"source": "apache",
			"extensions": ["jpm", "jpgm"]
		},
		"video/jxsv": { "source": "iana" },
		"video/mj2": {
			"source": "iana",
			"extensions": ["mj2", "mjp2"]
		},
		"video/mp1s": { "source": "iana" },
		"video/mp2p": { "source": "iana" },
		"video/mp2t": {
			"source": "iana",
			"extensions": ["ts"]
		},
		"video/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mp4",
				"mp4v",
				"mpg4"
			]
		},
		"video/mp4v-es": { "source": "iana" },
		"video/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpeg",
				"mpg",
				"mpe",
				"m1v",
				"m2v"
			]
		},
		"video/mpeg4-generic": { "source": "iana" },
		"video/mpv": { "source": "iana" },
		"video/nv": { "source": "iana" },
		"video/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": ["ogv"]
		},
		"video/parityfec": { "source": "iana" },
		"video/pointer": { "source": "iana" },
		"video/quicktime": {
			"source": "iana",
			"compressible": false,
			"extensions": ["qt", "mov"]
		},
		"video/raptorfec": { "source": "iana" },
		"video/raw": { "source": "iana" },
		"video/rtp-enc-aescm128": { "source": "iana" },
		"video/rtploopback": { "source": "iana" },
		"video/rtx": { "source": "iana" },
		"video/scip": { "source": "iana" },
		"video/smpte291": { "source": "iana" },
		"video/smpte292m": { "source": "iana" },
		"video/ulpfec": { "source": "iana" },
		"video/vc1": { "source": "iana" },
		"video/vc2": { "source": "iana" },
		"video/vnd.cctv": { "source": "iana" },
		"video/vnd.dece.hd": {
			"source": "iana",
			"extensions": ["uvh", "uvvh"]
		},
		"video/vnd.dece.mobile": {
			"source": "iana",
			"extensions": ["uvm", "uvvm"]
		},
		"video/vnd.dece.mp4": { "source": "iana" },
		"video/vnd.dece.pd": {
			"source": "iana",
			"extensions": ["uvp", "uvvp"]
		},
		"video/vnd.dece.sd": {
			"source": "iana",
			"extensions": ["uvs", "uvvs"]
		},
		"video/vnd.dece.video": {
			"source": "iana",
			"extensions": ["uvv", "uvvv"]
		},
		"video/vnd.directv.mpeg": { "source": "iana" },
		"video/vnd.directv.mpeg-tts": { "source": "iana" },
		"video/vnd.dlna.mpeg-tts": { "source": "iana" },
		"video/vnd.dvb.file": {
			"source": "iana",
			"extensions": ["dvb"]
		},
		"video/vnd.fvt": {
			"source": "iana",
			"extensions": ["fvt"]
		},
		"video/vnd.hns.video": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
		"video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
		"video/vnd.iptvforum.ttsavc": { "source": "iana" },
		"video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
		"video/vnd.motorola.video": { "source": "iana" },
		"video/vnd.motorola.videop": { "source": "iana" },
		"video/vnd.mpegurl": {
			"source": "iana",
			"extensions": ["mxu", "m4u"]
		},
		"video/vnd.ms-playready.media.pyv": {
			"source": "iana",
			"extensions": ["pyv"]
		},
		"video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
		"video/vnd.nokia.mp4vr": { "source": "iana" },
		"video/vnd.nokia.videovoip": { "source": "iana" },
		"video/vnd.objectvideo": { "source": "iana" },
		"video/vnd.radgamettools.bink": { "source": "iana" },
		"video/vnd.radgamettools.smacker": { "source": "iana" },
		"video/vnd.sealed.mpeg1": { "source": "iana" },
		"video/vnd.sealed.mpeg4": { "source": "iana" },
		"video/vnd.sealed.swf": { "source": "iana" },
		"video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
		"video/vnd.uvvu.mp4": {
			"source": "iana",
			"extensions": ["uvu", "uvvu"]
		},
		"video/vnd.vivo": {
			"source": "iana",
			"extensions": ["viv"]
		},
		"video/vnd.youtube.yt": { "source": "iana" },
		"video/vp8": { "source": "iana" },
		"video/vp9": { "source": "iana" },
		"video/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": ["webm"]
		},
		"video/x-f4v": {
			"source": "apache",
			"extensions": ["f4v"]
		},
		"video/x-fli": {
			"source": "apache",
			"extensions": ["fli"]
		},
		"video/x-flv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["flv"]
		},
		"video/x-m4v": {
			"source": "apache",
			"extensions": ["m4v"]
		},
		"video/x-matroska": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mkv",
				"mk3d",
				"mks"
			]
		},
		"video/x-mng": {
			"source": "apache",
			"extensions": ["mng"]
		},
		"video/x-ms-asf": {
			"source": "apache",
			"extensions": ["asf", "asx"]
		},
		"video/x-ms-vob": {
			"source": "apache",
			"extensions": ["vob"]
		},
		"video/x-ms-wm": {
			"source": "apache",
			"extensions": ["wm"]
		},
		"video/x-ms-wmv": {
			"source": "apache",
			"compressible": false,
			"extensions": ["wmv"]
		},
		"video/x-ms-wmx": {
			"source": "apache",
			"extensions": ["wmx"]
		},
		"video/x-ms-wvx": {
			"source": "apache",
			"extensions": ["wvx"]
		},
		"video/x-msvideo": {
			"source": "apache",
			"extensions": ["avi"]
		},
		"video/x-sgi-movie": {
			"source": "apache",
			"extensions": ["movie"]
		},
		"video/x-smv": {
			"source": "apache",
			"extensions": ["smv"]
		},
		"x-conference/x-cooltalk": {
			"source": "apache",
			"extensions": ["ice"]
		},
		"x-shader/x-fragment": { "compressible": true },
		"x-shader/x-vertex": { "compressible": true }
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js": ((exports, module) => {
	/*!
	* mime-db
	* Copyright(c) 2014 Jonathan Ong
	* Copyright(c) 2015-2022 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module exports.
	*/
	module.exports = require_db();
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js": ((exports) => {
	/**
	* Module dependencies.
	* @private
	*/
	var db = require_mime_db();
	var extname$3 = __require("path").extname;
	/**
	* Module variables.
	* @private
	*/
	var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	var TEXT_TYPE_REGEXP = /^text\//i;
	/**
	* Module exports.
	* @public
	*/
	exports.charset = charset;
	exports.charsets = { lookup: charset };
	exports.contentType = contentType$4;
	exports.extension = extension;
	exports.extensions = Object.create(null);
	exports.lookup = lookup;
	exports.types = Object.create(null);
	populateMaps(exports.extensions, exports.types);
	/**
	* Get the default charset for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function charset(type) {
		if (!type || typeof type !== "string") return false;
		var match$1 = EXTRACT_TYPE_REGEXP.exec(type);
		var mime$6 = match$1 && db[match$1[1].toLowerCase()];
		if (mime$6 && mime$6.charset) return mime$6.charset;
		if (match$1 && TEXT_TYPE_REGEXP.test(match$1[1])) return "UTF-8";
		return false;
	}
	/**
	* Create a full Content-Type header given a MIME type or extension.
	*
	* @param {string} str
	* @return {boolean|string}
	*/
	function contentType$4(str) {
		if (!str || typeof str !== "string") return false;
		var mime$6 = str.indexOf("/") === -1 ? exports.lookup(str) : str;
		if (!mime$6) return false;
		if (mime$6.indexOf("charset") === -1) {
			var charset$1 = exports.charset(mime$6);
			if (charset$1) mime$6 += "; charset=" + charset$1.toLowerCase();
		}
		return mime$6;
	}
	/**
	* Get the default extension for a MIME type.
	*
	* @param {string} type
	* @return {boolean|string}
	*/
	function extension(type) {
		if (!type || typeof type !== "string") return false;
		var match$1 = EXTRACT_TYPE_REGEXP.exec(type);
		var exts = match$1 && exports.extensions[match$1[1].toLowerCase()];
		if (!exts || !exts.length) return false;
		return exts[0];
	}
	/**
	* Lookup the MIME type for a file path/extension.
	*
	* @param {string} path
	* @return {boolean|string}
	*/
	function lookup(path$19) {
		if (!path$19 || typeof path$19 !== "string") return false;
		var extension$1 = extname$3("x." + path$19).toLowerCase().substr(1);
		if (!extension$1) return false;
		return exports.types[extension$1] || false;
	}
	/**
	* Populate the extensions and types maps.
	* @private
	*/
	function populateMaps(extensions, types) {
		var preference = [
			"nginx",
			"apache",
			void 0,
			"iana"
		];
		Object.keys(db).forEach(function forEachMimeType(type) {
			var mime$6 = db[type];
			var exts = mime$6.extensions;
			if (!exts || !exts.length) return;
			extensions[type] = exts;
			for (var i$8 = 0; i$8 < exts.length; i$8++) {
				var extension$1 = exts[i$8];
				if (types[extension$1]) {
					var from = preference.indexOf(db[types[extension$1]].source);
					var to = preference.indexOf(mime$6.source);
					if (types[extension$1] !== "application/octet-stream" && (from > to || from === to && types[extension$1].substr(0, 12) === "application/")) continue;
				}
				types[extension$1] = type;
			}
		});
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js
var require_type_is = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var typer = require_media_typer();
	var mime$5 = require_mime_types();
	/**
	* Module exports.
	* @public
	*/
	module.exports = typeofrequest;
	module.exports.is = typeis$5;
	module.exports.hasBody = hasbody;
	module.exports.normalize = normalize$1;
	module.exports.match = mimeMatch;
	/**
	* Compare a `value` content-type with `types`.
	* Each `type` can be an extension like `html`,
	* a special shortcut like `multipart` or `urlencoded`,
	* or a mime type.
	*
	* If no types match, `false` is returned.
	* Otherwise, the first `type` that matches is returned.
	*
	* @param {String} value
	* @param {Array} types
	* @public
	*/
	function typeis$5(value, types_) {
		var i$8;
		var types = types_;
		var val = tryNormalizeType(value);
		if (!val) return false;
		if (types && !Array.isArray(types)) {
			types = new Array(arguments.length - 1);
			for (i$8 = 0; i$8 < types.length; i$8++) types[i$8] = arguments[i$8 + 1];
		}
		if (!types || !types.length) return val;
		var type;
		for (i$8 = 0; i$8 < types.length; i$8++) if (mimeMatch(normalize$1(type = types[i$8]), val)) return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
		return false;
	}
	/**
	* Check if a request has a request body.
	* A request with a body __must__ either have `transfer-encoding`
	* or `content-length` headers set.
	* http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
	*
	* @param {Object} request
	* @return {Boolean}
	* @public
	*/
	function hasbody(req$2) {
		return req$2.headers["transfer-encoding"] !== void 0 || !isNaN(req$2.headers["content-length"]);
	}
	/**
	* Check if the incoming request contains the "Content-Type"
	* header field, and it contains any of the give mime `type`s.
	* If there is no request body, `null` is returned.
	* If there is no content type, `false` is returned.
	* Otherwise, it returns the first `type` that matches.
	*
	* Examples:
	*
	*     // With Content-Type: text/html; charset=utf-8
	*     this.is('html'); // => 'html'
	*     this.is('text/html'); // => 'text/html'
	*     this.is('text/*', 'application/json'); // => 'text/html'
	*
	*     // When Content-Type is application/json
	*     this.is('json', 'urlencoded'); // => 'json'
	*     this.is('application/json'); // => 'application/json'
	*     this.is('html', 'application/*'); // => 'application/json'
	*
	*     this.is('html'); // => false
	*
	* @param {String|Array} types...
	* @return {String|false|null}
	* @public
	*/
	function typeofrequest(req$2, types_) {
		var types = types_;
		if (!hasbody(req$2)) return null;
		if (arguments.length > 2) {
			types = new Array(arguments.length - 1);
			for (var i$8 = 0; i$8 < types.length; i$8++) types[i$8] = arguments[i$8 + 1];
		}
		var value = req$2.headers["content-type"];
		return typeis$5(value, types);
	}
	/**
	* Normalize a mime type.
	* If it's a shorthand, expand it to a valid mime type.
	*
	* In general, you probably want:
	*
	*   var type = is(req, ['urlencoded', 'json', 'multipart']);
	*
	* Then use the appropriate body parsers.
	* These three are the most common request body types
	* and are thus ensured to work.
	*
	* @param {String} type
	* @private
	*/
	function normalize$1(type) {
		if (typeof type !== "string") return false;
		switch (type) {
			case "urlencoded": return "application/x-www-form-urlencoded";
			case "multipart": return "multipart/*";
		}
		if (type[0] === "+") return "*/*" + type;
		return type.indexOf("/") === -1 ? mime$5.lookup(type) : type;
	}
	/**
	* Check if `expected` mime type
	* matches `actual` mime type with
	* wildcard and +suffix support.
	*
	* @param {String} expected
	* @param {String} actual
	* @return {Boolean}
	* @private
	*/
	function mimeMatch(expected, actual) {
		if (expected === false) return false;
		var actualParts = actual.split("/");
		var expectedParts = expected.split("/");
		if (actualParts.length !== 2 || expectedParts.length !== 2) return false;
		if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) return false;
		if (expectedParts[1].substr(0, 2) === "*+") return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
		if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) return false;
		return true;
	}
	/**
	* Normalize a type and remove parameters.
	*
	* @param {string} value
	* @return {string}
	* @private
	*/
	function normalizeType$1(value) {
		var type = typer.parse(value);
		type.parameters = void 0;
		return typer.format(type);
	}
	/**
	* Try to normalize a type and remove parameters.
	*
	* @param {string} value
	* @return {string}
	* @private
	*/
	function tryNormalizeType(value) {
		if (!value) return null;
		try {
			return normalizeType$1(value);
		} catch (err) {
			return null;
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/json.js
var require_json = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/json.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var bytes$3 = require_bytes();
	var contentType$3 = require_content_type();
	var createError$3 = require_http_errors();
	var debug$11 = require_src()("body-parser:json");
	var read$3 = require_read();
	var typeis$4 = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = json;
	/**
	* RegExp to match the first non-space in a string.
	*
	* Allowed whitespace is defined in RFC 7159:
	*
	*    ws = *(
	*            %x20 /              ; Space
	*            %x09 /              ; Horizontal tab
	*            %x0A /              ; Line feed or New line
	*            %x0D )              ; Carriage return
	*/
	var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
	var JSON_SYNTAX_CHAR = "#";
	var JSON_SYNTAX_REGEXP = /#+/g;
	/**
	* Create a middleware to parse JSON bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @public
	*/
	function json(options) {
		var opts = options || {};
		var limit$2 = typeof opts.limit !== "number" ? bytes$3.parse(opts.limit || "100kb") : opts.limit;
		var inflate = opts.inflate !== false;
		var reviver = opts.reviver;
		var strict = opts.strict !== false;
		var type = opts.type || "application/json";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var shouldParse = typeof type !== "function" ? typeChecker$3(type) : type;
		function parse$18(body$1) {
			if (body$1.length === 0) return {};
			if (strict) {
				var first$3 = firstchar(body$1);
				if (first$3 !== "{" && first$3 !== "[") {
					debug$11("strict violation");
					throw createStrictSyntaxError(body$1, first$3);
				}
			}
			try {
				debug$11("parse json");
				return JSON.parse(body$1, reviver);
			} catch (e) {
				throw normalizeJsonSyntaxError(e, {
					message: e.message,
					stack: e.stack
				});
			}
		}
		return function jsonParser(req$2, res$2, next) {
			if (req$2._body) {
				debug$11("body already parsed");
				next();
				return;
			}
			req$2.body = req$2.body || {};
			if (!typeis$4.hasBody(req$2)) {
				debug$11("skip empty body");
				next();
				return;
			}
			debug$11("content-type %j", req$2.headers["content-type"]);
			if (!shouldParse(req$2)) {
				debug$11("skip parsing");
				next();
				return;
			}
			var charset$1 = getCharset$2(req$2) || "utf-8";
			if (charset$1.slice(0, 4) !== "utf-") {
				debug$11("invalid charset");
				next(createError$3(415, "unsupported charset \"" + charset$1.toUpperCase() + "\"", {
					charset: charset$1,
					type: "charset.unsupported"
				}));
				return;
			}
			read$3(req$2, res$2, next, parse$18, debug$11, {
				encoding: charset$1,
				inflate,
				limit: limit$2,
				verify
			});
		};
	}
	/**
	* Create strict violation syntax error matching native error.
	*
	* @param {string} str
	* @param {string} char
	* @return {Error}
	* @private
	*/
	function createStrictSyntaxError(str, char) {
		var index$1 = str.indexOf(char);
		var partial = "";
		if (index$1 !== -1) {
			partial = str.substring(0, index$1) + JSON_SYNTAX_CHAR;
			for (var i$8 = index$1 + 1; i$8 < str.length; i$8++) partial += JSON_SYNTAX_CHAR;
		}
		try {
			JSON.parse(partial);
			/* istanbul ignore next */ throw new SyntaxError("strict violation");
		} catch (e) {
			return normalizeJsonSyntaxError(e, {
				message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
					return str.substring(index$1, index$1 + placeholder.length);
				}),
				stack: e.stack
			});
		}
	}
	/**
	* Get the first non-whitespace character in a string.
	*
	* @param {string} str
	* @return {function}
	* @private
	*/
	function firstchar(str) {
		var match$1 = FIRST_CHAR_REGEXP.exec(str);
		return match$1 ? match$1[1] : void 0;
	}
	/**
	* Get the charset of a request.
	*
	* @param {object} req
	* @api private
	*/
	function getCharset$2(req$2) {
		try {
			return (contentType$3.parse(req$2).parameters.charset || "").toLowerCase();
		} catch (e) {
			return;
		}
	}
	/**
	* Normalize a SyntaxError for JSON.parse.
	*
	* @param {SyntaxError} error
	* @param {object} obj
	* @return {SyntaxError}
	*/
	function normalizeJsonSyntaxError(error, obj) {
		var keys$6 = Object.getOwnPropertyNames(error);
		for (var i$8 = 0; i$8 < keys$6.length; i$8++) {
			var key$1 = keys$6[i$8];
			if (key$1 !== "stack" && key$1 !== "message") delete error[key$1];
		}
		error.stack = obj.stack.replace(error.message, obj.message);
		error.message = obj.message;
		return error;
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker$3(type) {
		return function checkType(req$2) {
			return Boolean(typeis$4(req$2, type));
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/raw.js
var require_raw = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/raw.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	var bytes$2 = require_bytes();
	var debug$10 = require_src()("body-parser:raw");
	var read$2 = require_read();
	var typeis$3 = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = raw;
	/**
	* Create a middleware to parse raw bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @api public
	*/
	function raw(options) {
		var opts = options || {};
		var inflate = opts.inflate !== false;
		var limit$2 = typeof opts.limit !== "number" ? bytes$2.parse(opts.limit || "100kb") : opts.limit;
		var type = opts.type || "application/octet-stream";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var shouldParse = typeof type !== "function" ? typeChecker$2(type) : type;
		function parse$18(buf) {
			return buf;
		}
		return function rawParser(req$2, res$2, next) {
			if (req$2._body) {
				debug$10("body already parsed");
				next();
				return;
			}
			req$2.body = req$2.body || {};
			if (!typeis$3.hasBody(req$2)) {
				debug$10("skip empty body");
				next();
				return;
			}
			debug$10("content-type %j", req$2.headers["content-type"]);
			if (!shouldParse(req$2)) {
				debug$10("skip parsing");
				next();
				return;
			}
			read$2(req$2, res$2, next, parse$18, debug$10, {
				encoding: null,
				inflate,
				limit: limit$2,
				verify
			});
		};
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker$2(type) {
		return function checkType(req$2) {
			return Boolean(typeis$3(req$2, type));
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/text.js
var require_text = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/text.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	var bytes$1 = require_bytes();
	var contentType$2 = require_content_type();
	var debug$9 = require_src()("body-parser:text");
	var read$1 = require_read();
	var typeis$2 = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = text$1;
	/**
	* Create a middleware to parse text bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @api public
	*/
	function text$1(options) {
		var opts = options || {};
		var defaultCharset = opts.defaultCharset || "utf-8";
		var inflate = opts.inflate !== false;
		var limit$2 = typeof opts.limit !== "number" ? bytes$1.parse(opts.limit || "100kb") : opts.limit;
		var type = opts.type || "text/plain";
		var verify = opts.verify || false;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var shouldParse = typeof type !== "function" ? typeChecker$1(type) : type;
		function parse$18(buf) {
			return buf;
		}
		return function textParser(req$2, res$2, next) {
			if (req$2._body) {
				debug$9("body already parsed");
				next();
				return;
			}
			req$2.body = req$2.body || {};
			if (!typeis$2.hasBody(req$2)) {
				debug$9("skip empty body");
				next();
				return;
			}
			debug$9("content-type %j", req$2.headers["content-type"]);
			if (!shouldParse(req$2)) {
				debug$9("skip parsing");
				next();
				return;
			}
			read$1(req$2, res$2, next, parse$18, debug$9, {
				encoding: getCharset$1(req$2) || defaultCharset,
				inflate,
				limit: limit$2,
				verify
			});
		};
	}
	/**
	* Get the charset of a request.
	*
	* @param {object} req
	* @api private
	*/
	function getCharset$1(req$2) {
		try {
			return (contentType$2.parse(req$2).parameters.charset || "").toLowerCase();
		} catch (e) {
			return;
		}
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker$1(type) {
		return function checkType(req$2) {
			return Boolean(typeis$2(req$2, type));
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js
var require_formats = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js": ((exports, module) => {
	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;
	var Format = {
		RFC1738: "RFC1738",
		RFC3986: "RFC3986"
	};
	module.exports = {
		"default": Format.RFC3986,
		formatters: {
			RFC1738: function(value) {
				return replace.call(value, percentTwenties, "+");
			},
			RFC3986: function(value) {
				return String(value);
			}
		},
		RFC1738: Format.RFC1738,
		RFC3986: Format.RFC3986
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/utils.js
var require_utils$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/utils.js": ((exports, module) => {
	var formats$2 = require_formats();
	var has$2 = Object.prototype.hasOwnProperty;
	var isArray$2 = Array.isArray;
	var hexTable = function() {
		var array = [];
		for (var i$8 = 0; i$8 < 256; ++i$8) array.push("%" + ((i$8 < 16 ? "0" : "") + i$8.toString(16)).toUpperCase());
		return array;
	}();
	var compactQueue = function compactQueue$2(queue$5) {
		while (queue$5.length > 1) {
			var item = queue$5.pop();
			var obj = item.obj[item.prop];
			if (isArray$2(obj)) {
				var compacted = [];
				for (var j$7 = 0; j$7 < obj.length; ++j$7) if (typeof obj[j$7] !== "undefined") compacted.push(obj[j$7]);
				item.obj[item.prop] = compacted;
			}
		}
	};
	var arrayToObject = function arrayToObject$2(source, options) {
		var obj = options && options.plainObjects ? Object.create(null) : {};
		for (var i$8 = 0; i$8 < source.length; ++i$8) if (typeof source[i$8] !== "undefined") obj[i$8] = source[i$8];
		return obj;
	};
	var merge$4 = function merge$6(target, source, options) {
		if (!source) return target;
		if (typeof source !== "object") {
			if (isArray$2(target)) target.push(source);
			else if (target && typeof target === "object") {
				if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) target[source] = true;
			} else return [target, source];
			return target;
		}
		if (!target || typeof target !== "object") return [target].concat(source);
		var mergeTarget = target;
		if (isArray$2(target) && !isArray$2(source)) mergeTarget = arrayToObject(target, options);
		if (isArray$2(target) && isArray$2(source)) {
			source.forEach(function(item, i$8) {
				if (has$2.call(target, i$8)) {
					var targetItem = target[i$8];
					if (targetItem && typeof targetItem === "object" && item && typeof item === "object") target[i$8] = merge$6(targetItem, item, options);
					else target.push(item);
				} else target[i$8] = item;
			});
			return target;
		}
		return Object.keys(source).reduce(function(acc, key$1) {
			var value = source[key$1];
			if (has$2.call(acc, key$1)) acc[key$1] = merge$6(acc[key$1], value, options);
			else acc[key$1] = value;
			return acc;
		}, mergeTarget);
	};
	var assign = function assignSingleSource(target, source) {
		return Object.keys(source).reduce(function(acc, key$1) {
			acc[key$1] = source[key$1];
			return acc;
		}, target);
	};
	var decode$2 = function(str, decoder, charset$1) {
		var strWithoutPlus = str.replace(/\+/g, " ");
		if (charset$1 === "iso-8859-1") return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
		try {
			return decodeURIComponent(strWithoutPlus);
		} catch (e) {
			return strWithoutPlus;
		}
	};
	var limit = 1024;
	var encode = function encode$3(str, defaultEncoder, charset$1, kind, format$6) {
		if (str.length === 0) return str;
		var string = str;
		if (typeof str === "symbol") string = Symbol.prototype.toString.call(str);
		else if (typeof str !== "string") string = String(str);
		if (charset$1 === "iso-8859-1") return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
			return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
		});
		var out = "";
		for (var j$7 = 0; j$7 < string.length; j$7 += limit) {
			var segment = string.length >= limit ? string.slice(j$7, j$7 + limit) : string;
			var arr = [];
			for (var i$8 = 0; i$8 < segment.length; ++i$8) {
				var c = segment.charCodeAt(i$8);
				if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format$6 === formats$2.RFC1738 && (c === 40 || c === 41)) {
					arr[arr.length] = segment.charAt(i$8);
					continue;
				}
				if (c < 128) {
					arr[arr.length] = hexTable[c];
					continue;
				}
				if (c < 2048) {
					arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
					continue;
				}
				if (c < 55296 || c >= 57344) {
					arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
					continue;
				}
				i$8 += 1;
				c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i$8) & 1023);
				arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
			}
			out += arr.join("");
		}
		return out;
	};
	var compact = function compact$2(value) {
		var queue$5 = [{
			obj: { o: value },
			prop: "o"
		}];
		var refs = [];
		for (var i$8 = 0; i$8 < queue$5.length; ++i$8) {
			var item = queue$5[i$8];
			var obj = item.obj[item.prop];
			var keys$6 = Object.keys(obj);
			for (var j$7 = 0; j$7 < keys$6.length; ++j$7) {
				var key$1 = keys$6[j$7];
				var val = obj[key$1];
				if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
					queue$5.push({
						obj,
						prop: key$1
					});
					refs.push(val);
				}
			}
		}
		compactQueue(queue$5);
		return value;
	};
	var isRegExp = function isRegExp$3(obj) {
		return Object.prototype.toString.call(obj) === "[object RegExp]";
	};
	var isBuffer = function isBuffer$3(obj) {
		if (!obj || typeof obj !== "object") return false;
		return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};
	var combine = function combine$2(a, b) {
		return [].concat(a, b);
	};
	var maybeMap = function maybeMap$2(val, fn) {
		if (isArray$2(val)) {
			var mapped = [];
			for (var i$8 = 0; i$8 < val.length; i$8 += 1) mapped.push(fn(val[i$8]));
			return mapped;
		}
		return fn(val);
	};
	module.exports = {
		arrayToObject,
		assign,
		combine,
		compact,
		decode: decode$2,
		encode,
		isBuffer,
		isRegExp,
		maybeMap,
		merge: merge$4
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/stringify.js
var require_stringify = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/stringify.js": ((exports, module) => {
	var getSideChannel = require_side_channel();
	var utils$2 = require_utils$1();
	var formats$1 = require_formats();
	var has$1 = Object.prototype.hasOwnProperty;
	var arrayPrefixGenerators = {
		brackets: function brackets(prefix) {
			return prefix + "[]";
		},
		comma: "comma",
		indices: function indices(prefix, key$1) {
			return prefix + "[" + key$1 + "]";
		},
		repeat: function repeat(prefix) {
			return prefix;
		}
	};
	var isArray$1 = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function(arr, valueOrArray) {
		push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
	};
	var toISO = Date.prototype.toISOString;
	var defaultFormat = formats$1["default"];
	var defaults$1 = {
		addQueryPrefix: false,
		allowDots: false,
		allowEmptyArrays: false,
		arrayFormat: "indices",
		charset: "utf-8",
		charsetSentinel: false,
		delimiter: "&",
		encode: true,
		encodeDotInKeys: false,
		encoder: utils$2.encode,
		encodeValuesOnly: false,
		format: defaultFormat,
		formatter: formats$1.formatters[defaultFormat],
		indices: false,
		serializeDate: function serializeDate(date) {
			return toISO.call(date);
		},
		skipNulls: false,
		strictNullHandling: false
	};
	var isNonNullishPrimitive = function isNonNullishPrimitive$2(v) {
		return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
	};
	var sentinel = {};
	var stringify$3 = function stringify$14(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format$6, formatter, encodeValuesOnly, charset$1, sideChannel) {
		var obj = object;
		var tmpSc = sideChannel;
		var step = 0;
		var findFlag = false;
		while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
			var pos = tmpSc.get(object);
			step += 1;
			if (typeof pos !== "undefined") if (pos === step) throw new RangeError("Cyclic object value");
			else findFlag = true;
			if (typeof tmpSc.get(sentinel) === "undefined") step = 0;
		}
		if (typeof filter === "function") obj = filter(prefix, obj);
		else if (obj instanceof Date) obj = serializeDate(obj);
		else if (generateArrayPrefix === "comma" && isArray$1(obj)) obj = utils$2.maybeMap(obj, function(value$1) {
			if (value$1 instanceof Date) return serializeDate(value$1);
			return value$1;
		});
		if (obj === null) {
			if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset$1, "key", format$6) : prefix;
			obj = "";
		}
		if (isNonNullishPrimitive(obj) || utils$2.isBuffer(obj)) {
			if (encoder) return [formatter(encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset$1, "key", format$6)) + "=" + formatter(encoder(obj, defaults$1.encoder, charset$1, "value", format$6))];
			return [formatter(prefix) + "=" + formatter(String(obj))];
		}
		var values = [];
		if (typeof obj === "undefined") return values;
		var objKeys;
		if (generateArrayPrefix === "comma" && isArray$1(obj)) {
			if (encodeValuesOnly && encoder) obj = utils$2.maybeMap(obj, encoder);
			objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
		} else if (isArray$1(filter)) objKeys = filter;
		else {
			var keys$6 = Object.keys(obj);
			objKeys = sort ? keys$6.sort(sort) : keys$6;
		}
		var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
		var adjustedPrefix = commaRoundTrip && isArray$1(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
		if (allowEmptyArrays && isArray$1(obj) && obj.length === 0) return adjustedPrefix + "[]";
		for (var j$7 = 0; j$7 < objKeys.length; ++j$7) {
			var key$1 = objKeys[j$7];
			var value = typeof key$1 === "object" && typeof key$1.value !== "undefined" ? key$1.value : obj[key$1];
			if (skipNulls && value === null) continue;
			var encodedKey = allowDots && encodeDotInKeys ? key$1.replace(/\./g, "%2E") : key$1;
			var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
			sideChannel.set(object, step);
			var valueSideChannel = getSideChannel();
			valueSideChannel.set(sentinel, sideChannel);
			pushToArray(values, stringify$14(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray$1(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format$6, formatter, encodeValuesOnly, charset$1, valueSideChannel));
		}
		return values;
	};
	var normalizeStringifyOptions = function normalizeStringifyOptions$2(opts) {
		if (!opts) return defaults$1;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") throw new TypeError("Encoder has to be a function.");
		var charset$1 = opts.charset || defaults$1.charset;
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		var format$6 = formats$1["default"];
		if (typeof opts.format !== "undefined") {
			if (!has$1.call(formats$1.formatters, opts.format)) throw new TypeError("Unknown format option provided.");
			format$6 = opts.format;
		}
		var formatter = formats$1.formatters[format$6];
		var filter = defaults$1.filter;
		if (typeof opts.filter === "function" || isArray$1(opts.filter)) filter = opts.filter;
		var arrayFormat$1;
		if (opts.arrayFormat in arrayPrefixGenerators) arrayFormat$1 = opts.arrayFormat;
		else if ("indices" in opts) arrayFormat$1 = opts.indices ? "indices" : "repeat";
		else arrayFormat$1 = defaults$1.arrayFormat;
		if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
		var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
		return {
			addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
			allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
			arrayFormat: arrayFormat$1,
			charset: charset$1,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
			commaRoundTrip: opts.commaRoundTrip,
			delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
			encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
			encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$1.encodeDotInKeys,
			encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
			encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
			filter,
			format: format$6,
			formatter,
			serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
			skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
			sort: typeof opts.sort === "function" ? opts.sort : null,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
		};
	};
	module.exports = function(object, opts) {
		var obj = object;
		var options = normalizeStringifyOptions(opts);
		var objKeys;
		var filter;
		if (typeof options.filter === "function") {
			filter = options.filter;
			obj = filter("", obj);
		} else if (isArray$1(options.filter)) {
			filter = options.filter;
			objKeys = filter;
		}
		var keys$6 = [];
		if (typeof obj !== "object" || obj === null) return "";
		var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
		var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
		if (!objKeys) objKeys = Object.keys(obj);
		if (options.sort) objKeys.sort(options.sort);
		var sideChannel = getSideChannel();
		for (var i$8 = 0; i$8 < objKeys.length; ++i$8) {
			var key$1 = objKeys[i$8];
			if (options.skipNulls && obj[key$1] === null) continue;
			pushToArray(keys$6, stringify$3(obj[key$1], key$1, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
		}
		var joined = keys$6.join(options.delimiter);
		var prefix = options.addQueryPrefix === true ? "?" : "";
		if (options.charsetSentinel) if (options.charset === "iso-8859-1") prefix += "utf8=%26%2310003%3B&";
		else prefix += "utf8=%E2%9C%93&";
		return joined.length > 0 ? prefix + joined : "";
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/parse.js
var require_parse = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/parse.js": ((exports, module) => {
	var utils$1 = require_utils$1();
	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;
	var defaults = {
		allowDots: false,
		allowEmptyArrays: false,
		allowPrototypes: false,
		allowSparse: false,
		arrayLimit: 20,
		charset: "utf-8",
		charsetSentinel: false,
		comma: false,
		decodeDotInKeys: false,
		decoder: utils$1.decode,
		delimiter: "&",
		depth: 5,
		duplicates: "combine",
		ignoreQueryPrefix: false,
		interpretNumericEntities: false,
		parameterLimit: 1e3,
		parseArrays: true,
		plainObjects: false,
		strictDepth: false,
		strictNullHandling: false
	};
	var interpretNumericEntities = function(str) {
		return str.replace(/&#(\d+);/g, function($0, numberStr) {
			return String.fromCharCode(parseInt(numberStr, 10));
		});
	};
	var parseArrayValue = function(val, options) {
		if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) return val.split(",");
		return val;
	};
	var isoSentinel = "utf8=%26%2310003%3B";
	var charsetSentinel = "utf8=%E2%9C%93";
	var parseValues = function parseQueryStringValues(str, options) {
		var obj = { __proto__: null };
		var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
		cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
		var limit$2 = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
		var parts = cleanStr.split(options.delimiter, limit$2);
		var skipIndex = -1;
		var i$8;
		var charset$1 = options.charset;
		if (options.charsetSentinel) {
			for (i$8 = 0; i$8 < parts.length; ++i$8) if (parts[i$8].indexOf("utf8=") === 0) {
				if (parts[i$8] === charsetSentinel) charset$1 = "utf-8";
				else if (parts[i$8] === isoSentinel) charset$1 = "iso-8859-1";
				skipIndex = i$8;
				i$8 = parts.length;
			}
		}
		for (i$8 = 0; i$8 < parts.length; ++i$8) {
			if (i$8 === skipIndex) continue;
			var part = parts[i$8];
			var bracketEqualsPos = part.indexOf("]=");
			var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
			var key$1, val;
			if (pos === -1) {
				key$1 = options.decoder(part, defaults.decoder, charset$1, "key");
				val = options.strictNullHandling ? null : "";
			} else {
				key$1 = options.decoder(part.slice(0, pos), defaults.decoder, charset$1, "key");
				val = utils$1.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
					return options.decoder(encodedVal, defaults.decoder, charset$1, "value");
				});
			}
			if (val && options.interpretNumericEntities && charset$1 === "iso-8859-1") val = interpretNumericEntities(val);
			if (part.indexOf("[]=") > -1) val = isArray(val) ? [val] : val;
			var existing = has.call(obj, key$1);
			if (existing && options.duplicates === "combine") obj[key$1] = utils$1.combine(obj[key$1], val);
			else if (!existing || options.duplicates === "last") obj[key$1] = val;
		}
		return obj;
	};
	var parseObject = function(chain, val, options, valuesParsed) {
		var leaf = valuesParsed ? val : parseArrayValue(val, options);
		for (var i$8 = chain.length - 1; i$8 >= 0; --i$8) {
			var obj;
			var root$3 = chain[i$8];
			if (root$3 === "[]" && options.parseArrays) obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
			else {
				obj = options.plainObjects ? Object.create(null) : {};
				var cleanRoot = root$3.charAt(0) === "[" && root$3.charAt(root$3.length - 1) === "]" ? root$3.slice(1, -1) : root$3;
				var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
				var index$1 = parseInt(decodedRoot, 10);
				if (!options.parseArrays && decodedRoot === "") obj = { 0: leaf };
				else if (!isNaN(index$1) && root$3 !== decodedRoot && String(index$1) === decodedRoot && index$1 >= 0 && options.parseArrays && index$1 <= options.arrayLimit) {
					obj = [];
					obj[index$1] = leaf;
				} else if (decodedRoot !== "__proto__") obj[decodedRoot] = leaf;
			}
			leaf = obj;
		}
		return leaf;
	};
	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
		if (!givenKey) return;
		var key$1 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
		var brackets = /(\[[^[\]]*])/;
		var child = /(\[[^[\]]*])/g;
		var segment = options.depth > 0 && brackets.exec(key$1);
		var parent = segment ? key$1.slice(0, segment.index) : key$1;
		var keys$6 = [];
		if (parent) {
			if (!options.plainObjects && has.call(Object.prototype, parent)) {
				if (!options.allowPrototypes) return;
			}
			keys$6.push(parent);
		}
		var i$8 = 0;
		while (options.depth > 0 && (segment = child.exec(key$1)) !== null && i$8 < options.depth) {
			i$8 += 1;
			if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
				if (!options.allowPrototypes) return;
			}
			keys$6.push(segment[1]);
		}
		if (segment) {
			if (options.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
			keys$6.push("[" + key$1.slice(segment.index) + "]");
		}
		return parseObject(keys$6, val, options, valuesParsed);
	};
	var normalizeParseOptions = function normalizeParseOptions$2(opts) {
		if (!opts) return defaults;
		if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
		if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
		if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") throw new TypeError("Decoder has to be a function.");
		if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
		var charset$1 = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
		var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
		if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
		return {
			allowDots: typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots,
			allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
			allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
			allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
			arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
			charset: charset$1,
			charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
			comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
			decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
			decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
			delimiter: typeof opts.delimiter === "string" || utils$1.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
			depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
			duplicates,
			ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
			interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
			parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
			parseArrays: opts.parseArrays !== false,
			plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
			strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
			strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
		};
	};
	module.exports = function(str, opts) {
		var options = normalizeParseOptions(opts);
		if (str === "" || str === null || typeof str === "undefined") return options.plainObjects ? Object.create(null) : {};
		var tempObj = typeof str === "string" ? parseValues(str, options) : str;
		var obj = options.plainObjects ? Object.create(null) : {};
		var keys$6 = Object.keys(tempObj);
		for (var i$8 = 0; i$8 < keys$6.length; ++i$8) {
			var key$1 = keys$6[i$8];
			var newObj = parseKeys(key$1, tempObj[key$1], options, typeof str === "string");
			obj = utils$1.merge(obj, newObj, options);
		}
		if (options.allowSparse === true) return obj;
		return utils$1.compact(obj);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js
var require_lib$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js": ((exports, module) => {
	var stringify$2 = require_stringify();
	var parse$6 = require_parse();
	var formats = require_formats();
	module.exports = {
		formats,
		parse: parse$6,
		stringify: stringify$2
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/urlencoded.js
var require_urlencoded = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/urlencoded.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var bytes = require_bytes();
	var contentType$1 = require_content_type();
	var createError$2 = require_http_errors();
	var debug$8 = require_src()("body-parser:urlencoded");
	var deprecate$7 = require_depd()("body-parser");
	var read = require_read();
	var typeis$1 = require_type_is();
	/**
	* Module exports.
	*/
	module.exports = urlencoded;
	/**
	* Cache of parser modules.
	*/
	var parsers$1 = Object.create(null);
	/**
	* Create a middleware to parse urlencoded bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @public
	*/
	function urlencoded(options) {
		var opts = options || {};
		if (opts.extended === void 0) deprecate$7("undefined extended: provide extended option");
		var extended = opts.extended !== false;
		var inflate = opts.inflate !== false;
		var limit$2 = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
		var type = opts.type || "application/x-www-form-urlencoded";
		var verify = opts.verify || false;
		var depth = typeof opts.depth !== "number" ? Number(opts.depth || 32) : opts.depth;
		if (verify !== false && typeof verify !== "function") throw new TypeError("option verify must be function");
		var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
		var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
		function parse$18(body$1) {
			return body$1.length ? queryparse(body$1) : {};
		}
		return function urlencodedParser(req$2, res$2, next) {
			if (req$2._body) {
				debug$8("body already parsed");
				next();
				return;
			}
			req$2.body = req$2.body || {};
			if (!typeis$1.hasBody(req$2)) {
				debug$8("skip empty body");
				next();
				return;
			}
			debug$8("content-type %j", req$2.headers["content-type"]);
			if (!shouldParse(req$2)) {
				debug$8("skip parsing");
				next();
				return;
			}
			var charset$1 = getCharset(req$2) || "utf-8";
			if (charset$1 !== "utf-8") {
				debug$8("invalid charset");
				next(createError$2(415, "unsupported charset \"" + charset$1.toUpperCase() + "\"", {
					charset: charset$1,
					type: "charset.unsupported"
				}));
				return;
			}
			read(req$2, res$2, next, parse$18, debug$8, {
				debug: debug$8,
				encoding: charset$1,
				inflate,
				limit: limit$2,
				verify,
				depth
			});
		};
	}
	/**
	* Get the extended query parser.
	*
	* @param {object} options
	*/
	function extendedparser(options) {
		var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
		var depth = typeof options.depth !== "number" ? Number(options.depth || 32) : options.depth;
		var parse$18 = parser("qs");
		if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError("option parameterLimit must be a positive number");
		if (isNaN(depth) || depth < 0) throw new TypeError("option depth must be a zero or a positive number");
		if (isFinite(parameterLimit)) parameterLimit = parameterLimit | 0;
		return function queryparse(body$1) {
			var paramCount = parameterCount(body$1, parameterLimit);
			if (paramCount === void 0) {
				debug$8("too many parameters");
				throw createError$2(413, "too many parameters", { type: "parameters.too.many" });
			}
			var arrayLimit = Math.max(100, paramCount);
			debug$8("parse extended urlencoding");
			try {
				return parse$18(body$1, {
					allowPrototypes: true,
					arrayLimit,
					depth,
					strictDepth: true,
					parameterLimit
				});
			} catch (err) {
				if (err instanceof RangeError) throw createError$2(400, "The input exceeded the depth", { type: "querystring.parse.rangeError" });
				else throw err;
			}
		};
	}
	/**
	* Get the charset of a request.
	*
	* @param {object} req
	* @api private
	*/
	function getCharset(req$2) {
		try {
			return (contentType$1.parse(req$2).parameters.charset || "").toLowerCase();
		} catch (e) {
			return;
		}
	}
	/**
	* Count the number of parameters, stopping once limit reached
	*
	* @param {string} body
	* @param {number} limit
	* @api private
	*/
	function parameterCount(body$1, limit$2) {
		var count = 0;
		var index$1 = 0;
		while ((index$1 = body$1.indexOf("&", index$1)) !== -1) {
			count++;
			index$1++;
			if (count === limit$2) return;
		}
		return count;
	}
	/**
	* Get parser for module name dynamically.
	*
	* @param {string} name
	* @return {function}
	* @api private
	*/
	function parser(name) {
		var mod = parsers$1[name];
		if (mod !== void 0) return mod.parse;
		switch (name) {
			case "qs":
				mod = require_lib$1();
				break;
			case "querystring":
				mod = __require("querystring");
				break;
		}
		parsers$1[name] = mod;
		return mod.parse;
	}
	/**
	* Get the simple query parser.
	*
	* @param {object} options
	*/
	function simpleparser(options) {
		var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
		var parse$18 = parser("querystring");
		if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError("option parameterLimit must be a positive number");
		if (isFinite(parameterLimit)) parameterLimit = parameterLimit | 0;
		return function queryparse(body$1) {
			if (parameterCount(body$1, parameterLimit) === void 0) {
				debug$8("too many parameters");
				throw createError$2(413, "too many parameters", { type: "parameters.too.many" });
			}
			debug$8("parse urlencoding");
			return parse$18(body$1, void 0, void 0, { maxKeys: parameterLimit });
		};
	}
	/**
	* Get the simple type checker.
	*
	* @param {string} type
	* @return {function}
	*/
	function typeChecker(type) {
		return function checkType(req$2) {
			return Boolean(typeis$1(req$2, type));
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/index.js
var require_body_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var deprecate$6 = require_depd()("body-parser");
	/**
	* Cache of loaded parsers.
	* @private
	*/
	var parsers = Object.create(null);
	/**
	* @typedef Parsers
	* @type {function}
	* @property {function} json
	* @property {function} raw
	* @property {function} text
	* @property {function} urlencoded
	*/
	/**
	* Module exports.
	* @type {Parsers}
	*/
	exports = module.exports = deprecate$6.function(bodyParser$2, "bodyParser: use individual json/urlencoded middlewares");
	/**
	* JSON parser.
	* @public
	*/
	Object.defineProperty(exports, "json", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("json")
	});
	/**
	* Raw parser.
	* @public
	*/
	Object.defineProperty(exports, "raw", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("raw")
	});
	/**
	* Text parser.
	* @public
	*/
	Object.defineProperty(exports, "text", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("text")
	});
	/**
	* URL-encoded parser.
	* @public
	*/
	Object.defineProperty(exports, "urlencoded", {
		configurable: true,
		enumerable: true,
		get: createParserGetter("urlencoded")
	});
	/**
	* Create a middleware to parse json and urlencoded bodies.
	*
	* @param {object} [options]
	* @return {function}
	* @deprecated
	* @public
	*/
	function bodyParser$2(options) {
		var opts = Object.create(options || null, { type: {
			configurable: true,
			enumerable: true,
			value: void 0,
			writable: true
		} });
		var _urlencoded = exports.urlencoded(opts);
		var _json = exports.json(opts);
		return function bodyParser$3(req$2, res$2, next) {
			_json(req$2, res$2, function(err) {
				if (err) return next(err);
				_urlencoded(req$2, res$2, next);
			});
		};
	}
	/**
	* Create a getter for loading a parser.
	* @private
	*/
	function createParserGetter(name) {
		return function get$1() {
			return loadParser(name);
		};
	}
	/**
	* Load a parser module.
	* @private
	*/
	function loadParser(parserName) {
		var parser$1 = parsers[parserName];
		if (parser$1 !== void 0) return parser$1;
		switch (parserName) {
			case "json":
				parser$1 = require_json();
				break;
			case "raw":
				parser$1 = require_raw();
				break;
			case "text":
				parser$1 = require_text();
				break;
			case "urlencoded":
				parser$1 = require_urlencoded();
				break;
		}
		return parsers[parserName] = parser$1;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/merge-descriptors@1.0.3/node_modules/merge-descriptors/index.js
var require_merge_descriptors = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/merge-descriptors@1.0.3/node_modules/merge-descriptors/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = merge$3;
	/**
	* Module variables.
	* @private
	*/
	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
	/**
	* Merge the property descriptors of `src` into `dest`
	*
	* @param {object} dest Object to add descriptors to
	* @param {object} src Object to clone descriptors from
	* @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
	* @returns {object} Reference to dest
	* @public
	*/
	function merge$3(dest, src$1, redefine) {
		if (!dest) throw new TypeError("argument dest is required");
		if (!src$1) throw new TypeError("argument src is required");
		if (redefine === void 0) redefine = true;
		Object.getOwnPropertyNames(src$1).forEach(function forEachOwnPropertyName(name) {
			if (!redefine && hasOwnProperty$3.call(dest, name)) return;
			var descriptor = Object.getOwnPropertyDescriptor(src$1, name);
			Object.defineProperty(dest, name, descriptor);
		});
		return dest;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js
var require_encodeurl$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = encodeUrl$5;
	/**
	* RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	* and including invalid escape sequences.
	* @private
	*/
	var ENCODE_CHARS_REGEXP$1 = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
	/**
	* RegExp to match unmatched surrogate pair.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REGEXP$1 = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
	/**
	* String to replace unmatched surrogate pair with.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REPLACE$1 = "$1$2";
	/**
	* Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	*
	* This function will take an already-encoded URL and encode all the non-URL
	* code points. This function will not encode the "%" character unless it is
	* not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	* be encoded as `%25foo`).
	*
	* This encode is meant to be "safe" and does not throw errors. It will try as
	* hard as it can to properly encode the given URL, including replacing any raw,
	* unpaired surrogate pairs with the Unicode replacement character prior to
	* encoding.
	*
	* @param {string} url
	* @return {string}
	* @public
	*/
	function encodeUrl$5(url$6) {
		return String(url$6).replace(UNMATCHED_SURROGATE_PAIR_REGEXP$1, UNMATCHED_SURROGATE_PAIR_REPLACE$1).replace(ENCODE_CHARS_REGEXP$1, encodeURI);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js
var require_escape_html = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js": ((exports, module) => {
	/**
	* Module variables.
	* @private
	*/
	var matchHtmlRegExp = /["'&<>]/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = escapeHtml$4;
	/**
	* Escape special characters in the given string of html.
	*
	* @param  {string} string The string to escape for inserting into HTML
	* @return {string}
	* @public
	*/
	function escapeHtml$4(string) {
		var str = "" + string;
		var match$1 = matchHtmlRegExp.exec(str);
		if (!match$1) return str;
		var escape$1;
		var html = "";
		var index$1 = 0;
		var lastIndex = 0;
		for (index$1 = match$1.index; index$1 < str.length; index$1++) {
			switch (str.charCodeAt(index$1)) {
				case 34:
					escape$1 = "&quot;";
					break;
				case 38:
					escape$1 = "&amp;";
					break;
				case 39:
					escape$1 = "&#39;";
					break;
				case 60:
					escape$1 = "&lt;";
					break;
				case 62:
					escape$1 = "&gt;";
					break;
				default: continue;
			}
			if (lastIndex !== index$1) html += str.substring(lastIndex, index$1);
			lastIndex = index$1 + 1;
			html += escape$1;
		}
		return lastIndex !== index$1 ? html + str.substring(lastIndex, index$1) : html;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js
var require_parseurl = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var url$1 = __require("url");
	var parse$5 = url$1.parse;
	var Url = url$1.Url;
	/**
	* Module exports.
	* @public
	*/
	module.exports = parseurl;
	module.exports.original = originalurl;
	/**
	* Parse the `req` url with memoization.
	*
	* @param {ServerRequest} req
	* @return {Object}
	* @public
	*/
	function parseurl(req$2) {
		var url$6 = req$2.url;
		if (url$6 === void 0) return;
		var parsed = req$2._parsedUrl;
		if (fresh$3(url$6, parsed)) return parsed;
		parsed = fastparse(url$6);
		parsed._raw = url$6;
		return req$2._parsedUrl = parsed;
	}
	/**
	* Parse the `req` original url with fallback and memoization.
	*
	* @param {ServerRequest} req
	* @return {Object}
	* @public
	*/
	function originalurl(req$2) {
		var url$6 = req$2.originalUrl;
		if (typeof url$6 !== "string") return parseurl(req$2);
		var parsed = req$2._parsedOriginalUrl;
		if (fresh$3(url$6, parsed)) return parsed;
		parsed = fastparse(url$6);
		parsed._raw = url$6;
		return req$2._parsedOriginalUrl = parsed;
	}
	/**
	* Parse the `str` url with fast-path short-cut.
	*
	* @param {string} str
	* @return {Object}
	* @private
	*/
	function fastparse(str) {
		if (typeof str !== "string" || str.charCodeAt(0) !== 47) return parse$5(str);
		var pathname = str;
		var query$1 = null;
		var search = null;
		for (var i$8 = 1; i$8 < str.length; i$8++) switch (str.charCodeAt(i$8)) {
			case 63:
				if (search === null) {
					pathname = str.substring(0, i$8);
					query$1 = str.substring(i$8 + 1);
					search = str.substring(i$8);
				}
				break;
			case 9:
			case 10:
			case 12:
			case 13:
			case 32:
			case 35:
			case 160:
			case 65279: return parse$5(str);
		}
		var url$6 = Url !== void 0 ? new Url() : {};
		url$6.path = str;
		url$6.href = str;
		url$6.pathname = pathname;
		if (search !== null) {
			url$6.query = query$1;
			url$6.search = search;
		}
		return url$6;
	}
	/**
	* Determine if parsed is still fresh for url.
	*
	* @param {string} url
	* @param {object} parsedUrl
	* @return {boolean}
	* @private
	*/
	function fresh$3(url$6, parsedUrl) {
		return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url$6;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/finalhandler@1.3.1/node_modules/finalhandler/index.js
var require_finalhandler = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/finalhandler@1.3.1/node_modules/finalhandler/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug$7 = require_src()("finalhandler");
	var encodeUrl$4 = require_encodeurl$1();
	var escapeHtml$3 = require_escape_html();
	var onFinished$2 = require_on_finished();
	var parseUrl$3 = require_parseurl();
	var statuses$2 = require_statuses();
	var unpipe = require_unpipe();
	/**
	* Module variables.
	* @private
	*/
	var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
	var NEWLINE_REGEXP = /\n/g;
	/* istanbul ignore next */
	var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
		process.nextTick(fn.bind.apply(fn, arguments));
	};
	var isFinished = onFinished$2.isFinished;
	/**
	* Create a minimal HTML document.
	*
	* @param {string} message
	* @private
	*/
	function createHtmlDocument$2(message) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Error</title>\n</head>\n<body>\n<pre>" + escapeHtml$3(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;") + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Module exports.
	* @public
	*/
	module.exports = finalhandler$1;
	/**
	* Create a function to handle the final response.
	*
	* @param {Request} req
	* @param {Response} res
	* @param {Object} [options]
	* @return {Function}
	* @public
	*/
	function finalhandler$1(req$2, res$2, options) {
		var opts = options || {};
		var env$2 = opts.env || process.env.NODE_ENV || "development";
		var onerror = opts.onerror;
		return function(err) {
			var headers$1;
			var msg;
			var status$1;
			if (!err && headersSent$1(res$2)) {
				debug$7("cannot 404 after headers sent");
				return;
			}
			if (err) {
				status$1 = getErrorStatusCode(err);
				if (status$1 === void 0) status$1 = getResponseStatusCode(res$2);
				else headers$1 = getErrorHeaders(err);
				msg = getErrorMessage(err, status$1, env$2);
			} else {
				status$1 = 404;
				msg = "Cannot " + req$2.method + " " + encodeUrl$4(getResourceName(req$2));
			}
			debug$7("default %s", status$1);
			if (err && onerror) defer(onerror, err, req$2, res$2);
			if (headersSent$1(res$2)) {
				debug$7("cannot %d after headers sent", status$1);
				if (req$2.socket) req$2.socket.destroy();
				return;
			}
			send$3(req$2, res$2, status$1, headers$1, msg);
		};
	}
	/**
	* Get headers from Error object.
	*
	* @param {Error} err
	* @return {object}
	* @private
	*/
	function getErrorHeaders(err) {
		if (!err.headers || typeof err.headers !== "object") return;
		var headers$1 = Object.create(null);
		var keys$6 = Object.keys(err.headers);
		for (var i$8 = 0; i$8 < keys$6.length; i$8++) {
			var key$1 = keys$6[i$8];
			headers$1[key$1] = err.headers[key$1];
		}
		return headers$1;
	}
	/**
	* Get message from Error object, fallback to status message.
	*
	* @param {Error} err
	* @param {number} status
	* @param {string} env
	* @return {string}
	* @private
	*/
	function getErrorMessage(err, status$1, env$2) {
		var msg;
		if (env$2 !== "production") {
			msg = err.stack;
			if (!msg && typeof err.toString === "function") msg = err.toString();
		}
		return msg || statuses$2.message[status$1];
	}
	/**
	* Get status code from Error object.
	*
	* @param {Error} err
	* @return {number}
	* @private
	*/
	function getErrorStatusCode(err) {
		if (typeof err.status === "number" && err.status >= 400 && err.status < 600) return err.status;
		if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) return err.statusCode;
	}
	/**
	* Get resource name for the request.
	*
	* This is typically just the original pathname of the request
	* but will fallback to "resource" is that cannot be determined.
	*
	* @param {IncomingMessage} req
	* @return {string}
	* @private
	*/
	function getResourceName(req$2) {
		try {
			return parseUrl$3.original(req$2).pathname;
		} catch (e) {
			return "resource";
		}
	}
	/**
	* Get status code from response.
	*
	* @param {OutgoingMessage} res
	* @return {number}
	* @private
	*/
	function getResponseStatusCode(res$2) {
		var status$1 = res$2.statusCode;
		if (typeof status$1 !== "number" || status$1 < 400 || status$1 > 599) status$1 = 500;
		return status$1;
	}
	/**
	* Determine if the response headers have been sent.
	*
	* @param {object} res
	* @returns {boolean}
	* @private
	*/
	function headersSent$1(res$2) {
		return typeof res$2.headersSent !== "boolean" ? Boolean(res$2._header) : res$2.headersSent;
	}
	/**
	* Send response.
	*
	* @param {IncomingMessage} req
	* @param {OutgoingMessage} res
	* @param {number} status
	* @param {object} headers
	* @param {string} message
	* @private
	*/
	function send$3(req$2, res$2, status$1, headers$1, message) {
		function write$1() {
			var body$1 = createHtmlDocument$2(message);
			res$2.statusCode = status$1;
			if (req$2.httpVersionMajor < 2) res$2.statusMessage = statuses$2.message[status$1];
			res$2.removeHeader("Content-Encoding");
			res$2.removeHeader("Content-Language");
			res$2.removeHeader("Content-Range");
			setHeaders$1(res$2, headers$1);
			res$2.setHeader("Content-Security-Policy", "default-src 'none'");
			res$2.setHeader("X-Content-Type-Options", "nosniff");
			res$2.setHeader("Content-Type", "text/html; charset=utf-8");
			res$2.setHeader("Content-Length", Buffer.byteLength(body$1, "utf8"));
			if (req$2.method === "HEAD") {
				res$2.end();
				return;
			}
			res$2.end(body$1, "utf8");
		}
		if (isFinished(req$2)) {
			write$1();
			return;
		}
		unpipe(req$2);
		onFinished$2(req$2, write$1);
		req$2.resume();
	}
	/**
	* Set response headers from an object.
	*
	* @param {OutgoingMessage} res
	* @param {object} headers
	* @private
	*/
	function setHeaders$1(res$2, headers$1) {
		if (!headers$1) return;
		var keys$6 = Object.keys(headers$1);
		for (var i$8 = 0; i$8 < keys$6.length; i$8++) {
			var key$1 = keys$6[i$8];
			res$2.setHeader(key$1, headers$1[key$1]);
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js
var require_array_flatten = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js": ((exports, module) => {
	/**
	* Expose `arrayFlatten`.
	*/
	module.exports = arrayFlatten;
	/**
	* Recursive flatten function with depth.
	*
	* @param  {Array}  array
	* @param  {Array}  result
	* @param  {Number} depth
	* @return {Array}
	*/
	function flattenWithDepth(array, result, depth) {
		for (var i$8 = 0; i$8 < array.length; i$8++) {
			var value = array[i$8];
			if (depth > 0 && Array.isArray(value)) flattenWithDepth(value, result, depth - 1);
			else result.push(value);
		}
		return result;
	}
	/**
	* Recursive flatten function. Omitting depth is slightly faster.
	*
	* @param  {Array} array
	* @param  {Array} result
	* @return {Array}
	*/
	function flattenForever(array, result) {
		for (var i$8 = 0; i$8 < array.length; i$8++) {
			var value = array[i$8];
			if (Array.isArray(value)) flattenForever(value, result);
			else result.push(value);
		}
		return result;
	}
	/**
	* Flatten an array, with the ability to define a depth.
	*
	* @param  {Array}  array
	* @param  {Number} depth
	* @return {Array}
	*/
	function arrayFlatten(array, depth) {
		if (depth == null) return flattenForever(array, []);
		return flattenWithDepth(array, [], depth);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/path-to-regexp@0.1.12/node_modules/path-to-regexp/index.js
var require_path_to_regexp = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/path-to-regexp@0.1.12/node_modules/path-to-regexp/index.js": ((exports, module) => {
	/**
	* Expose `pathToRegexp`.
	*/
	module.exports = pathToRegexp;
	/**
	* Match matching groups in a regular expression.
	*/
	var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;
	/**
	* Normalize the given path string,
	* returning a regular expression.
	*
	* An empty array should be passed,
	* which will contain the placeholder
	* key names. For example "/user/:id" will
	* then contain ["id"].
	*
	* @param  {String|RegExp|Array} path
	* @param  {Array} keys
	* @param  {Object} options
	* @return {RegExp}
	* @api private
	*/
	function pathToRegexp(path$19, keys$6, options) {
		options = options || {};
		keys$6 = keys$6 || [];
		var strict = options.strict;
		var end = options.end !== false;
		var flags = options.sensitive ? "" : "i";
		var lookahead = options.lookahead !== false;
		var extraOffset = 0;
		var keysOffset = keys$6.length;
		var i$8 = 0;
		var name = 0;
		var pos = 0;
		var backtrack = "";
		var m$3;
		if (path$19 instanceof RegExp) {
			while (m$3 = MATCHING_GROUP_REGEXP.exec(path$19.source)) {
				if (m$3[0][0] === "\\") continue;
				keys$6.push({
					name: m$3[1] || name++,
					optional: false,
					offset: m$3.index
				});
			}
			return path$19;
		}
		if (Array.isArray(path$19)) {
			path$19 = path$19.map(function(value) {
				return pathToRegexp(value, keys$6, options).source;
			});
			return new RegExp(path$19.join("|"), flags);
		}
		if (typeof path$19 !== "string") throw new TypeError("path must be a string, array of strings, or regular expression");
		path$19 = path$19.replace(/\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g, function(match$1, slash, format$6, key$1, capture, star, optional, offset) {
			if (match$1[0] === "\\") {
				backtrack += match$1;
				pos += 2;
				return match$1;
			}
			if (match$1 === ".") {
				backtrack += "\\.";
				extraOffset += 1;
				pos += 1;
				return "\\.";
			}
			if (slash || format$6) backtrack = "";
			else backtrack += path$19.slice(pos, offset);
			pos = offset + match$1.length;
			if (match$1 === "*") {
				extraOffset += 3;
				return "(.*)";
			}
			if (match$1 === "/(") {
				backtrack += "/";
				extraOffset += 2;
				return "/(?:";
			}
			slash = slash || "";
			format$6 = format$6 ? "\\." : "";
			optional = optional || "";
			capture = capture ? capture.replace(/\\.|\*/, function(m$4) {
				return m$4 === "*" ? "(.*)" : m$4;
			}) : backtrack ? "((?:(?!/|" + backtrack + ").)+?)" : "([^/" + format$6 + "]+?)";
			keys$6.push({
				name: key$1,
				optional: !!optional,
				offset: offset + extraOffset
			});
			var result = "(?:" + format$6 + slash + capture + (star ? "((?:[/" + format$6 + "].+?)?)" : "") + ")" + optional;
			extraOffset += result.length - match$1.length;
			return result;
		});
		while (m$3 = MATCHING_GROUP_REGEXP.exec(path$19)) {
			if (m$3[0][0] === "\\") continue;
			if (keysOffset + i$8 === keys$6.length || keys$6[keysOffset + i$8].offset > m$3.index) keys$6.splice(keysOffset + i$8, 0, {
				name: name++,
				optional: false,
				offset: m$3.index
			});
			i$8++;
		}
		path$19 += strict ? "" : path$19[path$19.length - 1] === "/" ? "?" : "/?";
		if (end) path$19 += "$";
		else if (path$19[path$19.length - 1] !== "/") path$19 += lookahead ? "(?=/|$)" : "(?:/|$)";
		return new RegExp("^" + path$19, flags);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/layer.js
var require_layer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/layer.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var pathRegexp = require_path_to_regexp();
	var debug$6 = require_src()("express:router:layer");
	/**
	* Module variables.
	* @private
	*/
	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
	/**
	* Module exports.
	* @public
	*/
	module.exports = Layer$2;
	function Layer$2(path$19, options, fn) {
		if (!(this instanceof Layer$2)) return new Layer$2(path$19, options, fn);
		debug$6("new %o", path$19);
		var opts = options || {};
		this.handle = fn;
		this.name = fn.name || "<anonymous>";
		this.params = void 0;
		this.path = void 0;
		this.regexp = pathRegexp(path$19, this.keys = [], opts);
		this.regexp.fast_star = path$19 === "*";
		this.regexp.fast_slash = path$19 === "/" && opts.end === false;
	}
	/**
	* Handle the error for the layer.
	*
	* @param {Error} error
	* @param {Request} req
	* @param {Response} res
	* @param {function} next
	* @api private
	*/
	Layer$2.prototype.handle_error = function handle_error(error, req$2, res$2, next) {
		var fn = this.handle;
		if (fn.length !== 4) return next(error);
		try {
			fn(error, req$2, res$2, next);
		} catch (err) {
			next(err);
		}
	};
	/**
	* Handle the request for the layer.
	*
	* @param {Request} req
	* @param {Response} res
	* @param {function} next
	* @api private
	*/
	Layer$2.prototype.handle_request = function handle(req$2, res$2, next) {
		var fn = this.handle;
		if (fn.length > 3) return next();
		try {
			fn(req$2, res$2, next);
		} catch (err) {
			next(err);
		}
	};
	/**
	* Check if this route matches `path`, if so
	* populate `.params`.
	*
	* @param {String} path
	* @return {Boolean}
	* @api private
	*/
	Layer$2.prototype.match = function match$1(path$19) {
		var match$2;
		if (path$19 != null) {
			if (this.regexp.fast_slash) {
				this.params = {};
				this.path = "";
				return true;
			}
			if (this.regexp.fast_star) {
				this.params = { "0": decode_param(path$19) };
				this.path = path$19;
				return true;
			}
			match$2 = this.regexp.exec(path$19);
		}
		if (!match$2) {
			this.params = void 0;
			this.path = void 0;
			return false;
		}
		this.params = {};
		this.path = match$2[0];
		var keys$6 = this.keys;
		var params = this.params;
		for (var i$8 = 1; i$8 < match$2.length; i$8++) {
			var prop = keys$6[i$8 - 1].name;
			var val = decode_param(match$2[i$8]);
			if (val !== void 0 || !hasOwnProperty$2.call(params, prop)) params[prop] = val;
		}
		return true;
	};
	/**
	* Decode param value.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function decode_param(val) {
		if (typeof val !== "string" || val.length === 0) return val;
		try {
			return decodeURIComponent(val);
		} catch (err) {
			if (err instanceof URIError) {
				err.message = "Failed to decode param '" + val + "'";
				err.status = err.statusCode = 400;
			}
			throw err;
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js
var require_methods = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var http$4 = __require("http");
	/**
	* Module exports.
	* @public
	*/
	module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
	/**
	* Get the current Node.js methods.
	* @private
	*/
	function getCurrentNodeMethods() {
		return http$4.METHODS && http$4.METHODS.map(function lowerCaseMethod(method$1) {
			return method$1.toLowerCase();
		});
	}
	/**
	* Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
	* @private
	*/
	function getBasicNodeMethods() {
		return [
			"get",
			"post",
			"put",
			"head",
			"delete",
			"options",
			"trace",
			"copy",
			"lock",
			"mkcol",
			"move",
			"purge",
			"propfind",
			"proppatch",
			"unlock",
			"report",
			"mkactivity",
			"checkout",
			"merge",
			"m-search",
			"notify",
			"subscribe",
			"unsubscribe",
			"patch",
			"search",
			"connect"
		];
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/route.js
var require_route = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/route.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug$5 = require_src()("express:router:route");
	var flatten$3 = require_array_flatten();
	var Layer$1 = require_layer();
	var methods$2 = require_methods();
	/**
	* Module variables.
	* @private
	*/
	var slice$2 = Array.prototype.slice;
	var toString$4 = Object.prototype.toString;
	/**
	* Module exports.
	* @public
	*/
	module.exports = Route$2;
	/**
	* Initialize `Route` with the given `path`,
	*
	* @param {String} path
	* @public
	*/
	function Route$2(path$19) {
		this.path = path$19;
		this.stack = [];
		debug$5("new %o", path$19);
		this.methods = {};
	}
	/**
	* Determine if the route handles a given method.
	* @private
	*/
	Route$2.prototype._handles_method = function _handles_method(method$1) {
		if (this.methods._all) return true;
		var name = typeof method$1 === "string" ? method$1.toLowerCase() : method$1;
		if (name === "head" && !this.methods["head"]) name = "get";
		return Boolean(this.methods[name]);
	};
	/**
	* @return {Array} supported HTTP methods
	* @private
	*/
	Route$2.prototype._options = function _options() {
		var methods$3 = Object.keys(this.methods);
		if (this.methods.get && !this.methods.head) methods$3.push("head");
		for (var i$8 = 0; i$8 < methods$3.length; i$8++) methods$3[i$8] = methods$3[i$8].toUpperCase();
		return methods$3;
	};
	/**
	* dispatch req, res into this route
	* @private
	*/
	Route$2.prototype.dispatch = function dispatch(req$2, res$2, done) {
		var idx = 0;
		var stack = this.stack;
		var sync = 0;
		if (stack.length === 0) return done();
		var method$1 = typeof req$2.method === "string" ? req$2.method.toLowerCase() : req$2.method;
		if (method$1 === "head" && !this.methods["head"]) method$1 = "get";
		req$2.route = this;
		next();
		function next(err) {
			if (err && err === "route") return done();
			if (err && err === "router") return done(err);
			if (++sync > 100) return setImmediate(next, err);
			var layer = stack[idx++];
			if (!layer) return done(err);
			if (layer.method && layer.method !== method$1) next(err);
			else if (err) layer.handle_error(err, req$2, res$2, next);
			else layer.handle_request(req$2, res$2, next);
			sync = 0;
		}
	};
	/**
	* Add a handler for all HTTP verbs to this route.
	*
	* Behaves just like middleware and can respond or call `next`
	* to continue processing.
	*
	* You can use multiple `.all` call to add multiple handlers.
	*
	*   function check_something(req, res, next){
	*     next();
	*   };
	*
	*   function validate_user(req, res, next){
	*     next();
	*   };
	*
	*   route
	*   .all(validate_user)
	*   .all(check_something)
	*   .get(function(req, res, next){
	*     res.send('hello world');
	*   });
	*
	* @param {function} handler
	* @return {Route} for chaining
	* @api public
	*/
	Route$2.prototype.all = function all() {
		var handles = flatten$3(slice$2.call(arguments));
		for (var i$8 = 0; i$8 < handles.length; i$8++) {
			var handle = handles[i$8];
			if (typeof handle !== "function") {
				var msg = "Route.all() requires a callback function but got a " + toString$4.call(handle);
				throw new TypeError(msg);
			}
			var layer = Layer$1("/", {}, handle);
			layer.method = void 0;
			this.methods._all = true;
			this.stack.push(layer);
		}
		return this;
	};
	methods$2.forEach(function(method$1) {
		Route$2.prototype[method$1] = function() {
			var handles = flatten$3(slice$2.call(arguments));
			for (var i$8 = 0; i$8 < handles.length; i$8++) {
				var handle = handles[i$8];
				if (typeof handle !== "function") {
					var type = toString$4.call(handle);
					var msg = "Route." + method$1 + "() requires a callback function but got a " + type;
					throw new Error(msg);
				}
				debug$5("%s %o", method$1, this.path);
				var layer = Layer$1("/", {}, handle);
				layer.method = method$1;
				this.methods[method$1] = true;
				this.stack.push(layer);
			}
			return this;
		};
	});
}) });

//#endregion
//#region ../../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js
var require_utils_merge = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js": ((exports, module) => {
	/**
	* Merge object b with object a.
	*
	*     var a = { foo: 'bar' }
	*       , b = { bar: 'baz' };
	*
	*     merge(a, b);
	*     // => { foo: 'bar', bar: 'baz' }
	*
	* @param {Object} a
	* @param {Object} b
	* @return {Object}
	* @api public
	*/
	exports = module.exports = function(a, b) {
		if (a && b) for (var key$1 in b) a[key$1] = b[key$1];
		return a;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/index.js
var require_router = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Route$1 = require_route();
	var Layer = require_layer();
	var methods$1 = require_methods();
	var mixin$1 = require_utils_merge();
	var debug$4 = require_src()("express:router");
	var deprecate$5 = require_depd()("express");
	var flatten$2 = require_array_flatten();
	var parseUrl$2 = require_parseurl();
	var setPrototypeOf$2 = require_setprototypeof();
	/**
	* Module variables.
	* @private
	*/
	var objectRegExp = /^\[object (\S+)\]$/;
	var slice$1 = Array.prototype.slice;
	var toString$3 = Object.prototype.toString;
	/**
	* Initialize a new `Router` with the given `options`.
	*
	* @param {Object} [options]
	* @return {Router} which is a callable function
	* @public
	*/
	var proto$1 = module.exports = function(options) {
		var opts = options || {};
		function router(req$2, res$2, next) {
			router.handle(req$2, res$2, next);
		}
		setPrototypeOf$2(router, proto$1);
		router.params = {};
		router._params = [];
		router.caseSensitive = opts.caseSensitive;
		router.mergeParams = opts.mergeParams;
		router.strict = opts.strict;
		router.stack = [];
		return router;
	};
	/**
	* Map the given param placeholder `name`(s) to the given callback.
	*
	* Parameter mapping is used to provide pre-conditions to routes
	* which use normalized placeholders. For example a _:user_id_ parameter
	* could automatically load a user's information from the database without
	* any additional code,
	*
	* The callback uses the same signature as middleware, the only difference
	* being that the value of the placeholder is passed, in this case the _id_
	* of the user. Once the `next()` function is invoked, just like middleware
	* it will continue on to execute the route, or subsequent parameter functions.
	*
	* Just like in middleware, you must either respond to the request or call next
	* to avoid stalling the request.
	*
	*  app.param('user_id', function(req, res, next, id){
	*    User.find(id, function(err, user){
	*      if (err) {
	*        return next(err);
	*      } else if (!user) {
	*        return next(new Error('failed to load user'));
	*      }
	*      req.user = user;
	*      next();
	*    });
	*  });
	*
	* @param {String} name
	* @param {Function} fn
	* @return {app} for chaining
	* @public
	*/
	proto$1.param = function param(name, fn) {
		if (typeof name === "function") {
			deprecate$5("router.param(fn): Refactor to use path params");
			this._params.push(name);
			return;
		}
		var params = this._params;
		var len$1 = params.length;
		var ret;
		if (name[0] === ":") {
			deprecate$5("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.slice(1)) + ", fn) instead");
			name = name.slice(1);
		}
		for (var i$8 = 0; i$8 < len$1; ++i$8) if (ret = params[i$8](name, fn)) fn = ret;
		if ("function" !== typeof fn) throw new Error("invalid param() call for " + name + ", got " + fn);
		(this.params[name] = this.params[name] || []).push(fn);
		return this;
	};
	/**
	* Dispatch a req, res into the router.
	* @private
	*/
	proto$1.handle = function handle(req$2, res$2, out) {
		var self$1 = this;
		debug$4("dispatching %s %s", req$2.method, req$2.url);
		var idx = 0;
		var protohost = getProtohost(req$2.url) || "";
		var removed = "";
		var slashAdded = false;
		var sync = 0;
		var paramcalled = {};
		var options = [];
		var stack = self$1.stack;
		var parentParams = req$2.params;
		var parentUrl = req$2.baseUrl || "";
		var done = restore(out, req$2, "baseUrl", "next", "params");
		req$2.next = next;
		if (req$2.method === "OPTIONS") done = wrap$1(done, function(old, err) {
			if (err || options.length === 0) return old(err);
			sendOptionsResponse(res$2, options, old);
		});
		req$2.baseUrl = parentUrl;
		req$2.originalUrl = req$2.originalUrl || req$2.url;
		next();
		function next(err) {
			var layerError = err === "route" ? null : err;
			if (slashAdded) {
				req$2.url = req$2.url.slice(1);
				slashAdded = false;
			}
			if (removed.length !== 0) {
				req$2.baseUrl = parentUrl;
				req$2.url = protohost + removed + req$2.url.slice(protohost.length);
				removed = "";
			}
			if (layerError === "router") {
				setImmediate(done, null);
				return;
			}
			if (idx >= stack.length) {
				setImmediate(done, layerError);
				return;
			}
			if (++sync > 100) return setImmediate(next, err);
			var path$19 = getPathname(req$2);
			if (path$19 == null) return done(layerError);
			var layer;
			var match$1;
			var route;
			while (match$1 !== true && idx < stack.length) {
				layer = stack[idx++];
				match$1 = matchLayer(layer, path$19);
				route = layer.route;
				if (typeof match$1 !== "boolean") layerError = layerError || match$1;
				if (match$1 !== true) continue;
				if (!route) continue;
				if (layerError) {
					match$1 = false;
					continue;
				}
				var method$1 = req$2.method;
				var has_method = route._handles_method(method$1);
				if (!has_method && method$1 === "OPTIONS") appendMethods(options, route._options());
				if (!has_method && method$1 !== "HEAD") match$1 = false;
			}
			if (match$1 !== true) return done(layerError);
			if (route) req$2.route = route;
			req$2.params = self$1.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
			var layerPath = layer.path;
			self$1.process_params(layer, paramcalled, req$2, res$2, function(err$1) {
				if (err$1) next(layerError || err$1);
				else if (route) layer.handle_request(req$2, res$2, next);
				else trim_prefix(layer, layerError, layerPath, path$19);
				sync = 0;
			});
		}
		function trim_prefix(layer, layerError, layerPath, path$19) {
			if (layerPath.length !== 0) {
				if (layerPath !== path$19.slice(0, layerPath.length)) {
					next(layerError);
					return;
				}
				var c = path$19[layerPath.length];
				if (c && c !== "/" && c !== ".") return next(layerError);
				debug$4("trim prefix (%s) from url %s", layerPath, req$2.url);
				removed = layerPath;
				req$2.url = protohost + req$2.url.slice(protohost.length + removed.length);
				if (!protohost && req$2.url[0] !== "/") {
					req$2.url = "/" + req$2.url;
					slashAdded = true;
				}
				req$2.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
			}
			debug$4("%s %s : %s", layer.name, layerPath, req$2.originalUrl);
			if (layerError) layer.handle_error(layerError, req$2, res$2, next);
			else layer.handle_request(req$2, res$2, next);
		}
	};
	/**
	* Process any parameters for the layer.
	* @private
	*/
	proto$1.process_params = function process_params(layer, called, req$2, res$2, done) {
		var params = this.params;
		var keys$6 = layer.keys;
		if (!keys$6 || keys$6.length === 0) return done();
		var i$8 = 0;
		var name;
		var paramIndex = 0;
		var key$1;
		var paramVal;
		var paramCallbacks;
		var paramCalled;
		function param(err) {
			if (err) return done(err);
			if (i$8 >= keys$6.length) return done();
			paramIndex = 0;
			key$1 = keys$6[i$8++];
			name = key$1.name;
			paramVal = req$2.params[name];
			paramCallbacks = params[name];
			paramCalled = called[name];
			if (paramVal === void 0 || !paramCallbacks) return param();
			if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
				req$2.params[name] = paramCalled.value;
				return param(paramCalled.error);
			}
			called[name] = paramCalled = {
				error: null,
				match: paramVal,
				value: paramVal
			};
			paramCallback();
		}
		function paramCallback(err) {
			var fn = paramCallbacks[paramIndex++];
			paramCalled.value = req$2.params[key$1.name];
			if (err) {
				paramCalled.error = err;
				param(err);
				return;
			}
			if (!fn) return param();
			try {
				fn(req$2, res$2, paramCallback, paramVal, key$1.name);
			} catch (e) {
				paramCallback(e);
			}
		}
		param();
	};
	/**
	* Use the given middleware function, with optional path, defaulting to "/".
	*
	* Use (like `.all`) will run for any http METHOD, but it will not add
	* handlers for those methods so OPTIONS requests will not consider `.use`
	* functions even if they could respond.
	*
	* The other difference is that _route_ path is stripped and not visible
	* to the handler function. The main effect of this feature is that mounted
	* handlers can operate without any code changes regardless of the "prefix"
	* pathname.
	*
	* @public
	*/
	proto$1.use = function use(fn) {
		var offset = 0;
		var path$19 = "/";
		if (typeof fn !== "function") {
			var arg = fn;
			while (Array.isArray(arg) && arg.length !== 0) arg = arg[0];
			if (typeof arg !== "function") {
				offset = 1;
				path$19 = fn;
			}
		}
		var callbacks = flatten$2(slice$1.call(arguments, offset));
		if (callbacks.length === 0) throw new TypeError("Router.use() requires a middleware function");
		for (var i$8 = 0; i$8 < callbacks.length; i$8++) {
			var fn = callbacks[i$8];
			if (typeof fn !== "function") throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
			debug$4("use %o %s", path$19, fn.name || "<anonymous>");
			var layer = new Layer(path$19, {
				sensitive: this.caseSensitive,
				strict: false,
				end: false
			}, fn);
			layer.route = void 0;
			this.stack.push(layer);
		}
		return this;
	};
	/**
	* Create a new Route for the given path.
	*
	* Each route contains a separate middleware stack and VERB handlers.
	*
	* See the Route api documentation for details on adding handlers
	* and middleware to routes.
	*
	* @param {String} path
	* @return {Route}
	* @public
	*/
	proto$1.route = function route(path$19) {
		var route$1 = new Route$1(path$19);
		var layer = new Layer(path$19, {
			sensitive: this.caseSensitive,
			strict: this.strict,
			end: true
		}, route$1.dispatch.bind(route$1));
		layer.route = route$1;
		this.stack.push(layer);
		return route$1;
	};
	methods$1.concat("all").forEach(function(method$1) {
		proto$1[method$1] = function(path$19) {
			var route = this.route(path$19);
			route[method$1].apply(route, slice$1.call(arguments, 1));
			return this;
		};
	});
	function appendMethods(list, addition) {
		for (var i$8 = 0; i$8 < addition.length; i$8++) {
			var method$1 = addition[i$8];
			if (list.indexOf(method$1) === -1) list.push(method$1);
		}
	}
	function getPathname(req$2) {
		try {
			return parseUrl$2(req$2).pathname;
		} catch (err) {
			return;
		}
	}
	function getProtohost(url$6) {
		if (typeof url$6 !== "string" || url$6.length === 0 || url$6[0] === "/") return;
		var searchIndex = url$6.indexOf("?");
		var pathLength = searchIndex !== -1 ? searchIndex : url$6.length;
		var fqdnIndex = url$6.slice(0, pathLength).indexOf("://");
		return fqdnIndex !== -1 ? url$6.substring(0, url$6.indexOf("/", 3 + fqdnIndex)) : void 0;
	}
	function gettype(obj) {
		var type = typeof obj;
		if (type !== "object") return type;
		return toString$3.call(obj).replace(objectRegExp, "$1");
	}
	/**
	* Match path to a layer.
	*
	* @param {Layer} layer
	* @param {string} path
	* @private
	*/
	function matchLayer(layer, path$19) {
		try {
			return layer.match(path$19);
		} catch (err) {
			return err;
		}
	}
	function mergeParams(params, parent) {
		if (typeof parent !== "object" || !parent) return params;
		var obj = mixin$1({}, parent);
		if (!(0 in params) || !(0 in parent)) return mixin$1(obj, params);
		var i$8 = 0;
		var o = 0;
		while (i$8 in params) i$8++;
		while (o in parent) o++;
		for (i$8--; i$8 >= 0; i$8--) {
			params[i$8 + o] = params[i$8];
			if (i$8 < o) delete params[i$8];
		}
		return mixin$1(obj, params);
	}
	function restore(fn, obj) {
		var props = new Array(arguments.length - 2);
		var vals = new Array(arguments.length - 2);
		for (var i$8 = 0; i$8 < props.length; i$8++) {
			props[i$8] = arguments[i$8 + 2];
			vals[i$8] = obj[props[i$8]];
		}
		return function() {
			for (var i$9 = 0; i$9 < props.length; i$9++) obj[props[i$9]] = vals[i$9];
			return fn.apply(this, arguments);
		};
	}
	function sendOptionsResponse(res$2, options, next) {
		try {
			var body$1 = options.join(",");
			res$2.set("Allow", body$1);
			res$2.send(body$1);
		} catch (err) {
			next(err);
		}
	}
	function wrap$1(old, fn) {
		return function proxy() {
			var args = new Array(arguments.length + 1);
			args[0] = old;
			for (var i$8 = 0, len$1 = arguments.length; i$8 < len$1; i$8++) args[i$8 + 1] = arguments[i$8];
			fn.apply(this, args);
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/init.js
var require_init = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/init.js": ((exports) => {
	/**
	* Module dependencies.
	* @private
	*/
	var setPrototypeOf$1 = require_setprototypeof();
	/**
	* Initialization middleware, exposing the
	* request and response to each other, as well
	* as defaulting the X-Powered-By header field.
	*
	* @param {Function} app
	* @return {Function}
	* @api private
	*/
	exports.init = function(app$1) {
		return function expressInit(req$2, res$2, next) {
			if (app$1.enabled("x-powered-by")) res$2.setHeader("X-Powered-By", "Express");
			req$2.res = res$2;
			res$2.req = req$2;
			req$2.next = next;
			setPrototypeOf$1(req$2, app$1.request);
			setPrototypeOf$1(res$2, app$1.response);
			res$2.locals = res$2.locals || Object.create(null);
			next();
		};
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/query.js
var require_query = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/query.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	var merge$2 = require_utils_merge();
	var parseUrl$1 = require_parseurl();
	var qs$1 = require_lib$1();
	/**
	* @param {Object} options
	* @return {Function}
	* @api public
	*/
	module.exports = function query$1(options) {
		var opts = merge$2({}, options);
		var queryparse = qs$1.parse;
		if (typeof options === "function") {
			queryparse = options;
			opts = void 0;
		}
		if (opts !== void 0 && opts.allowPrototypes === void 0) opts.allowPrototypes = true;
		return function query$2(req$2, res$2, next) {
			if (!req$2.query) {
				var val = parseUrl$1(req$2).query;
				req$2.query = queryparse(val, opts);
			}
			next();
		};
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/view.js
var require_view = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/view.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var debug$3 = require_src()("express:view");
	var path$4 = __require("path");
	var fs$3 = __require("fs");
	/**
	* Module variables.
	* @private
	*/
	var dirname = path$4.dirname;
	var basename$1 = path$4.basename;
	var extname$2 = path$4.extname;
	var join$1 = path$4.join;
	var resolve$4 = path$4.resolve;
	/**
	* Module exports.
	* @public
	*/
	module.exports = View$1;
	/**
	* Initialize a new `View` with the given `name`.
	*
	* Options:
	*
	*   - `defaultEngine` the default template engine name
	*   - `engines` template engine require() cache
	*   - `root` root path for view lookup
	*
	* @param {string} name
	* @param {object} options
	* @public
	*/
	function View$1(name, options) {
		var opts = options || {};
		this.defaultEngine = opts.defaultEngine;
		this.ext = extname$2(name);
		this.name = name;
		this.root = opts.root;
		if (!this.ext && !this.defaultEngine) throw new Error("No default engine was specified and no extension was provided.");
		var fileName = name;
		if (!this.ext) {
			this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
			fileName += this.ext;
		}
		if (!opts.engines[this.ext]) {
			var mod = this.ext.slice(1);
			debug$3("require \"%s\"", mod);
			var fn = __require(mod).__express;
			if (typeof fn !== "function") throw new Error("Module \"" + mod + "\" does not provide a view engine.");
			opts.engines[this.ext] = fn;
		}
		this.engine = opts.engines[this.ext];
		this.path = this.lookup(fileName);
	}
	/**
	* Lookup view by the given `name`
	*
	* @param {string} name
	* @private
	*/
	View$1.prototype.lookup = function lookup$2(name) {
		var path$19;
		var roots = [].concat(this.root);
		debug$3("lookup \"%s\"", name);
		for (var i$8 = 0; i$8 < roots.length && !path$19; i$8++) {
			var root$3 = roots[i$8];
			var loc = resolve$4(root$3, name);
			var dir = dirname(loc);
			var file = basename$1(loc);
			path$19 = this.resolve(dir, file);
		}
		return path$19;
	};
	/**
	* Render with the given options.
	*
	* @param {object} options
	* @param {function} callback
	* @private
	*/
	View$1.prototype.render = function render(options, callback) {
		debug$3("render \"%s\"", this.path);
		this.engine(this.path, options, callback);
	};
	/**
	* Resolve the file within the given directory.
	*
	* @param {string} dir
	* @param {string} file
	* @private
	*/
	View$1.prototype.resolve = function resolve$6(dir, file) {
		var ext = this.ext;
		var path$19 = join$1(dir, file);
		var stat$4 = tryStat(path$19);
		if (stat$4 && stat$4.isFile()) return path$19;
		path$19 = join$1(dir, basename$1(file, ext), "index" + ext);
		stat$4 = tryStat(path$19);
		if (stat$4 && stat$4.isFile()) return path$19;
	};
	/**
	* Return a stat, maybe.
	*
	* @param {string} path
	* @return {fs.Stats}
	* @private
	*/
	function tryStat(path$19) {
		debug$3("stat \"%s\"", path$19);
		try {
			return fs$3.statSync(path$19);
		} catch (e) {
			return;
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js": ((exports, module) => {
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	var buffer = __require("buffer");
	var Buffer$4 = buffer.Buffer;
	function copyProps(src$1, dst) {
		for (var key$1 in src$1) dst[key$1] = src$1[key$1];
	}
	if (Buffer$4.from && Buffer$4.alloc && Buffer$4.allocUnsafe && Buffer$4.allocUnsafeSlow) module.exports = buffer;
	else {
		copyProps(buffer, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer$4(arg, encodingOrOffset, length);
	}
	SafeBuffer.prototype = Object.create(Buffer$4.prototype);
	copyProps(Buffer$4, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer$4(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer$4(size);
		if (fill !== void 0) if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer$4(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer.SlowBuffer(size);
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/content-disposition@0.5.4/node_modules/content-disposition/index.js
var require_content_disposition = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/content-disposition@0.5.4/node_modules/content-disposition/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = contentDisposition$2;
	module.exports.parse = parse$4;
	/**
	* Module dependencies.
	* @private
	*/
	var basename = __require("path").basename;
	var Buffer$3 = require_safe_buffer().Buffer;
	/**
	* RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
	* @private
	*/
	var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
	/**
	* RegExp to match percent encoding escape.
	* @private
	*/
	var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
	var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
	/**
	* RegExp to match non-latin1 characters.
	* @private
	*/
	var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
	/**
	* RegExp to match quoted-pair in RFC 2616
	*
	* quoted-pair = "\" CHAR
	* CHAR        = <any US-ASCII character (octets 0 - 127)>
	* @private
	*/
	var QESC_REGEXP = /\\([\u0000-\u007f])/g;
	/**
	* RegExp to match chars that must be quoted-pair in RFC 2616
	* @private
	*/
	var QUOTE_REGEXP = /([\\"])/g;
	/**
	* RegExp for various RFC 2616 grammar
	*
	* parameter     = token "=" ( token | quoted-string )
	* token         = 1*<any CHAR except CTLs or separators>
	* separators    = "(" | ")" | "<" | ">" | "@"
	*               | "," | ";" | ":" | "\" | <">
	*               | "/" | "[" | "]" | "?" | "="
	*               | "{" | "}" | SP | HT
	* quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	* qdtext        = <any TEXT except <">>
	* quoted-pair   = "\" CHAR
	* CHAR          = <any US-ASCII character (octets 0 - 127)>
	* TEXT          = <any OCTET except CTLs, but including LWS>
	* LWS           = [CRLF] 1*( SP | HT )
	* CRLF          = CR LF
	* CR            = <US-ASCII CR, carriage return (13)>
	* LF            = <US-ASCII LF, linefeed (10)>
	* SP            = <US-ASCII SP, space (32)>
	* HT            = <US-ASCII HT, horizontal-tab (9)>
	* CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	* OCTET         = <any 8-bit sequence of data>
	* @private
	*/
	var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
	var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
	var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
	/**
	* RegExp for various RFC 5987 grammar
	*
	* ext-value     = charset  "'" [ language ] "'" value-chars
	* charset       = "UTF-8" / "ISO-8859-1" / mime-charset
	* mime-charset  = 1*mime-charsetc
	* mime-charsetc = ALPHA / DIGIT
	*               / "!" / "#" / "$" / "%" / "&"
	*               / "+" / "-" / "^" / "_" / "`"
	*               / "{" / "}" / "~"
	* language      = ( 2*3ALPHA [ extlang ] )
	*               / 4ALPHA
	*               / 5*8ALPHA
	* extlang       = *3( "-" 3ALPHA )
	* value-chars   = *( pct-encoded / attr-char )
	* pct-encoded   = "%" HEXDIG HEXDIG
	* attr-char     = ALPHA / DIGIT
	*               / "!" / "#" / "$" / "&" / "+" / "-" / "."
	*               / "^" / "_" / "`" / "|" / "~"
	* @private
	*/
	var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
	/**
	* RegExp for various RFC 6266 grammar
	*
	* disposition-type = "inline" | "attachment" | disp-ext-type
	* disp-ext-type    = token
	* disposition-parm = filename-parm | disp-ext-parm
	* filename-parm    = "filename" "=" value
	*                  | "filename*" "=" ext-value
	* disp-ext-parm    = token "=" value
	*                  | ext-token "=" ext-value
	* ext-token        = <the characters in token, followed by "*">
	* @private
	*/
	var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
	/**
	* Create an attachment Content-Disposition header.
	*
	* @param {string} [filename]
	* @param {object} [options]
	* @param {string} [options.type=attachment]
	* @param {string|boolean} [options.fallback=true]
	* @return {string}
	* @public
	*/
	function contentDisposition$2(filename, options) {
		var opts = options || {};
		return format(new ContentDisposition(opts.type || "attachment", createparams(filename, opts.fallback)));
	}
	/**
	* Create parameters object from filename and fallback.
	*
	* @param {string} [filename]
	* @param {string|boolean} [fallback=true]
	* @return {object}
	* @private
	*/
	function createparams(filename, fallback) {
		if (filename === void 0) return;
		var params = {};
		if (typeof filename !== "string") throw new TypeError("filename must be a string");
		if (fallback === void 0) fallback = true;
		if (typeof fallback !== "string" && typeof fallback !== "boolean") throw new TypeError("fallback must be a string or boolean");
		if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) throw new TypeError("fallback must be ISO-8859-1 string");
		var name = basename(filename);
		var isQuotedString = TEXT_REGEXP.test(name);
		var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
		var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
		if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) params["filename*"] = name;
		if (isQuotedString || hasFallback) params.filename = hasFallback ? fallbackName : name;
		return params;
	}
	/**
	* Format object to Content-Disposition header.
	*
	* @param {object} obj
	* @param {string} obj.type
	* @param {object} [obj.parameters]
	* @return {string}
	* @private
	*/
	function format(obj) {
		var parameters = obj.parameters;
		var type = obj.type;
		if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) throw new TypeError("invalid type");
		var string = String(type).toLowerCase();
		if (parameters && typeof parameters === "object") {
			var param;
			var params = Object.keys(parameters).sort();
			for (var i$8 = 0; i$8 < params.length; i$8++) {
				param = params[i$8];
				var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
				string += "; " + param + "=" + val;
			}
		}
		return string;
	}
	/**
	* Decode a RFC 5987 field value (gracefully).
	*
	* @param {string} str
	* @return {string}
	* @private
	*/
	function decodefield(str) {
		var match$1 = EXT_VALUE_REGEXP.exec(str);
		if (!match$1) throw new TypeError("invalid extended field value");
		var charset$1 = match$1[1].toLowerCase();
		var encoded = match$1[2];
		var value;
		var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
		switch (charset$1) {
			case "iso-8859-1":
				value = getlatin1(binary);
				break;
			case "utf-8":
				value = Buffer$3.from(binary, "binary").toString("utf8");
				break;
			default: throw new TypeError("unsupported charset in extended field");
		}
		return value;
	}
	/**
	* Get ISO-8859-1 version of string.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function getlatin1(val) {
		return String(val).replace(NON_LATIN1_REGEXP, "?");
	}
	/**
	* Parse Content-Disposition header string.
	*
	* @param {string} string
	* @return {object}
	* @public
	*/
	function parse$4(string) {
		if (!string || typeof string !== "string") throw new TypeError("argument string is required");
		var match$1 = DISPOSITION_TYPE_REGEXP.exec(string);
		if (!match$1) throw new TypeError("invalid type format");
		var index$1 = match$1[0].length;
		var type = match$1[1].toLowerCase();
		var key$1;
		var names = [];
		var params = {};
		var value;
		index$1 = PARAM_REGEXP.lastIndex = match$1[0].substr(-1) === ";" ? index$1 - 1 : index$1;
		while (match$1 = PARAM_REGEXP.exec(string)) {
			if (match$1.index !== index$1) throw new TypeError("invalid parameter format");
			index$1 += match$1[0].length;
			key$1 = match$1[1].toLowerCase();
			value = match$1[2];
			if (names.indexOf(key$1) !== -1) throw new TypeError("invalid duplicate parameter");
			names.push(key$1);
			if (key$1.indexOf("*") + 1 === key$1.length) {
				key$1 = key$1.slice(0, -1);
				value = decodefield(value);
				params[key$1] = value;
				continue;
			}
			if (typeof params[key$1] === "string") continue;
			if (value[0] === "\"") value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
			params[key$1] = value;
		}
		if (index$1 !== -1 && index$1 !== string.length) throw new TypeError("invalid parameter format");
		return new ContentDisposition(type, params);
	}
	/**
	* Percent decode a single character.
	*
	* @param {string} str
	* @param {string} hex
	* @return {string}
	* @private
	*/
	function pdecode(str, hex$3) {
		return String.fromCharCode(parseInt(hex$3, 16));
	}
	/**
	* Percent encode a single character.
	*
	* @param {string} char
	* @return {string}
	* @private
	*/
	function pencode(char) {
		return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
	}
	/**
	* Quote a string for HTTP.
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function qstring(val) {
		return "\"" + String(val).replace(QUOTE_REGEXP, "\\$1") + "\"";
	}
	/**
	* Encode a Unicode string for HTTP (RFC 5987).
	*
	* @param {string} val
	* @return {string}
	* @private
	*/
	function ustring(val) {
		var str = String(val);
		return "UTF-8''" + encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
	}
	/**
	* Class for parsed Content-Disposition header for v8 optimization
	*
	* @public
	* @param {string} type
	* @param {object} parameters
	* @constructor
	*/
	function ContentDisposition(type, parameters) {
		this.type = type;
		this.parameters = parameters;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/encodeurl@1.0.2/node_modules/encodeurl/index.js
var require_encodeurl = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/encodeurl@1.0.2/node_modules/encodeurl/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = encodeUrl$3;
	/**
	* RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
	* and including invalid escape sequences.
	* @private
	*/
	var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
	/**
	* RegExp to match unmatched surrogate pair.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
	/**
	* String to replace unmatched surrogate pair with.
	* @private
	*/
	var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
	/**
	* Encode a URL to a percent-encoded form, excluding already-encoded sequences.
	*
	* This function will take an already-encoded URL and encode all the non-URL
	* code points. This function will not encode the "%" character unless it is
	* not part of a valid sequence (`%20` will be left as-is, but `%foo` will
	* be encoded as `%25foo`).
	*
	* This encode is meant to be "safe" and does not throw errors. It will try as
	* hard as it can to properly encode the given URL, including replacing any raw,
	* unpaired surrogate pairs with the Unicode replacement character prior to
	* encoding.
	*
	* @param {string} url
	* @return {string}
	* @public
	*/
	function encodeUrl$3(url$6) {
		return String(url$6).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js
var require_etag = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = etag$2;
	/**
	* Module dependencies.
	* @private
	*/
	var crypto$1 = __require("crypto");
	var Stats = __require("fs").Stats;
	/**
	* Module variables.
	* @private
	*/
	var toString$2 = Object.prototype.toString;
	/**
	* Generate an entity tag.
	*
	* @param {Buffer|string} entity
	* @return {string}
	* @private
	*/
	function entitytag(entity) {
		if (entity.length === 0) return "\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"";
		var hash = crypto$1.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
		return "\"" + (typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length).toString(16) + "-" + hash + "\"";
	}
	/**
	* Create a simple ETag.
	*
	* @param {string|Buffer|Stats} entity
	* @param {object} [options]
	* @param {boolean} [options.weak]
	* @return {String}
	* @public
	*/
	function etag$2(entity, options) {
		if (entity == null) throw new TypeError("argument entity is required");
		var isStats = isstats(entity);
		var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
		if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
		var tag = isStats ? stattag(entity) : entitytag(entity);
		return weak ? "W/" + tag : tag;
	}
	/**
	* Determine if object is a Stats object.
	*
	* @param {object} obj
	* @return {boolean}
	* @api private
	*/
	function isstats(obj) {
		if (typeof Stats === "function" && obj instanceof Stats) return true;
		return obj && typeof obj === "object" && "ctime" in obj && toString$2.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString$2.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
	}
	/**
	* Generate a tag for a stat.
	*
	* @param {object} stat
	* @return {string}
	* @private
	*/
	function stattag(stat$4) {
		var mtime = stat$4.mtime.getTime().toString(16);
		return "\"" + stat$4.size.toString(16) + "-" + mtime + "\"";
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js
var require_fresh = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js": ((exports, module) => {
	/**
	* RegExp to check for no-cache token in Cache-Control.
	* @private
	*/
	var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = fresh$2;
	/**
	* Check freshness of the response using request and response headers.
	*
	* @param {Object} reqHeaders
	* @param {Object} resHeaders
	* @return {Boolean}
	* @public
	*/
	function fresh$2(reqHeaders, resHeaders) {
		var modifiedSince = reqHeaders["if-modified-since"];
		var noneMatch = reqHeaders["if-none-match"];
		if (!modifiedSince && !noneMatch) return false;
		var cacheControl = reqHeaders["cache-control"];
		if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) return false;
		if (noneMatch && noneMatch !== "*") {
			var etag$3 = resHeaders["etag"];
			if (!etag$3) return false;
			var etagStale = true;
			var matches = parseTokenList$1(noneMatch);
			for (var i$8 = 0; i$8 < matches.length; i$8++) {
				var match$1 = matches[i$8];
				if (match$1 === etag$3 || match$1 === "W/" + etag$3 || "W/" + match$1 === etag$3) {
					etagStale = false;
					break;
				}
			}
			if (etagStale) return false;
		}
		if (modifiedSince) {
			var lastModified = resHeaders["last-modified"];
			if (!lastModified || !(parseHttpDate$1(lastModified) <= parseHttpDate$1(modifiedSince))) return false;
		}
		return true;
	}
	/**
	* Parse an HTTP Date into a number.
	*
	* @param {string} date
	* @private
	*/
	function parseHttpDate$1(date) {
		var timestamp$1 = date && Date.parse(date);
		// istanbul ignore next: guard against date.js Date.parse patching
		return typeof timestamp$1 === "number" ? timestamp$1 : NaN;
	}
	/**
	* Parse a HTTP token list.
	*
	* @param {string} str
	* @private
	*/
	function parseTokenList$1(str) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i$8 = 0, len$1 = str.length; i$8 < len$1; i$8++) switch (str.charCodeAt(i$8)) {
			case 32:
				if (start === end) start = end = i$8 + 1;
				break;
			case 44:
				list.push(str.substring(start, end));
				start = end = i$8 + 1;
				break;
			default:
				end = i$8 + 1;
				break;
		}
		list.push(str.substring(start, end));
		return list;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime@1.6.0/node_modules/mime/types.json
var require_types = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mime@1.6.0/node_modules/mime/types.json": ((exports, module) => {
	module.exports = {
		"application/andrew-inset": ["ez"],
		"application/applixware": ["aw"],
		"application/atom+xml": ["atom"],
		"application/atomcat+xml": ["atomcat"],
		"application/atomsvc+xml": ["atomsvc"],
		"application/bdoc": ["bdoc"],
		"application/ccxml+xml": ["ccxml"],
		"application/cdmi-capability": ["cdmia"],
		"application/cdmi-container": ["cdmic"],
		"application/cdmi-domain": ["cdmid"],
		"application/cdmi-object": ["cdmio"],
		"application/cdmi-queue": ["cdmiq"],
		"application/cu-seeme": ["cu"],
		"application/dash+xml": ["mpd"],
		"application/davmount+xml": ["davmount"],
		"application/docbook+xml": ["dbk"],
		"application/dssc+der": ["dssc"],
		"application/dssc+xml": ["xdssc"],
		"application/ecmascript": ["ecma"],
		"application/emma+xml": ["emma"],
		"application/epub+zip": ["epub"],
		"application/exi": ["exi"],
		"application/font-tdpfr": ["pfr"],
		"application/font-woff": [],
		"application/font-woff2": [],
		"application/geo+json": ["geojson"],
		"application/gml+xml": ["gml"],
		"application/gpx+xml": ["gpx"],
		"application/gxf": ["gxf"],
		"application/gzip": ["gz"],
		"application/hyperstudio": ["stk"],
		"application/inkml+xml": ["ink", "inkml"],
		"application/ipfix": ["ipfix"],
		"application/java-archive": [
			"jar",
			"war",
			"ear"
		],
		"application/java-serialized-object": ["ser"],
		"application/java-vm": ["class"],
		"application/javascript": ["js", "mjs"],
		"application/json": ["json", "map"],
		"application/json5": ["json5"],
		"application/jsonml+json": ["jsonml"],
		"application/ld+json": ["jsonld"],
		"application/lost+xml": ["lostxml"],
		"application/mac-binhex40": ["hqx"],
		"application/mac-compactpro": ["cpt"],
		"application/mads+xml": ["mads"],
		"application/manifest+json": ["webmanifest"],
		"application/marc": ["mrc"],
		"application/marcxml+xml": ["mrcx"],
		"application/mathematica": [
			"ma",
			"nb",
			"mb"
		],
		"application/mathml+xml": ["mathml"],
		"application/mbox": ["mbox"],
		"application/mediaservercontrol+xml": ["mscml"],
		"application/metalink+xml": ["metalink"],
		"application/metalink4+xml": ["meta4"],
		"application/mets+xml": ["mets"],
		"application/mods+xml": ["mods"],
		"application/mp21": ["m21", "mp21"],
		"application/mp4": ["mp4s", "m4p"],
		"application/msword": ["doc", "dot"],
		"application/mxf": ["mxf"],
		"application/octet-stream": [
			"bin",
			"dms",
			"lrf",
			"mar",
			"so",
			"dist",
			"distz",
			"pkg",
			"bpk",
			"dump",
			"elc",
			"deploy",
			"exe",
			"dll",
			"deb",
			"dmg",
			"iso",
			"img",
			"msi",
			"msp",
			"msm",
			"buffer"
		],
		"application/oda": ["oda"],
		"application/oebps-package+xml": ["opf"],
		"application/ogg": ["ogx"],
		"application/omdoc+xml": ["omdoc"],
		"application/onenote": [
			"onetoc",
			"onetoc2",
			"onetmp",
			"onepkg"
		],
		"application/oxps": ["oxps"],
		"application/patch-ops-error+xml": ["xer"],
		"application/pdf": ["pdf"],
		"application/pgp-encrypted": ["pgp"],
		"application/pgp-signature": ["asc", "sig"],
		"application/pics-rules": ["prf"],
		"application/pkcs10": ["p10"],
		"application/pkcs7-mime": ["p7m", "p7c"],
		"application/pkcs7-signature": ["p7s"],
		"application/pkcs8": ["p8"],
		"application/pkix-attr-cert": ["ac"],
		"application/pkix-cert": ["cer"],
		"application/pkix-crl": ["crl"],
		"application/pkix-pkipath": ["pkipath"],
		"application/pkixcmp": ["pki"],
		"application/pls+xml": ["pls"],
		"application/postscript": [
			"ai",
			"eps",
			"ps"
		],
		"application/prs.cww": ["cww"],
		"application/pskc+xml": ["pskcxml"],
		"application/raml+yaml": ["raml"],
		"application/rdf+xml": ["rdf"],
		"application/reginfo+xml": ["rif"],
		"application/relax-ng-compact-syntax": ["rnc"],
		"application/resource-lists+xml": ["rl"],
		"application/resource-lists-diff+xml": ["rld"],
		"application/rls-services+xml": ["rs"],
		"application/rpki-ghostbusters": ["gbr"],
		"application/rpki-manifest": ["mft"],
		"application/rpki-roa": ["roa"],
		"application/rsd+xml": ["rsd"],
		"application/rss+xml": ["rss"],
		"application/rtf": ["rtf"],
		"application/sbml+xml": ["sbml"],
		"application/scvp-cv-request": ["scq"],
		"application/scvp-cv-response": ["scs"],
		"application/scvp-vp-request": ["spq"],
		"application/scvp-vp-response": ["spp"],
		"application/sdp": ["sdp"],
		"application/set-payment-initiation": ["setpay"],
		"application/set-registration-initiation": ["setreg"],
		"application/shf+xml": ["shf"],
		"application/smil+xml": ["smi", "smil"],
		"application/sparql-query": ["rq"],
		"application/sparql-results+xml": ["srx"],
		"application/srgs": ["gram"],
		"application/srgs+xml": ["grxml"],
		"application/sru+xml": ["sru"],
		"application/ssdl+xml": ["ssdl"],
		"application/ssml+xml": ["ssml"],
		"application/tei+xml": ["tei", "teicorpus"],
		"application/thraud+xml": ["tfi"],
		"application/timestamped-data": ["tsd"],
		"application/vnd.3gpp.pic-bw-large": ["plb"],
		"application/vnd.3gpp.pic-bw-small": ["psb"],
		"application/vnd.3gpp.pic-bw-var": ["pvb"],
		"application/vnd.3gpp2.tcap": ["tcap"],
		"application/vnd.3m.post-it-notes": ["pwn"],
		"application/vnd.accpac.simply.aso": ["aso"],
		"application/vnd.accpac.simply.imp": ["imp"],
		"application/vnd.acucobol": ["acu"],
		"application/vnd.acucorp": ["atc", "acutc"],
		"application/vnd.adobe.air-application-installer-package+zip": ["air"],
		"application/vnd.adobe.formscentral.fcdt": ["fcdt"],
		"application/vnd.adobe.fxp": ["fxp", "fxpl"],
		"application/vnd.adobe.xdp+xml": ["xdp"],
		"application/vnd.adobe.xfdf": ["xfdf"],
		"application/vnd.ahead.space": ["ahead"],
		"application/vnd.airzip.filesecure.azf": ["azf"],
		"application/vnd.airzip.filesecure.azs": ["azs"],
		"application/vnd.amazon.ebook": ["azw"],
		"application/vnd.americandynamics.acc": ["acc"],
		"application/vnd.amiga.ami": ["ami"],
		"application/vnd.android.package-archive": ["apk"],
		"application/vnd.anser-web-certificate-issue-initiation": ["cii"],
		"application/vnd.anser-web-funds-transfer-initiation": ["fti"],
		"application/vnd.antix.game-component": ["atx"],
		"application/vnd.apple.installer+xml": ["mpkg"],
		"application/vnd.apple.mpegurl": ["m3u8"],
		"application/vnd.apple.pkpass": ["pkpass"],
		"application/vnd.aristanetworks.swi": ["swi"],
		"application/vnd.astraea-software.iota": ["iota"],
		"application/vnd.audiograph": ["aep"],
		"application/vnd.blueice.multipass": ["mpm"],
		"application/vnd.bmi": ["bmi"],
		"application/vnd.businessobjects": ["rep"],
		"application/vnd.chemdraw+xml": ["cdxml"],
		"application/vnd.chipnuts.karaoke-mmd": ["mmd"],
		"application/vnd.cinderella": ["cdy"],
		"application/vnd.claymore": ["cla"],
		"application/vnd.cloanto.rp9": ["rp9"],
		"application/vnd.clonk.c4group": [
			"c4g",
			"c4d",
			"c4f",
			"c4p",
			"c4u"
		],
		"application/vnd.cluetrust.cartomobile-config": ["c11amc"],
		"application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
		"application/vnd.commonspace": ["csp"],
		"application/vnd.contact.cmsg": ["cdbcmsg"],
		"application/vnd.cosmocaller": ["cmc"],
		"application/vnd.crick.clicker": ["clkx"],
		"application/vnd.crick.clicker.keyboard": ["clkk"],
		"application/vnd.crick.clicker.palette": ["clkp"],
		"application/vnd.crick.clicker.template": ["clkt"],
		"application/vnd.crick.clicker.wordbank": ["clkw"],
		"application/vnd.criticaltools.wbs+xml": ["wbs"],
		"application/vnd.ctc-posml": ["pml"],
		"application/vnd.cups-ppd": ["ppd"],
		"application/vnd.curl.car": ["car"],
		"application/vnd.curl.pcurl": ["pcurl"],
		"application/vnd.dart": ["dart"],
		"application/vnd.data-vision.rdz": ["rdz"],
		"application/vnd.dece.data": [
			"uvf",
			"uvvf",
			"uvd",
			"uvvd"
		],
		"application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
		"application/vnd.dece.unspecified": ["uvx", "uvvx"],
		"application/vnd.dece.zip": ["uvz", "uvvz"],
		"application/vnd.denovo.fcselayout-link": ["fe_launch"],
		"application/vnd.dna": ["dna"],
		"application/vnd.dolby.mlp": ["mlp"],
		"application/vnd.dpgraph": ["dpg"],
		"application/vnd.dreamfactory": ["dfac"],
		"application/vnd.ds-keypoint": ["kpxx"],
		"application/vnd.dvb.ait": ["ait"],
		"application/vnd.dvb.service": ["svc"],
		"application/vnd.dynageo": ["geo"],
		"application/vnd.ecowin.chart": ["mag"],
		"application/vnd.enliven": ["nml"],
		"application/vnd.epson.esf": ["esf"],
		"application/vnd.epson.msf": ["msf"],
		"application/vnd.epson.quickanime": ["qam"],
		"application/vnd.epson.salt": ["slt"],
		"application/vnd.epson.ssf": ["ssf"],
		"application/vnd.eszigno3+xml": ["es3", "et3"],
		"application/vnd.ezpix-album": ["ez2"],
		"application/vnd.ezpix-package": ["ez3"],
		"application/vnd.fdf": ["fdf"],
		"application/vnd.fdsn.mseed": ["mseed"],
		"application/vnd.fdsn.seed": ["seed", "dataless"],
		"application/vnd.flographit": ["gph"],
		"application/vnd.fluxtime.clip": ["ftc"],
		"application/vnd.framemaker": [
			"fm",
			"frame",
			"maker",
			"book"
		],
		"application/vnd.frogans.fnc": ["fnc"],
		"application/vnd.frogans.ltf": ["ltf"],
		"application/vnd.fsc.weblaunch": ["fsc"],
		"application/vnd.fujitsu.oasys": ["oas"],
		"application/vnd.fujitsu.oasys2": ["oa2"],
		"application/vnd.fujitsu.oasys3": ["oa3"],
		"application/vnd.fujitsu.oasysgp": ["fg5"],
		"application/vnd.fujitsu.oasysprs": ["bh2"],
		"application/vnd.fujixerox.ddd": ["ddd"],
		"application/vnd.fujixerox.docuworks": ["xdw"],
		"application/vnd.fujixerox.docuworks.binder": ["xbd"],
		"application/vnd.fuzzysheet": ["fzs"],
		"application/vnd.genomatix.tuxedo": ["txd"],
		"application/vnd.geogebra.file": ["ggb"],
		"application/vnd.geogebra.tool": ["ggt"],
		"application/vnd.geometry-explorer": ["gex", "gre"],
		"application/vnd.geonext": ["gxt"],
		"application/vnd.geoplan": ["g2w"],
		"application/vnd.geospace": ["g3w"],
		"application/vnd.gmx": ["gmx"],
		"application/vnd.google-apps.document": ["gdoc"],
		"application/vnd.google-apps.presentation": ["gslides"],
		"application/vnd.google-apps.spreadsheet": ["gsheet"],
		"application/vnd.google-earth.kml+xml": ["kml"],
		"application/vnd.google-earth.kmz": ["kmz"],
		"application/vnd.grafeq": ["gqf", "gqs"],
		"application/vnd.groove-account": ["gac"],
		"application/vnd.groove-help": ["ghf"],
		"application/vnd.groove-identity-message": ["gim"],
		"application/vnd.groove-injector": ["grv"],
		"application/vnd.groove-tool-message": ["gtm"],
		"application/vnd.groove-tool-template": ["tpl"],
		"application/vnd.groove-vcard": ["vcg"],
		"application/vnd.hal+xml": ["hal"],
		"application/vnd.handheld-entertainment+xml": ["zmm"],
		"application/vnd.hbci": ["hbci"],
		"application/vnd.hhe.lesson-player": ["les"],
		"application/vnd.hp-hpgl": ["hpgl"],
		"application/vnd.hp-hpid": ["hpid"],
		"application/vnd.hp-hps": ["hps"],
		"application/vnd.hp-jlyt": ["jlt"],
		"application/vnd.hp-pcl": ["pcl"],
		"application/vnd.hp-pclxl": ["pclxl"],
		"application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
		"application/vnd.ibm.minipay": ["mpy"],
		"application/vnd.ibm.modcap": [
			"afp",
			"listafp",
			"list3820"
		],
		"application/vnd.ibm.rights-management": ["irm"],
		"application/vnd.ibm.secure-container": ["sc"],
		"application/vnd.iccprofile": ["icc", "icm"],
		"application/vnd.igloader": ["igl"],
		"application/vnd.immervision-ivp": ["ivp"],
		"application/vnd.immervision-ivu": ["ivu"],
		"application/vnd.insors.igm": ["igm"],
		"application/vnd.intercon.formnet": ["xpw", "xpx"],
		"application/vnd.intergeo": ["i2g"],
		"application/vnd.intu.qbo": ["qbo"],
		"application/vnd.intu.qfx": ["qfx"],
		"application/vnd.ipunplugged.rcprofile": ["rcprofile"],
		"application/vnd.irepository.package+xml": ["irp"],
		"application/vnd.is-xpr": ["xpr"],
		"application/vnd.isac.fcs": ["fcs"],
		"application/vnd.jam": ["jam"],
		"application/vnd.jcp.javame.midlet-rms": ["rms"],
		"application/vnd.jisp": ["jisp"],
		"application/vnd.joost.joda-archive": ["joda"],
		"application/vnd.kahootz": ["ktz", "ktr"],
		"application/vnd.kde.karbon": ["karbon"],
		"application/vnd.kde.kchart": ["chrt"],
		"application/vnd.kde.kformula": ["kfo"],
		"application/vnd.kde.kivio": ["flw"],
		"application/vnd.kde.kontour": ["kon"],
		"application/vnd.kde.kpresenter": ["kpr", "kpt"],
		"application/vnd.kde.kspread": ["ksp"],
		"application/vnd.kde.kword": ["kwd", "kwt"],
		"application/vnd.kenameaapp": ["htke"],
		"application/vnd.kidspiration": ["kia"],
		"application/vnd.kinar": ["kne", "knp"],
		"application/vnd.koan": [
			"skp",
			"skd",
			"skt",
			"skm"
		],
		"application/vnd.kodak-descriptor": ["sse"],
		"application/vnd.las.las+xml": ["lasxml"],
		"application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
		"application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
		"application/vnd.lotus-1-2-3": ["123"],
		"application/vnd.lotus-approach": ["apr"],
		"application/vnd.lotus-freelance": ["pre"],
		"application/vnd.lotus-notes": ["nsf"],
		"application/vnd.lotus-organizer": ["org"],
		"application/vnd.lotus-screencam": ["scm"],
		"application/vnd.lotus-wordpro": ["lwp"],
		"application/vnd.macports.portpkg": ["portpkg"],
		"application/vnd.mcd": ["mcd"],
		"application/vnd.medcalcdata": ["mc1"],
		"application/vnd.mediastation.cdkey": ["cdkey"],
		"application/vnd.mfer": ["mwf"],
		"application/vnd.mfmp": ["mfm"],
		"application/vnd.micrografx.flo": ["flo"],
		"application/vnd.micrografx.igx": ["igx"],
		"application/vnd.mif": ["mif"],
		"application/vnd.mobius.daf": ["daf"],
		"application/vnd.mobius.dis": ["dis"],
		"application/vnd.mobius.mbk": ["mbk"],
		"application/vnd.mobius.mqy": ["mqy"],
		"application/vnd.mobius.msl": ["msl"],
		"application/vnd.mobius.plc": ["plc"],
		"application/vnd.mobius.txf": ["txf"],
		"application/vnd.mophun.application": ["mpn"],
		"application/vnd.mophun.certificate": ["mpc"],
		"application/vnd.mozilla.xul+xml": ["xul"],
		"application/vnd.ms-artgalry": ["cil"],
		"application/vnd.ms-cab-compressed": ["cab"],
		"application/vnd.ms-excel": [
			"xls",
			"xlm",
			"xla",
			"xlc",
			"xlt",
			"xlw"
		],
		"application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
		"application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
		"application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
		"application/vnd.ms-fontobject": ["eot"],
		"application/vnd.ms-htmlhelp": ["chm"],
		"application/vnd.ms-ims": ["ims"],
		"application/vnd.ms-lrm": ["lrm"],
		"application/vnd.ms-officetheme": ["thmx"],
		"application/vnd.ms-outlook": ["msg"],
		"application/vnd.ms-pki.seccat": ["cat"],
		"application/vnd.ms-pki.stl": ["stl"],
		"application/vnd.ms-powerpoint": [
			"ppt",
			"pps",
			"pot"
		],
		"application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
		"application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
		"application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
		"application/vnd.ms-project": ["mpp", "mpt"],
		"application/vnd.ms-word.document.macroenabled.12": ["docm"],
		"application/vnd.ms-word.template.macroenabled.12": ["dotm"],
		"application/vnd.ms-works": [
			"wps",
			"wks",
			"wcm",
			"wdb"
		],
		"application/vnd.ms-wpl": ["wpl"],
		"application/vnd.ms-xpsdocument": ["xps"],
		"application/vnd.mseq": ["mseq"],
		"application/vnd.musician": ["mus"],
		"application/vnd.muvee.style": ["msty"],
		"application/vnd.mynfc": ["taglet"],
		"application/vnd.neurolanguage.nlu": ["nlu"],
		"application/vnd.nitf": ["ntf", "nitf"],
		"application/vnd.noblenet-directory": ["nnd"],
		"application/vnd.noblenet-sealer": ["nns"],
		"application/vnd.noblenet-web": ["nnw"],
		"application/vnd.nokia.n-gage.data": ["ngdat"],
		"application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
		"application/vnd.nokia.radio-preset": ["rpst"],
		"application/vnd.nokia.radio-presets": ["rpss"],
		"application/vnd.novadigm.edm": ["edm"],
		"application/vnd.novadigm.edx": ["edx"],
		"application/vnd.novadigm.ext": ["ext"],
		"application/vnd.oasis.opendocument.chart": ["odc"],
		"application/vnd.oasis.opendocument.chart-template": ["otc"],
		"application/vnd.oasis.opendocument.database": ["odb"],
		"application/vnd.oasis.opendocument.formula": ["odf"],
		"application/vnd.oasis.opendocument.formula-template": ["odft"],
		"application/vnd.oasis.opendocument.graphics": ["odg"],
		"application/vnd.oasis.opendocument.graphics-template": ["otg"],
		"application/vnd.oasis.opendocument.image": ["odi"],
		"application/vnd.oasis.opendocument.image-template": ["oti"],
		"application/vnd.oasis.opendocument.presentation": ["odp"],
		"application/vnd.oasis.opendocument.presentation-template": ["otp"],
		"application/vnd.oasis.opendocument.spreadsheet": ["ods"],
		"application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
		"application/vnd.oasis.opendocument.text": ["odt"],
		"application/vnd.oasis.opendocument.text-master": ["odm"],
		"application/vnd.oasis.opendocument.text-template": ["ott"],
		"application/vnd.oasis.opendocument.text-web": ["oth"],
		"application/vnd.olpc-sugar": ["xo"],
		"application/vnd.oma.dd2+xml": ["dd2"],
		"application/vnd.openofficeorg.extension": ["oxt"],
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
		"application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
		"application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
		"application/vnd.osgeo.mapguide.package": ["mgp"],
		"application/vnd.osgi.dp": ["dp"],
		"application/vnd.osgi.subsystem": ["esa"],
		"application/vnd.palm": [
			"pdb",
			"pqa",
			"oprc"
		],
		"application/vnd.pawaafile": ["paw"],
		"application/vnd.pg.format": ["str"],
		"application/vnd.pg.osasli": ["ei6"],
		"application/vnd.picsel": ["efif"],
		"application/vnd.pmi.widget": ["wg"],
		"application/vnd.pocketlearn": ["plf"],
		"application/vnd.powerbuilder6": ["pbd"],
		"application/vnd.previewsystems.box": ["box"],
		"application/vnd.proteus.magazine": ["mgz"],
		"application/vnd.publishare-delta-tree": ["qps"],
		"application/vnd.pvi.ptid1": ["ptid"],
		"application/vnd.quark.quarkxpress": [
			"qxd",
			"qxt",
			"qwd",
			"qwt",
			"qxl",
			"qxb"
		],
		"application/vnd.realvnc.bed": ["bed"],
		"application/vnd.recordare.musicxml": ["mxl"],
		"application/vnd.recordare.musicxml+xml": ["musicxml"],
		"application/vnd.rig.cryptonote": ["cryptonote"],
		"application/vnd.rim.cod": ["cod"],
		"application/vnd.rn-realmedia": ["rm"],
		"application/vnd.rn-realmedia-vbr": ["rmvb"],
		"application/vnd.route66.link66+xml": ["link66"],
		"application/vnd.sailingtracker.track": ["st"],
		"application/vnd.seemail": ["see"],
		"application/vnd.sema": ["sema"],
		"application/vnd.semd": ["semd"],
		"application/vnd.semf": ["semf"],
		"application/vnd.shana.informed.formdata": ["ifm"],
		"application/vnd.shana.informed.formtemplate": ["itp"],
		"application/vnd.shana.informed.interchange": ["iif"],
		"application/vnd.shana.informed.package": ["ipk"],
		"application/vnd.simtech-mindmapper": ["twd", "twds"],
		"application/vnd.smaf": ["mmf"],
		"application/vnd.smart.teacher": ["teacher"],
		"application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
		"application/vnd.spotfire.dxp": ["dxp"],
		"application/vnd.spotfire.sfs": ["sfs"],
		"application/vnd.stardivision.calc": ["sdc"],
		"application/vnd.stardivision.draw": ["sda"],
		"application/vnd.stardivision.impress": ["sdd"],
		"application/vnd.stardivision.math": ["smf"],
		"application/vnd.stardivision.writer": ["sdw", "vor"],
		"application/vnd.stardivision.writer-global": ["sgl"],
		"application/vnd.stepmania.package": ["smzip"],
		"application/vnd.stepmania.stepchart": ["sm"],
		"application/vnd.sun.wadl+xml": ["wadl"],
		"application/vnd.sun.xml.calc": ["sxc"],
		"application/vnd.sun.xml.calc.template": ["stc"],
		"application/vnd.sun.xml.draw": ["sxd"],
		"application/vnd.sun.xml.draw.template": ["std"],
		"application/vnd.sun.xml.impress": ["sxi"],
		"application/vnd.sun.xml.impress.template": ["sti"],
		"application/vnd.sun.xml.math": ["sxm"],
		"application/vnd.sun.xml.writer": ["sxw"],
		"application/vnd.sun.xml.writer.global": ["sxg"],
		"application/vnd.sun.xml.writer.template": ["stw"],
		"application/vnd.sus-calendar": ["sus", "susp"],
		"application/vnd.svd": ["svd"],
		"application/vnd.symbian.install": ["sis", "sisx"],
		"application/vnd.syncml+xml": ["xsm"],
		"application/vnd.syncml.dm+wbxml": ["bdm"],
		"application/vnd.syncml.dm+xml": ["xdm"],
		"application/vnd.tao.intent-module-archive": ["tao"],
		"application/vnd.tcpdump.pcap": [
			"pcap",
			"cap",
			"dmp"
		],
		"application/vnd.tmobile-livetv": ["tmo"],
		"application/vnd.trid.tpt": ["tpt"],
		"application/vnd.triscape.mxs": ["mxs"],
		"application/vnd.trueapp": ["tra"],
		"application/vnd.ufdl": ["ufd", "ufdl"],
		"application/vnd.uiq.theme": ["utz"],
		"application/vnd.umajin": ["umj"],
		"application/vnd.unity": ["unityweb"],
		"application/vnd.uoml+xml": ["uoml"],
		"application/vnd.vcx": ["vcx"],
		"application/vnd.visio": [
			"vsd",
			"vst",
			"vss",
			"vsw"
		],
		"application/vnd.visionary": ["vis"],
		"application/vnd.vsf": ["vsf"],
		"application/vnd.wap.wbxml": ["wbxml"],
		"application/vnd.wap.wmlc": ["wmlc"],
		"application/vnd.wap.wmlscriptc": ["wmlsc"],
		"application/vnd.webturbo": ["wtb"],
		"application/vnd.wolfram.player": ["nbp"],
		"application/vnd.wordperfect": ["wpd"],
		"application/vnd.wqd": ["wqd"],
		"application/vnd.wt.stf": ["stf"],
		"application/vnd.xara": ["xar"],
		"application/vnd.xfdl": ["xfdl"],
		"application/vnd.yamaha.hv-dic": ["hvd"],
		"application/vnd.yamaha.hv-script": ["hvs"],
		"application/vnd.yamaha.hv-voice": ["hvp"],
		"application/vnd.yamaha.openscoreformat": ["osf"],
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
		"application/vnd.yamaha.smaf-audio": ["saf"],
		"application/vnd.yamaha.smaf-phrase": ["spf"],
		"application/vnd.yellowriver-custom-menu": ["cmp"],
		"application/vnd.zul": ["zir", "zirz"],
		"application/vnd.zzazz.deck+xml": ["zaz"],
		"application/voicexml+xml": ["vxml"],
		"application/wasm": ["wasm"],
		"application/widget": ["wgt"],
		"application/winhlp": ["hlp"],
		"application/wsdl+xml": ["wsdl"],
		"application/wspolicy+xml": ["wspolicy"],
		"application/x-7z-compressed": ["7z"],
		"application/x-abiword": ["abw"],
		"application/x-ace-compressed": ["ace"],
		"application/x-apple-diskimage": [],
		"application/x-arj": ["arj"],
		"application/x-authorware-bin": [
			"aab",
			"x32",
			"u32",
			"vox"
		],
		"application/x-authorware-map": ["aam"],
		"application/x-authorware-seg": ["aas"],
		"application/x-bcpio": ["bcpio"],
		"application/x-bdoc": [],
		"application/x-bittorrent": ["torrent"],
		"application/x-blorb": ["blb", "blorb"],
		"application/x-bzip": ["bz"],
		"application/x-bzip2": ["bz2", "boz"],
		"application/x-cbr": [
			"cbr",
			"cba",
			"cbt",
			"cbz",
			"cb7"
		],
		"application/x-cdlink": ["vcd"],
		"application/x-cfs-compressed": ["cfs"],
		"application/x-chat": ["chat"],
		"application/x-chess-pgn": ["pgn"],
		"application/x-chrome-extension": ["crx"],
		"application/x-cocoa": ["cco"],
		"application/x-conference": ["nsc"],
		"application/x-cpio": ["cpio"],
		"application/x-csh": ["csh"],
		"application/x-debian-package": ["udeb"],
		"application/x-dgc-compressed": ["dgc"],
		"application/x-director": [
			"dir",
			"dcr",
			"dxr",
			"cst",
			"cct",
			"cxt",
			"w3d",
			"fgd",
			"swa"
		],
		"application/x-doom": ["wad"],
		"application/x-dtbncx+xml": ["ncx"],
		"application/x-dtbook+xml": ["dtb"],
		"application/x-dtbresource+xml": ["res"],
		"application/x-dvi": ["dvi"],
		"application/x-envoy": ["evy"],
		"application/x-eva": ["eva"],
		"application/x-font-bdf": ["bdf"],
		"application/x-font-ghostscript": ["gsf"],
		"application/x-font-linux-psf": ["psf"],
		"application/x-font-pcf": ["pcf"],
		"application/x-font-snf": ["snf"],
		"application/x-font-type1": [
			"pfa",
			"pfb",
			"pfm",
			"afm"
		],
		"application/x-freearc": ["arc"],
		"application/x-futuresplash": ["spl"],
		"application/x-gca-compressed": ["gca"],
		"application/x-glulx": ["ulx"],
		"application/x-gnumeric": ["gnumeric"],
		"application/x-gramps-xml": ["gramps"],
		"application/x-gtar": ["gtar"],
		"application/x-hdf": ["hdf"],
		"application/x-httpd-php": ["php"],
		"application/x-install-instructions": ["install"],
		"application/x-iso9660-image": [],
		"application/x-java-archive-diff": ["jardiff"],
		"application/x-java-jnlp-file": ["jnlp"],
		"application/x-latex": ["latex"],
		"application/x-lua-bytecode": ["luac"],
		"application/x-lzh-compressed": ["lzh", "lha"],
		"application/x-makeself": ["run"],
		"application/x-mie": ["mie"],
		"application/x-mobipocket-ebook": ["prc", "mobi"],
		"application/x-ms-application": ["application"],
		"application/x-ms-shortcut": ["lnk"],
		"application/x-ms-wmd": ["wmd"],
		"application/x-ms-wmz": ["wmz"],
		"application/x-ms-xbap": ["xbap"],
		"application/x-msaccess": ["mdb"],
		"application/x-msbinder": ["obd"],
		"application/x-mscardfile": ["crd"],
		"application/x-msclip": ["clp"],
		"application/x-msdos-program": [],
		"application/x-msdownload": ["com", "bat"],
		"application/x-msmediaview": [
			"mvb",
			"m13",
			"m14"
		],
		"application/x-msmetafile": [
			"wmf",
			"emf",
			"emz"
		],
		"application/x-msmoney": ["mny"],
		"application/x-mspublisher": ["pub"],
		"application/x-msschedule": ["scd"],
		"application/x-msterminal": ["trm"],
		"application/x-mswrite": ["wri"],
		"application/x-netcdf": ["nc", "cdf"],
		"application/x-ns-proxy-autoconfig": ["pac"],
		"application/x-nzb": ["nzb"],
		"application/x-perl": ["pl", "pm"],
		"application/x-pilot": [],
		"application/x-pkcs12": ["p12", "pfx"],
		"application/x-pkcs7-certificates": ["p7b", "spc"],
		"application/x-pkcs7-certreqresp": ["p7r"],
		"application/x-rar-compressed": ["rar"],
		"application/x-redhat-package-manager": ["rpm"],
		"application/x-research-info-systems": ["ris"],
		"application/x-sea": ["sea"],
		"application/x-sh": ["sh"],
		"application/x-shar": ["shar"],
		"application/x-shockwave-flash": ["swf"],
		"application/x-silverlight-app": ["xap"],
		"application/x-sql": ["sql"],
		"application/x-stuffit": ["sit"],
		"application/x-stuffitx": ["sitx"],
		"application/x-subrip": ["srt"],
		"application/x-sv4cpio": ["sv4cpio"],
		"application/x-sv4crc": ["sv4crc"],
		"application/x-t3vm-image": ["t3"],
		"application/x-tads": ["gam"],
		"application/x-tar": ["tar"],
		"application/x-tcl": ["tcl", "tk"],
		"application/x-tex": ["tex"],
		"application/x-tex-tfm": ["tfm"],
		"application/x-texinfo": ["texinfo", "texi"],
		"application/x-tgif": ["obj"],
		"application/x-ustar": ["ustar"],
		"application/x-virtualbox-hdd": ["hdd"],
		"application/x-virtualbox-ova": ["ova"],
		"application/x-virtualbox-ovf": ["ovf"],
		"application/x-virtualbox-vbox": ["vbox"],
		"application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
		"application/x-virtualbox-vdi": ["vdi"],
		"application/x-virtualbox-vhd": ["vhd"],
		"application/x-virtualbox-vmdk": ["vmdk"],
		"application/x-wais-source": ["src"],
		"application/x-web-app-manifest+json": ["webapp"],
		"application/x-x509-ca-cert": [
			"der",
			"crt",
			"pem"
		],
		"application/x-xfig": ["fig"],
		"application/x-xliff+xml": ["xlf"],
		"application/x-xpinstall": ["xpi"],
		"application/x-xz": ["xz"],
		"application/x-zmachine": [
			"z1",
			"z2",
			"z3",
			"z4",
			"z5",
			"z6",
			"z7",
			"z8"
		],
		"application/xaml+xml": ["xaml"],
		"application/xcap-diff+xml": ["xdf"],
		"application/xenc+xml": ["xenc"],
		"application/xhtml+xml": ["xhtml", "xht"],
		"application/xml": [
			"xml",
			"xsl",
			"xsd",
			"rng"
		],
		"application/xml-dtd": ["dtd"],
		"application/xop+xml": ["xop"],
		"application/xproc+xml": ["xpl"],
		"application/xslt+xml": ["xslt"],
		"application/xspf+xml": ["xspf"],
		"application/xv+xml": [
			"mxml",
			"xhvml",
			"xvml",
			"xvm"
		],
		"application/yang": ["yang"],
		"application/yin+xml": ["yin"],
		"application/zip": ["zip"],
		"audio/3gpp": [],
		"audio/adpcm": ["adp"],
		"audio/basic": ["au", "snd"],
		"audio/midi": [
			"mid",
			"midi",
			"kar",
			"rmi"
		],
		"audio/mp3": [],
		"audio/mp4": ["m4a", "mp4a"],
		"audio/mpeg": [
			"mpga",
			"mp2",
			"mp2a",
			"mp3",
			"m2a",
			"m3a"
		],
		"audio/ogg": [
			"oga",
			"ogg",
			"spx"
		],
		"audio/s3m": ["s3m"],
		"audio/silk": ["sil"],
		"audio/vnd.dece.audio": ["uva", "uvva"],
		"audio/vnd.digital-winds": ["eol"],
		"audio/vnd.dra": ["dra"],
		"audio/vnd.dts": ["dts"],
		"audio/vnd.dts.hd": ["dtshd"],
		"audio/vnd.lucent.voice": ["lvp"],
		"audio/vnd.ms-playready.media.pya": ["pya"],
		"audio/vnd.nuera.ecelp4800": ["ecelp4800"],
		"audio/vnd.nuera.ecelp7470": ["ecelp7470"],
		"audio/vnd.nuera.ecelp9600": ["ecelp9600"],
		"audio/vnd.rip": ["rip"],
		"audio/wav": ["wav"],
		"audio/wave": [],
		"audio/webm": ["weba"],
		"audio/x-aac": ["aac"],
		"audio/x-aiff": [
			"aif",
			"aiff",
			"aifc"
		],
		"audio/x-caf": ["caf"],
		"audio/x-flac": ["flac"],
		"audio/x-m4a": [],
		"audio/x-matroska": ["mka"],
		"audio/x-mpegurl": ["m3u"],
		"audio/x-ms-wax": ["wax"],
		"audio/x-ms-wma": ["wma"],
		"audio/x-pn-realaudio": ["ram", "ra"],
		"audio/x-pn-realaudio-plugin": ["rmp"],
		"audio/x-realaudio": [],
		"audio/x-wav": [],
		"audio/xm": ["xm"],
		"chemical/x-cdx": ["cdx"],
		"chemical/x-cif": ["cif"],
		"chemical/x-cmdf": ["cmdf"],
		"chemical/x-cml": ["cml"],
		"chemical/x-csml": ["csml"],
		"chemical/x-xyz": ["xyz"],
		"font/collection": ["ttc"],
		"font/otf": ["otf"],
		"font/ttf": ["ttf"],
		"font/woff": ["woff"],
		"font/woff2": ["woff2"],
		"image/apng": ["apng"],
		"image/bmp": ["bmp"],
		"image/cgm": ["cgm"],
		"image/g3fax": ["g3"],
		"image/gif": ["gif"],
		"image/ief": ["ief"],
		"image/jp2": ["jp2", "jpg2"],
		"image/jpeg": [
			"jpeg",
			"jpg",
			"jpe"
		],
		"image/jpm": ["jpm"],
		"image/jpx": ["jpx", "jpf"],
		"image/ktx": ["ktx"],
		"image/png": ["png"],
		"image/prs.btif": ["btif"],
		"image/sgi": ["sgi"],
		"image/svg+xml": ["svg", "svgz"],
		"image/tiff": ["tiff", "tif"],
		"image/vnd.adobe.photoshop": ["psd"],
		"image/vnd.dece.graphic": [
			"uvi",
			"uvvi",
			"uvg",
			"uvvg"
		],
		"image/vnd.djvu": ["djvu", "djv"],
		"image/vnd.dvb.subtitle": [],
		"image/vnd.dwg": ["dwg"],
		"image/vnd.dxf": ["dxf"],
		"image/vnd.fastbidsheet": ["fbs"],
		"image/vnd.fpx": ["fpx"],
		"image/vnd.fst": ["fst"],
		"image/vnd.fujixerox.edmics-mmr": ["mmr"],
		"image/vnd.fujixerox.edmics-rlc": ["rlc"],
		"image/vnd.ms-modi": ["mdi"],
		"image/vnd.ms-photo": ["wdp"],
		"image/vnd.net-fpx": ["npx"],
		"image/vnd.wap.wbmp": ["wbmp"],
		"image/vnd.xiff": ["xif"],
		"image/webp": ["webp"],
		"image/x-3ds": ["3ds"],
		"image/x-cmu-raster": ["ras"],
		"image/x-cmx": ["cmx"],
		"image/x-freehand": [
			"fh",
			"fhc",
			"fh4",
			"fh5",
			"fh7"
		],
		"image/x-icon": ["ico"],
		"image/x-jng": ["jng"],
		"image/x-mrsid-image": ["sid"],
		"image/x-ms-bmp": [],
		"image/x-pcx": ["pcx"],
		"image/x-pict": ["pic", "pct"],
		"image/x-portable-anymap": ["pnm"],
		"image/x-portable-bitmap": ["pbm"],
		"image/x-portable-graymap": ["pgm"],
		"image/x-portable-pixmap": ["ppm"],
		"image/x-rgb": ["rgb"],
		"image/x-tga": ["tga"],
		"image/x-xbitmap": ["xbm"],
		"image/x-xpixmap": ["xpm"],
		"image/x-xwindowdump": ["xwd"],
		"message/rfc822": ["eml", "mime"],
		"model/gltf+json": ["gltf"],
		"model/gltf-binary": ["glb"],
		"model/iges": ["igs", "iges"],
		"model/mesh": [
			"msh",
			"mesh",
			"silo"
		],
		"model/vnd.collada+xml": ["dae"],
		"model/vnd.dwf": ["dwf"],
		"model/vnd.gdl": ["gdl"],
		"model/vnd.gtw": ["gtw"],
		"model/vnd.mts": ["mts"],
		"model/vnd.vtu": ["vtu"],
		"model/vrml": ["wrl", "vrml"],
		"model/x3d+binary": ["x3db", "x3dbz"],
		"model/x3d+vrml": ["x3dv", "x3dvz"],
		"model/x3d+xml": ["x3d", "x3dz"],
		"text/cache-manifest": ["appcache", "manifest"],
		"text/calendar": ["ics", "ifb"],
		"text/coffeescript": ["coffee", "litcoffee"],
		"text/css": ["css"],
		"text/csv": ["csv"],
		"text/hjson": ["hjson"],
		"text/html": [
			"html",
			"htm",
			"shtml"
		],
		"text/jade": ["jade"],
		"text/jsx": ["jsx"],
		"text/less": ["less"],
		"text/markdown": ["markdown", "md"],
		"text/mathml": ["mml"],
		"text/n3": ["n3"],
		"text/plain": [
			"txt",
			"text",
			"conf",
			"def",
			"list",
			"log",
			"in",
			"ini"
		],
		"text/prs.lines.tag": ["dsc"],
		"text/richtext": ["rtx"],
		"text/rtf": [],
		"text/sgml": ["sgml", "sgm"],
		"text/slim": ["slim", "slm"],
		"text/stylus": ["stylus", "styl"],
		"text/tab-separated-values": ["tsv"],
		"text/troff": [
			"t",
			"tr",
			"roff",
			"man",
			"me",
			"ms"
		],
		"text/turtle": ["ttl"],
		"text/uri-list": [
			"uri",
			"uris",
			"urls"
		],
		"text/vcard": ["vcard"],
		"text/vnd.curl": ["curl"],
		"text/vnd.curl.dcurl": ["dcurl"],
		"text/vnd.curl.mcurl": ["mcurl"],
		"text/vnd.curl.scurl": ["scurl"],
		"text/vnd.dvb.subtitle": ["sub"],
		"text/vnd.fly": ["fly"],
		"text/vnd.fmi.flexstor": ["flx"],
		"text/vnd.graphviz": ["gv"],
		"text/vnd.in3d.3dml": ["3dml"],
		"text/vnd.in3d.spot": ["spot"],
		"text/vnd.sun.j2me.app-descriptor": ["jad"],
		"text/vnd.wap.wml": ["wml"],
		"text/vnd.wap.wmlscript": ["wmls"],
		"text/vtt": ["vtt"],
		"text/x-asm": ["s", "asm"],
		"text/x-c": [
			"c",
			"cc",
			"cxx",
			"cpp",
			"h",
			"hh",
			"dic"
		],
		"text/x-component": ["htc"],
		"text/x-fortran": [
			"f",
			"for",
			"f77",
			"f90"
		],
		"text/x-handlebars-template": ["hbs"],
		"text/x-java-source": ["java"],
		"text/x-lua": ["lua"],
		"text/x-markdown": ["mkd"],
		"text/x-nfo": ["nfo"],
		"text/x-opml": ["opml"],
		"text/x-org": [],
		"text/x-pascal": ["p", "pas"],
		"text/x-processing": ["pde"],
		"text/x-sass": ["sass"],
		"text/x-scss": ["scss"],
		"text/x-setext": ["etx"],
		"text/x-sfv": ["sfv"],
		"text/x-suse-ymp": ["ymp"],
		"text/x-uuencode": ["uu"],
		"text/x-vcalendar": ["vcs"],
		"text/x-vcard": ["vcf"],
		"text/xml": [],
		"text/yaml": ["yaml", "yml"],
		"video/3gpp": ["3gp", "3gpp"],
		"video/3gpp2": ["3g2"],
		"video/h261": ["h261"],
		"video/h263": ["h263"],
		"video/h264": ["h264"],
		"video/jpeg": ["jpgv"],
		"video/jpm": ["jpgm"],
		"video/mj2": ["mj2", "mjp2"],
		"video/mp2t": ["ts"],
		"video/mp4": [
			"mp4",
			"mp4v",
			"mpg4"
		],
		"video/mpeg": [
			"mpeg",
			"mpg",
			"mpe",
			"m1v",
			"m2v"
		],
		"video/ogg": ["ogv"],
		"video/quicktime": ["qt", "mov"],
		"video/vnd.dece.hd": ["uvh", "uvvh"],
		"video/vnd.dece.mobile": ["uvm", "uvvm"],
		"video/vnd.dece.pd": ["uvp", "uvvp"],
		"video/vnd.dece.sd": ["uvs", "uvvs"],
		"video/vnd.dece.video": ["uvv", "uvvv"],
		"video/vnd.dvb.file": ["dvb"],
		"video/vnd.fvt": ["fvt"],
		"video/vnd.mpegurl": ["mxu", "m4u"],
		"video/vnd.ms-playready.media.pyv": ["pyv"],
		"video/vnd.uvvu.mp4": ["uvu", "uvvu"],
		"video/vnd.vivo": ["viv"],
		"video/webm": ["webm"],
		"video/x-f4v": ["f4v"],
		"video/x-fli": ["fli"],
		"video/x-flv": ["flv"],
		"video/x-m4v": ["m4v"],
		"video/x-matroska": [
			"mkv",
			"mk3d",
			"mks"
		],
		"video/x-mng": ["mng"],
		"video/x-ms-asf": ["asf", "asx"],
		"video/x-ms-vob": ["vob"],
		"video/x-ms-wm": ["wm"],
		"video/x-ms-wmv": ["wmv"],
		"video/x-ms-wmx": ["wmx"],
		"video/x-ms-wvx": ["wvx"],
		"video/x-msvideo": ["avi"],
		"video/x-sgi-movie": ["movie"],
		"video/x-smv": ["smv"],
		"x-conference/x-cooltalk": ["ice"]
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime@1.6.0/node_modules/mime/mime.js
var require_mime = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mime@1.6.0/node_modules/mime/mime.js": ((exports, module) => {
	__require("path");
	var fs$2 = __require("fs");
	function Mime() {
		this.types = Object.create(null);
		this.extensions = Object.create(null);
	}
	/**
	* Define mimetype -> extension mappings.  Each key is a mime-type that maps
	* to an array of extensions associated with the type.  The first extension is
	* used as the default extension for the type.
	*
	* e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
	*
	* @param map (Object) type definitions
	*/
	Mime.prototype.define = function(map$2) {
		for (var type in map$2) {
			var exts = map$2[type];
			for (var i$8 = 0; i$8 < exts.length; i$8++) {
				if (process.env.DEBUG_MIME && this.types[exts[i$8]]) console.warn((this._loading || "define()").replace(/.*\//, ""), "changes \"" + exts[i$8] + "\" extension type from " + this.types[exts[i$8]] + " to " + type);
				this.types[exts[i$8]] = type;
			}
			if (!this.extensions[type]) this.extensions[type] = exts[0];
		}
	};
	/**
	* Load an Apache2-style ".types" file
	*
	* This may be called multiple times (it's expected).  Where files declare
	* overlapping types/extensions, the last file wins.
	*
	* @param file (String) path of file to load.
	*/
	Mime.prototype.load = function(file) {
		this._loading = file;
		var map$2 = {};
		fs$2.readFileSync(file, "ascii").split(/[\r\n]+/).forEach(function(line) {
			var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
			map$2[fields.shift()] = fields;
		});
		this.define(map$2);
		this._loading = null;
	};
	/**
	* Lookup a mime type based on extension
	*/
	Mime.prototype.lookup = function(path$19, fallback) {
		var ext = path$19.replace(/^.*[\.\/\\]/, "").toLowerCase();
		return this.types[ext] || fallback || this.default_type;
	};
	/**
	* Return file extension associated with a mime type
	*/
	Mime.prototype.extension = function(mimeType) {
		var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
		return this.extensions[type];
	};
	var mime$4 = new Mime();
	mime$4.define(require_types());
	mime$4.default_type = mime$4.lookup("bin");
	mime$4.Mime = Mime;
	/**
	* Lookup a charset based on mime type.
	*/
	mime$4.charsets = { lookup: function(mimeType, fallback) {
		return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
	} };
	module.exports = mime$4;
}) });

//#endregion
//#region ../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js
var require_range_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = rangeParser;
	/**
	* Parse "Range" header `str` relative to the given file `size`.
	*
	* @param {Number} size
	* @param {String} str
	* @param {Object} [options]
	* @return {Array}
	* @public
	*/
	function rangeParser(size, str, options) {
		if (typeof str !== "string") throw new TypeError("argument str must be a string");
		var index$1 = str.indexOf("=");
		if (index$1 === -1) return -2;
		var arr = str.slice(index$1 + 1).split(",");
		var ranges = [];
		ranges.type = str.slice(0, index$1);
		for (var i$8 = 0; i$8 < arr.length; i$8++) {
			var range = arr[i$8].split("-");
			var start = parseInt(range[0], 10);
			var end = parseInt(range[1], 10);
			if (isNaN(start)) {
				start = size - end;
				end = size - 1;
			} else if (isNaN(end)) end = size - 1;
			if (end > size - 1) end = size - 1;
			if (isNaN(start) || isNaN(end) || start > end || start < 0) continue;
			ranges.push({
				start,
				end
			});
		}
		if (ranges.length < 1) return -1;
		return options && options.combine ? combineRanges(ranges) : ranges;
	}
	/**
	* Combine overlapping & adjacent ranges.
	* @private
	*/
	function combineRanges(ranges) {
		var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
		for (var j$7 = 0, i$8 = 1; i$8 < ordered.length; i$8++) {
			var range = ordered[i$8];
			var current = ordered[j$7];
			if (range.start > current.end + 1) ordered[++j$7] = range;
			else if (range.end > current.end) {
				current.end = range.end;
				current.index = Math.min(current.index, range.index);
			}
		}
		ordered.length = j$7 + 1;
		var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
		combined.type = ranges.type;
		return combined;
	}
	/**
	* Map function to add index value to ranges.
	* @private
	*/
	function mapWithIndex(range, index$1) {
		return {
			start: range.start,
			end: range.end,
			index: index$1
		};
	}
	/**
	* Map function to remove index value from ranges.
	* @private
	*/
	function mapWithoutIndex(range) {
		return {
			start: range.start,
			end: range.end
		};
	}
	/**
	* Sort function to sort ranges by index.
	* @private
	*/
	function sortByRangeIndex(a, b) {
		return a.index - b.index;
	}
	/**
	* Sort function to sort ranges by start position.
	* @private
	*/
	function sortByRangeStart(a, b) {
		return a.start - b.start;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js
var require_send = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var createError$1 = require_http_errors();
	var debug$2 = require_src()("send");
	var deprecate$4 = require_depd()("send");
	var destroy = require_destroy();
	var encodeUrl$2 = require_encodeurl();
	var escapeHtml$2 = require_escape_html();
	var etag$1 = require_etag();
	var fresh$1 = require_fresh();
	var fs$1 = __require("fs");
	var mime$3 = require_mime();
	var ms = require_ms$1();
	var onFinished$1 = require_on_finished();
	var parseRange$1 = require_range_parser();
	var path$3 = __require("path");
	var statuses$1 = require_statuses();
	var Stream = __require("stream");
	var util = __require("util");
	/**
	* Path function references.
	* @private
	*/
	var extname$1 = path$3.extname;
	var join = path$3.join;
	var normalize = path$3.normalize;
	var resolve$3 = path$3.resolve;
	var sep = path$3.sep;
	/**
	* Regular expression for identifying a bytes Range header.
	* @private
	*/
	var BYTES_RANGE_REGEXP = /^ *bytes=/;
	/**
	* Maximum value allowed for the max age.
	* @private
	*/
	var MAX_MAXAGE = 3600 * 24 * 365 * 1e3;
	/**
	* Regular expression to match a path with a directory up component.
	* @private
	*/
	var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
	/**
	* Module exports.
	* @public
	*/
	module.exports = send$2;
	module.exports.mime = mime$3;
	/**
	* Return a `SendStream` for `req` and `path`.
	*
	* @param {object} req
	* @param {string} path
	* @param {object} [options]
	* @return {SendStream}
	* @public
	*/
	function send$2(req$2, path$19, options) {
		return new SendStream(req$2, path$19, options);
	}
	/**
	* Initialize a `SendStream` with the given `path`.
	*
	* @param {Request} req
	* @param {String} path
	* @param {object} [options]
	* @private
	*/
	function SendStream(req$2, path$19, options) {
		Stream.call(this);
		var opts = options || {};
		this.options = opts;
		this.path = path$19;
		this.req = req$2;
		this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
		this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
		this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
		this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
		if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") throw new TypeError("dotfiles option must be \"allow\", \"deny\", or \"ignore\"");
		this._hidden = Boolean(opts.hidden);
		if (opts.hidden !== void 0) deprecate$4("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
		if (opts.dotfiles === void 0) this._dotfiles = void 0;
		this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
		this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
		this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
		this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
		this._maxage = opts.maxAge || opts.maxage;
		this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
		this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
		this._root = opts.root ? resolve$3(opts.root) : null;
		if (!this._root && opts.from) this.from(opts.from);
	}
	/**
	* Inherits from `Stream`.
	*/
	util.inherits(SendStream, Stream);
	/**
	* Enable or disable etag generation.
	*
	* @param {Boolean} val
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.etag = deprecate$4.function(function etag$3(val) {
		this._etag = Boolean(val);
		debug$2("etag %s", this._etag);
		return this;
	}, "send.etag: pass etag as option");
	/**
	* Enable or disable "hidden" (dot) files.
	*
	* @param {Boolean} path
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.hidden = deprecate$4.function(function hidden(val) {
		this._hidden = Boolean(val);
		this._dotfiles = void 0;
		debug$2("hidden %s", this._hidden);
		return this;
	}, "send.hidden: use dotfiles option");
	/**
	* Set index `paths`, set to a falsy
	* value to disable index support.
	*
	* @param {String|Boolean|Array} paths
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.index = deprecate$4.function(function index$1(paths) {
		var index$2 = !paths ? [] : normalizeList(paths, "paths argument");
		debug$2("index %o", paths);
		this._index = index$2;
		return this;
	}, "send.index: pass index as option");
	/**
	* Set root `path`.
	*
	* @param {String} path
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.root = function root$3(path$19) {
		this._root = resolve$3(String(path$19));
		debug$2("root %s", this._root);
		return this;
	};
	SendStream.prototype.from = deprecate$4.function(SendStream.prototype.root, "send.from: pass root as option");
	SendStream.prototype.root = deprecate$4.function(SendStream.prototype.root, "send.root: pass root as option");
	/**
	* Set max-age to `maxAge`.
	*
	* @param {Number} maxAge
	* @return {SendStream}
	* @api public
	*/
	SendStream.prototype.maxage = deprecate$4.function(function maxage(maxAge) {
		this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
		this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
		debug$2("max-age %d", this._maxage);
		return this;
	}, "send.maxage: pass maxAge as option");
	/**
	* Emit error with `status`.
	*
	* @param {number} status
	* @param {Error} [err]
	* @private
	*/
	SendStream.prototype.error = function error(status$1, err) {
		if (hasListeners(this, "error")) return this.emit("error", createHttpError(status$1, err));
		var res$2 = this.res;
		var doc = createHtmlDocument$1("Error", escapeHtml$2(statuses$1.message[status$1] || String(status$1)));
		clearHeaders(res$2);
		if (err && err.headers) setHeaders(res$2, err.headers);
		res$2.statusCode = status$1;
		res$2.setHeader("Content-Type", "text/html; charset=UTF-8");
		res$2.setHeader("Content-Length", Buffer.byteLength(doc));
		res$2.setHeader("Content-Security-Policy", "default-src 'none'");
		res$2.setHeader("X-Content-Type-Options", "nosniff");
		res$2.end(doc);
	};
	/**
	* Check if the pathname ends with "/".
	*
	* @return {boolean}
	* @private
	*/
	SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
		return this.path[this.path.length - 1] === "/";
	};
	/**
	* Check if this is a conditional GET request.
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isConditionalGET = function isConditionalGET() {
		return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
	};
	/**
	* Check if the request preconditions failed.
	*
	* @return {boolean}
	* @private
	*/
	SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
		var req$2 = this.req;
		var res$2 = this.res;
		var match$1 = req$2.headers["if-match"];
		if (match$1) {
			var etag$3 = res$2.getHeader("ETag");
			return !etag$3 || match$1 !== "*" && parseTokenList(match$1).every(function(match$2) {
				return match$2 !== etag$3 && match$2 !== "W/" + etag$3 && "W/" + match$2 !== etag$3;
			});
		}
		var unmodifiedSince = parseHttpDate(req$2.headers["if-unmodified-since"]);
		if (!isNaN(unmodifiedSince)) {
			var lastModified = parseHttpDate(res$2.getHeader("Last-Modified"));
			return isNaN(lastModified) || lastModified > unmodifiedSince;
		}
		return false;
	};
	/**
	* Strip various content header fields for a change in entity.
	*
	* @private
	*/
	SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
		var res$2 = this.res;
		res$2.removeHeader("Content-Encoding");
		res$2.removeHeader("Content-Language");
		res$2.removeHeader("Content-Length");
		res$2.removeHeader("Content-Range");
		res$2.removeHeader("Content-Type");
	};
	/**
	* Respond with 304 not modified.
	*
	* @api private
	*/
	SendStream.prototype.notModified = function notModified() {
		var res$2 = this.res;
		debug$2("not modified");
		this.removeContentHeaderFields();
		res$2.statusCode = 304;
		res$2.end();
	};
	/**
	* Raise error that headers already sent.
	*
	* @api private
	*/
	SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
		var err = /* @__PURE__ */ new Error("Can't set headers after they are sent.");
		debug$2("headers already sent");
		this.error(500, err);
	};
	/**
	* Check if the request is cacheable, aka
	* responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isCachable = function isCachable() {
		var statusCode = this.res.statusCode;
		return statusCode >= 200 && statusCode < 300 || statusCode === 304;
	};
	/**
	* Handle stat() error.
	*
	* @param {Error} error
	* @private
	*/
	SendStream.prototype.onStatError = function onStatError(error) {
		switch (error.code) {
			case "ENAMETOOLONG":
			case "ENOENT":
			case "ENOTDIR":
				this.error(404, error);
				break;
			default:
				this.error(500, error);
				break;
		}
	};
	/**
	* Check if the cache is fresh.
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isFresh = function isFresh() {
		return fresh$1(this.req.headers, {
			etag: this.res.getHeader("ETag"),
			"last-modified": this.res.getHeader("Last-Modified")
		});
	};
	/**
	* Check if the range is fresh.
	*
	* @return {Boolean}
	* @api private
	*/
	SendStream.prototype.isRangeFresh = function isRangeFresh() {
		var ifRange = this.req.headers["if-range"];
		if (!ifRange) return true;
		if (ifRange.indexOf("\"") !== -1) {
			var etag$3 = this.res.getHeader("ETag");
			return Boolean(etag$3 && ifRange.indexOf(etag$3) !== -1);
		}
		return parseHttpDate(this.res.getHeader("Last-Modified")) <= parseHttpDate(ifRange);
	};
	/**
	* Redirect to path.
	*
	* @param {string} path
	* @private
	*/
	SendStream.prototype.redirect = function redirect(path$19) {
		var res$2 = this.res;
		if (hasListeners(this, "directory")) {
			this.emit("directory", res$2, path$19);
			return;
		}
		if (this.hasTrailingSlash()) {
			this.error(403);
			return;
		}
		var loc = encodeUrl$2(collapseLeadingSlashes$1(this.path + "/"));
		var doc = createHtmlDocument$1("Redirecting", "Redirecting to " + escapeHtml$2(loc));
		res$2.statusCode = 301;
		res$2.setHeader("Content-Type", "text/html; charset=UTF-8");
		res$2.setHeader("Content-Length", Buffer.byteLength(doc));
		res$2.setHeader("Content-Security-Policy", "default-src 'none'");
		res$2.setHeader("X-Content-Type-Options", "nosniff");
		res$2.setHeader("Location", loc);
		res$2.end(doc);
	};
	/**
	* Pipe to `res.
	*
	* @param {Stream} res
	* @return {Stream} res
	* @api public
	*/
	SendStream.prototype.pipe = function pipe(res$2) {
		var root$3 = this._root;
		this.res = res$2;
		var path$19 = decode$1(this.path);
		if (path$19 === -1) {
			this.error(400);
			return res$2;
		}
		if (~path$19.indexOf("\0")) {
			this.error(400);
			return res$2;
		}
		var parts;
		if (root$3 !== null) {
			if (path$19) path$19 = normalize("." + sep + path$19);
			if (UP_PATH_REGEXP.test(path$19)) {
				debug$2("malicious path \"%s\"", path$19);
				this.error(403);
				return res$2;
			}
			parts = path$19.split(sep);
			path$19 = normalize(join(root$3, path$19));
		} else {
			if (UP_PATH_REGEXP.test(path$19)) {
				debug$2("malicious path \"%s\"", path$19);
				this.error(403);
				return res$2;
			}
			parts = normalize(path$19).split(sep);
			path$19 = resolve$3(path$19);
		}
		if (containsDotFile(parts)) {
			var access = this._dotfiles;
			if (access === void 0) access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
			debug$2("%s dotfile \"%s\"", access, path$19);
			switch (access) {
				case "allow": break;
				case "deny":
					this.error(403);
					return res$2;
				case "ignore":
				default:
					this.error(404);
					return res$2;
			}
		}
		if (this._index.length && this.hasTrailingSlash()) {
			this.sendIndex(path$19);
			return res$2;
		}
		this.sendFile(path$19);
		return res$2;
	};
	/**
	* Transfer `path`.
	*
	* @param {String} path
	* @api public
	*/
	SendStream.prototype.send = function send$4(path$19, stat$4) {
		var len$1 = stat$4.size;
		var options = this.options;
		var opts = {};
		var res$2 = this.res;
		var req$2 = this.req;
		var ranges = req$2.headers.range;
		var offset = options.start || 0;
		if (headersSent(res$2)) {
			this.headersAlreadySent();
			return;
		}
		debug$2("pipe \"%s\"", path$19);
		this.setHeader(path$19, stat$4);
		this.type(path$19);
		if (this.isConditionalGET()) {
			if (this.isPreconditionFailure()) {
				this.error(412);
				return;
			}
			if (this.isCachable() && this.isFresh()) {
				this.notModified();
				return;
			}
		}
		len$1 = Math.max(0, len$1 - offset);
		if (options.end !== void 0) {
			var bytes$6 = options.end - offset + 1;
			if (len$1 > bytes$6) len$1 = bytes$6;
		}
		if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
			ranges = parseRange$1(len$1, ranges, { combine: true });
			if (!this.isRangeFresh()) {
				debug$2("range stale");
				ranges = -2;
			}
			if (ranges === -1) {
				debug$2("range unsatisfiable");
				res$2.setHeader("Content-Range", contentRange("bytes", len$1));
				return this.error(416, { headers: { "Content-Range": res$2.getHeader("Content-Range") } });
			}
			if (ranges !== -2 && ranges.length === 1) {
				debug$2("range %j", ranges);
				res$2.statusCode = 206;
				res$2.setHeader("Content-Range", contentRange("bytes", len$1, ranges[0]));
				offset += ranges[0].start;
				len$1 = ranges[0].end - ranges[0].start + 1;
			}
		}
		for (var prop in options) opts[prop] = options[prop];
		opts.start = offset;
		opts.end = Math.max(offset, offset + len$1 - 1);
		res$2.setHeader("Content-Length", len$1);
		if (req$2.method === "HEAD") {
			res$2.end();
			return;
		}
		this.stream(path$19, opts);
	};
	/**
	* Transfer file for `path`.
	*
	* @param {String} path
	* @api private
	*/
	SendStream.prototype.sendFile = function sendFile(path$19) {
		var i$8 = 0;
		var self$1 = this;
		debug$2("stat \"%s\"", path$19);
		fs$1.stat(path$19, function onstat(err, stat$4) {
			if (err && err.code === "ENOENT" && !extname$1(path$19) && path$19[path$19.length - 1] !== sep) return next(err);
			if (err) return self$1.onStatError(err);
			if (stat$4.isDirectory()) return self$1.redirect(path$19);
			self$1.emit("file", path$19, stat$4);
			self$1.send(path$19, stat$4);
		});
		function next(err) {
			if (self$1._extensions.length <= i$8) return err ? self$1.onStatError(err) : self$1.error(404);
			var p = path$19 + "." + self$1._extensions[i$8++];
			debug$2("stat \"%s\"", p);
			fs$1.stat(p, function(err$1, stat$4) {
				if (err$1) return next(err$1);
				if (stat$4.isDirectory()) return next();
				self$1.emit("file", p, stat$4);
				self$1.send(p, stat$4);
			});
		}
	};
	/**
	* Transfer index for `path`.
	*
	* @param {String} path
	* @api private
	*/
	SendStream.prototype.sendIndex = function sendIndex(path$19) {
		var i$8 = -1;
		var self$1 = this;
		function next(err) {
			if (++i$8 >= self$1._index.length) {
				if (err) return self$1.onStatError(err);
				return self$1.error(404);
			}
			var p = join(path$19, self$1._index[i$8]);
			debug$2("stat \"%s\"", p);
			fs$1.stat(p, function(err$1, stat$4) {
				if (err$1) return next(err$1);
				if (stat$4.isDirectory()) return next();
				self$1.emit("file", p, stat$4);
				self$1.send(p, stat$4);
			});
		}
		next();
	};
	/**
	* Stream `path` to the response.
	*
	* @param {String} path
	* @param {Object} options
	* @api private
	*/
	SendStream.prototype.stream = function stream$3(path$19, options) {
		var self$1 = this;
		var res$2 = this.res;
		var stream$4 = fs$1.createReadStream(path$19, options);
		this.emit("stream", stream$4);
		stream$4.pipe(res$2);
		function cleanup() {
			destroy(stream$4, true);
		}
		onFinished$1(res$2, cleanup);
		stream$4.on("error", function onerror(err) {
			cleanup();
			self$1.onStatError(err);
		});
		stream$4.on("end", function onend() {
			self$1.emit("end");
		});
	};
	/**
	* Set content-type based on `path`
	* if it hasn't been explicitly set.
	*
	* @param {String} path
	* @api private
	*/
	SendStream.prototype.type = function type(path$19) {
		var res$2 = this.res;
		if (res$2.getHeader("Content-Type")) return;
		var type$1 = mime$3.lookup(path$19);
		if (!type$1) {
			debug$2("no content-type");
			return;
		}
		var charset$1 = mime$3.charsets.lookup(type$1);
		debug$2("content-type %s", type$1);
		res$2.setHeader("Content-Type", type$1 + (charset$1 ? "; charset=" + charset$1 : ""));
	};
	/**
	* Set response header fields, most
	* fields may be pre-defined.
	*
	* @param {String} path
	* @param {Object} stat
	* @api private
	*/
	SendStream.prototype.setHeader = function setHeader(path$19, stat$4) {
		var res$2 = this.res;
		this.emit("headers", res$2, path$19, stat$4);
		if (this._acceptRanges && !res$2.getHeader("Accept-Ranges")) {
			debug$2("accept ranges");
			res$2.setHeader("Accept-Ranges", "bytes");
		}
		if (this._cacheControl && !res$2.getHeader("Cache-Control")) {
			var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
			if (this._immutable) cacheControl += ", immutable";
			debug$2("cache-control %s", cacheControl);
			res$2.setHeader("Cache-Control", cacheControl);
		}
		if (this._lastModified && !res$2.getHeader("Last-Modified")) {
			var modified = stat$4.mtime.toUTCString();
			debug$2("modified %s", modified);
			res$2.setHeader("Last-Modified", modified);
		}
		if (this._etag && !res$2.getHeader("ETag")) {
			var val = etag$1(stat$4);
			debug$2("etag %s", val);
			res$2.setHeader("ETag", val);
		}
	};
	/**
	* Clear all headers from a response.
	*
	* @param {object} res
	* @private
	*/
	function clearHeaders(res$2) {
		var headers$1 = getHeaderNames(res$2);
		for (var i$8 = 0; i$8 < headers$1.length; i$8++) res$2.removeHeader(headers$1[i$8]);
	}
	/**
	* Collapse all leading slashes into a single slash
	*
	* @param {string} str
	* @private
	*/
	function collapseLeadingSlashes$1(str) {
		for (var i$8 = 0; i$8 < str.length; i$8++) if (str[i$8] !== "/") break;
		return i$8 > 1 ? "/" + str.substr(i$8) : str;
	}
	/**
	* Determine if path parts contain a dotfile.
	*
	* @api private
	*/
	function containsDotFile(parts) {
		for (var i$8 = 0; i$8 < parts.length; i$8++) {
			var part = parts[i$8];
			if (part.length > 1 && part[0] === ".") return true;
		}
		return false;
	}
	/**
	* Create a Content-Range header.
	*
	* @param {string} type
	* @param {number} size
	* @param {array} [range]
	*/
	function contentRange(type, size, range) {
		return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
	}
	/**
	* Create a minimal HTML document.
	*
	* @param {string} title
	* @param {string} body
	* @private
	*/
	function createHtmlDocument$1(title, body$1) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>" + title + "</title>\n</head>\n<body>\n<pre>" + body$1 + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Create a HttpError object from simple arguments.
	*
	* @param {number} status
	* @param {Error|object} err
	* @private
	*/
	function createHttpError(status$1, err) {
		if (!err) return createError$1(status$1);
		return err instanceof Error ? createError$1(status$1, err, { expose: false }) : createError$1(status$1, err);
	}
	/**
	* decodeURIComponent.
	*
	* Allows V8 to only deoptimize this fn instead of all
	* of send().
	*
	* @param {String} path
	* @api private
	*/
	function decode$1(path$19) {
		try {
			return decodeURIComponent(path$19);
		} catch (err) {
			return -1;
		}
	}
	/**
	* Get the header names on a respnse.
	*
	* @param {object} res
	* @returns {array[string]}
	* @private
	*/
	function getHeaderNames(res$2) {
		return typeof res$2.getHeaderNames !== "function" ? Object.keys(res$2._headers || {}) : res$2.getHeaderNames();
	}
	/**
	* Determine if emitter has listeners of a given type.
	*
	* The way to do this check is done three different ways in Node.js >= 0.8
	* so this consolidates them into a minimal set using instance methods.
	*
	* @param {EventEmitter} emitter
	* @param {string} type
	* @returns {boolean}
	* @private
	*/
	function hasListeners(emitter$1, type) {
		return (typeof emitter$1.listenerCount !== "function" ? emitter$1.listeners(type).length : emitter$1.listenerCount(type)) > 0;
	}
	/**
	* Determine if the response headers have been sent.
	*
	* @param {object} res
	* @returns {boolean}
	* @private
	*/
	function headersSent(res$2) {
		return typeof res$2.headersSent !== "boolean" ? Boolean(res$2._header) : res$2.headersSent;
	}
	/**
	* Normalize the index option into an array.
	*
	* @param {boolean|string|array} val
	* @param {string} name
	* @private
	*/
	function normalizeList(val, name) {
		var list = [].concat(val || []);
		for (var i$8 = 0; i$8 < list.length; i$8++) if (typeof list[i$8] !== "string") throw new TypeError(name + " must be array of strings or false");
		return list;
	}
	/**
	* Parse an HTTP Date into a number.
	*
	* @param {string} date
	* @private
	*/
	function parseHttpDate(date) {
		var timestamp$1 = date && Date.parse(date);
		return typeof timestamp$1 === "number" ? timestamp$1 : NaN;
	}
	/**
	* Parse a HTTP token list.
	*
	* @param {string} str
	* @private
	*/
	function parseTokenList(str) {
		var end = 0;
		var list = [];
		var start = 0;
		for (var i$8 = 0, len$1 = str.length; i$8 < len$1; i$8++) switch (str.charCodeAt(i$8)) {
			case 32:
				if (start === end) start = end = i$8 + 1;
				break;
			case 44:
				if (start !== end) list.push(str.substring(start, end));
				start = end = i$8 + 1;
				break;
			default:
				end = i$8 + 1;
				break;
		}
		if (start !== end) list.push(str.substring(start, end));
		return list;
	}
	/**
	* Set an object of headers on a response.
	*
	* @param {object} res
	* @param {object} headers
	* @private
	*/
	function setHeaders(res$2, headers$1) {
		var keys$6 = Object.keys(headers$1);
		for (var i$8 = 0; i$8 < keys$6.length; i$8++) {
			var key$1 = keys$6[i$8];
			res$2.setHeader(key$1, headers$1[key$1]);
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js
var require_forwarded = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = forwarded$1;
	/**
	* Get all addresses in the request, using the `X-Forwarded-For` header.
	*
	* @param {object} req
	* @return {array}
	* @public
	*/
	function forwarded$1(req$2) {
		if (!req$2) throw new TypeError("argument req is required");
		var proxyAddrs = parse$3(req$2.headers["x-forwarded-for"] || "");
		return [getSocketAddr(req$2)].concat(proxyAddrs);
	}
	/**
	* Get the socket address for a request.
	*
	* @param {object} req
	* @return {string}
	* @private
	*/
	function getSocketAddr(req$2) {
		return req$2.socket ? req$2.socket.remoteAddress : req$2.connection.remoteAddress;
	}
	/**
	* Parse the X-Forwarded-For header.
	*
	* @param {string} header
	* @private
	*/
	function parse$3(header) {
		var end = header.length;
		var list = [];
		var start = header.length;
		for (var i$8 = header.length - 1; i$8 >= 0; i$8--) switch (header.charCodeAt(i$8)) {
			case 32:
				if (start === end) start = end = i$8;
				break;
			case 44:
				if (start !== end) list.push(header.substring(start, end));
				start = end = i$8;
				break;
			default:
				start = i$8;
				break;
		}
		if (start !== end) list.push(header.substring(start, end));
		return list;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js": ((exports, module) => {
	(function() {
		var expandIPv6, ipaddr$1 = {}, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root$3 = this, zoneIndex;
		if (typeof module !== "undefined" && module !== null && module.exports) module.exports = ipaddr$1;
		else root$3["ipaddr"] = ipaddr$1;
		matchCIDR = function(first$3, second, partSize, cidrBits) {
			var part, shift;
			if (first$3.length !== second.length) throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
			part = 0;
			while (cidrBits > 0) {
				shift = partSize - cidrBits;
				if (shift < 0) shift = 0;
				if (first$3[part] >> shift !== second[part] >> shift) return false;
				cidrBits -= partSize;
				part += 1;
			}
			return true;
		};
		ipaddr$1.subnetMatch = function(address, rangeList, defaultName) {
			var k$7, len$1, rangeName, rangeSubnets, subnet;
			if (defaultName == null) defaultName = "unicast";
			for (rangeName in rangeList) {
				rangeSubnets = rangeList[rangeName];
				if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) rangeSubnets = [rangeSubnets];
				for (k$7 = 0, len$1 = rangeSubnets.length; k$7 < len$1; k$7++) {
					subnet = rangeSubnets[k$7];
					if (address.kind() === subnet[0].kind()) {
						if (address.match.apply(address, subnet)) return rangeName;
					}
				}
			}
			return defaultName;
		};
		ipaddr$1.IPv4 = (function() {
			function IPv4(octets) {
				var k$7, len$1, octet;
				if (octets.length !== 4) throw new Error("ipaddr: ipv4 octet count should be 4");
				for (k$7 = 0, len$1 = octets.length; k$7 < len$1; k$7++) {
					octet = octets[k$7];
					if (!(0 <= octet && octet <= 255)) throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
				}
				this.octets = octets;
			}
			IPv4.prototype.kind = function() {
				return "ipv4";
			};
			IPv4.prototype.toString = function() {
				return this.octets.join(".");
			};
			IPv4.prototype.toNormalizedString = function() {
				return this.toString();
			};
			IPv4.prototype.toByteArray = function() {
				return this.octets.slice(0);
			};
			IPv4.prototype.match = function(other, cidrRange) {
				var ref;
				if (cidrRange === void 0) ref = other, other = ref[0], cidrRange = ref[1];
				if (other.kind() !== "ipv4") throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
				return matchCIDR(this.octets, other.octets, 8, cidrRange);
			};
			IPv4.prototype.SpecialRanges = {
				unspecified: [[new IPv4([
					0,
					0,
					0,
					0
				]), 8]],
				broadcast: [[new IPv4([
					255,
					255,
					255,
					255
				]), 32]],
				multicast: [[new IPv4([
					224,
					0,
					0,
					0
				]), 4]],
				linkLocal: [[new IPv4([
					169,
					254,
					0,
					0
				]), 16]],
				loopback: [[new IPv4([
					127,
					0,
					0,
					0
				]), 8]],
				carrierGradeNat: [[new IPv4([
					100,
					64,
					0,
					0
				]), 10]],
				"private": [
					[new IPv4([
						10,
						0,
						0,
						0
					]), 8],
					[new IPv4([
						172,
						16,
						0,
						0
					]), 12],
					[new IPv4([
						192,
						168,
						0,
						0
					]), 16]
				],
				reserved: [
					[new IPv4([
						192,
						0,
						0,
						0
					]), 24],
					[new IPv4([
						192,
						0,
						2,
						0
					]), 24],
					[new IPv4([
						192,
						88,
						99,
						0
					]), 24],
					[new IPv4([
						198,
						51,
						100,
						0
					]), 24],
					[new IPv4([
						203,
						0,
						113,
						0
					]), 24],
					[new IPv4([
						240,
						0,
						0,
						0
					]), 4]
				]
			};
			IPv4.prototype.range = function() {
				return ipaddr$1.subnetMatch(this, this.SpecialRanges);
			};
			IPv4.prototype.toIPv4MappedAddress = function() {
				return ipaddr$1.IPv6.parse("::ffff:" + this.toString());
			};
			IPv4.prototype.prefixLengthFromSubnetMask = function() {
				var cidr, i$8, k$7, octet, stop, zeros, zerotable = {
					0: 8,
					128: 7,
					192: 6,
					224: 5,
					240: 4,
					248: 3,
					252: 2,
					254: 1,
					255: 0
				};
				cidr = 0;
				stop = false;
				for (i$8 = k$7 = 3; k$7 >= 0; i$8 = k$7 += -1) {
					octet = this.octets[i$8];
					if (octet in zerotable) {
						zeros = zerotable[octet];
						if (stop && zeros !== 0) return null;
						if (zeros !== 8) stop = true;
						cidr += zeros;
					} else return null;
				}
				return 32 - cidr;
			};
			return IPv4;
		})();
		ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
		ipv4Regexes = {
			fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
			longValue: new RegExp("^" + ipv4Part + "$", "i")
		};
		ipaddr$1.IPv4.parser = function(string) {
			var match$1, parseIntAuto = function(string$1) {
				if (string$1[0] === "0" && string$1[1] !== "x") return parseInt(string$1, 8);
				else return parseInt(string$1);
			}, part, shift, value;
			if (match$1 = string.match(ipv4Regexes.fourOctet)) return (function() {
				var k$7, len$1, ref = match$1.slice(1, 6), results = [];
				for (k$7 = 0, len$1 = ref.length; k$7 < len$1; k$7++) {
					part = ref[k$7];
					results.push(parseIntAuto(part));
				}
				return results;
			})();
			else if (match$1 = string.match(ipv4Regexes.longValue)) {
				value = parseIntAuto(match$1[1]);
				if (value > 4294967295 || value < 0) throw new Error("ipaddr: address outside defined range");
				return (function() {
					var k$7, results = [];
					for (shift = k$7 = 0; k$7 <= 24; shift = k$7 += 8) results.push(value >> shift & 255);
					return results;
				})().reverse();
			} else return null;
		};
		ipaddr$1.IPv6 = (function() {
			function IPv6(parts, zoneId) {
				var i$8, k$7, l, len$1, part, ref;
				if (parts.length === 16) {
					this.parts = [];
					for (i$8 = k$7 = 0; k$7 <= 14; i$8 = k$7 += 2) this.parts.push(parts[i$8] << 8 | parts[i$8 + 1]);
				} else if (parts.length === 8) this.parts = parts;
				else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
				ref = this.parts;
				for (l = 0, len$1 = ref.length; l < len$1; l++) {
					part = ref[l];
					if (!(0 <= part && part <= 65535)) throw new Error("ipaddr: ipv6 part should fit in 16 bits");
				}
				if (zoneId) this.zoneId = zoneId;
			}
			IPv6.prototype.kind = function() {
				return "ipv6";
			};
			IPv6.prototype.toString = function() {
				return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
			};
			IPv6.prototype.toRFC5952String = function() {
				var bestMatchIndex, bestMatchLength, match$1, regex = /((^|:)(0(:|$)){2,})/g, string = this.toNormalizedString();
				bestMatchIndex = 0;
				bestMatchLength = -1;
				while (match$1 = regex.exec(string)) if (match$1[0].length > bestMatchLength) {
					bestMatchIndex = match$1.index;
					bestMatchLength = match$1[0].length;
				}
				if (bestMatchLength < 0) return string;
				return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
			};
			IPv6.prototype.toByteArray = function() {
				var bytes$6 = [], k$7, len$1, part, ref = this.parts;
				for (k$7 = 0, len$1 = ref.length; k$7 < len$1; k$7++) {
					part = ref[k$7];
					bytes$6.push(part >> 8);
					bytes$6.push(part & 255);
				}
				return bytes$6;
			};
			IPv6.prototype.toNormalizedString = function() {
				var addr = (function() {
					var k$7, len$1, ref = this.parts, results = [];
					for (k$7 = 0, len$1 = ref.length; k$7 < len$1; k$7++) {
						part = ref[k$7];
						results.push(part.toString(16));
					}
					return results;
				}).call(this).join(":"), part, suffix = "";
				if (this.zoneId) suffix = "%" + this.zoneId;
				return addr + suffix;
			};
			IPv6.prototype.toFixedLengthString = function() {
				var addr = (function() {
					var k$7, len$1, ref = this.parts, results = [];
					for (k$7 = 0, len$1 = ref.length; k$7 < len$1; k$7++) {
						part = ref[k$7];
						results.push(part.toString(16).padStart(4, "0"));
					}
					return results;
				}).call(this).join(":"), part, suffix = "";
				if (this.zoneId) suffix = "%" + this.zoneId;
				return addr + suffix;
			};
			IPv6.prototype.match = function(other, cidrRange) {
				var ref;
				if (cidrRange === void 0) ref = other, other = ref[0], cidrRange = ref[1];
				if (other.kind() !== "ipv6") throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
				return matchCIDR(this.parts, other.parts, 16, cidrRange);
			};
			IPv6.prototype.SpecialRanges = {
				unspecified: [new IPv6([
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 128],
				linkLocal: [new IPv6([
					65152,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 10],
				multicast: [new IPv6([
					65280,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 8],
				loopback: [new IPv6([
					0,
					0,
					0,
					0,
					0,
					0,
					0,
					1
				]), 128],
				uniqueLocal: [new IPv6([
					64512,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 7],
				ipv4Mapped: [new IPv6([
					0,
					0,
					0,
					0,
					0,
					65535,
					0,
					0
				]), 96],
				rfc6145: [new IPv6([
					0,
					0,
					0,
					0,
					65535,
					0,
					0,
					0
				]), 96],
				rfc6052: [new IPv6([
					100,
					65435,
					0,
					0,
					0,
					0,
					0,
					0
				]), 96],
				"6to4": [new IPv6([
					8194,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 16],
				teredo: [new IPv6([
					8193,
					0,
					0,
					0,
					0,
					0,
					0,
					0
				]), 32],
				reserved: [[new IPv6([
					8193,
					3512,
					0,
					0,
					0,
					0,
					0,
					0
				]), 32]]
			};
			IPv6.prototype.range = function() {
				return ipaddr$1.subnetMatch(this, this.SpecialRanges);
			};
			IPv6.prototype.isIPv4MappedAddress = function() {
				return this.range() === "ipv4Mapped";
			};
			IPv6.prototype.toIPv4Address = function() {
				var high, low, ref;
				if (!this.isIPv4MappedAddress()) throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
				ref = this.parts.slice(-2), high = ref[0], low = ref[1];
				return new ipaddr$1.IPv4([
					high >> 8,
					high & 255,
					low >> 8,
					low & 255
				]);
			};
			IPv6.prototype.prefixLengthFromSubnetMask = function() {
				var cidr, i$8, k$7, part, stop, zeros, zerotable = {
					0: 16,
					32768: 15,
					49152: 14,
					57344: 13,
					61440: 12,
					63488: 11,
					64512: 10,
					65024: 9,
					65280: 8,
					65408: 7,
					65472: 6,
					65504: 5,
					65520: 4,
					65528: 3,
					65532: 2,
					65534: 1,
					65535: 0
				};
				cidr = 0;
				stop = false;
				for (i$8 = k$7 = 7; k$7 >= 0; i$8 = k$7 += -1) {
					part = this.parts[i$8];
					if (part in zerotable) {
						zeros = zerotable[part];
						if (stop && zeros !== 0) return null;
						if (zeros !== 16) stop = true;
						cidr += zeros;
					} else return null;
				}
				return 128 - cidr;
			};
			return IPv6;
		})();
		ipv6Part = "(?:[0-9a-f]+::?)+";
		zoneIndex = "%[0-9a-z]{1,}";
		ipv6Regexes = {
			zoneIndex: new RegExp(zoneIndex, "i"),
			"native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
			transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
		};
		expandIPv6 = function(string, parts) {
			var colonCount, lastColon, part, replacement, replacementCount, zoneId;
			if (string.indexOf("::") !== string.lastIndexOf("::")) return null;
			zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
			if (zoneId) {
				zoneId = zoneId.substring(1);
				string = string.replace(/%.+$/, "");
			}
			colonCount = 0;
			lastColon = -1;
			while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) colonCount++;
			if (string.substr(0, 2) === "::") colonCount--;
			if (string.substr(-2, 2) === "::") colonCount--;
			if (colonCount > parts) return null;
			replacementCount = parts - colonCount;
			replacement = ":";
			while (replacementCount--) replacement += "0:";
			string = string.replace("::", replacement);
			if (string[0] === ":") string = string.slice(1);
			if (string[string.length - 1] === ":") string = string.slice(0, -1);
			parts = (function() {
				var k$7, len$1, ref = string.split(":"), results = [];
				for (k$7 = 0, len$1 = ref.length; k$7 < len$1; k$7++) {
					part = ref[k$7];
					results.push(parseInt(part, 16));
				}
				return results;
			})();
			return {
				parts,
				zoneId
			};
		};
		ipaddr$1.IPv6.parser = function(string) {
			var addr, k$7, len$1, match$1, octet, octets, zoneId;
			if (ipv6Regexes["native"].test(string)) return expandIPv6(string, 8);
			else if (match$1 = string.match(ipv6Regexes["transitional"])) {
				zoneId = match$1[6] || "";
				addr = expandIPv6(match$1[1].slice(0, -1) + zoneId, 6);
				if (addr.parts) {
					octets = [
						parseInt(match$1[2]),
						parseInt(match$1[3]),
						parseInt(match$1[4]),
						parseInt(match$1[5])
					];
					for (k$7 = 0, len$1 = octets.length; k$7 < len$1; k$7++) {
						octet = octets[k$7];
						if (!(0 <= octet && octet <= 255)) return null;
					}
					addr.parts.push(octets[0] << 8 | octets[1]);
					addr.parts.push(octets[2] << 8 | octets[3]);
					return {
						parts: addr.parts,
						zoneId: addr.zoneId
					};
				}
			}
			return null;
		};
		ipaddr$1.IPv4.isIPv4 = ipaddr$1.IPv6.isIPv6 = function(string) {
			return this.parser(string) !== null;
		};
		ipaddr$1.IPv4.isValid = function(string) {
			try {
				new this(this.parser(string));
				return true;
			} catch (error1) {
				return false;
			}
		};
		ipaddr$1.IPv4.isValidFourPartDecimal = function(string) {
			if (ipaddr$1.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) return true;
			else return false;
		};
		ipaddr$1.IPv6.isValid = function(string) {
			var addr;
			if (typeof string === "string" && string.indexOf(":") === -1) return false;
			try {
				addr = this.parser(string);
				new this(addr.parts, addr.zoneId);
				return true;
			} catch (error1) {
				return false;
			}
		};
		ipaddr$1.IPv4.parse = function(string) {
			var parts = this.parser(string);
			if (parts === null) throw new Error("ipaddr: string is not formatted like ip address");
			return new this(parts);
		};
		ipaddr$1.IPv6.parse = function(string) {
			var addr = this.parser(string);
			if (addr.parts === null) throw new Error("ipaddr: string is not formatted like ip address");
			return new this(addr.parts, addr.zoneId);
		};
		ipaddr$1.IPv4.parseCIDR = function(string) {
			var maskLength, match$1, parsed;
			if (match$1 = string.match(/^(.+)\/(\d+)$/)) {
				maskLength = parseInt(match$1[2]);
				if (maskLength >= 0 && maskLength <= 32) {
					parsed = [this.parse(match$1[1]), maskLength];
					Object.defineProperty(parsed, "toString", { value: function() {
						return this.join("/");
					} });
					return parsed;
				}
			}
			throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
		};
		ipaddr$1.IPv4.subnetMaskFromPrefixLength = function(prefix) {
			var filledOctetCount, j$7, octets;
			prefix = parseInt(prefix);
			if (prefix < 0 || prefix > 32) throw new Error("ipaddr: invalid IPv4 prefix length");
			octets = [
				0,
				0,
				0,
				0
			];
			j$7 = 0;
			filledOctetCount = Math.floor(prefix / 8);
			while (j$7 < filledOctetCount) {
				octets[j$7] = 255;
				j$7++;
			}
			if (filledOctetCount < 4) octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
			return new this(octets);
		};
		ipaddr$1.IPv4.broadcastAddressFromCIDR = function(string) {
			var cidr, i$8, ipInterfaceOctets, octets, subnetMaskOctets;
			try {
				cidr = this.parseCIDR(string);
				ipInterfaceOctets = cidr[0].toByteArray();
				subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
				octets = [];
				i$8 = 0;
				while (i$8 < 4) {
					octets.push(parseInt(ipInterfaceOctets[i$8], 10) | parseInt(subnetMaskOctets[i$8], 10) ^ 255);
					i$8++;
				}
				return new this(octets);
			} catch (error1) {
				throw new Error("ipaddr: the address does not have IPv4 CIDR format");
			}
		};
		ipaddr$1.IPv4.networkAddressFromCIDR = function(string) {
			var cidr, i$8, ipInterfaceOctets, octets, subnetMaskOctets;
			try {
				cidr = this.parseCIDR(string);
				ipInterfaceOctets = cidr[0].toByteArray();
				subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
				octets = [];
				i$8 = 0;
				while (i$8 < 4) {
					octets.push(parseInt(ipInterfaceOctets[i$8], 10) & parseInt(subnetMaskOctets[i$8], 10));
					i$8++;
				}
				return new this(octets);
			} catch (error1) {
				throw new Error("ipaddr: the address does not have IPv4 CIDR format");
			}
		};
		ipaddr$1.IPv6.parseCIDR = function(string) {
			var maskLength, match$1, parsed;
			if (match$1 = string.match(/^(.+)\/(\d+)$/)) {
				maskLength = parseInt(match$1[2]);
				if (maskLength >= 0 && maskLength <= 128) {
					parsed = [this.parse(match$1[1]), maskLength];
					Object.defineProperty(parsed, "toString", { value: function() {
						return this.join("/");
					} });
					return parsed;
				}
			}
			throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
		};
		ipaddr$1.isValid = function(string) {
			return ipaddr$1.IPv6.isValid(string) || ipaddr$1.IPv4.isValid(string);
		};
		ipaddr$1.parse = function(string) {
			if (ipaddr$1.IPv6.isValid(string)) return ipaddr$1.IPv6.parse(string);
			else if (ipaddr$1.IPv4.isValid(string)) return ipaddr$1.IPv4.parse(string);
			else throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
		};
		ipaddr$1.parseCIDR = function(string) {
			try {
				return ipaddr$1.IPv6.parseCIDR(string);
			} catch (error1) {
				try {
					return ipaddr$1.IPv4.parseCIDR(string);
				} catch (error1$1) {
					throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
				}
			}
		};
		ipaddr$1.fromByteArray = function(bytes$6) {
			var length = bytes$6.length;
			if (length === 4) return new ipaddr$1.IPv4(bytes$6);
			else if (length === 16) return new ipaddr$1.IPv6(bytes$6);
			else throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
		};
		ipaddr$1.process = function(string) {
			var addr = this.parse(string);
			if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) return addr.toIPv4Address();
			else return addr;
		};
	}).call(exports);
}) });

//#endregion
//#region ../../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js
var require_proxy_addr = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = proxyaddr$2;
	module.exports.all = alladdrs;
	module.exports.compile = compile;
	/**
	* Module dependencies.
	* @private
	*/
	var forwarded = require_forwarded();
	var ipaddr = require_ipaddr();
	/**
	* Variables.
	* @private
	*/
	var DIGIT_REGEXP = /^[0-9]+$/;
	var isip = ipaddr.isValid;
	var parseip = ipaddr.parse;
	/**
	* Pre-defined IP ranges.
	* @private
	*/
	var IP_RANGES = {
		linklocal: ["169.254.0.0/16", "fe80::/10"],
		loopback: ["127.0.0.1/8", "::1/128"],
		uniquelocal: [
			"10.0.0.0/8",
			"172.16.0.0/12",
			"192.168.0.0/16",
			"fc00::/7"
		]
	};
	/**
	* Get all addresses in the request, optionally stopping
	* at the first untrusted.
	*
	* @param {Object} request
	* @param {Function|Array|String} [trust]
	* @public
	*/
	function alladdrs(req$2, trust) {
		var addrs = forwarded(req$2);
		if (!trust) return addrs;
		if (typeof trust !== "function") trust = compile(trust);
		for (var i$8 = 0; i$8 < addrs.length - 1; i$8++) {
			if (trust(addrs[i$8], i$8)) continue;
			addrs.length = i$8 + 1;
		}
		return addrs;
	}
	/**
	* Compile argument into trust function.
	*
	* @param {Array|String} val
	* @private
	*/
	function compile(val) {
		if (!val) throw new TypeError("argument is required");
		var trust;
		if (typeof val === "string") trust = [val];
		else if (Array.isArray(val)) trust = val.slice();
		else throw new TypeError("unsupported trust argument");
		for (var i$8 = 0; i$8 < trust.length; i$8++) {
			val = trust[i$8];
			if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) continue;
			val = IP_RANGES[val];
			trust.splice.apply(trust, [i$8, 1].concat(val));
			i$8 += val.length - 1;
		}
		return compileTrust$1(compileRangeSubnets(trust));
	}
	/**
	* Compile `arr` elements into range subnets.
	*
	* @param {Array} arr
	* @private
	*/
	function compileRangeSubnets(arr) {
		var rangeSubnets = new Array(arr.length);
		for (var i$8 = 0; i$8 < arr.length; i$8++) rangeSubnets[i$8] = parseipNotation(arr[i$8]);
		return rangeSubnets;
	}
	/**
	* Compile range subnet array into trust function.
	*
	* @param {Array} rangeSubnets
	* @private
	*/
	function compileTrust$1(rangeSubnets) {
		var len$1 = rangeSubnets.length;
		return len$1 === 0 ? trustNone : len$1 === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
	}
	/**
	* Parse IP notation string into range subnet.
	*
	* @param {String} note
	* @private
	*/
	function parseipNotation(note) {
		var pos = note.lastIndexOf("/");
		var str = pos !== -1 ? note.substring(0, pos) : note;
		if (!isip(str)) throw new TypeError("invalid IP address: " + str);
		var ip = parseip(str);
		if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) ip = ip.toIPv4Address();
		var max$9 = ip.kind() === "ipv6" ? 128 : 32;
		var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
		if (range === null) range = max$9;
		else if (DIGIT_REGEXP.test(range)) range = parseInt(range, 10);
		else if (ip.kind() === "ipv4" && isip(range)) range = parseNetmask(range);
		else range = null;
		if (range <= 0 || range > max$9) throw new TypeError("invalid range on address: " + note);
		return [ip, range];
	}
	/**
	* Parse netmask string into CIDR range.
	*
	* @param {String} netmask
	* @private
	*/
	function parseNetmask(netmask) {
		var ip = parseip(netmask);
		return ip.kind() === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
	}
	/**
	* Determine address of proxied request.
	*
	* @param {Object} request
	* @param {Function|Array|String} trust
	* @public
	*/
	function proxyaddr$2(req$2, trust) {
		if (!req$2) throw new TypeError("req argument is required");
		if (!trust) throw new TypeError("trust argument is required");
		var addrs = alladdrs(req$2, trust);
		return addrs[addrs.length - 1];
	}
	/**
	* Static trust function to trust nothing.
	*
	* @private
	*/
	function trustNone() {
		return false;
	}
	/**
	* Compile trust function for multiple subnets.
	*
	* @param {Array} subnets
	* @private
	*/
	function trustMulti(subnets) {
		return function trust(addr) {
			if (!isip(addr)) return false;
			var ip = parseip(addr);
			var ipconv;
			var kind = ip.kind();
			for (var i$8 = 0; i$8 < subnets.length; i$8++) {
				var subnet = subnets[i$8];
				var subnetip = subnet[0];
				var subnetkind = subnetip.kind();
				var subnetrange = subnet[1];
				var trusted = ip;
				if (kind !== subnetkind) {
					if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) continue;
					if (!ipconv) ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
					trusted = ipconv;
				}
				if (trusted.match(subnetip, subnetrange)) return true;
			}
			return false;
		};
	}
	/**
	* Compile trust function for single subnet.
	*
	* @param {Object} subnet
	* @private
	*/
	function trustSingle(subnet) {
		var subnetip = subnet[0];
		var subnetkind = subnetip.kind();
		var subnetisipv4 = subnetkind === "ipv4";
		var subnetrange = subnet[1];
		return function trust(addr) {
			if (!isip(addr)) return false;
			var ip = parseip(addr);
			if (ip.kind() !== subnetkind) {
				if (subnetisipv4 && !ip.isIPv4MappedAddress()) return false;
				ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
			}
			return ip.match(subnetip, subnetrange);
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js
var require_utils = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js": ((exports) => {
	/**
	* Module dependencies.
	* @api private
	*/
	var Buffer$2 = require_safe_buffer().Buffer;
	var contentDisposition$1 = require_content_disposition();
	var contentType = require_content_type();
	var deprecate$3 = require_depd()("express");
	var flatten$1 = require_array_flatten();
	var mime$2 = require_send().mime;
	var etag = require_etag();
	var proxyaddr$1 = require_proxy_addr();
	var qs = require_lib$1();
	var querystring = __require("querystring");
	/**
	* Return strong ETag for `body`.
	*
	* @param {String|Buffer} body
	* @param {String} [encoding]
	* @return {String}
	* @api private
	*/
	exports.etag = createETagGenerator({ weak: false });
	/**
	* Return weak ETag for `body`.
	*
	* @param {String|Buffer} body
	* @param {String} [encoding]
	* @return {String}
	* @api private
	*/
	exports.wetag = createETagGenerator({ weak: true });
	/**
	* Check if `path` looks absolute.
	*
	* @param {String} path
	* @return {Boolean}
	* @api private
	*/
	exports.isAbsolute = function(path$19) {
		if ("/" === path$19[0]) return true;
		if (":" === path$19[1] && ("\\" === path$19[2] || "/" === path$19[2])) return true;
		if ("\\\\" === path$19.substring(0, 2)) return true;
	};
	/**
	* Flatten the given `arr`.
	*
	* @param {Array} arr
	* @return {Array}
	* @api private
	*/
	exports.flatten = deprecate$3.function(flatten$1, "utils.flatten: use array-flatten npm module instead");
	/**
	* Normalize the given `type`, for example "html" becomes "text/html".
	*
	* @param {String} type
	* @return {Object}
	* @api private
	*/
	exports.normalizeType = function(type) {
		return ~type.indexOf("/") ? acceptParams(type) : {
			value: mime$2.lookup(type),
			params: {}
		};
	};
	/**
	* Normalize `types`, for example "html" becomes "text/html".
	*
	* @param {Array} types
	* @return {Array}
	* @api private
	*/
	exports.normalizeTypes = function(types) {
		var ret = [];
		for (var i$8 = 0; i$8 < types.length; ++i$8) ret.push(exports.normalizeType(types[i$8]));
		return ret;
	};
	/**
	* Generate Content-Disposition header appropriate for the filename.
	* non-ascii filenames are urlencoded and a filename* parameter is added
	*
	* @param {String} filename
	* @return {String}
	* @api private
	*/
	exports.contentDisposition = deprecate$3.function(contentDisposition$1, "utils.contentDisposition: use content-disposition npm module instead");
	/**
	* Parse accept params `str` returning an
	* object with `.value`, `.quality` and `.params`.
	*
	* @param {String} str
	* @return {Object}
	* @api private
	*/
	function acceptParams(str) {
		var parts = str.split(/ *; */);
		var ret = {
			value: parts[0],
			quality: 1,
			params: {}
		};
		for (var i$8 = 1; i$8 < parts.length; ++i$8) {
			var pms = parts[i$8].split(/ *= */);
			if ("q" === pms[0]) ret.quality = parseFloat(pms[1]);
			else ret.params[pms[0]] = pms[1];
		}
		return ret;
	}
	/**
	* Compile "etag" value to function.
	*
	* @param  {Boolean|String|Function} val
	* @return {Function}
	* @api private
	*/
	exports.compileETag = function(val) {
		var fn;
		if (typeof val === "function") return val;
		switch (val) {
			case true:
			case "weak":
				fn = exports.wetag;
				break;
			case false: break;
			case "strong":
				fn = exports.etag;
				break;
			default: throw new TypeError("unknown value for etag function: " + val);
		}
		return fn;
	};
	/**
	* Compile "query parser" value to function.
	*
	* @param  {String|Function} val
	* @return {Function}
	* @api private
	*/
	exports.compileQueryParser = function compileQueryParser$1(val) {
		var fn;
		if (typeof val === "function") return val;
		switch (val) {
			case true:
			case "simple":
				fn = querystring.parse;
				break;
			case false:
				fn = newObject;
				break;
			case "extended":
				fn = parseExtendedQueryString;
				break;
			default: throw new TypeError("unknown value for query parser function: " + val);
		}
		return fn;
	};
	/**
	* Compile "proxy trust" value to function.
	*
	* @param  {Boolean|String|Number|Array|Function} val
	* @return {Function}
	* @api private
	*/
	exports.compileTrust = function(val) {
		if (typeof val === "function") return val;
		if (val === true) return function() {
			return true;
		};
		if (typeof val === "number") return function(a, i$8) {
			return i$8 < val;
		};
		if (typeof val === "string") val = val.split(",").map(function(v) {
			return v.trim();
		});
		return proxyaddr$1.compile(val || []);
	};
	/**
	* Set the charset in a given Content-Type string.
	*
	* @param {String} type
	* @param {String} charset
	* @return {String}
	* @api private
	*/
	exports.setCharset = function setCharset$1(type, charset$1) {
		if (!type || !charset$1) return type;
		var parsed = contentType.parse(type);
		parsed.parameters.charset = charset$1;
		return contentType.format(parsed);
	};
	/**
	* Create an ETag generator function, generating ETags with
	* the given options.
	*
	* @param {object} options
	* @return {function}
	* @private
	*/
	function createETagGenerator(options) {
		return function generateETag(body$1, encoding) {
			return etag(!Buffer$2.isBuffer(body$1) ? Buffer$2.from(body$1, encoding) : body$1, options);
		};
	}
	/**
	* Parse an extended query string with qs.
	*
	* @param {String} str
	* @return {Object}
	* @private
	*/
	function parseExtendedQueryString(str) {
		return qs.parse(str, { allowPrototypes: true });
	}
	/**
	* Return new empty object.
	*
	* @return {Object}
	* @api private
	*/
	function newObject() {
		return {};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/application.js
var require_application = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/application.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var finalhandler = require_finalhandler();
	var Router$1 = require_router();
	var methods = require_methods();
	var middleware = require_init();
	var query = require_query();
	var debug$1 = require_src()("express:application");
	var View = require_view();
	var http$3 = __require("http");
	var compileETag = require_utils().compileETag;
	var compileQueryParser = require_utils().compileQueryParser;
	var compileTrust = require_utils().compileTrust;
	var deprecate$2 = require_depd()("express");
	var flatten = require_array_flatten();
	var merge$1 = require_utils_merge();
	var resolve$2 = __require("path").resolve;
	var setPrototypeOf = require_setprototypeof();
	/**
	* Module variables.
	* @private
	*/
	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
	var slice = Array.prototype.slice;
	/**
	* Application prototype.
	*/
	var app = exports = module.exports = {};
	/**
	* Variable for trust proxy inheritance back-compat
	* @private
	*/
	var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
	/**
	* Initialize the server.
	*
	*   - setup default configuration
	*   - setup default middleware
	*   - setup route reflection methods
	*
	* @private
	*/
	app.init = function init$2() {
		this.cache = {};
		this.engines = {};
		this.settings = {};
		this.defaultConfiguration();
	};
	/**
	* Initialize application configuration.
	* @private
	*/
	app.defaultConfiguration = function defaultConfiguration() {
		var env$2 = process.env.NODE_ENV || "development";
		this.enable("x-powered-by");
		this.set("etag", "weak");
		this.set("env", env$2);
		this.set("query parser", "extended");
		this.set("subdomain offset", 2);
		this.set("trust proxy", false);
		Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
			configurable: true,
			value: true
		});
		debug$1("booting in %s mode", env$2);
		this.on("mount", function onmount(parent) {
			if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
				delete this.settings["trust proxy"];
				delete this.settings["trust proxy fn"];
			}
			setPrototypeOf(this.request, parent.request);
			setPrototypeOf(this.response, parent.response);
			setPrototypeOf(this.engines, parent.engines);
			setPrototypeOf(this.settings, parent.settings);
		});
		this.locals = Object.create(null);
		this.mountpath = "/";
		this.locals.settings = this.settings;
		this.set("view", View);
		this.set("views", resolve$2("views"));
		this.set("jsonp callback name", "callback");
		if (env$2 === "production") this.enable("view cache");
		Object.defineProperty(this, "router", { get: function() {
			throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
		} });
	};
	/**
	* lazily adds the base router if it has not yet been added.
	*
	* We cannot add the base router in the defaultConfiguration because
	* it reads app settings which might be set after that has run.
	*
	* @private
	*/
	app.lazyrouter = function lazyrouter() {
		if (!this._router) {
			this._router = new Router$1({
				caseSensitive: this.enabled("case sensitive routing"),
				strict: this.enabled("strict routing")
			});
			this._router.use(query(this.get("query parser fn")));
			this._router.use(middleware.init(this));
		}
	};
	/**
	* Dispatch a req, res pair into the application. Starts pipeline processing.
	*
	* If no callback is provided, then default error handlers will respond
	* in the event of an error bubbling through the stack.
	*
	* @private
	*/
	app.handle = function handle(req$2, res$2, callback) {
		var router = this._router;
		var done = callback || finalhandler(req$2, res$2, {
			env: this.get("env"),
			onerror: logerror.bind(this)
		});
		if (!router) {
			debug$1("no routes defined on app");
			done();
			return;
		}
		router.handle(req$2, res$2, done);
	};
	/**
	* Proxy `Router#use()` to add middleware to the app router.
	* See Router#use() documentation for details.
	*
	* If the _fn_ parameter is an express app, then it will be
	* mounted at the _route_ specified.
	*
	* @public
	*/
	app.use = function use(fn) {
		var offset = 0;
		var path$19 = "/";
		if (typeof fn !== "function") {
			var arg = fn;
			while (Array.isArray(arg) && arg.length !== 0) arg = arg[0];
			if (typeof arg !== "function") {
				offset = 1;
				path$19 = fn;
			}
		}
		var fns = flatten(slice.call(arguments, offset));
		if (fns.length === 0) throw new TypeError("app.use() requires a middleware function");
		this.lazyrouter();
		var router = this._router;
		fns.forEach(function(fn$1) {
			if (!fn$1 || !fn$1.handle || !fn$1.set) return router.use(path$19, fn$1);
			debug$1(".use app under %s", path$19);
			fn$1.mountpath = path$19;
			fn$1.parent = this;
			router.use(path$19, function mounted_app(req$2, res$2, next) {
				var orig = req$2.app;
				fn$1.handle(req$2, res$2, function(err) {
					setPrototypeOf(req$2, orig.request);
					setPrototypeOf(res$2, orig.response);
					next(err);
				});
			});
			fn$1.emit("mount", this);
		}, this);
		return this;
	};
	/**
	* Proxy to the app `Router#route()`
	* Returns a new `Route` instance for the _path_.
	*
	* Routes are isolated middleware stacks for specific paths.
	* See the Route api docs for details.
	*
	* @public
	*/
	app.route = function route(path$19) {
		this.lazyrouter();
		return this._router.route(path$19);
	};
	/**
	* Register the given template engine callback `fn`
	* as `ext`.
	*
	* By default will `require()` the engine based on the
	* file extension. For example if you try to render
	* a "foo.ejs" file Express will invoke the following internally:
	*
	*     app.engine('ejs', require('ejs').__express);
	*
	* For engines that do not provide `.__express` out of the box,
	* or if you wish to "map" a different extension to the template engine
	* you may use this method. For example mapping the EJS template engine to
	* ".html" files:
	*
	*     app.engine('html', require('ejs').renderFile);
	*
	* In this case EJS provides a `.renderFile()` method with
	* the same signature that Express expects: `(path, options, callback)`,
	* though note that it aliases this method as `ejs.__express` internally
	* so if you're using ".ejs" extensions you don't need to do anything.
	*
	* Some template engines do not follow this convention, the
	* [Consolidate.js](https://github.com/tj/consolidate.js)
	* library was created to map all of node's popular template
	* engines to follow this convention, thus allowing them to
	* work seamlessly within Express.
	*
	* @param {String} ext
	* @param {Function} fn
	* @return {app} for chaining
	* @public
	*/
	app.engine = function engine(ext, fn) {
		if (typeof fn !== "function") throw new Error("callback function required");
		var extension$1 = ext[0] !== "." ? "." + ext : ext;
		this.engines[extension$1] = fn;
		return this;
	};
	/**
	* Proxy to `Router#param()` with one added api feature. The _name_ parameter
	* can be an array of names.
	*
	* See the Router#param() docs for more details.
	*
	* @param {String|Array} name
	* @param {Function} fn
	* @return {app} for chaining
	* @public
	*/
	app.param = function param(name, fn) {
		this.lazyrouter();
		if (Array.isArray(name)) {
			for (var i$8 = 0; i$8 < name.length; i$8++) this.param(name[i$8], fn);
			return this;
		}
		this._router.param(name, fn);
		return this;
	};
	/**
	* Assign `setting` to `val`, or return `setting`'s value.
	*
	*    app.set('foo', 'bar');
	*    app.set('foo');
	*    // => "bar"
	*
	* Mounted servers inherit their parent server's settings.
	*
	* @param {String} setting
	* @param {*} [val]
	* @return {Server} for chaining
	* @public
	*/
	app.set = function set$3(setting, val) {
		if (arguments.length === 1) {
			var settings = this.settings;
			while (settings && settings !== Object.prototype) {
				if (hasOwnProperty$1.call(settings, setting)) return settings[setting];
				settings = Object.getPrototypeOf(settings);
			}
			return;
		}
		debug$1("set \"%s\" to %o", setting, val);
		this.settings[setting] = val;
		switch (setting) {
			case "etag":
				this.set("etag fn", compileETag(val));
				break;
			case "query parser":
				this.set("query parser fn", compileQueryParser(val));
				break;
			case "trust proxy":
				this.set("trust proxy fn", compileTrust(val));
				Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
					configurable: true,
					value: false
				});
				break;
		}
		return this;
	};
	/**
	* Return the app's absolute pathname
	* based on the parent(s) that have
	* mounted it.
	*
	* For example if the application was
	* mounted as "/admin", which itself
	* was mounted as "/blog" then the
	* return value would be "/blog/admin".
	*
	* @return {String}
	* @private
	*/
	app.path = function path$19() {
		return this.parent ? this.parent.path() + this.mountpath : "";
	};
	/**
	* Check if `setting` is enabled (truthy).
	*
	*    app.enabled('foo')
	*    // => false
	*
	*    app.enable('foo')
	*    app.enabled('foo')
	*    // => true
	*
	* @param {String} setting
	* @return {Boolean}
	* @public
	*/
	app.enabled = function enabled$1(setting) {
		return Boolean(this.set(setting));
	};
	/**
	* Check if `setting` is disabled.
	*
	*    app.disabled('foo')
	*    // => true
	*
	*    app.enable('foo')
	*    app.disabled('foo')
	*    // => false
	*
	* @param {String} setting
	* @return {Boolean}
	* @public
	*/
	app.disabled = function disabled(setting) {
		return !this.set(setting);
	};
	/**
	* Enable `setting`.
	*
	* @param {String} setting
	* @return {app} for chaining
	* @public
	*/
	app.enable = function enable$1(setting) {
		return this.set(setting, true);
	};
	/**
	* Disable `setting`.
	*
	* @param {String} setting
	* @return {app} for chaining
	* @public
	*/
	app.disable = function disable$1(setting) {
		return this.set(setting, false);
	};
	/**
	* Delegate `.VERB(...)` calls to `router.VERB(...)`.
	*/
	methods.forEach(function(method$1) {
		app[method$1] = function(path$19) {
			if (method$1 === "get" && arguments.length === 1) return this.set(path$19);
			this.lazyrouter();
			var route = this._router.route(path$19);
			route[method$1].apply(route, slice.call(arguments, 1));
			return this;
		};
	});
	/**
	* Special-cased "all" method, applying the given route `path`,
	* middleware, and callback to _every_ HTTP method.
	*
	* @param {String} path
	* @param {Function} ...
	* @return {app} for chaining
	* @public
	*/
	app.all = function all(path$19) {
		this.lazyrouter();
		var route = this._router.route(path$19);
		var args = slice.call(arguments, 1);
		for (var i$8 = 0; i$8 < methods.length; i$8++) route[methods[i$8]].apply(route, args);
		return this;
	};
	app.del = deprecate$2.function(app.delete, "app.del: Use app.delete instead");
	/**
	* Render the given view `name` name with `options`
	* and a callback accepting an error and the
	* rendered template string.
	*
	* Example:
	*
	*    app.render('email', { name: 'Tobi' }, function(err, html){
	*      // ...
	*    })
	*
	* @param {String} name
	* @param {Object|Function} options or fn
	* @param {Function} callback
	* @public
	*/
	app.render = function render(name, options, callback) {
		var cache = this.cache;
		var done = callback;
		var engines = this.engines;
		var opts = options;
		var renderOptions = {};
		var view;
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		merge$1(renderOptions, this.locals);
		if (opts._locals) merge$1(renderOptions, opts._locals);
		merge$1(renderOptions, opts);
		if (renderOptions.cache == null) renderOptions.cache = this.enabled("view cache");
		if (renderOptions.cache) view = cache[name];
		if (!view) {
			view = new (this.get("view"))(name, {
				defaultEngine: this.get("view engine"),
				root: this.get("views"),
				engines
			});
			if (!view.path) {
				var dirs = Array.isArray(view.root) && view.root.length > 1 ? "directories \"" + view.root.slice(0, -1).join("\", \"") + "\" or \"" + view.root[view.root.length - 1] + "\"" : "directory \"" + view.root + "\"";
				var err = /* @__PURE__ */ new Error("Failed to lookup view \"" + name + "\" in views " + dirs);
				err.view = view;
				return done(err);
			}
			if (renderOptions.cache) cache[name] = view;
		}
		tryRender(view, renderOptions, done);
	};
	/**
	* Listen for connections.
	*
	* A node `http.Server` is returned, with this
	* application (which is a `Function`) as its
	* callback. If you wish to create both an HTTP
	* and HTTPS server you may do so with the "http"
	* and "https" modules as shown here:
	*
	*    var http = require('http')
	*      , https = require('https')
	*      , express = require('express')
	*      , app = express();
	*
	*    http.createServer(app).listen(80);
	*    https.createServer({ ... }, app).listen(443);
	*
	* @return {http.Server}
	* @public
	*/
	app.listen = function listen() {
		var server = http$3.createServer(this);
		return server.listen.apply(server, arguments);
	};
	/**
	* Log error using console.error.
	*
	* @param {Error} err
	* @private
	*/
	function logerror(err) {
		/* istanbul ignore next */
		if (this.get("env") !== "test") console.error(err.stack || err.toString());
	}
	/**
	* Try rendering a view.
	* @private
	*/
	function tryRender(view, options, callback) {
		try {
			view.render(options, callback);
		} catch (err) {
			callback(err);
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/charset.js
var require_charset = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/charset.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredCharsets$1;
	module.exports.preferredCharsets = preferredCharsets$1;
	/**
	* Module variables.
	* @private
	*/
	var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	/**
	* Parse the Accept-Charset header.
	* @private
	*/
	function parseAcceptCharset(accept) {
		var accepts$1 = accept.split(",");
		for (var i$8 = 0, j$7 = 0; i$8 < accepts$1.length; i$8++) {
			var charset$1 = parseCharset(accepts$1[i$8].trim(), i$8);
			if (charset$1) accepts$1[j$7++] = charset$1;
		}
		accepts$1.length = j$7;
		return accepts$1;
	}
	/**
	* Parse a charset from the Accept-Charset header.
	* @private
	*/
	function parseCharset(str, i$8) {
		var match$1 = simpleCharsetRegExp.exec(str);
		if (!match$1) return null;
		var charset$1 = match$1[1];
		var q = 1;
		if (match$1[2]) {
			var params = match$1[2].split(";");
			for (var j$7 = 0; j$7 < params.length; j$7++) {
				var p = params[j$7].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			charset: charset$1,
			q,
			i: i$8
		};
	}
	/**
	* Get the priority of a charset.
	* @private
	*/
	function getCharsetPriority(charset$1, accepted, index$1) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i$8 = 0; i$8 < accepted.length; i$8++) {
			var spec = specify$3(charset$1, accepted[i$8], index$1);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the charset.
	* @private
	*/
	function specify$3(charset$1, spec, index$1) {
		var s$3 = 0;
		if (spec.charset.toLowerCase() === charset$1.toLowerCase()) s$3 |= 1;
		else if (spec.charset !== "*") return null;
		return {
			i: index$1,
			o: spec.i,
			q: spec.q,
			s: s$3
		};
	}
	/**
	* Get the preferred charsets from an Accept-Charset header.
	* @public
	*/
	function preferredCharsets$1(accept, provided) {
		var accepts$1 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts$1.filter(isQuality$3).sort(compareSpecs$3).map(getFullCharset);
		var priorities = provided.map(function getPriority(type, index$1) {
			return getCharsetPriority(type, accepts$1, index$1);
		});
		return priorities.filter(isQuality$3).sort(compareSpecs$3).map(function getCharset$3(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs$3(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full charset string.
	* @private
	*/
	function getFullCharset(spec) {
		return spec.charset;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality$3(spec) {
		return spec.q > 0;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/encoding.js
var require_encoding = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/encoding.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredEncodings$1;
	module.exports.preferredEncodings = preferredEncodings$1;
	/**
	* Module variables.
	* @private
	*/
	var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
	/**
	* Parse the Accept-Encoding header.
	* @private
	*/
	function parseAcceptEncoding(accept) {
		var accepts$1 = accept.split(",");
		var hasIdentity = false;
		var minQuality = 1;
		for (var i$8 = 0, j$7 = 0; i$8 < accepts$1.length; i$8++) {
			var encoding = parseEncoding(accepts$1[i$8].trim(), i$8);
			if (encoding) {
				accepts$1[j$7++] = encoding;
				hasIdentity = hasIdentity || specify$2("identity", encoding);
				minQuality = Math.min(minQuality, encoding.q || 1);
			}
		}
		if (!hasIdentity) accepts$1[j$7++] = {
			encoding: "identity",
			q: minQuality,
			i: i$8
		};
		accepts$1.length = j$7;
		return accepts$1;
	}
	/**
	* Parse an encoding from the Accept-Encoding header.
	* @private
	*/
	function parseEncoding(str, i$8) {
		var match$1 = simpleEncodingRegExp.exec(str);
		if (!match$1) return null;
		var encoding = match$1[1];
		var q = 1;
		if (match$1[2]) {
			var params = match$1[2].split(";");
			for (var j$7 = 0; j$7 < params.length; j$7++) {
				var p = params[j$7].trim().split("=");
				if (p[0] === "q") {
					q = parseFloat(p[1]);
					break;
				}
			}
		}
		return {
			encoding,
			q,
			i: i$8
		};
	}
	/**
	* Get the priority of an encoding.
	* @private
	*/
	function getEncodingPriority(encoding, accepted, index$1) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i$8 = 0; i$8 < accepted.length; i$8++) {
			var spec = specify$2(encoding, accepted[i$8], index$1);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the encoding.
	* @private
	*/
	function specify$2(encoding, spec, index$1) {
		var s$3 = 0;
		if (spec.encoding.toLowerCase() === encoding.toLowerCase()) s$3 |= 1;
		else if (spec.encoding !== "*") return null;
		return {
			i: index$1,
			o: spec.i,
			q: spec.q,
			s: s$3
		};
	}
	/**
	* Get the preferred encodings from an Accept-Encoding header.
	* @public
	*/
	function preferredEncodings$1(accept, provided) {
		var accepts$1 = parseAcceptEncoding(accept || "");
		if (!provided) return accepts$1.filter(isQuality$2).sort(compareSpecs$2).map(getFullEncoding);
		var priorities = provided.map(function getPriority(type, index$1) {
			return getEncodingPriority(type, accepts$1, index$1);
		});
		return priorities.filter(isQuality$2).sort(compareSpecs$2).map(function getEncoding(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs$2(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full encoding string.
	* @private
	*/
	function getFullEncoding(spec) {
		return spec.encoding;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality$2(spec) {
		return spec.q > 0;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/language.js
var require_language = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/language.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredLanguages$1;
	module.exports.preferredLanguages = preferredLanguages$1;
	/**
	* Module variables.
	* @private
	*/
	var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
	/**
	* Parse the Accept-Language header.
	* @private
	*/
	function parseAcceptLanguage(accept) {
		var accepts$1 = accept.split(",");
		for (var i$8 = 0, j$7 = 0; i$8 < accepts$1.length; i$8++) {
			var language = parseLanguage(accepts$1[i$8].trim(), i$8);
			if (language) accepts$1[j$7++] = language;
		}
		accepts$1.length = j$7;
		return accepts$1;
	}
	/**
	* Parse a language from the Accept-Language header.
	* @private
	*/
	function parseLanguage(str, i$8) {
		var match$1 = simpleLanguageRegExp.exec(str);
		if (!match$1) return null;
		var prefix = match$1[1];
		var suffix = match$1[2];
		var full = prefix;
		if (suffix) full += "-" + suffix;
		var q = 1;
		if (match$1[3]) {
			var params = match$1[3].split(";");
			for (var j$7 = 0; j$7 < params.length; j$7++) {
				var p = params[j$7].split("=");
				if (p[0] === "q") q = parseFloat(p[1]);
			}
		}
		return {
			prefix,
			suffix,
			q,
			i: i$8,
			full
		};
	}
	/**
	* Get the priority of a language.
	* @private
	*/
	function getLanguagePriority(language, accepted, index$1) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i$8 = 0; i$8 < accepted.length; i$8++) {
			var spec = specify$1(language, accepted[i$8], index$1);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the language.
	* @private
	*/
	function specify$1(language, spec, index$1) {
		var p = parseLanguage(language);
		if (!p) return null;
		var s$3 = 0;
		if (spec.full.toLowerCase() === p.full.toLowerCase()) s$3 |= 4;
		else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) s$3 |= 2;
		else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) s$3 |= 1;
		else if (spec.full !== "*") return null;
		return {
			i: index$1,
			o: spec.i,
			q: spec.q,
			s: s$3
		};
	}
	/**
	* Get the preferred languages from an Accept-Language header.
	* @public
	*/
	function preferredLanguages$1(accept, provided) {
		var accepts$1 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
		if (!provided) return accepts$1.filter(isQuality$1).sort(compareSpecs$1).map(getFullLanguage);
		var priorities = provided.map(function getPriority(type, index$1) {
			return getLanguagePriority(type, accepts$1, index$1);
		});
		return priorities.filter(isQuality$1).sort(compareSpecs$1).map(function getLanguage(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs$1(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full language string.
	* @private
	*/
	function getFullLanguage(spec) {
		return spec.full;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality$1(spec) {
		return spec.q > 0;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/mediaType.js
var require_mediaType = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/mediaType.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = preferredMediaTypes$1;
	module.exports.preferredMediaTypes = preferredMediaTypes$1;
	/**
	* Module variables.
	* @private
	*/
	var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
	/**
	* Parse the Accept header.
	* @private
	*/
	function parseAccept(accept) {
		var accepts$1 = splitMediaTypes(accept);
		for (var i$8 = 0, j$7 = 0; i$8 < accepts$1.length; i$8++) {
			var mediaType = parseMediaType(accepts$1[i$8].trim(), i$8);
			if (mediaType) accepts$1[j$7++] = mediaType;
		}
		accepts$1.length = j$7;
		return accepts$1;
	}
	/**
	* Parse a media type from the Accept header.
	* @private
	*/
	function parseMediaType(str, i$8) {
		var match$1 = simpleMediaTypeRegExp.exec(str);
		if (!match$1) return null;
		var params = Object.create(null);
		var q = 1;
		var subtype = match$1[2];
		var type = match$1[1];
		if (match$1[3]) {
			var kvps = splitParameters(match$1[3]).map(splitKeyValuePair);
			for (var j$7 = 0; j$7 < kvps.length; j$7++) {
				var pair = kvps[j$7];
				var key$1 = pair[0].toLowerCase();
				var val = pair[1];
				var value = val && val[0] === "\"" && val[val.length - 1] === "\"" ? val.substr(1, val.length - 2) : val;
				if (key$1 === "q") {
					q = parseFloat(value);
					break;
				}
				params[key$1] = value;
			}
		}
		return {
			type,
			subtype,
			params,
			q,
			i: i$8
		};
	}
	/**
	* Get the priority of a media type.
	* @private
	*/
	function getMediaTypePriority(type, accepted, index$1) {
		var priority = {
			o: -1,
			q: 0,
			s: 0
		};
		for (var i$8 = 0; i$8 < accepted.length; i$8++) {
			var spec = specify(type, accepted[i$8], index$1);
			if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
		}
		return priority;
	}
	/**
	* Get the specificity of the media type.
	* @private
	*/
	function specify(type, spec, index$1) {
		var p = parseMediaType(type);
		var s$3 = 0;
		if (!p) return null;
		if (spec.type.toLowerCase() == p.type.toLowerCase()) s$3 |= 4;
		else if (spec.type != "*") return null;
		if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) s$3 |= 2;
		else if (spec.subtype != "*") return null;
		var keys$6 = Object.keys(spec.params);
		if (keys$6.length > 0) if (keys$6.every(function(k$7) {
			return spec.params[k$7] == "*" || (spec.params[k$7] || "").toLowerCase() == (p.params[k$7] || "").toLowerCase();
		})) s$3 |= 1;
		else return null;
		return {
			i: index$1,
			o: spec.i,
			q: spec.q,
			s: s$3
		};
	}
	/**
	* Get the preferred media types from an Accept header.
	* @public
	*/
	function preferredMediaTypes$1(accept, provided) {
		var accepts$1 = parseAccept(accept === void 0 ? "*/*" : accept || "");
		if (!provided) return accepts$1.filter(isQuality).sort(compareSpecs).map(getFullType);
		var priorities = provided.map(function getPriority(type, index$1) {
			return getMediaTypePriority(type, accepts$1, index$1);
		});
		return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
			return provided[priorities.indexOf(priority)];
		});
	}
	/**
	* Compare two specs.
	* @private
	*/
	function compareSpecs(a, b) {
		return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
	}
	/**
	* Get full type string.
	* @private
	*/
	function getFullType(spec) {
		return spec.type + "/" + spec.subtype;
	}
	/**
	* Check if a spec has any quality.
	* @private
	*/
	function isQuality(spec) {
		return spec.q > 0;
	}
	/**
	* Count the number of quotes in a string.
	* @private
	*/
	function quoteCount(string) {
		var count = 0;
		var index$1 = 0;
		while ((index$1 = string.indexOf("\"", index$1)) !== -1) {
			count++;
			index$1++;
		}
		return count;
	}
	/**
	* Split a key value pair.
	* @private
	*/
	function splitKeyValuePair(str) {
		var index$1 = str.indexOf("=");
		var key$1;
		var val;
		if (index$1 === -1) key$1 = str;
		else {
			key$1 = str.substr(0, index$1);
			val = str.substr(index$1 + 1);
		}
		return [key$1, val];
	}
	/**
	* Split an Accept header into media types.
	* @private
	*/
	function splitMediaTypes(accept) {
		var accepts$1 = accept.split(",");
		for (var i$8 = 1, j$7 = 0; i$8 < accepts$1.length; i$8++) if (quoteCount(accepts$1[j$7]) % 2 == 0) accepts$1[++j$7] = accepts$1[i$8];
		else accepts$1[j$7] += "," + accepts$1[i$8];
		accepts$1.length = j$7 + 1;
		return accepts$1;
	}
	/**
	* Split a string of parameters.
	* @private
	*/
	function splitParameters(str) {
		var parameters = str.split(";");
		for (var i$8 = 1, j$7 = 0; i$8 < parameters.length; i$8++) if (quoteCount(parameters[j$7]) % 2 == 0) parameters[++j$7] = parameters[i$8];
		else parameters[j$7] += ";" + parameters[i$8];
		parameters.length = j$7 + 1;
		for (var i$8 = 0; i$8 < parameters.length; i$8++) parameters[i$8] = parameters[i$8].trim();
		return parameters;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/index.js
var require_negotiator = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/index.js": ((exports, module) => {
	var preferredCharsets = require_charset();
	var preferredEncodings = require_encoding();
	var preferredLanguages = require_language();
	var preferredMediaTypes = require_mediaType();
	/**
	* Module exports.
	* @public
	*/
	module.exports = Negotiator$1;
	module.exports.Negotiator = Negotiator$1;
	/**
	* Create a Negotiator instance from a request.
	* @param {object} request
	* @public
	*/
	function Negotiator$1(request) {
		if (!(this instanceof Negotiator$1)) return new Negotiator$1(request);
		this.request = request;
	}
	Negotiator$1.prototype.charset = function charset$1(available) {
		var set$3 = this.charsets(available);
		return set$3 && set$3[0];
	};
	Negotiator$1.prototype.charsets = function charsets(available) {
		return preferredCharsets(this.request.headers["accept-charset"], available);
	};
	Negotiator$1.prototype.encoding = function encoding(available) {
		var set$3 = this.encodings(available);
		return set$3 && set$3[0];
	};
	Negotiator$1.prototype.encodings = function encodings(available) {
		return preferredEncodings(this.request.headers["accept-encoding"], available);
	};
	Negotiator$1.prototype.language = function language(available) {
		var set$3 = this.languages(available);
		return set$3 && set$3[0];
	};
	Negotiator$1.prototype.languages = function languages(available) {
		return preferredLanguages(this.request.headers["accept-language"], available);
	};
	Negotiator$1.prototype.mediaType = function mediaType(available) {
		var set$3 = this.mediaTypes(available);
		return set$3 && set$3[0];
	};
	Negotiator$1.prototype.mediaTypes = function mediaTypes(available) {
		return preferredMediaTypes(this.request.headers.accept, available);
	};
	Negotiator$1.prototype.preferredCharset = Negotiator$1.prototype.charset;
	Negotiator$1.prototype.preferredCharsets = Negotiator$1.prototype.charsets;
	Negotiator$1.prototype.preferredEncoding = Negotiator$1.prototype.encoding;
	Negotiator$1.prototype.preferredEncodings = Negotiator$1.prototype.encodings;
	Negotiator$1.prototype.preferredLanguage = Negotiator$1.prototype.language;
	Negotiator$1.prototype.preferredLanguages = Negotiator$1.prototype.languages;
	Negotiator$1.prototype.preferredMediaType = Negotiator$1.prototype.mediaType;
	Negotiator$1.prototype.preferredMediaTypes = Negotiator$1.prototype.mediaTypes;
}) });

//#endregion
//#region ../../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js
var require_accepts = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Negotiator = require_negotiator();
	var mime$1 = require_mime_types();
	/**
	* Module exports.
	* @public
	*/
	module.exports = Accepts;
	/**
	* Create a new Accepts object for the given req.
	*
	* @param {object} req
	* @public
	*/
	function Accepts(req$2) {
		if (!(this instanceof Accepts)) return new Accepts(req$2);
		this.headers = req$2.headers;
		this.negotiator = new Negotiator(req$2);
	}
	/**
	* Check if the given `type(s)` is acceptable, returning
	* the best match when true, otherwise `undefined`, in which
	* case you should respond with 406 "Not Acceptable".
	*
	* The `type` value may be a single mime type string
	* such as "application/json", the extension name
	* such as "json" or an array `["json", "html", "text/plain"]`. When a list
	* or array is given the _best_ match, if any is returned.
	*
	* Examples:
	*
	*     // Accept: text/html
	*     this.types('html');
	*     // => "html"
	*
	*     // Accept: text/*, application/json
	*     this.types('html');
	*     // => "html"
	*     this.types('text/html');
	*     // => "text/html"
	*     this.types('json', 'text');
	*     // => "json"
	*     this.types('application/json');
	*     // => "application/json"
	*
	*     // Accept: text/*, application/json
	*     this.types('image/png');
	*     this.types('png');
	*     // => undefined
	*
	*     // Accept: text/*;q=.5, application/json
	*     this.types(['html', 'json']);
	*     this.types('html', 'json');
	*     // => "json"
	*
	* @param {String|Array} types...
	* @return {String|Array|Boolean}
	* @public
	*/
	Accepts.prototype.type = Accepts.prototype.types = function(types_) {
		var types = types_;
		if (types && !Array.isArray(types)) {
			types = new Array(arguments.length);
			for (var i$8 = 0; i$8 < types.length; i$8++) types[i$8] = arguments[i$8];
		}
		if (!types || types.length === 0) return this.negotiator.mediaTypes();
		if (!this.headers.accept) return types[0];
		var mimes = types.map(extToMime);
		var first$3 = this.negotiator.mediaTypes(mimes.filter(validMime))[0];
		return first$3 ? types[mimes.indexOf(first$3)] : false;
	};
	/**
	* Return accepted encodings or best fit based on `encodings`.
	*
	* Given `Accept-Encoding: gzip, deflate`
	* an array sorted by quality is returned:
	*
	*     ['gzip', 'deflate']
	*
	* @param {String|Array} encodings...
	* @return {String|Array}
	* @public
	*/
	Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
		var encodings = encodings_;
		if (encodings && !Array.isArray(encodings)) {
			encodings = new Array(arguments.length);
			for (var i$8 = 0; i$8 < encodings.length; i$8++) encodings[i$8] = arguments[i$8];
		}
		if (!encodings || encodings.length === 0) return this.negotiator.encodings();
		return this.negotiator.encodings(encodings)[0] || false;
	};
	/**
	* Return accepted charsets or best fit based on `charsets`.
	*
	* Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
	* an array sorted by quality is returned:
	*
	*     ['utf-8', 'utf-7', 'iso-8859-1']
	*
	* @param {String|Array} charsets...
	* @return {String|Array}
	* @public
	*/
	Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
		var charsets = charsets_;
		if (charsets && !Array.isArray(charsets)) {
			charsets = new Array(arguments.length);
			for (var i$8 = 0; i$8 < charsets.length; i$8++) charsets[i$8] = arguments[i$8];
		}
		if (!charsets || charsets.length === 0) return this.negotiator.charsets();
		return this.negotiator.charsets(charsets)[0] || false;
	};
	/**
	* Return accepted languages or best fit based on `langs`.
	*
	* Given `Accept-Language: en;q=0.8, es, pt`
	* an array sorted by quality is returned:
	*
	*     ['es', 'pt', 'en']
	*
	* @param {String|Array} langs...
	* @return {Array|String}
	* @public
	*/
	Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
		var languages = languages_;
		if (languages && !Array.isArray(languages)) {
			languages = new Array(arguments.length);
			for (var i$8 = 0; i$8 < languages.length; i$8++) languages[i$8] = arguments[i$8];
		}
		if (!languages || languages.length === 0) return this.negotiator.languages();
		return this.negotiator.languages(languages)[0] || false;
	};
	/**
	* Convert extnames to mime.
	*
	* @param {String} type
	* @return {String}
	* @private
	*/
	function extToMime(type) {
		return type.indexOf("/") === -1 ? mime$1.lookup(type) : type;
	}
	/**
	* Check if mime is valid.
	*
	* @param {String} type
	* @return {String}
	* @private
	*/
	function validMime(type) {
		return typeof type === "string";
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/request.js
var require_request = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/request.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var accepts = require_accepts();
	var deprecate$1 = require_depd()("express");
	var isIP = __require("net").isIP;
	var typeis = require_type_is();
	var http$2 = __require("http");
	var fresh = require_fresh();
	var parseRange = require_range_parser();
	var parse$2 = require_parseurl();
	var proxyaddr = require_proxy_addr();
	/**
	* Request prototype.
	* @public
	*/
	var req$1 = Object.create(http$2.IncomingMessage.prototype);
	/**
	* Module exports.
	* @public
	*/
	module.exports = req$1;
	/**
	* Return request header.
	*
	* The `Referrer` header field is special-cased,
	* both `Referrer` and `Referer` are interchangeable.
	*
	* Examples:
	*
	*     req.get('Content-Type');
	*     // => "text/plain"
	*
	*     req.get('content-type');
	*     // => "text/plain"
	*
	*     req.get('Something');
	*     // => undefined
	*
	* Aliased as `req.header()`.
	*
	* @param {String} name
	* @return {String}
	* @public
	*/
	req$1.get = req$1.header = function header(name) {
		if (!name) throw new TypeError("name argument is required to req.get");
		if (typeof name !== "string") throw new TypeError("name must be a string to req.get");
		var lc = name.toLowerCase();
		switch (lc) {
			case "referer":
			case "referrer": return this.headers.referrer || this.headers.referer;
			default: return this.headers[lc];
		}
	};
	/**
	* To do: update docs.
	*
	* Check if the given `type(s)` is acceptable, returning
	* the best match when true, otherwise `undefined`, in which
	* case you should respond with 406 "Not Acceptable".
	*
	* The `type` value may be a single MIME type string
	* such as "application/json", an extension name
	* such as "json", a comma-delimited list such as "json, html, text/plain",
	* an argument list such as `"json", "html", "text/plain"`,
	* or an array `["json", "html", "text/plain"]`. When a list
	* or array is given, the _best_ match, if any is returned.
	*
	* Examples:
	*
	*     // Accept: text/html
	*     req.accepts('html');
	*     // => "html"
	*
	*     // Accept: text/*, application/json
	*     req.accepts('html');
	*     // => "html"
	*     req.accepts('text/html');
	*     // => "text/html"
	*     req.accepts('json, text');
	*     // => "json"
	*     req.accepts('application/json');
	*     // => "application/json"
	*
	*     // Accept: text/*, application/json
	*     req.accepts('image/png');
	*     req.accepts('png');
	*     // => undefined
	*
	*     // Accept: text/*;q=.5, application/json
	*     req.accepts(['html', 'json']);
	*     req.accepts('html', 'json');
	*     req.accepts('html, json');
	*     // => "json"
	*
	* @param {String|Array} type(s)
	* @return {String|Array|Boolean}
	* @public
	*/
	req$1.accepts = function() {
		var accept = accepts(this);
		return accept.types.apply(accept, arguments);
	};
	/**
	* Check if the given `encoding`s are accepted.
	*
	* @param {String} ...encoding
	* @return {String|Array}
	* @public
	*/
	req$1.acceptsEncodings = function() {
		var accept = accepts(this);
		return accept.encodings.apply(accept, arguments);
	};
	req$1.acceptsEncoding = deprecate$1.function(req$1.acceptsEncodings, "req.acceptsEncoding: Use acceptsEncodings instead");
	/**
	* Check if the given `charset`s are acceptable,
	* otherwise you should respond with 406 "Not Acceptable".
	*
	* @param {String} ...charset
	* @return {String|Array}
	* @public
	*/
	req$1.acceptsCharsets = function() {
		var accept = accepts(this);
		return accept.charsets.apply(accept, arguments);
	};
	req$1.acceptsCharset = deprecate$1.function(req$1.acceptsCharsets, "req.acceptsCharset: Use acceptsCharsets instead");
	/**
	* Check if the given `lang`s are acceptable,
	* otherwise you should respond with 406 "Not Acceptable".
	*
	* @param {String} ...lang
	* @return {String|Array}
	* @public
	*/
	req$1.acceptsLanguages = function() {
		var accept = accepts(this);
		return accept.languages.apply(accept, arguments);
	};
	req$1.acceptsLanguage = deprecate$1.function(req$1.acceptsLanguages, "req.acceptsLanguage: Use acceptsLanguages instead");
	/**
	* Parse Range header field, capping to the given `size`.
	*
	* Unspecified ranges such as "0-" require knowledge of your resource length. In
	* the case of a byte range this is of course the total number of bytes. If the
	* Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
	* and `-2` when syntactically invalid.
	*
	* When ranges are returned, the array has a "type" property which is the type of
	* range that is required (most commonly, "bytes"). Each array element is an object
	* with a "start" and "end" property for the portion of the range.
	*
	* The "combine" option can be set to `true` and overlapping & adjacent ranges
	* will be combined into a single range.
	*
	* NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
	* should respond with 4 users when available, not 3.
	*
	* @param {number} size
	* @param {object} [options]
	* @param {boolean} [options.combine=false]
	* @return {number|array}
	* @public
	*/
	req$1.range = function range(size, options) {
		var range$1 = this.get("Range");
		if (!range$1) return;
		return parseRange(size, range$1, options);
	};
	/**
	* Return the value of param `name` when present or `defaultValue`.
	*
	*  - Checks route placeholders, ex: _/user/:id_
	*  - Checks body params, ex: id=12, {"id":12}
	*  - Checks query string params, ex: ?id=12
	*
	* To utilize request bodies, `req.body`
	* should be an object. This can be done by using
	* the `bodyParser()` middleware.
	*
	* @param {String} name
	* @param {Mixed} [defaultValue]
	* @return {String}
	* @public
	*/
	req$1.param = function param(name, defaultValue) {
		var params = this.params || {};
		var body$1 = this.body || {};
		var query$1 = this.query || {};
		deprecate$1("req.param(" + (arguments.length === 1 ? "name" : "name, default") + "): Use req.params, req.body, or req.query instead");
		if (null != params[name] && params.hasOwnProperty(name)) return params[name];
		if (null != body$1[name]) return body$1[name];
		if (null != query$1[name]) return query$1[name];
		return defaultValue;
	};
	/**
	* Check if the incoming request contains the "Content-Type"
	* header field, and it contains the given mime `type`.
	*
	* Examples:
	*
	*      // With Content-Type: text/html; charset=utf-8
	*      req.is('html');
	*      req.is('text/html');
	*      req.is('text/*');
	*      // => true
	*
	*      // When Content-Type is application/json
	*      req.is('json');
	*      req.is('application/json');
	*      req.is('application/*');
	*      // => true
	*
	*      req.is('html');
	*      // => false
	*
	* @param {String|Array} types...
	* @return {String|false|null}
	* @public
	*/
	req$1.is = function is$8(types) {
		var arr = types;
		if (!Array.isArray(types)) {
			arr = new Array(arguments.length);
			for (var i$8 = 0; i$8 < arr.length; i$8++) arr[i$8] = arguments[i$8];
		}
		return typeis(this, arr);
	};
	/**
	* Return the protocol string "http" or "https"
	* when requested with TLS. When the "trust proxy"
	* setting trusts the socket address, the
	* "X-Forwarded-Proto" header field will be trusted
	* and used if present.
	*
	* If you're running behind a reverse proxy that
	* supplies https for you this may be enabled.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req$1, "protocol", function protocol() {
		var proto$7 = this.connection.encrypted ? "https" : "http";
		if (!this.app.get("trust proxy fn")(this.connection.remoteAddress, 0)) return proto$7;
		var header = this.get("X-Forwarded-Proto") || proto$7;
		var index$1 = header.indexOf(",");
		return index$1 !== -1 ? header.substring(0, index$1).trim() : header.trim();
	});
	/**
	* Short-hand for:
	*
	*    req.protocol === 'https'
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req$1, "secure", function secure() {
		return this.protocol === "https";
	});
	/**
	* Return the remote address from the trusted proxy.
	*
	* The is the remote address on the socket unless
	* "trust proxy" is set.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req$1, "ip", function ip() {
		var trust = this.app.get("trust proxy fn");
		return proxyaddr(this, trust);
	});
	/**
	* When "trust proxy" is set, trusted proxy addresses + client.
	*
	* For example if the value were "client, proxy1, proxy2"
	* you would receive the array `["client", "proxy1", "proxy2"]`
	* where "proxy2" is the furthest down-stream and "proxy1" and
	* "proxy2" were trusted.
	*
	* @return {Array}
	* @public
	*/
	defineGetter(req$1, "ips", function ips() {
		var trust = this.app.get("trust proxy fn");
		var addrs = proxyaddr.all(this, trust);
		addrs.reverse().pop();
		return addrs;
	});
	/**
	* Return subdomains as an array.
	*
	* Subdomains are the dot-separated parts of the host before the main domain of
	* the app. By default, the domain of the app is assumed to be the last two
	* parts of the host. This can be changed by setting "subdomain offset".
	*
	* For example, if the domain is "tobi.ferrets.example.com":
	* If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
	* If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
	*
	* @return {Array}
	* @public
	*/
	defineGetter(req$1, "subdomains", function subdomains() {
		var hostname = this.hostname;
		if (!hostname) return [];
		var offset = this.app.get("subdomain offset");
		return (!isIP(hostname) ? hostname.split(".").reverse() : [hostname]).slice(offset);
	});
	/**
	* Short-hand for `url.parse(req.url).pathname`.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req$1, "path", function path$19() {
		return parse$2(this).pathname;
	});
	/**
	* Parse the "Host" header field to a hostname.
	*
	* When the "trust proxy" setting trusts the socket
	* address, the "X-Forwarded-Host" header field will
	* be trusted.
	*
	* @return {String}
	* @public
	*/
	defineGetter(req$1, "hostname", function hostname() {
		var trust = this.app.get("trust proxy fn");
		var host = this.get("X-Forwarded-Host");
		if (!host || !trust(this.connection.remoteAddress, 0)) host = this.get("Host");
		else if (host.indexOf(",") !== -1) host = host.substring(0, host.indexOf(",")).trimRight();
		if (!host) return;
		var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
		var index$1 = host.indexOf(":", offset);
		return index$1 !== -1 ? host.substring(0, index$1) : host;
	});
	defineGetter(req$1, "host", deprecate$1.function(function host() {
		return this.hostname;
	}, "req.host: Use req.hostname instead"));
	/**
	* Check if the request is fresh, aka
	* Last-Modified and/or the ETag
	* still match.
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req$1, "fresh", function() {
		var method$1 = this.method;
		var res$2 = this.res;
		var status$1 = res$2.statusCode;
		if ("GET" !== method$1 && "HEAD" !== method$1) return false;
		if (status$1 >= 200 && status$1 < 300 || 304 === status$1) return fresh(this.headers, {
			"etag": res$2.get("ETag"),
			"last-modified": res$2.get("Last-Modified")
		});
		return false;
	});
	/**
	* Check if the request is stale, aka
	* "Last-Modified" and / or the "ETag" for the
	* resource has changed.
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req$1, "stale", function stale() {
		return !this.fresh;
	});
	/**
	* Check if the request was an _XMLHttpRequest_.
	*
	* @return {Boolean}
	* @public
	*/
	defineGetter(req$1, "xhr", function xhr() {
		return (this.get("X-Requested-With") || "").toLowerCase() === "xmlhttprequest";
	});
	/**
	* Helper function for creating a getter on an object.
	*
	* @param {Object} obj
	* @param {String} name
	* @param {Function} getter
	* @private
	*/
	function defineGetter(obj, name, getter) {
		Object.defineProperty(obj, name, {
			configurable: true,
			enumerable: true,
			get: getter
		});
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/cookie-signature@1.0.6/node_modules/cookie-signature/index.js
var require_cookie_signature = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cookie-signature@1.0.6/node_modules/cookie-signature/index.js": ((exports) => {
	/**
	* Module dependencies.
	*/
	var crypto = __require("crypto");
	/**
	* Sign the given `val` with `secret`.
	*
	* @param {String} val
	* @param {String} secret
	* @return {String}
	* @api private
	*/
	exports.sign = function(val, secret) {
		if ("string" != typeof val) throw new TypeError("Cookie value must be provided as a string.");
		if ("string" != typeof secret) throw new TypeError("Secret string must be provided.");
		return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
	};
	/**
	* Unsign and decode the given `val` with `secret`,
	* returning `false` if the signature is invalid.
	*
	* @param {String} val
	* @param {String} secret
	* @return {String|Boolean}
	* @api private
	*/
	exports.unsign = function(val, secret) {
		if ("string" != typeof val) throw new TypeError("Signed cookie string must be provided.");
		if ("string" != typeof secret) throw new TypeError("Secret string must be provided.");
		var str = val.slice(0, val.lastIndexOf("."));
		return sha1(exports.sign(str, secret)) == sha1(val) ? str : false;
	};
	/**
	* Private
	*/
	function sha1(str) {
		return crypto.createHash("sha1").update(str).digest("hex");
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/cookie@0.7.1/node_modules/cookie/index.js
var require_cookie = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/cookie@0.7.1/node_modules/cookie/index.js": ((exports) => {
	/**
	* Module exports.
	* @public
	*/
	exports.parse = parse$1;
	exports.serialize = serialize;
	/**
	* Module variables.
	* @private
	*/
	var __toString = Object.prototype.toString;
	/**
	* RegExp to match cookie-name in RFC 6265 sec 4.1.1
	* This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
	* which has been replaced by the token definition in RFC 7230 appendix B.
	*
	* cookie-name       = token
	* token             = 1*tchar
	* tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
	*                     "*" / "+" / "-" / "." / "^" / "_" /
	*                     "`" / "|" / "~" / DIGIT / ALPHA
	*/
	var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
	/**
	* RegExp to match cookie-value in RFC 6265 sec 4.1.1
	*
	* cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	* cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	*                     ; US-ASCII characters excluding CTLs,
	*                     ; whitespace DQUOTE, comma, semicolon,
	*                     ; and backslash
	*/
	var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
	/**
	* RegExp to match domain-value in RFC 6265 sec 4.1.1
	*
	* domain-value      = <subdomain>
	*                     ; defined in [RFC1034], Section 3.5, as
	*                     ; enhanced by [RFC1123], Section 2.1
	* <subdomain>       = <label> | <subdomain> "." <label>
	* <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
	*                     Labels must be 63 characters or less.
	*                     'let-dig' not 'letter' in the first char, per RFC1123
	* <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	* <let-dig-hyp>     = <let-dig> | "-"
	* <let-dig>         = <letter> | <digit>
	* <letter>          = any one of the 52 alphabetic characters A through Z in
	*                     upper case and a through z in lower case
	* <digit>           = any one of the ten digits 0 through 9
	*
	* Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
	*
	* > (Note that a leading %x2E ("."), if present, is ignored even though that
	* character is not permitted, but a trailing %x2E ("."), if present, will
	* cause the user agent to ignore the attribute.)
	*/
	var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
	/**
	* RegExp to match path-value in RFC 6265 sec 4.1.1
	*
	* path-value        = <any CHAR except CTLs or ";">
	* CHAR              = %x01-7F
	*                     ; defined in RFC 5234 appendix B.1
	*/
	var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
	/**
	* Parse a cookie header.
	*
	* Parse the given cookie header string into an object
	* The object has the various cookies as keys(names) => values
	*
	* @param {string} str
	* @param {object} [opt]
	* @return {object}
	* @public
	*/
	function parse$1(str, opt) {
		if (typeof str !== "string") throw new TypeError("argument str must be a string");
		var obj = {};
		var len$1 = str.length;
		if (len$1 < 2) return obj;
		var dec = opt && opt.decode || decode;
		var index$1 = 0;
		var eqIdx = 0;
		var endIdx = 0;
		do {
			eqIdx = str.indexOf("=", index$1);
			if (eqIdx === -1) break;
			endIdx = str.indexOf(";", index$1);
			if (endIdx === -1) endIdx = len$1;
			else if (eqIdx > endIdx) {
				index$1 = str.lastIndexOf(";", eqIdx - 1) + 1;
				continue;
			}
			var keyStartIdx = startIndex(str, index$1, eqIdx);
			var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
			var key$1 = str.slice(keyStartIdx, keyEndIdx);
			if (!obj.hasOwnProperty(key$1)) {
				var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
				var valEndIdx = endIndex(str, endIdx, valStartIdx);
				if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {
					valStartIdx++;
					valEndIdx--;
				}
				obj[key$1] = tryDecode(str.slice(valStartIdx, valEndIdx), dec);
			}
			index$1 = endIdx + 1;
		} while (index$1 < len$1);
		return obj;
	}
	function startIndex(str, index$1, max$9) {
		do {
			var code$1 = str.charCodeAt(index$1);
			if (code$1 !== 32 && code$1 !== 9) return index$1;
		} while (++index$1 < max$9);
		return max$9;
	}
	function endIndex(str, index$1, min$8) {
		while (index$1 > min$8) {
			var code$1 = str.charCodeAt(--index$1);
			if (code$1 !== 32 && code$1 !== 9) return index$1 + 1;
		}
		return min$8;
	}
	/**
	* Serialize data into a cookie header.
	*
	* Serialize a name value pair into a cookie string suitable for
	* http headers. An optional options object specifies cookie parameters.
	*
	* serialize('foo', 'bar', { httpOnly: true })
	*   => "foo=bar; httpOnly"
	*
	* @param {string} name
	* @param {string} val
	* @param {object} [opt]
	* @return {string}
	* @public
	*/
	function serialize(name, val, opt) {
		var enc$1 = opt && opt.encode || encodeURIComponent;
		if (typeof enc$1 !== "function") throw new TypeError("option encode is invalid");
		if (!cookieNameRegExp.test(name)) throw new TypeError("argument name is invalid");
		var value = enc$1(val);
		if (!cookieValueRegExp.test(value)) throw new TypeError("argument val is invalid");
		var str = name + "=" + value;
		if (!opt) return str;
		if (null != opt.maxAge) {
			var maxAge = Math.floor(opt.maxAge);
			if (!isFinite(maxAge)) throw new TypeError("option maxAge is invalid");
			str += "; Max-Age=" + maxAge;
		}
		if (opt.domain) {
			if (!domainValueRegExp.test(opt.domain)) throw new TypeError("option domain is invalid");
			str += "; Domain=" + opt.domain;
		}
		if (opt.path) {
			if (!pathValueRegExp.test(opt.path)) throw new TypeError("option path is invalid");
			str += "; Path=" + opt.path;
		}
		if (opt.expires) {
			var expires = opt.expires;
			if (!isDate(expires) || isNaN(expires.valueOf())) throw new TypeError("option expires is invalid");
			str += "; Expires=" + expires.toUTCString();
		}
		if (opt.httpOnly) str += "; HttpOnly";
		if (opt.secure) str += "; Secure";
		if (opt.partitioned) str += "; Partitioned";
		if (opt.priority) switch (typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority) {
			case "low":
				str += "; Priority=Low";
				break;
			case "medium":
				str += "; Priority=Medium";
				break;
			case "high":
				str += "; Priority=High";
				break;
			default: throw new TypeError("option priority is invalid");
		}
		if (opt.sameSite) switch (typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite) {
			case true:
				str += "; SameSite=Strict";
				break;
			case "lax":
				str += "; SameSite=Lax";
				break;
			case "strict":
				str += "; SameSite=Strict";
				break;
			case "none":
				str += "; SameSite=None";
				break;
			default: throw new TypeError("option sameSite is invalid");
		}
		return str;
	}
	/**
	* URL-decode string value. Optimized to skip native call when no %.
	*
	* @param {string} str
	* @returns {string}
	*/
	function decode(str) {
		return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
	}
	/**
	* Determine if value is a Date.
	*
	* @param {*} val
	* @private
	*/
	function isDate(val) {
		return __toString.call(val) === "[object Date]";
	}
	/**
	* Try decoding a string using a decoding function.
	*
	* @param {string} str
	* @param {function} decode
	* @private
	*/
	function tryDecode(str, decode$5) {
		try {
			return decode$5(str);
		} catch (e) {
			return str;
		}
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/response.js
var require_response = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/response.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var Buffer$1 = require_safe_buffer().Buffer;
	var contentDisposition = require_content_disposition();
	var createError = require_http_errors();
	var deprecate = require_depd()("express");
	var encodeUrl$1 = require_encodeurl$1();
	var escapeHtml$1 = require_escape_html();
	var http$1 = __require("http");
	var isAbsolute = require_utils().isAbsolute;
	var onFinished = require_on_finished();
	var path$2 = __require("path");
	var statuses = require_statuses();
	var merge = require_utils_merge();
	var sign = require_cookie_signature().sign;
	var normalizeType = require_utils().normalizeType;
	var normalizeTypes = require_utils().normalizeTypes;
	var setCharset = require_utils().setCharset;
	var cookie = require_cookie();
	var send$1 = require_send();
	var extname = path$2.extname;
	var mime = send$1.mime;
	var resolve$1 = path$2.resolve;
	var vary = require_vary();
	/**
	* Response prototype.
	* @public
	*/
	var res$1 = Object.create(http$1.ServerResponse.prototype);
	/**
	* Module exports.
	* @public
	*/
	module.exports = res$1;
	/**
	* Module variables.
	* @private
	*/
	var charsetRegExp = /;\s*charset\s*=/;
	/**
	* Set status `code`.
	*
	* @param {Number} code
	* @return {ServerResponse}
	* @public
	*/
	res$1.status = function status$1(code$1) {
		if ((typeof code$1 === "string" || Math.floor(code$1) !== code$1) && code$1 > 99 && code$1 < 1e3) deprecate("res.status(" + JSON.stringify(code$1) + "): use res.status(" + Math.floor(code$1) + ") instead");
		this.statusCode = code$1;
		return this;
	};
	/**
	* Set Link header field with the given `links`.
	*
	* Examples:
	*
	*    res.links({
	*      next: 'http://api.example.com/users?page=2',
	*      last: 'http://api.example.com/users?page=5'
	*    });
	*
	* @param {Object} links
	* @return {ServerResponse}
	* @public
	*/
	res$1.links = function(links) {
		var link = this.get("Link") || "";
		if (link) link += ", ";
		return this.set("Link", link + Object.keys(links).map(function(rel) {
			return "<" + links[rel] + ">; rel=\"" + rel + "\"";
		}).join(", "));
	};
	/**
	* Send a response.
	*
	* Examples:
	*
	*     res.send(Buffer.from('wahoo'));
	*     res.send({ some: 'json' });
	*     res.send('<p>some html</p>');
	*
	* @param {string|number|boolean|object|Buffer} body
	* @public
	*/
	res$1.send = function send$4(body$1) {
		var chunk = body$1;
		var encoding;
		var req$2 = this.req;
		var type;
		var app$1 = this.app;
		if (arguments.length === 2) if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
			deprecate("res.send(body, status): Use res.status(status).send(body) instead");
			this.statusCode = arguments[1];
		} else {
			deprecate("res.send(status, body): Use res.status(status).send(body) instead");
			this.statusCode = arguments[0];
			chunk = arguments[1];
		}
		if (typeof chunk === "number" && arguments.length === 1) {
			if (!this.get("Content-Type")) this.type("txt");
			deprecate("res.send(status): Use res.sendStatus(status) instead");
			this.statusCode = chunk;
			chunk = statuses.message[chunk];
		}
		switch (typeof chunk) {
			case "string":
				if (!this.get("Content-Type")) this.type("html");
				break;
			case "boolean":
			case "number":
			case "object":
				if (chunk === null) chunk = "";
				else if (Buffer$1.isBuffer(chunk)) {
					if (!this.get("Content-Type")) this.type("bin");
				} else return this.json(chunk);
				break;
		}
		if (typeof chunk === "string") {
			encoding = "utf8";
			type = this.get("Content-Type");
			if (typeof type === "string") this.set("Content-Type", setCharset(type, "utf-8"));
		}
		var etagFn = app$1.get("etag fn");
		var generateETag = !this.get("ETag") && typeof etagFn === "function";
		var len$1;
		if (chunk !== void 0) {
			if (Buffer$1.isBuffer(chunk)) len$1 = chunk.length;
			else if (!generateETag && chunk.length < 1e3) len$1 = Buffer$1.byteLength(chunk, encoding);
			else {
				chunk = Buffer$1.from(chunk, encoding);
				encoding = void 0;
				len$1 = chunk.length;
			}
			this.set("Content-Length", len$1);
		}
		var etag$3;
		if (generateETag && len$1 !== void 0) {
			if (etag$3 = etagFn(chunk, encoding)) this.set("ETag", etag$3);
		}
		if (req$2.fresh) this.statusCode = 304;
		if (204 === this.statusCode || 304 === this.statusCode) {
			this.removeHeader("Content-Type");
			this.removeHeader("Content-Length");
			this.removeHeader("Transfer-Encoding");
			chunk = "";
		}
		if (this.statusCode === 205) {
			this.set("Content-Length", "0");
			this.removeHeader("Transfer-Encoding");
			chunk = "";
		}
		if (req$2.method === "HEAD") this.end();
		else this.end(chunk, encoding);
		return this;
	};
	/**
	* Send JSON response.
	*
	* Examples:
	*
	*     res.json(null);
	*     res.json({ user: 'tj' });
	*
	* @param {string|number|boolean|object} obj
	* @public
	*/
	res$1.json = function json$1(obj) {
		var val = obj;
		if (arguments.length === 2) if (typeof arguments[1] === "number") {
			deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
			this.statusCode = arguments[1];
		} else {
			deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
			this.statusCode = arguments[0];
			val = arguments[1];
		}
		var app$1 = this.app;
		var escape$1 = app$1.get("json escape");
		var replacer = app$1.get("json replacer");
		var spaces = app$1.get("json spaces");
		var body$1 = stringify$1(val, replacer, spaces, escape$1);
		if (!this.get("Content-Type")) this.set("Content-Type", "application/json");
		return this.send(body$1);
	};
	/**
	* Send JSON response with JSONP callback support.
	*
	* Examples:
	*
	*     res.jsonp(null);
	*     res.jsonp({ user: 'tj' });
	*
	* @param {string|number|boolean|object} obj
	* @public
	*/
	res$1.jsonp = function jsonp(obj) {
		var val = obj;
		if (arguments.length === 2) if (typeof arguments[1] === "number") {
			deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
			this.statusCode = arguments[1];
		} else {
			deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
			this.statusCode = arguments[0];
			val = arguments[1];
		}
		var app$1 = this.app;
		var escape$1 = app$1.get("json escape");
		var replacer = app$1.get("json replacer");
		var spaces = app$1.get("json spaces");
		var body$1 = stringify$1(val, replacer, spaces, escape$1);
		var callback = this.req.query[app$1.get("jsonp callback name")];
		if (!this.get("Content-Type")) {
			this.set("X-Content-Type-Options", "nosniff");
			this.set("Content-Type", "application/json");
		}
		if (Array.isArray(callback)) callback = callback[0];
		if (typeof callback === "string" && callback.length !== 0) {
			this.set("X-Content-Type-Options", "nosniff");
			this.set("Content-Type", "text/javascript");
			callback = callback.replace(/[^\[\]\w$.]/g, "");
			if (body$1 === void 0) body$1 = "";
			else if (typeof body$1 === "string") body$1 = body$1.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
			body$1 = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body$1 + ");";
		}
		return this.send(body$1);
	};
	/**
	* Send given HTTP status code.
	*
	* Sets the response status to `statusCode` and the body of the
	* response to the standard description from node's http.STATUS_CODES
	* or the statusCode number if no description.
	*
	* Examples:
	*
	*     res.sendStatus(200);
	*
	* @param {number} statusCode
	* @public
	*/
	res$1.sendStatus = function sendStatus(statusCode) {
		var body$1 = statuses.message[statusCode] || String(statusCode);
		this.statusCode = statusCode;
		this.type("txt");
		return this.send(body$1);
	};
	/**
	* Transfer the file at the given `path`.
	*
	* Automatically sets the _Content-Type_ response header field.
	* The callback `callback(err)` is invoked when the transfer is complete
	* or when an error occurs. Be sure to check `res.headersSent`
	* if you wish to attempt responding, as the header and some data
	* may have already been transferred.
	*
	* Options:
	*
	*   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	*   - `root`     root directory for relative filenames
	*   - `headers`  object of headers to serve with file
	*   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	*
	* Other options are passed along to `send`.
	*
	* Examples:
	*
	*  The following example illustrates how `res.sendFile()` may
	*  be used as an alternative for the `static()` middleware for
	*  dynamic situations. The code backing `res.sendFile()` is actually
	*  the same code, so HTTP cache support etc is identical.
	*
	*     app.get('/user/:uid/photos/:file', function(req, res){
	*       var uid = req.params.uid
	*         , file = req.params.file;
	*
	*       req.user.mayViewFilesFrom(uid, function(yes){
	*         if (yes) {
	*           res.sendFile('/uploads/' + uid + '/' + file);
	*         } else {
	*           res.send(403, 'Sorry! you cant see that.');
	*         }
	*       });
	*     });
	*
	* @public
	*/
	res$1.sendFile = function sendFile(path$19, options, callback) {
		var done = callback;
		var req$2 = this.req;
		var res$2 = this;
		var next = req$2.next;
		var opts = options || {};
		if (!path$19) throw new TypeError("path argument is required to res.sendFile");
		if (typeof path$19 !== "string") throw new TypeError("path must be a string to res.sendFile");
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (!opts.root && !isAbsolute(path$19)) throw new TypeError("path must be absolute or specify root to res.sendFile");
		sendfile(res$2, send$1(req$2, encodeURI(path$19), opts), opts, function(err) {
			if (done) return done(err);
			if (err && err.code === "EISDIR") return next();
			if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") next(err);
		});
	};
	/**
	* Transfer the file at the given `path`.
	*
	* Automatically sets the _Content-Type_ response header field.
	* The callback `callback(err)` is invoked when the transfer is complete
	* or when an error occurs. Be sure to check `res.headersSent`
	* if you wish to attempt responding, as the header and some data
	* may have already been transferred.
	*
	* Options:
	*
	*   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
	*   - `root`     root directory for relative filenames
	*   - `headers`  object of headers to serve with file
	*   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
	*
	* Other options are passed along to `send`.
	*
	* Examples:
	*
	*  The following example illustrates how `res.sendfile()` may
	*  be used as an alternative for the `static()` middleware for
	*  dynamic situations. The code backing `res.sendfile()` is actually
	*  the same code, so HTTP cache support etc is identical.
	*
	*     app.get('/user/:uid/photos/:file', function(req, res){
	*       var uid = req.params.uid
	*         , file = req.params.file;
	*
	*       req.user.mayViewFilesFrom(uid, function(yes){
	*         if (yes) {
	*           res.sendfile('/uploads/' + uid + '/' + file);
	*         } else {
	*           res.send(403, 'Sorry! you cant see that.');
	*         }
	*       });
	*     });
	*
	* @public
	*/
	res$1.sendfile = function(path$19, options, callback) {
		var done = callback;
		var req$2 = this.req;
		var res$2 = this;
		var next = req$2.next;
		var opts = options || {};
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		sendfile(res$2, send$1(req$2, path$19, opts), opts, function(err) {
			if (done) return done(err);
			if (err && err.code === "EISDIR") return next();
			if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") next(err);
		});
	};
	res$1.sendfile = deprecate.function(res$1.sendfile, "res.sendfile: Use res.sendFile instead");
	/**
	* Transfer the file at the given `path` as an attachment.
	*
	* Optionally providing an alternate attachment `filename`,
	* and optional callback `callback(err)`. The callback is invoked
	* when the data transfer is complete, or when an error has
	* occurred. Be sure to check `res.headersSent` if you plan to respond.
	*
	* Optionally providing an `options` object to use with `res.sendFile()`.
	* This function will set the `Content-Disposition` header, overriding
	* any `Content-Disposition` header passed as header options in order
	* to set the attachment and filename.
	*
	* This method uses `res.sendFile()`.
	*
	* @public
	*/
	res$1.download = function download(path$19, filename, options, callback) {
		var done = callback;
		var name = filename;
		var opts = options || null;
		if (typeof filename === "function") {
			done = filename;
			name = null;
			opts = null;
		} else if (typeof options === "function") {
			done = options;
			opts = null;
		}
		if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
			name = null;
			opts = filename;
		}
		var headers$1 = { "Content-Disposition": contentDisposition(name || path$19) };
		if (opts && opts.headers) {
			var keys$6 = Object.keys(opts.headers);
			for (var i$8 = 0; i$8 < keys$6.length; i$8++) {
				var key$1 = keys$6[i$8];
				if (key$1.toLowerCase() !== "content-disposition") headers$1[key$1] = opts.headers[key$1];
			}
		}
		opts = Object.create(opts);
		opts.headers = headers$1;
		var fullPath = !opts.root ? resolve$1(path$19) : path$19;
		return this.sendFile(fullPath, opts, done);
	};
	/**
	* Set _Content-Type_ response header with `type` through `mime.lookup()`
	* when it does not contain "/", or set the Content-Type to `type` otherwise.
	*
	* Examples:
	*
	*     res.type('.html');
	*     res.type('html');
	*     res.type('json');
	*     res.type('application/json');
	*     res.type('png');
	*
	* @param {String} type
	* @return {ServerResponse} for chaining
	* @public
	*/
	res$1.contentType = res$1.type = function contentType$5(type) {
		var ct = type.indexOf("/") === -1 ? mime.lookup(type) : type;
		return this.set("Content-Type", ct);
	};
	/**
	* Respond to the Acceptable formats using an `obj`
	* of mime-type callbacks.
	*
	* This method uses `req.accepted`, an array of
	* acceptable types ordered by their quality values.
	* When "Accept" is not present the _first_ callback
	* is invoked, otherwise the first match is used. When
	* no match is performed the server responds with
	* 406 "Not Acceptable".
	*
	* Content-Type is set for you, however if you choose
	* you may alter this within the callback using `res.type()`
	* or `res.set('Content-Type', ...)`.
	*
	*    res.format({
	*      'text/plain': function(){
	*        res.send('hey');
	*      },
	*
	*      'text/html': function(){
	*        res.send('<p>hey</p>');
	*      },
	*
	*      'application/json': function () {
	*        res.send({ message: 'hey' });
	*      }
	*    });
	*
	* In addition to canonicalized MIME types you may
	* also use extnames mapped to these types:
	*
	*    res.format({
	*      text: function(){
	*        res.send('hey');
	*      },
	*
	*      html: function(){
	*        res.send('<p>hey</p>');
	*      },
	*
	*      json: function(){
	*        res.send({ message: 'hey' });
	*      }
	*    });
	*
	* By default Express passes an `Error`
	* with a `.status` of 406 to `next(err)`
	* if a match is not made. If you provide
	* a `.default` callback it will be invoked
	* instead.
	*
	* @param {Object} obj
	* @return {ServerResponse} for chaining
	* @public
	*/
	res$1.format = function(obj) {
		var req$2 = this.req;
		var next = req$2.next;
		var keys$6 = Object.keys(obj).filter(function(v) {
			return v !== "default";
		});
		var key$1 = keys$6.length > 0 ? req$2.accepts(keys$6) : false;
		this.vary("Accept");
		if (key$1) {
			this.set("Content-Type", normalizeType(key$1).value);
			obj[key$1](req$2, this, next);
		} else if (obj.default) obj.default(req$2, this, next);
		else next(createError(406, { types: normalizeTypes(keys$6).map(function(o) {
			return o.value;
		}) }));
		return this;
	};
	/**
	* Set _Content-Disposition_ header to _attachment_ with optional `filename`.
	*
	* @param {String} filename
	* @return {ServerResponse}
	* @public
	*/
	res$1.attachment = function attachment(filename) {
		if (filename) this.type(extname(filename));
		this.set("Content-Disposition", contentDisposition(filename));
		return this;
	};
	/**
	* Append additional header `field` with value `val`.
	*
	* Example:
	*
	*    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
	*    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
	*    res.append('Warning', '199 Miscellaneous warning');
	*
	* @param {String} field
	* @param {String|Array} val
	* @return {ServerResponse} for chaining
	* @public
	*/
	res$1.append = function append$1(field, val) {
		var prev = this.get(field);
		var value = val;
		if (prev) value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
		return this.set(field, value);
	};
	/**
	* Set header `field` to `val`, or pass
	* an object of header fields.
	*
	* Examples:
	*
	*    res.set('Foo', ['bar', 'baz']);
	*    res.set('Accept', 'application/json');
	*    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
	*
	* Aliased as `res.header()`.
	*
	* @param {String|Object} field
	* @param {String|Array} val
	* @return {ServerResponse} for chaining
	* @public
	*/
	res$1.set = res$1.header = function header(field, val) {
		if (arguments.length === 2) {
			var value = Array.isArray(val) ? val.map(String) : String(val);
			if (field.toLowerCase() === "content-type") {
				if (Array.isArray(value)) throw new TypeError("Content-Type cannot be set to an Array");
				if (!charsetRegExp.test(value)) {
					var charset$1 = mime.charsets.lookup(value.split(";")[0]);
					if (charset$1) value += "; charset=" + charset$1.toLowerCase();
				}
			}
			this.setHeader(field, value);
		} else for (var key$1 in field) this.set(key$1, field[key$1]);
		return this;
	};
	/**
	* Get value for header `field`.
	*
	* @param {String} field
	* @return {String}
	* @public
	*/
	res$1.get = function(field) {
		return this.getHeader(field);
	};
	/**
	* Clear cookie `name`.
	*
	* @param {String} name
	* @param {Object} [options]
	* @return {ServerResponse} for chaining
	* @public
	*/
	res$1.clearCookie = function clearCookie(name, options) {
		if (options) {
			if (options.maxAge) deprecate("res.clearCookie: Passing \"options.maxAge\" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.");
			if (options.expires) deprecate("res.clearCookie: Passing \"options.expires\" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.");
		}
		var opts = merge({
			expires: /* @__PURE__ */ new Date(1),
			path: "/"
		}, options);
		return this.cookie(name, "", opts);
	};
	/**
	* Set cookie `name` to `value`, with the given `options`.
	*
	* Options:
	*
	*    - `maxAge`   max-age in milliseconds, converted to `expires`
	*    - `signed`   sign the cookie
	*    - `path`     defaults to "/"
	*
	* Examples:
	*
	*    // "Remember Me" for 15 minutes
	*    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
	*
	*    // same as above
	*    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
	*
	* @param {String} name
	* @param {String|Object} value
	* @param {Object} [options]
	* @return {ServerResponse} for chaining
	* @public
	*/
	res$1.cookie = function(name, value, options) {
		var opts = merge({}, options);
		var secret = this.req.secret;
		var signed = opts.signed;
		if (signed && !secret) throw new Error("cookieParser(\"secret\") required for signed cookies");
		var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
		if (signed) val = "s:" + sign(val, secret);
		if (opts.maxAge != null) {
			var maxAge = opts.maxAge - 0;
			if (!isNaN(maxAge)) {
				opts.expires = new Date(Date.now() + maxAge);
				opts.maxAge = Math.floor(maxAge / 1e3);
			}
		}
		if (opts.path == null) opts.path = "/";
		this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
		return this;
	};
	/**
	* Set the location header to `url`.
	*
	* The given `url` can also be "back", which redirects
	* to the _Referrer_ or _Referer_ headers or "/".
	*
	* Examples:
	*
	*    res.location('/foo/bar').;
	*    res.location('http://example.com');
	*    res.location('../login');
	*
	* @param {String} url
	* @return {ServerResponse} for chaining
	* @public
	*/
	res$1.location = function location(url$6) {
		var loc;
		if (url$6 === "back") {
			deprecate("res.location(\"back\"): use res.location(req.get(\"Referrer\") || \"/\") and refer to https://dub.sh/security-redirect for best practices");
			loc = this.req.get("Referrer") || "/";
		} else loc = String(url$6);
		return this.set("Location", encodeUrl$1(loc));
	};
	/**
	* Redirect to the given `url` with optional response `status`
	* defaulting to 302.
	*
	* The resulting `url` is determined by `res.location()`, so
	* it will play nicely with mounted apps, relative paths,
	* `"back"` etc.
	*
	* Examples:
	*
	*    res.redirect('/foo/bar');
	*    res.redirect('http://example.com');
	*    res.redirect(301, 'http://example.com');
	*    res.redirect('../login'); // /blog/post/1 -> /blog/login
	*
	* @public
	*/
	res$1.redirect = function redirect(url$6) {
		var address = url$6;
		var body$1;
		var status$1 = 302;
		if (arguments.length === 2) if (typeof arguments[0] === "number") {
			status$1 = arguments[0];
			address = arguments[1];
		} else {
			deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
			status$1 = arguments[1];
		}
		address = this.location(address).get("Location");
		this.format({
			text: function() {
				body$1 = statuses.message[status$1] + ". Redirecting to " + address;
			},
			html: function() {
				var u$12 = escapeHtml$1(address);
				body$1 = "<p>" + statuses.message[status$1] + ". Redirecting to " + u$12 + "</p>";
			},
			default: function() {
				body$1 = "";
			}
		});
		this.statusCode = status$1;
		this.set("Content-Length", Buffer$1.byteLength(body$1));
		if (this.req.method === "HEAD") this.end();
		else this.end(body$1);
	};
	/**
	* Add `field` to Vary. If already present in the Vary set, then
	* this call is simply ignored.
	*
	* @param {Array|String} field
	* @return {ServerResponse} for chaining
	* @public
	*/
	res$1.vary = function(field) {
		if (!field || Array.isArray(field) && !field.length) {
			deprecate("res.vary(): Provide a field name");
			return this;
		}
		vary(this, field);
		return this;
	};
	/**
	* Render `view` with the given `options` and optional callback `fn`.
	* When a callback function is given a response will _not_ be made
	* automatically, otherwise a response of _200_ and _text/html_ is given.
	*
	* Options:
	*
	*  - `cache`     boolean hinting to the engine it should cache
	*  - `filename`  filename of the view being rendered
	*
	* @public
	*/
	res$1.render = function render(view, options, callback) {
		var app$1 = this.req.app;
		var done = callback;
		var opts = options || {};
		var req$2 = this.req;
		var self$1 = this;
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		opts._locals = self$1.locals;
		done = done || function(err, str) {
			if (err) return req$2.next(err);
			self$1.send(str);
		};
		app$1.render(view, opts, done);
	};
	function sendfile(res$2, file, options, callback) {
		var done = false;
		var streaming;
		function onaborted() {
			if (done) return;
			done = true;
			var err = /* @__PURE__ */ new Error("Request aborted");
			err.code = "ECONNABORTED";
			callback(err);
		}
		function ondirectory() {
			if (done) return;
			done = true;
			var err = /* @__PURE__ */ new Error("EISDIR, read");
			err.code = "EISDIR";
			callback(err);
		}
		function onerror(err) {
			if (done) return;
			done = true;
			callback(err);
		}
		function onend() {
			if (done) return;
			done = true;
			callback();
		}
		function onfile() {
			streaming = false;
		}
		function onfinish(err) {
			if (err && err.code === "ECONNRESET") return onaborted();
			if (err) return onerror(err);
			if (done) return;
			setImmediate(function() {
				if (streaming !== false && !done) {
					onaborted();
					return;
				}
				if (done) return;
				done = true;
				callback();
			});
		}
		function onstream() {
			streaming = true;
		}
		file.on("directory", ondirectory);
		file.on("end", onend);
		file.on("error", onerror);
		file.on("file", onfile);
		file.on("stream", onstream);
		onFinished(res$2, onfinish);
		if (options.headers) file.on("headers", function headers$1(res$3) {
			var obj = options.headers;
			var keys$6 = Object.keys(obj);
			for (var i$8 = 0; i$8 < keys$6.length; i$8++) {
				var k$7 = keys$6[i$8];
				res$3.setHeader(k$7, obj[k$7]);
			}
		});
		file.pipe(res$2);
	}
	/**
	* Stringify JSON, like JSON.stringify, but v8 optimized, with the
	* ability to escape characters that can trigger HTML sniffing.
	*
	* @param {*} value
	* @param {function} replacer
	* @param {number} spaces
	* @param {boolean} escape
	* @returns {string}
	* @private
	*/
	function stringify$1(value, replacer, spaces, escape$1) {
		var json$1 = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
		if (escape$1 && typeof json$1 === "string") json$1 = json$1.replace(/[<>&]/g, function(c) {
			switch (c.charCodeAt(0)) {
				case 60: return "\\u003c";
				case 62: return "\\u003e";
				case 38: return "\\u0026";
				default: return c;
			}
		});
		return json$1;
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/serve-static@1.16.2/node_modules/serve-static/index.js
var require_serve_static = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/serve-static@1.16.2/node_modules/serve-static/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var encodeUrl = require_encodeurl$1();
	var escapeHtml = require_escape_html();
	var parseUrl = require_parseurl();
	var resolve = __require("path").resolve;
	var send = require_send();
	var url = __require("url");
	/**
	* Module exports.
	* @public
	*/
	module.exports = serveStatic;
	module.exports.mime = send.mime;
	/**
	* @param {string} root
	* @param {object} [options]
	* @return {function}
	* @public
	*/
	function serveStatic(root$3, options) {
		if (!root$3) throw new TypeError("root path required");
		if (typeof root$3 !== "string") throw new TypeError("root path must be a string");
		var opts = Object.create(options || null);
		var fallthrough = opts.fallthrough !== false;
		var redirect = opts.redirect !== false;
		var setHeaders$2 = opts.setHeaders;
		if (setHeaders$2 && typeof setHeaders$2 !== "function") throw new TypeError("option setHeaders must be function");
		opts.maxage = opts.maxage || opts.maxAge || 0;
		opts.root = resolve(root$3);
		var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
		return function serveStatic$1(req$2, res$2, next) {
			if (req$2.method !== "GET" && req$2.method !== "HEAD") {
				if (fallthrough) return next();
				res$2.statusCode = 405;
				res$2.setHeader("Allow", "GET, HEAD");
				res$2.setHeader("Content-Length", "0");
				res$2.end();
				return;
			}
			var forwardError = !fallthrough;
			var originalUrl = parseUrl.original(req$2);
			var path$19 = parseUrl(req$2).pathname;
			if (path$19 === "/" && originalUrl.pathname.substr(-1) !== "/") path$19 = "";
			var stream$3 = send(req$2, path$19, opts);
			stream$3.on("directory", onDirectory);
			if (setHeaders$2) stream$3.on("headers", setHeaders$2);
			if (fallthrough) stream$3.on("file", function onFile$2() {
				forwardError = true;
			});
			stream$3.on("error", function error(err) {
				if (forwardError || !(err.statusCode < 500)) {
					next(err);
					return;
				}
				next();
			});
			stream$3.pipe(res$2);
		};
	}
	/**
	* Collapse all leading slashes into a single slash
	* @private
	*/
	function collapseLeadingSlashes(str) {
		for (var i$8 = 0; i$8 < str.length; i$8++) if (str.charCodeAt(i$8) !== 47) break;
		return i$8 > 1 ? "/" + str.substr(i$8) : str;
	}
	/**
	* Create a minimal HTML document.
	*
	* @param {string} title
	* @param {string} body
	* @private
	*/
	function createHtmlDocument(title, body$1) {
		return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>" + title + "</title>\n</head>\n<body>\n<pre>" + body$1 + "</pre>\n</body>\n</html>\n";
	}
	/**
	* Create a directory listener that just 404s.
	* @private
	*/
	function createNotFoundDirectoryListener() {
		return function notFound() {
			this.error(404);
		};
	}
	/**
	* Create a directory listener that performs a redirect.
	* @private
	*/
	function createRedirectDirectoryListener() {
		return function redirect(res$2) {
			if (this.hasTrailingSlash()) {
				this.error(404);
				return;
			}
			var originalUrl = parseUrl.original(this.req);
			originalUrl.path = null;
			originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
			var loc = encodeUrl(url.format(originalUrl));
			var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
			res$2.statusCode = 301;
			res$2.setHeader("Content-Type", "text/html; charset=UTF-8");
			res$2.setHeader("Content-Length", Buffer.byteLength(doc));
			res$2.setHeader("Content-Security-Policy", "default-src 'none'");
			res$2.setHeader("X-Content-Type-Options", "nosniff");
			res$2.setHeader("Location", loc);
			res$2.end(doc);
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/express.js
var require_express$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/express.js": ((exports, module) => {
	/**
	* Module dependencies.
	*/
	var bodyParser$1 = require_body_parser();
	var EventEmitter = __require("events").EventEmitter;
	var mixin = require_merge_descriptors();
	var proto = require_application();
	var Route = require_route();
	var Router = require_router();
	var req = require_request();
	var res = require_response();
	/**
	* Expose `createApplication()`.
	*/
	exports = module.exports = createApplication;
	/**
	* Create an express application.
	*
	* @return {Function}
	* @api public
	*/
	function createApplication() {
		var app$1 = function(req$2, res$2, next) {
			app$1.handle(req$2, res$2, next);
		};
		mixin(app$1, EventEmitter.prototype, false);
		mixin(app$1, proto, false);
		app$1.request = Object.create(req, { app: {
			configurable: true,
			enumerable: true,
			writable: true,
			value: app$1
		} });
		app$1.response = Object.create(res, { app: {
			configurable: true,
			enumerable: true,
			writable: true,
			value: app$1
		} });
		app$1.init();
		return app$1;
	}
	/**
	* Expose the prototypes.
	*/
	exports.application = proto;
	exports.request = req;
	exports.response = res;
	/**
	* Expose constructors.
	*/
	exports.Route = Route;
	exports.Router = Router;
	/**
	* Expose middleware
	*/
	exports.json = bodyParser$1.json;
	exports.query = require_query();
	exports.raw = bodyParser$1.raw;
	exports.static = require_serve_static();
	exports.text = bodyParser$1.text;
	exports.urlencoded = bodyParser$1.urlencoded;
	[
		"bodyParser",
		"compress",
		"cookieSession",
		"session",
		"logger",
		"cookieParser",
		"favicon",
		"responseTime",
		"errorHandler",
		"timeout",
		"methodOverride",
		"vhost",
		"csrf",
		"directory",
		"limit",
		"multipart",
		"staticCache"
	].forEach(function(name) {
		Object.defineProperty(exports, name, {
			get: function() {
				throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
			},
			configurable: true
		});
	});
}) });

//#endregion
//#region ../../node_modules/.pnpm/express@4.21.2/node_modules/express/index.js
var require_express = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/express@4.21.2/node_modules/express/index.js": ((exports, module) => {
	module.exports = require_express$1();
}) });

//#endregion
//#region ../../node_modules/.pnpm/http-graceful-shutdown@3.1.14/node_modules/http-graceful-shutdown/lib/index.js
var require_lib = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/http-graceful-shutdown@3.1.14/node_modules/http-graceful-shutdown/lib/index.js": ((exports, module) => {
	const debug = require_src$1()("http-graceful-shutdown");
	const http = __require("http");
	/**
	* Gracefully shuts down `server` when the process receives
	* the passed signals
	*
	* @param {http.Server} server
	* @param {object} opts
	*        signals: string (each signal separated by SPACE)
	*        timeout: timeout value for forceful shutdown in ms
	*        forceExit: force process.exit() - otherwise just let event loop clear
	*        development: boolean value (if true, no graceful shutdown to speed up development
	*        preShutdown: optional function. Needs to return a promise. - HTTP sockets are still available and untouched
	*        onShutdown: optional function. Needs to return a promise.
	*        finally: optional function, handled at the end of the shutdown.
	*/
	function GracefulShutdown(server, opts) {
		opts = opts || {};
		let options = Object.assign({
			signals: "SIGINT SIGTERM",
			timeout: 3e4,
			development: false,
			forceExit: true,
			onShutdown: (signal) => Promise.resolve(signal),
			preShutdown: (signal) => Promise.resolve(signal)
		}, opts);
		let isShuttingDown = false;
		let connections = {};
		let connectionCounter = 0;
		let secureConnections = {};
		let secureConnectionCounter = 0;
		let failed = false;
		let finalRun = false;
		function onceFactory() {
			let called = false;
			return (emitter$1, events, callback) => {
				function call$1() {
					if (!called) {
						called = true;
						return callback.apply(this, arguments);
					}
				}
				events.forEach((e) => emitter$1.on(e, call$1));
			};
		}
		const signals = options.signals.split(" ").map((s$3) => s$3.trim()).filter((s$3) => !!s$3.length);
		onceFactory()(process, signals, (signal) => {
			debug("received shut down signal", signal);
			shutdown(signal).then(() => {
				if (options.forceExit) process.exit(failed ? 1 : 0);
			}).catch((err) => {
				debug("server shut down error occurred", err);
				process.exit(1);
			});
		});
		function isFunction$3(functionToCheck) {
			let getType = Object.prototype.toString.call(functionToCheck);
			return /^\[object\s([a-zA-Z]+)?Function\]$/.test(getType);
		}
		function destroy$3(socket, force = false) {
			if (socket._isIdle && isShuttingDown || force) {
				socket.destroy();
				if (socket.server instanceof http.Server) delete connections[socket._connectionId];
				else delete secureConnections[socket._connectionId];
			}
		}
		function destroyAllConnections(force = false) {
			debug("Destroy Connections : " + (force ? "forced close" : "close"));
			let counter$5 = 0;
			let secureCounter = 0;
			Object.keys(connections).forEach(function(key$1) {
				const socket = connections[key$1];
				const serverResponse = socket._httpMessage;
				if (serverResponse && !force) {
					if (!serverResponse.headersSent) serverResponse.setHeader("connection", "close");
				} else {
					counter$5++;
					destroy$3(socket);
				}
			});
			debug("Connections destroyed : " + counter$5);
			debug("Connection Counter    : " + connectionCounter);
			Object.keys(secureConnections).forEach(function(key$1) {
				const socket = secureConnections[key$1];
				const serverResponse = socket._httpMessage;
				if (serverResponse && !force) {
					if (!serverResponse.headersSent) serverResponse.setHeader("connection", "close");
				} else {
					secureCounter++;
					destroy$3(socket);
				}
			});
			debug("Secure Connections destroyed : " + secureCounter);
			debug("Secure Connection Counter    : " + secureConnectionCounter);
		}
		server.on("request", function(req$2, res$2) {
			req$2.socket._isIdle = false;
			if (isShuttingDown && !res$2.headersSent) res$2.setHeader("connection", "close");
			res$2.on("finish", function() {
				req$2.socket._isIdle = true;
				destroy$3(req$2.socket);
			});
		});
		server.on("connection", function(socket) {
			if (isShuttingDown) socket.destroy();
			else {
				let id$7 = connectionCounter++;
				socket._isIdle = true;
				socket._connectionId = id$7;
				connections[id$7] = socket;
				socket.once("close", () => {
					delete connections[socket._connectionId];
				});
			}
		});
		server.on("secureConnection", (socket) => {
			if (isShuttingDown) socket.destroy();
			else {
				let id$7 = secureConnectionCounter++;
				socket._isIdle = true;
				socket._connectionId = id$7;
				secureConnections[id$7] = socket;
				socket.once("close", () => {
					delete secureConnections[socket._connectionId];
				});
			}
		});
		process.on("close", function() {
			debug("closed");
		});
		function shutdown(sig) {
			function cleanupHttp() {
				destroyAllConnections();
				debug("Close http server");
				return new Promise((resolve$6, reject) => {
					server.close((err) => {
						if (err) return reject(err);
						return resolve$6(true);
					});
				});
			}
			debug("shutdown signal - " + sig);
			if (options.development) {
				debug("DEV-Mode - immediate forceful shutdown");
				return process.exit(0);
			}
			function finalHandler() {
				if (!finalRun) {
					finalRun = true;
					if (options.finally && isFunction$3(options.finally)) {
						debug("executing finally()");
						options.finally();
					}
				}
				return Promise.resolve();
			}
			function waitForReadyToShutDown(totalNumInterval) {
				debug(`waitForReadyToShutDown... ${totalNumInterval}`);
				if (totalNumInterval === 0) {
					debug(`Could not close connections in time (${options.timeout}ms), will forcefully shut down`);
					return Promise.resolve(true);
				}
				if (Object.keys(connections).length === 0 && Object.keys(secureConnections).length === 0) {
					debug("All connections closed. Continue to shutting down");
					return Promise.resolve(false);
				}
				debug("Schedule the next waitForReadyToShutdown");
				return new Promise((resolve$6) => {
					setTimeout(() => {
						resolve$6(waitForReadyToShutDown(totalNumInterval - 1));
					}, 250);
				});
			}
			if (isShuttingDown) return Promise.resolve();
			debug("shutting down");
			return options.preShutdown(sig).then(() => {
				isShuttingDown = true;
				cleanupHttp();
			}).then(() => {
				return waitForReadyToShutDown(options.timeout ? Math.round(options.timeout / 250) : 0);
			}).then((force) => {
				debug("Do onShutdown now");
				if (force) destroyAllConnections(force);
				return options.onShutdown(sig);
			}).then(finalHandler).catch((err) => {
				const errString = typeof err === "string" ? err : JSON.stringify(err);
				debug(errString);
				failed = true;
				throw errString;
			});
		}
		function shutdownManual() {
			return shutdown("manual");
		}
		return shutdownManual;
	}
	module.exports = GracefulShutdown;
}) });

//#endregion
//#region ../../node_modules/.pnpm/nocache@3.0.4/node_modules/nocache/index.js
var require_nocache = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/nocache@3.0.4/node_modules/nocache/index.js": ((exports, module) => {
	module.exports = function nocache$1() {
		return function nocache$2(_, res$2, next) {
			res$2.setHeader("Surrogate-Control", "no-store");
			res$2.setHeader("Cache-Control", "no-store, no-cache, must-revalidate, proxy-revalidate");
			res$2.setHeader("Pragma", "no-cache");
			res$2.setHeader("Expires", "0");
			next();
		};
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/@pollyjs+node-server@6.0.6/node_modules/@pollyjs/node-server/dist/cjs/pollyjs-node-server.js
var require_pollyjs_node_server = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/@pollyjs+node-server@6.0.6/node_modules/@pollyjs/node-server/dist/cjs/pollyjs-node-server.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function _interopDefault$1(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var path$1 = _interopDefault$1(__require("path"));
	var fs = _interopDefault$1(require_lib$4());
	var utils = require_pollyjs_utils();
	var cors = _interopDefault$1(require_lib$3());
	var morgan = _interopDefault$1(require_morgan());
	var express = _interopDefault$1(require_express());
	var gracefulShutdown = _interopDefault$1(require_lib());
	var bodyParser = _interopDefault$1(require_body_parser());
	var nocache = _interopDefault$1(require_nocache());
	var API = class {
		constructor(options = {}) {
			const { recordingsDir } = options;
			utils.assert(`Invalid recordings directory provided. Expected string, received: "${typeof recordingsDir}".`, typeof recordingsDir === "string");
			this.recordingsDir = recordingsDir;
		}
		getRecording(recording) {
			const recordingFilename = this.filenameFor(recording);
			if (fs.existsSync(recordingFilename)) return this.respond(200, fs.readJsonSync(recordingFilename));
			return this.respond(204);
		}
		saveRecording(recording, data) {
			fs.outputJsonSync(this.filenameFor(recording), data, { spaces: 2 });
			return this.respond(201);
		}
		deleteRecording(recording) {
			const recordingFilename = this.filenameFor(recording);
			if (fs.existsSync(recordingFilename)) fs.removeSync(recordingFilename);
			return this.respond(200);
		}
		filenameFor(recording) {
			return path$1.join(this.recordingsDir, recording, "recording.har");
		}
		respond(status$1, body$1) {
			return {
				status: status$1,
				body: body$1
			};
		}
	};
	var _defined = function(it) {
		if (it == void 0) throw TypeError("Can't call method on  " + it);
		return it;
	};
	var _toObject = function(it) {
		return Object(_defined(it));
	};
	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function(it, key$1) {
		return hasOwnProperty.call(it, key$1);
	};
	var toString = {}.toString;
	var _cof = function(it) {
		return toString.call(it).slice(8, -1);
	};
	var _iobject = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
		return _cof(it) == "String" ? it.split("") : Object(it);
	};
	var _toIobject = function(it) {
		return _iobject(_defined(it));
	};
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function(it) {
		return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};
	var min = Math.min;
	var _toLength = function(it) {
		return it > 0 ? min(_toInteger(it), 9007199254740991) : 0;
	};
	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function(index$1, length) {
		index$1 = _toInteger(index$1);
		return index$1 < 0 ? max(index$1 + length, 0) : min$1(index$1, length);
	};
	var _arrayIncludes = function(IS_INCLUDES) {
		return function($this, el, fromIndex) {
			var O = _toIobject($this);
			var length = _toLength(O.length);
			var index$1 = _toAbsoluteIndex(fromIndex, length);
			var value;
			if (IS_INCLUDES && el != el) while (length > index$1) {
				value = O[index$1++];
				if (value != value) return true;
			}
			else for (; length > index$1; index$1++) if (IS_INCLUDES || index$1 in O) {
				if (O[index$1] === el) return IS_INCLUDES || index$1 || 0;
			}
			return !IS_INCLUDES && -1;
		};
	};
	function unwrapExports(x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
	}
	function createCommonjsModule(fn, module$2) {
		return module$2 = { exports: {} }, fn(module$2, module$2.exports), module$2.exports;
	}
	var _core = createCommonjsModule(function(module$2) {
		var core = module$2.exports = { version: "2.6.9" };
		if (typeof __e == "number") __e = core;
	});
	_core.version;
	var _global = createCommonjsModule(function(module$2) {
		var global$1 = module$2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
		if (typeof __g == "number") __g = global$1;
	});
	var _library = true;
	var _shared = createCommonjsModule(function(module$2) {
		var SHARED = "__core-js_shared__";
		var store = _global[SHARED] || (_global[SHARED] = {});
		(module$2.exports = function(key$1, value) {
			return store[key$1] || (store[key$1] = value !== void 0 ? value : {});
		})("versions", []).push({
			version: _core.version,
			mode: "pure",
			copyright: " 2019 Denis Pushkarev (zloirock.ru)"
		});
	});
	var id = 0;
	var px = Math.random();
	var _uid = function(key$1) {
		return "Symbol(".concat(key$1 === void 0 ? "" : key$1, ")_", (++id + px).toString(36));
	};
	var shared = _shared("keys");
	var _sharedKey = function(key$1) {
		return shared[key$1] || (shared[key$1] = _uid(key$1));
	};
	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey("IE_PROTO");
	var _objectKeysInternal = function(object, names) {
		var O = _toIobject(object);
		var i$8 = 0;
		var result = [];
		var key$1;
		for (key$1 in O) if (key$1 != IE_PROTO) _has(O, key$1) && result.push(key$1);
		while (names.length > i$8) if (_has(O, key$1 = names[i$8++])) ~arrayIndexOf(result, key$1) || result.push(key$1);
		return result;
	};
	var _enumBugKeys = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
	var _objectKeys = Object.keys || function keys$6(O) {
		return _objectKeysInternal(O, _enumBugKeys);
	};
	var _aFunction = function(it) {
		if (typeof it != "function") throw TypeError(it + " is not a function!");
		return it;
	};
	var _ctx = function(fn, that, length) {
		_aFunction(fn);
		if (that === void 0) return fn;
		switch (length) {
			case 1: return function(a) {
				return fn.call(that, a);
			};
			case 2: return function(a, b) {
				return fn.call(that, a, b);
			};
			case 3: return function(a, b, c) {
				return fn.call(that, a, b, c);
			};
		}
		return function() {
			return fn.apply(that, arguments);
		};
	};
	var _isObject = function(it) {
		return typeof it === "object" ? it !== null : typeof it === "function";
	};
	var _anObject = function(it) {
		if (!_isObject(it)) throw TypeError(it + " is not an object!");
		return it;
	};
	var _fails = function(exec) {
		try {
			return !!exec();
		} catch (e) {
			return true;
		}
	};
	var _descriptors = !_fails(function() {
		return Object.defineProperty({}, "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var document$1 = _global.document;
	var is$1 = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function(it) {
		return is$1 ? document$1.createElement(it) : {};
	};
	var _ie8DomDefine = !_descriptors && !_fails(function() {
		return Object.defineProperty(_domCreate("div"), "a", { get: function() {
			return 7;
		} }).a != 7;
	});
	var _toPrimitive = function(it, S) {
		if (!_isObject(it)) return it;
		var fn, val;
		if (S && typeof (fn = it.toString) == "function" && !_isObject(val = fn.call(it))) return val;
		if (typeof (fn = it.valueOf) == "function" && !_isObject(val = fn.call(it))) return val;
		if (!S && typeof (fn = it.toString) == "function" && !_isObject(val = fn.call(it))) return val;
		throw TypeError("Can't convert object to primitive value");
	};
	var dP = Object.defineProperty;
	var _objectDp = { f: _descriptors ? Object.defineProperty : function defineProperty$8(O, P, Attributes) {
		_anObject(O);
		P = _toPrimitive(P, true);
		_anObject(Attributes);
		if (_ie8DomDefine) try {
			return dP(O, P, Attributes);
		} catch (e) {}
		if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
		if ("value" in Attributes) O[P] = Attributes.value;
		return O;
	} };
	var _propertyDesc = function(bitmap, value) {
		return {
			enumerable: !(bitmap & 1),
			configurable: !(bitmap & 2),
			writable: !(bitmap & 4),
			value
		};
	};
	var _hide = _descriptors ? function(object, key$1, value) {
		return _objectDp.f(object, key$1, _propertyDesc(1, value));
	} : function(object, key$1, value) {
		object[key$1] = value;
		return object;
	};
	var PROTOTYPE = "prototype";
	var $export = function(type, name, source) {
		var IS_FORCED = type & $export.F;
		var IS_GLOBAL = type & $export.G;
		var IS_STATIC = type & $export.S;
		var IS_PROTO = type & $export.P;
		var IS_BIND = type & $export.B;
		var IS_WRAP = type & $export.W;
		var exports$1 = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
		var expProto = exports$1[PROTOTYPE];
		var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
		var key$1, own, out;
		if (IS_GLOBAL) source = name;
		for (key$1 in source) {
			own = !IS_FORCED && target && target[key$1] !== void 0;
			if (own && _has(exports$1, key$1)) continue;
			out = own ? target[key$1] : source[key$1];
			exports$1[key$1] = IS_GLOBAL && typeof target[key$1] != "function" ? source[key$1] : IS_BIND && own ? _ctx(out, _global) : IS_WRAP && target[key$1] == out ? (function(C) {
				var F = function(a, b, c) {
					if (this instanceof C) {
						switch (arguments.length) {
							case 0: return new C();
							case 1: return new C(a);
							case 2: return new C(a, b);
						}
						return new C(a, b, c);
					}
					return C.apply(this, arguments);
				};
				F[PROTOTYPE] = C[PROTOTYPE];
				return F;
			})(out) : IS_PROTO && typeof out == "function" ? _ctx(Function.call, out) : out;
			if (IS_PROTO) {
				(exports$1.virtual || (exports$1.virtual = {}))[key$1] = out;
				if (type & $export.R && expProto && !expProto[key$1]) _hide(expProto, key$1, out);
			}
		}
	};
	$export.F = 1;
	$export.G = 2;
	$export.S = 4;
	$export.P = 8;
	$export.B = 16;
	$export.W = 32;
	$export.U = 64;
	$export.R = 128;
	var _export = $export;
	var _objectSap = function(KEY, exec) {
		var fn = (_core.Object || {})[KEY] || Object[KEY];
		var exp = {};
		exp[KEY] = exec(fn);
		_export(_export.S + _export.F * _fails(function() {
			fn(1);
		}), "Object", exp);
	};
	_objectSap("keys", function() {
		return function keys$6(it) {
			return _objectKeys(_toObject(it));
		};
	});
	var keys$1 = _core.Object.keys;
	var _redefine = _hide;
	var _meta = createCommonjsModule(function(module$2) {
		var META$7 = _uid("meta");
		var setDesc = _objectDp.f;
		var id$7 = 0;
		var isExtensible = Object.isExtensible || function() {
			return true;
		};
		var FREEZE = !_fails(function() {
			return isExtensible(Object.preventExtensions({}));
		});
		var setMeta = function(it) {
			setDesc(it, META$7, { value: {
				i: "O" + ++id$7,
				w: {}
			} });
		};
		var fastKey$2 = function(it, create) {
			if (!_isObject(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
			if (!_has(it, META$7)) {
				if (!isExtensible(it)) return "F";
				if (!create) return "E";
				setMeta(it);
			}
			return it[META$7].i;
		};
		var getWeak$2 = function(it, create) {
			if (!_has(it, META$7)) {
				if (!isExtensible(it)) return true;
				if (!create) return false;
				setMeta(it);
			}
			return it[META$7].w;
		};
		var onFreeze = function(it) {
			if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META$7)) setMeta(it);
			return it;
		};
		var meta = module$2.exports = {
			KEY: META$7,
			NEED: false,
			fastKey: fastKey$2,
			getWeak: getWeak$2,
			onFreeze
		};
	});
	_meta.KEY;
	_meta.NEED;
	_meta.fastKey;
	_meta.getWeak;
	_meta.onFreeze;
	var _wks = createCommonjsModule(function(module$2) {
		var store = _shared("wks");
		var Symbol$2 = _global.Symbol;
		var USE_SYMBOL = typeof Symbol$2 == "function";
		var $exports = module$2.exports = function(name) {
			return store[name] || (store[name] = USE_SYMBOL && Symbol$2[name] || (USE_SYMBOL ? Symbol$2 : _uid)("Symbol." + name));
		};
		$exports.store = store;
	});
	var def = _objectDp.f;
	var TAG = _wks("toStringTag");
	var _setToStringTag = function(it, tag, stat$4) {
		if (it && !_has(it = stat$4 ? it : it.prototype, TAG)) def(it, TAG, {
			configurable: true,
			value: tag
		});
	};
	var _wksExt = { f: _wks };
	var defineProperty = _objectDp.f;
	var _wksDefine = function(name) {
		var $Symbol$7 = _core.Symbol || (_core.Symbol = {});
		if (name.charAt(0) != "_" && !(name in $Symbol$7)) defineProperty($Symbol$7, name, { value: _wksExt.f(name) });
	};
	var _objectGops = { f: Object.getOwnPropertySymbols };
	var _objectPie = { f: {}.propertyIsEnumerable };
	var _enumKeys = function(it) {
		var result = _objectKeys(it);
		var getSymbols = _objectGops.f;
		if (getSymbols) {
			var symbols = getSymbols(it);
			var isEnum$7 = _objectPie.f;
			var i$8 = 0;
			var key$1;
			while (symbols.length > i$8) if (isEnum$7.call(it, key$1 = symbols[i$8++])) result.push(key$1);
		}
		return result;
	};
	var _isArray = Array.isArray || function isArray$11(arg) {
		return _cof(arg) == "Array";
	};
	var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
		_anObject(O);
		var keys$6 = _objectKeys(Properties);
		var length = keys$6.length;
		var i$8 = 0;
		var P;
		while (length > i$8) _objectDp.f(O, P = keys$6[i$8++], Properties[P]);
		return O;
	};
	var document$1$1 = _global.document;
	var _html = document$1$1 && document$1$1.documentElement;
	var IE_PROTO$1 = _sharedKey("IE_PROTO");
	var Empty = function() {};
	var PROTOTYPE$1 = "prototype";
	var createDict = function() {
		var iframe = _domCreate("iframe");
		var i$8 = _enumBugKeys.length;
		var lt = "<";
		var gt = ">";
		var iframeDocument;
		iframe.style.display = "none";
		_html.appendChild(iframe);
		iframe.src = "javascript:";
		iframeDocument = iframe.contentWindow.document;
		iframeDocument.open();
		iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
		iframeDocument.close();
		createDict = iframeDocument.F;
		while (i$8--) delete createDict[PROTOTYPE$1][_enumBugKeys[i$8]];
		return createDict();
	};
	var _objectCreate = Object.create || function create(O, Properties) {
		var result;
		if (O !== null) {
			Empty[PROTOTYPE$1] = _anObject(O);
			result = new Empty();
			Empty[PROTOTYPE$1] = null;
			result[IE_PROTO$1] = O;
		} else result = createDict();
		return Properties === void 0 ? result : _objectDps(result, Properties);
	};
	var hiddenKeys = _enumBugKeys.concat("length", "prototype");
	var _objectGopn = { f: Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		return _objectKeysInternal(O, hiddenKeys);
	} };
	var gOPN = _objectGopn.f;
	var toString$1 = {}.toString;
	var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
	var getWindowNames = function(it) {
		try {
			return gOPN(it);
		} catch (e) {
			return windowNames.slice();
		}
	};
	var _objectGopnExt = { f: function getOwnPropertyNames(it) {
		return windowNames && toString$1.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(_toIobject(it));
	} };
	var gOPD = Object.getOwnPropertyDescriptor;
	var _objectGopd = { f: _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
		O = _toIobject(O);
		P = _toPrimitive(P, true);
		if (_ie8DomDefine) try {
			return gOPD(O, P);
		} catch (e) {}
		if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
	} };
	var META = _meta.KEY;
	var gOPD$1 = _objectGopd.f;
	var dP$1 = _objectDp.f;
	var gOPN$1 = _objectGopnExt.f;
	var $Symbol = _global.Symbol;
	var $JSON = _global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE$2 = "prototype";
	var HIDDEN = _wks("_hidden");
	var TO_PRIMITIVE = _wks("toPrimitive");
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = _shared("symbol-registry");
	var AllSymbols = _shared("symbols");
	var OPSymbols = _shared("op-symbols");
	var ObjectProto = Object[PROTOTYPE$2];
	var USE_NATIVE = typeof $Symbol == "function" && !!_objectGops.f;
	var QObject = _global.QObject;
	var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;
	var setSymbolDesc = _descriptors && _fails(function() {
		return _objectCreate(dP$1({}, "a", { get: function() {
			return dP$1(this, "a", { value: 7 }).a;
		} })).a != 7;
	}) ? function(it, key$1, D) {
		var protoDesc = gOPD$1(ObjectProto, key$1);
		if (protoDesc) delete ObjectProto[key$1];
		dP$1(it, key$1, D);
		if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key$1, protoDesc);
	} : dP$1;
	var wrap = function(tag) {
		var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
		sym._k = tag;
		return sym;
	};
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
		return typeof it == "symbol";
	} : function(it) {
		return it instanceof $Symbol;
	};
	var $defineProperty = function defineProperty$8(it, key$1, D) {
		if (it === ObjectProto) $defineProperty(OPSymbols, key$1, D);
		_anObject(it);
		key$1 = _toPrimitive(key$1, true);
		_anObject(D);
		if (_has(AllSymbols, key$1)) {
			if (!D.enumerable) {
				if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
				it[HIDDEN][key$1] = true;
			} else {
				if (_has(it, HIDDEN) && it[HIDDEN][key$1]) it[HIDDEN][key$1] = false;
				D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
			}
			return setSymbolDesc(it, key$1, D);
		}
		return dP$1(it, key$1, D);
	};
	var $defineProperties = function defineProperties(it, P) {
		_anObject(it);
		var keys$6 = _enumKeys(P = _toIobject(P));
		var i$8 = 0;
		var l = keys$6.length;
		var key$1;
		while (l > i$8) $defineProperty(it, key$1 = keys$6[i$8++], P[key$1]);
		return it;
	};
	var $create = function create(it, P) {
		return P === void 0 ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable$1(key$1) {
		var E = isEnum.call(this, key$1 = _toPrimitive(key$1, true));
		if (this === ObjectProto && _has(AllSymbols, key$1) && !_has(OPSymbols, key$1)) return false;
		return E || !_has(this, key$1) || !_has(AllSymbols, key$1) || _has(this, HIDDEN) && this[HIDDEN][key$1] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key$1) {
		it = _toIobject(it);
		key$1 = _toPrimitive(key$1, true);
		if (it === ObjectProto && _has(AllSymbols, key$1) && !_has(OPSymbols, key$1)) return;
		var D = gOPD$1(it, key$1);
		if (D && _has(AllSymbols, key$1) && !(_has(it, HIDDEN) && it[HIDDEN][key$1])) D.enumerable = true;
		return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
		var names = gOPN$1(_toIobject(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (!_has(AllSymbols, key$1 = names[i$8++]) && key$1 != HIDDEN && key$1 != META) result.push(key$1);
		return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols$2(it) {
		var IS_OP = it === ObjectProto;
		var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
		var result = [];
		var i$8 = 0;
		var key$1;
		while (names.length > i$8) if (_has(AllSymbols, key$1 = names[i$8++]) && (IS_OP ? _has(ObjectProto, key$1) : true)) result.push(AllSymbols[key$1]);
		return result;
	};
	if (!USE_NATIVE) {
		$Symbol = function Symbol$2() {
			if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
			var tag = _uid(arguments.length > 0 ? arguments[0] : void 0);
			var $set = function(value) {
				if (this === ObjectProto) $set.call(OPSymbols, value);
				if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
				setSymbolDesc(this, tag, _propertyDesc(1, value));
			};
			if (_descriptors && setter) setSymbolDesc(ObjectProto, tag, {
				configurable: true,
				set: $set
			});
			return wrap(tag);
		};
		_redefine($Symbol[PROTOTYPE$2], "toString", function toString$11() {
			return this._k;
		});
		_objectGopd.f = $getOwnPropertyDescriptor;
		_objectDp.f = $defineProperty;
		_objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
		_objectPie.f = $propertyIsEnumerable;
		_objectGops.f = $getOwnPropertySymbols;
		if (_descriptors && !_library) _redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
		_wksExt.f = function(name) {
			return wrap(_wks(name));
		};
	}
	_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Symbol: $Symbol });
	for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j;) _wks(es6Symbols[j++]);
	for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);
	_export(_export.S + _export.F * !USE_NATIVE, "Symbol", {
		"for": function(key$1) {
			return _has(SymbolRegistry, key$1 += "") ? SymbolRegistry[key$1] : SymbolRegistry[key$1] = $Symbol(key$1);
		},
		keyFor: function keyFor$1(sym) {
			if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
			for (var key$1 in SymbolRegistry) if (SymbolRegistry[key$1] === sym) return key$1;
		},
		useSetter: function() {
			setter = true;
		},
		useSimple: function() {
			setter = false;
		}
	});
	_export(_export.S + _export.F * !USE_NATIVE, "Object", {
		create: $create,
		defineProperty: $defineProperty,
		defineProperties: $defineProperties,
		getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
		getOwnPropertyNames: $getOwnPropertyNames,
		getOwnPropertySymbols: $getOwnPropertySymbols
	});
	var FAILS_ON_PRIMITIVES = _fails(function() {
		_objectGops.f(1);
	});
	_export(_export.S + _export.F * FAILS_ON_PRIMITIVES, "Object", { getOwnPropertySymbols: function getOwnPropertySymbols$2(it) {
		return _objectGops.f(_toObject(it));
	} });
	$JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function() {
		var S = $Symbol();
		return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
	})), "JSON", { stringify: function stringify$14(it) {
		var args = [it];
		var i$8 = 1;
		var replacer, $replacer;
		while (arguments.length > i$8) args.push(arguments[i$8++]);
		$replacer = replacer = args[1];
		if (!_isObject(replacer) && it === void 0 || isSymbol(it)) return;
		if (!_isArray(replacer)) replacer = function(key$1, value) {
			if (typeof $replacer == "function") value = $replacer.call(this, key$1, value);
			if (!isSymbol(value)) return value;
		};
		args[1] = replacer;
		return _stringify.apply($JSON, args);
	} });
	$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
	_setToStringTag($Symbol, "Symbol");
	_setToStringTag(Math, "Math", true);
	_setToStringTag(_global.JSON, "JSON", true);
	var getOwnPropertySymbols$1 = _core.Object.getOwnPropertySymbols;
	var $getOwnPropertyDescriptor$1 = _objectGopd.f;
	_objectSap("getOwnPropertyDescriptor", function() {
		return function getOwnPropertyDescriptor(it, key$1) {
			return $getOwnPropertyDescriptor$1(_toIobject(it), key$1);
		};
	});
	var $Object = _core.Object;
	var getOwnPropertyDescriptor$1 = function getOwnPropertyDescriptor(it, key$1) {
		return $Object.getOwnPropertyDescriptor(it, key$1);
	};
	var Reflect$1 = _global.Reflect;
	var _ownKeys = Reflect$1 && Reflect$1.ownKeys || function ownKeys$8(it) {
		var keys$6 = _objectGopn.f(_anObject(it));
		var getSymbols = _objectGops.f;
		return getSymbols ? keys$6.concat(getSymbols(it)) : keys$6;
	};
	var _createProperty = function(object, index$1, value) {
		if (index$1 in object) _objectDp.f(object, index$1, _propertyDesc(0, value));
		else object[index$1] = value;
	};
	_export(_export.S, "Object", { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
		var O = _toIobject(object);
		var getDesc = _objectGopd.f;
		var keys$6 = _ownKeys(O);
		var result = {};
		var i$8 = 0;
		var key$1, desc$1;
		while (keys$6.length > i$8) {
			desc$1 = getDesc(O, key$1 = keys$6[i$8++]);
			if (desc$1 !== void 0) _createProperty(result, key$1, desc$1);
		}
		return result;
	} });
	var getOwnPropertyDescriptors$1 = _core.Object.getOwnPropertyDescriptors;
	_export(_export.S + _export.F * !_descriptors, "Object", { defineProperties: _objectDps });
	var $Object$1 = _core.Object;
	var defineProperties$1 = function defineProperties(T, D) {
		return $Object$1.defineProperties(T, D);
	};
	_export(_export.S + _export.F * !_descriptors, "Object", { defineProperty: _objectDp.f });
	var $Object$2 = _core.Object;
	var defineProperty$2 = function defineProperty$8(it, key$1, desc$1) {
		return $Object$2.defineProperty(it, key$1, desc$1);
	};
	var _defineProperty = unwrapExports(createCommonjsModule(function(module$2) {
		function _defineProperty$7(obj, key$1, value) {
			if (key$1 in obj) defineProperty$2(obj, key$1, {
				value,
				enumerable: true,
				configurable: true,
				writable: true
			});
			else obj[key$1] = value;
			return obj;
		}
		module$2.exports = _defineProperty$7;
		module$2.exports["default"] = module$2.exports, module$2.exports.__esModule = true;
	}));
	var DefaultConfig = {
		port: 3e3,
		quiet: false,
		recordingSizeLimit: "50mb",
		recordingsDir: "recordings",
		apiNamespace: "/polly"
	};
	function ownKeys(object, enumerableOnly) {
		var keys$6 = keys$1(object);
		if (getOwnPropertySymbols$1) {
			var symbols = getOwnPropertySymbols$1(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys(Object(source), true).forEach(function(key$1) {
				_defineProperty(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1) defineProperties$1(target, getOwnPropertyDescriptors$1(source));
			else ownKeys(Object(source)).forEach(function(key$1) {
				defineProperty$2(target, key$1, getOwnPropertyDescriptor$1(source, key$1));
			});
		}
		return target;
	}
	function prependSlash(slash = "") {
		if (slash.startsWith("/")) return slash;
		return `/${slash}`;
	}
	function registerAPI(app$1, config) {
		config = _objectSpread(_objectSpread({}, DefaultConfig), config);
		config.apiNamespace = prependSlash(config.apiNamespace);
		const router = express.Router();
		const api$1 = new API({ recordingsDir: config.recordingsDir });
		router.use(nocache());
		router.get("/:recording", function(req$2, res$2) {
			const { recording } = req$2.params;
			const { status: status$1, body: body$1 } = api$1.getRecording(recording);
			res$2.status(status$1);
			if (status$1 === 200) res$2.json(body$1);
			else res$2.end();
		});
		router.post("/:recording", bodyParser.json({ limit: config.recordingSizeLimit }), function(req$2, res$2) {
			const { recording } = req$2.params;
			const { status: status$1, body: body$1 } = api$1.saveRecording(recording, req$2.body);
			res$2.status(status$1).send(body$1);
		});
		router.delete("/:recording", function(req$2, res$2) {
			const { recording } = req$2.params;
			const { status: status$1, body: body$1 } = api$1.deleteRecording(recording);
			res$2.status(status$1).send(body$1);
		});
		app$1.use(config.apiNamespace, router);
	}
	function ownKeys$1(object, enumerableOnly) {
		var keys$6 = keys$1(object);
		if (getOwnPropertySymbols$1) {
			var symbols = getOwnPropertySymbols$1(object);
			if (enumerableOnly) symbols = symbols.filter(function(sym) {
				return getOwnPropertyDescriptor$1(object, sym).enumerable;
			});
			keys$6.push.apply(keys$6, symbols);
		}
		return keys$6;
	}
	function _objectSpread$1(target) {
		for (var i$8 = 1; i$8 < arguments.length; i$8++) {
			var source = arguments[i$8] != null ? arguments[i$8] : {};
			if (i$8 % 2) ownKeys$1(Object(source), true).forEach(function(key$1) {
				_defineProperty(target, key$1, source[key$1]);
			});
			else if (getOwnPropertyDescriptors$1) defineProperties$1(target, getOwnPropertyDescriptors$1(source));
			else ownKeys$1(Object(source)).forEach(function(key$1) {
				defineProperty$2(target, key$1, getOwnPropertyDescriptor$1(source, key$1));
			});
		}
		return target;
	}
	var Server = class {
		constructor(config = {}) {
			this.config = _objectSpread$1(_objectSpread$1({}, DefaultConfig), config);
			this.app = express();
			this.app.use(cors(this.config.corsOptions));
			if (!this.config.quiet) this.app.use(morgan("dev"));
			this.app.get("/", (req$2, res$2) => res$2.sendStatus(200));
			this.app.head("/", (req$2, res$2) => res$2.sendStatus(200));
			registerAPI(this.app, {
				recordingsDir: this.config.recordingsDir,
				apiNamespace: this.config.apiNamespace
			});
		}
		listen(port$6, host) {
			if (this.server) return;
			port$6 = port$6 || this.config.port;
			host = host || this.config.host;
			this.server = this.app.listen(port$6, host).on("listening", () => {
				if (!this.config.quiet) console.log(`Listening on http://${host || "localhost"}:${port$6}/\n`);
			}).on("error", (e) => {
				if (e.code === "EADDRINUSE") {
					console.error(`Port ${port$6} already in use.`);
					process.exit(1);
				} else console.error(e);
			});
			gracefulShutdown(this.server);
			return this.server;
		}
	};
	exports.API = API;
	exports.Defaults = DefaultConfig;
	exports.Server = Server;
	exports.registerExpressAPI = registerAPI;
}) });

//#endregion
//#region ../../node_modules/.pnpm/@pollyjs+persister-fs@6.0.6/node_modules/@pollyjs/persister-fs/dist/cjs/pollyjs-persister-fs.js
var require_pollyjs_persister_fs = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/@pollyjs+persister-fs@6.0.6/node_modules/@pollyjs/persister-fs/dist/cjs/pollyjs-persister-fs.js": ((exports, module) => {
	function _interopDefault(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var Persister = _interopDefault(require_pollyjs_persister());
	var nodeServer = require_pollyjs_node_server();
	const { parse } = JSON;
	var FSPersister$1 = class extends Persister {
		constructor() {
			super(...arguments);
			this.api = new nodeServer.API(this.options);
		}
		static get id() {
			return "fs";
		}
		get defaultOptions() {
			return { recordingsDir: nodeServer.Defaults.recordingsDir };
		}
		onFindRecording(recordingId) {
			return this.api.getRecording(recordingId).body || null;
		}
		onSaveRecording(recordingId, data) {
			this.api.saveRecording(recordingId, parse(this.stringify(data)));
		}
		onDeleteRecording(recordingId) {
			this.api.deleteRecording(recordingId);
		}
	};
	module.exports = FSPersister$1;
}) });

//#endregion
//#region src/testing/utils/polly.ts
var import_pollyjs_core = /* @__PURE__ */ __toESM(require_pollyjs_core(), 1);
var import_pollyjs_adapter_node_http = /* @__PURE__ */ __toESM(require_pollyjs_adapter_node_http(), 1);
var import_pollyjs_adapter_fetch = /* @__PURE__ */ __toESM(require_pollyjs_adapter_fetch(), 1);
var import_pollyjs_persister_fs = /* @__PURE__ */ __toESM(require_pollyjs_persister_fs(), 1);
import_pollyjs_core.Polly.register(import_pollyjs_adapter_node_http.default);
import_pollyjs_core.Polly.register(import_pollyjs_adapter_fetch.default);
import_pollyjs_core.Polly.register(import_pollyjs_persister_fs.default);
const globalAny = global;
if (!globalAny.__pollyManagerInstance) globalAny.__pollyManagerInstance = null;
var PollyManager = class PollyManager {
	static get polly() {
		return globalAny.__pollyManagerInstance;
	}
	static set polly(value) {
		globalAny.__pollyManagerInstance = value;
	}
	static AI_PROVIDERS = [
		/127\.0\.0\.1:11434/,
		/api\.anthropic\.com/,
		/api\.openai\.com/,
		/generativelanguage\.googleapis\.com/
	];
	static RECORDINGS_DIR = path.join(process.cwd(), "tests", "recordings");
	/**
	* Gets or creates a Polly instance for a specific node.
	* This is designed to be called by node decorators.
	* 
	* @param nodeName The name of the node (used for recording name)
	* @param options Additional options for the node
	* @returns The Polly instance (either existing or newly created)
	*/
	static async startPolly(recordingName, mode, configure) {
		let polly = PollyManager.polly;
		if (!polly) polly = PollyManager.hardStartPolly({
			recordingName,
			mode,
			configure
		});
		PollyManager.setRecordingName(recordingName);
		return polly;
	}
	/**
	* Gets the current Polly instance if one exists.
	*/
	static getPolly() {
		return PollyManager.polly;
	}
	/**
	* Stops and cleans up the global Polly instance.
	*/
	static async stopPolly() {
		if (PollyManager.polly) {
			if (PollyManager.polly.persister) await PollyManager.polly.persister.persist();
			await PollyManager.polly.stop();
			PollyManager.polly = null;
		}
	}
	/**
	* Persists all recordings for the active Polly instance.
	*/
	static async persistRecordings() {
		await PollyManager.polly?.persister?.persist();
	}
	/**
	* Configures request routing for a specific node.
	* Only updates AI/LLM host routes to use node-specific recordings.
	* This preserves any test-specific configuration for other routes.
	* 
	* @param nodeName The name of the node (used for recording name)
	*/
	static setRecordingName(nodeName) {
		const polly = PollyManager.polly;
		if (!polly) throw new Error("No active Polly instance to configure");
		const { server } = polly;
		server.any().recordingName(nodeName);
	}
	static configureRails() {
		const { server } = PollyManager.polly;
		server.any("http://localhost:3000/*").passthrough();
	}
	static configureLlms() {
		const { server } = PollyManager.polly;
		PollyManager.AI_PROVIDERS.forEach((providerRegex) => {
			server.any(providerRegex).configure({ matchRequestsBy: {
				method: true,
				headers: false,
				body: true,
				order: false,
				url: true
			} });
		});
	}
	static configureHeaders() {
		if (!PollyManager.polly) return;
		const { server } = PollyManager.polly;
		server.any().on("beforePersist", (req$2, recording) => {
			const headersToIgnore = [
				"x-api-key",
				"authorization",
				"api-key",
				"x-test-proof",
				"x-test-mode",
				"anthropic-ratelimit-input-tokens-limit",
				"anthropic-ratelimit-input-tokens-remaining",
				"anthropic-ratelimit-input-tokens-reset",
				"x-stainless-os",
				"x-stainless-arch",
				"x-stainless-runtime-version"
			];
			if (recording.request && recording.request.headers && Array.isArray(recording.request.headers)) recording.request.headers = recording.request.headers.filter((header) => {
				const name = header.name?.toLowerCase();
				return !headersToIgnore.includes(name);
			});
			if (recording.headers && Array.isArray(recording.headers)) recording.headers = recording.headers.filter((header) => {
				const name = header.name?.toLowerCase();
				return !headersToIgnore.includes(name);
			});
		});
	}
	/**
	* Gets or creates a Polly instance.
	* - If no Polly exists, creates a new one with the given options
	* - If a Polly exists with the SAME recording name, returns it (optionally applying additional config)
	* - If a Polly exists with a DIFFERENT recording name, returns the existing one WITHOUT changing it
	*   (This allows nodes to share a test-level Polly instance)
	*/
	static hardStartPolly(options) {
		PollyManager.polly = new import_pollyjs_core.Polly(options.recordingName, {
			mode: options.mode || "replay",
			adapters: ["node-http", "fetch"],
			persister: "fs",
			persisterOptions: {
				fs: { recordingsDir: PollyManager.RECORDINGS_DIR },
				keepUnusedRequests: true
			},
			recordIfMissing: true,
			matchRequestsBy: {
				method: true,
				headers: false,
				body: true,
				order: false,
				url: true
			},
			recordFailedRequests: true
		});
		PollyManager.configureRails();
		PollyManager.configureLlms();
		PollyManager.configureHeaders();
		if (options.configure) options.configure(PollyManager.polly);
		return PollyManager.polly;
	}
};
const { startPolly, stopPolly, persistRecordings, getPolly } = PollyManager;

//#endregion
//#region src/testing/node/withPolly.ts
/**
* Wraps a node function with polly (for testing, when we don't want to use fixtures)
*/
const withPolly = (nodeFunction, options) => {
	return async (state, config) => {
		if (process.env.NODE_ENV !== "test") return nodeFunction(state, config);
		await startPolly(kebabCase(getNodeContext()?.name || "unknown-node-execution"));
		try {
			return await nodeFunction(state, config);
		} catch (error) {
			throw error;
		} finally {
			await persistRecordings();
		}
	};
};

//#endregion
//#region src/testing/node/nodeMiddleware.ts
const NodeMiddleware = new NodeMiddlewareFactory().addMiddleware("context", withContext).addMiddleware("notifications", withNotifications).addMiddleware("errorHandling", withErrorHandling).addMiddleware("polly", withPolly);

//#endregion
//#region src/testing/graphs/graph/types.ts
/**
* Schema for structured messages with intro, examples, and conclusion
*/
const structuredMessageSchema = z.object({
	type: z.literal("structuredMessage"),
	intro: z.string().describe("Introduction to the response"),
	bulletPoints: z.array(z.string()).optional().describe("List of bullet points"),
	conclusion: z.string().optional().describe("Conclusion of the response")
});
/**
* Graph state annotation for the sample graph
*/
const SampleGraphAnnotation = Annotation.Root({
	messages: Annotation({
		default: () => [],
		reducer: messagesStateReducer
	}),
	projectName: Annotation({
		default: () => void 0,
		reducer: (curr, next) => next ?? curr
	})
});

//#endregion
//#region src/testing/graphs/graph/sampleGraph.ts
/**
* Node that generates a project name based on the user's message
* Only runs if projectName is not already set in state
*/
const nameProjectNode = NodeMiddleware.use({ notifications: { taskName: "Name Project" } }, async (state, config) => {
	if (state.projectName) return {};
	const userMessage = state.messages.find((m$3) => m$3._getType() === "human");
	if (!userMessage) return {};
	const prompt = `Based on this user message, generate a short, catchy project name (2-4 words max):

"${userMessage.content}"

Return ONLY the project name, nothing else.`;
	const schema = z.object({ projectName: z.string().describe("Project name") });
	let projectName;
	const llm = getLLM();
	try {
		projectName = (await llm.withStructuredOutput(schema).invoke(prompt)).projectName;
	} catch (e) {
		return {};
	}
	return { projectName };
});
/**
* Node that generates a response to the user's message
* Uses the messageSchema to return either simple or structured messages
* Tagged with 'notify' for streaming support
*/
const responseNode = NodeMiddleware.use({ notifications: { taskName: "Generate Response" } }, async (state, config) => {
	const userPrompt = state.messages[state.messages.length - 1];
	if (!userPrompt) throw new Error("Need user prompt");
	const projectContext = state.projectName ? `Project: "${state.projectName}"\n\n` : "";
	const parser$1 = StructuredOutputParser.fromZodSchema(structuredMessageSchema);
	const prompt = `${projectContext}
    <task>
      Answer the user's question
    </task>

    <message-history>
      ${state.messages.map((m$3) => {
		return `<role>${m$3.getType()}</role><content>${m$3.content}</content>`;
	}).join("\n")}
    </message-history>

    <question>
      ${userPrompt.content}
    </question>

    <choose>
      Choose whichever output format you think is most appropriate, given
      the answer you are about to provide.
    </choose>

    <output>
      ${parser$1.getFormatInstructions()}
    </output>
  `;
	const structuredOutput = await getLLM().withStructuredOutput(structuredMessageSchema).withConfig({ tags: ["notify"] }).invoke(prompt, config);
	return { messages: [new AIMessage({
		content: JSON.stringify(structuredOutput),
		response_metadata: structuredOutput
	})] };
});
/**
* Creates a compiled sample graph with the given checkpointer
*
* Graph flow: START  nameProjectNode  responseNode  END
*
* @param checkpointer - Optional checkpointer for state persistence
* @param graphName - Name to identify the graph (default: 'sample')
* @returns Compiled LangGraph
*/
function createSampleGraph(checkpointer, graphName = "sample") {
	return new StateGraph(SampleGraphAnnotation).addNode("nameProjectNode", nameProjectNode).addNode("responseNode", responseNode).addEdge(START, "nameProjectNode").addEdge("nameProjectNode", "responseNode").addEdge("responseNode", END).compile({
		checkpointer,
		name: graphName
	});
}

//#endregion
//#region src/testing/graphs/agent/types.ts
/**
* Schema for structured questions with intro, examples, and conclusion
*/
const questionSchema = z.object({
	type: z.literal("question"),
	text: z.string().describe("A simple intro to the question"),
	examples: z.array(z.string()).optional().describe(`OPTIONAL: List of examples to help the user understand what we're asking.`),
	conclusion: z.string().optional().describe(`OPTIONAL: Conclusion text to include after examples`)
});
/**
* Schema for marketing template output
* Generated when the agent has enough context to create landing page copy
*/
const marketingTemplateSchema = z.object({
	type: z.literal("marketingTemplate"),
	headline: z.string().describe("Compelling headline that grabs attention"),
	subheadline: z.string().optional().describe("Supporting subheadline that expands on the main headline"),
	valueProposition: z.string().describe("Clear statement of what makes this business unique"),
	bulletPoints: z.array(z.string()).optional().describe("3-5 key benefits or features to highlight"),
	callToAction: z.string().describe("Strong call-to-action text"),
	tone: z.enum([
		"professional",
		"friendly",
		"urgent",
		"authoritative",
		"playful"
	]).describe("The tone of the copy"),
	socialProofSnippet: z.string().optional().describe("Brief social proof or testimonial snippet")
});
/**
* Union schema for all agent outputs
*/
const agentOutputSchema = [questionSchema, marketingTemplateSchema];
/**
* Brainstorm topics
*/
const brainstormTopics = [
	"idea",
	"audience",
	"solution",
	"socialProof",
	"lookAndFeel"
];
/**
* State annotation for the brainstorm agent
*/
const BrainstormStateAnnotation = Annotation.Root({
	messages: Annotation({
		default: () => [],
		reducer: messagesStateReducer
	}),
	brainstorm: Annotation({
		default: () => ({}),
		reducer: (current, next) => ({
			...current,
			...next
		})
	}),
	remainingTopics: Annotation({
		default: () => [...brainstormTopics],
		reducer: (current, next) => next
	}),
	userContext: Annotation({
		default: () => ({}),
		reducer: (current, next) => ({
			...current,
			...next
		})
	})
});

//#endregion
//#region src/testing/prompts/toJSON.ts
var import_fast_json_stable_stringify = /* @__PURE__ */ __toESM(require_fast_json_stable_stringify(), 1);
const toJSON = (data) => {
	return (0, import_fast_json_stable_stringify.default)(data);
};

//#endregion
//#region ../../node_modules/.pnpm/xml-parser-xo@4.1.5/node_modules/xml-parser-xo/dist/cjs/index.js
var require_cjs$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/xml-parser-xo@4.1.5/node_modules/xml-parser-xo/dist/cjs/index.js": ((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ParsingError = void 0;
	var ParsingError = class extends Error {
		constructor(message, cause) {
			super(message);
			this.cause = cause;
		}
	};
	exports.ParsingError = ParsingError;
	let parsingState;
	function nextChild() {
		return element(false) || text() || comment() || cdata() || processingInstruction();
	}
	function nextRootChild() {
		match(/\s*/);
		return element(true) || comment() || doctype() || processingInstruction();
	}
	function parseDocument() {
		const declaration = processingInstruction();
		const children = [];
		let documentRootNode;
		let child = nextRootChild();
		while (child) {
			if (child.node.type === "Element") {
				if (documentRootNode) throw new Error("Found multiple root nodes");
				documentRootNode = child.node;
			}
			if (!child.excluded) children.push(child.node);
			child = nextRootChild();
		}
		if (!documentRootNode) throw new ParsingError("Failed to parse XML", "Root Element not found");
		if (parsingState.xml.length !== 0) throw new ParsingError("Failed to parse XML", "Not Well-Formed XML");
		return {
			declaration: declaration ? declaration.node : null,
			root: documentRootNode,
			children
		};
	}
	function processingInstruction() {
		const m$3 = match(/^<\?([\w-:.]+)\s*/);
		if (!m$3) return;
		const node$1 = {
			name: m$3[1],
			type: "ProcessingInstruction",
			content: ""
		};
		const endMarkerIndex = parsingState.xml.indexOf("?>");
		if (endMarkerIndex > -1) {
			node$1.content = parsingState.xml.substring(0, endMarkerIndex).trim();
			parsingState.xml = parsingState.xml.slice(endMarkerIndex);
		} else throw new ParsingError("Failed to parse XML", "ProcessingInstruction closing tag not found");
		match(/\?>/);
		return {
			excluded: parsingState.options.filter(node$1) === false,
			node: node$1
		};
	}
	function element(matchRoot) {
		const m$3 = match(/^<([^?!</>\s]+)\s*/);
		if (!m$3) return;
		const node$1 = {
			type: "Element",
			name: m$3[1],
			attributes: {},
			children: []
		};
		const excluded = matchRoot ? false : parsingState.options.filter(node$1) === false;
		while (!(eos() || is(">") || is("?>") || is("/>"))) {
			const attr = attribute();
			if (attr) node$1.attributes[attr.name] = attr.value;
			else return;
		}
		if (match(/^\s*\/>/)) {
			node$1.children = null;
			return {
				excluded,
				node: node$1
			};
		}
		match(/\??>/);
		let child = nextChild();
		while (child) {
			if (!child.excluded) node$1.children.push(child.node);
			child = nextChild();
		}
		if (parsingState.options.strictMode) {
			const closingTag = `</${node$1.name}>`;
			if (parsingState.xml.startsWith(closingTag)) parsingState.xml = parsingState.xml.slice(closingTag.length);
			else throw new ParsingError("Failed to parse XML", `Closing tag not matching "${closingTag}"`);
		} else match(/^<\/[\w-:.\u00C0-\u00FF]+\s*>/);
		return {
			excluded,
			node: node$1
		};
	}
	function doctype() {
		const m$3 = match(/^<!DOCTYPE\s+\S+\s+SYSTEM[^>]*>/) || match(/^<!DOCTYPE\s+\S+\s+PUBLIC[^>]*>/) || match(/^<!DOCTYPE\s+\S+\s*\[[^\]]*]>/) || match(/^<!DOCTYPE\s+\S+\s*>/);
		if (m$3) {
			const node$1 = {
				type: "DocumentType",
				content: m$3[0]
			};
			return {
				excluded: parsingState.options.filter(node$1) === false,
				node: node$1
			};
		}
	}
	function cdata() {
		if (parsingState.xml.startsWith("<![CDATA[")) {
			const endPositionStart = parsingState.xml.indexOf("]]>");
			if (endPositionStart > -1) {
				const endPositionFinish = endPositionStart + 3;
				const node$1 = {
					type: "CDATA",
					content: parsingState.xml.substring(0, endPositionFinish)
				};
				parsingState.xml = parsingState.xml.slice(endPositionFinish);
				return {
					excluded: parsingState.options.filter(node$1) === false,
					node: node$1
				};
			}
		}
	}
	function comment() {
		const m$3 = match(/^<!--[\s\S]*?-->/);
		if (m$3) {
			const node$1 = {
				type: "Comment",
				content: m$3[0]
			};
			return {
				excluded: parsingState.options.filter(node$1) === false,
				node: node$1
			};
		}
	}
	function text() {
		const m$3 = match(/^([^<]+)/);
		if (m$3) {
			const node$1 = {
				type: "Text",
				content: m$3[1]
			};
			return {
				excluded: parsingState.options.filter(node$1) === false,
				node: node$1
			};
		}
	}
	function attribute() {
		const m$3 = match(/([^=]+)\s*=\s*("[^"]*"|'[^']*'|[^>\s]+)\s*/);
		if (m$3) return {
			name: m$3[1].trim(),
			value: stripQuotes(m$3[2].trim())
		};
	}
	function stripQuotes(val) {
		return val.replace(/^['"]|['"]$/g, "");
	}
	/**
	* Match `re` and advance the string.
	*/
	function match(re) {
		const m$3 = parsingState.xml.match(re);
		if (m$3) {
			parsingState.xml = parsingState.xml.slice(m$3[0].length);
			return m$3;
		}
	}
	/**
	* End-of-source.
	*/
	function eos() {
		return 0 === parsingState.xml.length;
	}
	/**
	* Check for `prefix`.
	*/
	function is(prefix) {
		return 0 === parsingState.xml.indexOf(prefix);
	}
	/**
	* Parse the given XML string into an object.
	*/
	function parseXml(xml, options = {}) {
		xml = xml.trim();
		const filter = options.filter || (() => true);
		parsingState = {
			xml,
			options: Object.assign(Object.assign({}, options), {
				filter,
				strictMode: options.strictMode === true
			})
		};
		return parseDocument();
	}
	if (typeof module !== "undefined" && typeof exports === "object") module.exports = parseXml;
	exports.default = parseXml;
}) });

//#endregion
//#region ../../node_modules/.pnpm/xml-formatter@3.6.7/node_modules/xml-formatter/dist/cjs/index.js
var require_cjs = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/xml-formatter@3.6.7/node_modules/xml-formatter/dist/cjs/index.js": ((exports, module) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	const xml_parser_xo_1 = __importDefault(require_cjs$1());
	function newLine(state) {
		if (!state.options.indentation && !state.options.lineSeparator) return;
		state.content += state.options.lineSeparator;
		let i$8;
		for (i$8 = 0; i$8 < state.level; i$8++) state.content += state.options.indentation;
	}
	function indent(state) {
		state.content = state.content.replace(/ +$/, "");
		let i$8;
		for (i$8 = 0; i$8 < state.level; i$8++) state.content += state.options.indentation;
	}
	function appendContent(state, content) {
		state.content += content;
	}
	function processNode(node$1, state, preserveSpace) {
		if (node$1.type === "Element") processElementNode(node$1, state, preserveSpace);
		else if (node$1.type === "ProcessingInstruction") processProcessingIntruction(node$1, state);
		else if (typeof node$1.content === "string") processContent(node$1.content, state, preserveSpace);
		else throw new Error("Unknown node type: " + node$1.type);
	}
	function processContent(content, state, preserveSpace) {
		if (!preserveSpace) {
			const trimmedContent = content.trim();
			if (state.options.lineSeparator) content = trimmedContent;
			else if (trimmedContent.length === 0) content = trimmedContent;
		}
		if (content.length > 0) {
			if (!preserveSpace && state.content.length > 0) newLine(state);
			appendContent(state, content);
		}
	}
	function isPathMatchingIgnoredPaths(path$19, ignoredPaths) {
		const fullPath = "/" + path$19.join("/");
		const pathLastPart = path$19[path$19.length - 1];
		return ignoredPaths.includes(pathLastPart) || ignoredPaths.includes(fullPath);
	}
	function processElementNode(node$1, state, preserveSpace) {
		state.path.push(node$1.name);
		if (!preserveSpace && state.content.length > 0) newLine(state);
		appendContent(state, "<" + node$1.name);
		processAttributes(state, node$1.attributes);
		if (node$1.children === null || state.options.forceSelfClosingEmptyTag && node$1.children.length === 0) appendContent(state, state.options.whiteSpaceAtEndOfSelfclosingTag ? " />" : "/>");
		else if (node$1.children.length === 0) appendContent(state, "></" + node$1.name + ">");
		else {
			const nodeChildren = node$1.children;
			appendContent(state, ">");
			state.level++;
			let nodePreserveSpace = node$1.attributes["xml:space"] === "preserve" || preserveSpace;
			let ignoredPath = false;
			if (!nodePreserveSpace && state.options.ignoredPaths) {
				ignoredPath = isPathMatchingIgnoredPaths(state.path, state.options.ignoredPaths);
				nodePreserveSpace = ignoredPath;
			}
			if (!nodePreserveSpace && state.options.collapseContent) {
				let containsTextNodes = false;
				let containsTextNodesWithLineBreaks = false;
				let containsNonTextNodes = false;
				nodeChildren.forEach(function(child, index$1) {
					if (child.type === "Text") {
						if (child.content.includes("\n")) {
							containsTextNodesWithLineBreaks = true;
							child.content = child.content.trim();
						} else if ((index$1 === 0 || index$1 === nodeChildren.length - 1) && !preserveSpace) {
							if (child.content.trim().length === 0) child.content = "";
						}
						if (child.content.trim().length > 0 || nodeChildren.length === 1) containsTextNodes = true;
					} else if (child.type === "CDATA") containsTextNodes = true;
					else containsNonTextNodes = true;
				});
				if (containsTextNodes && (!containsNonTextNodes || !containsTextNodesWithLineBreaks)) nodePreserveSpace = true;
			}
			nodeChildren.forEach(function(child) {
				processNode(child, state, preserveSpace || nodePreserveSpace);
			});
			state.level--;
			if (!preserveSpace && !nodePreserveSpace) newLine(state);
			if (ignoredPath) indent(state);
			appendContent(state, "</" + node$1.name + ">");
		}
		state.path.pop();
	}
	function processAttributes(state, attributes) {
		Object.keys(attributes).forEach(function(attr) {
			const escaped = attributes[attr].replace(/"/g, "&quot;");
			appendContent(state, " " + attr + "=\"" + escaped + "\"");
		});
	}
	function processProcessingIntruction(node$1, state) {
		if (state.content.length > 0) newLine(state);
		appendContent(state, "<?" + node$1.name);
		appendContent(state, " " + node$1.content.trim());
		appendContent(state, "?>");
	}
	/**
	* Converts the given XML into human readable format.
	*/
	function formatXml(xml, options = {}) {
		options.indentation = "indentation" in options ? options.indentation : "    ";
		options.collapseContent = options.collapseContent === true;
		options.lineSeparator = "lineSeparator" in options ? options.lineSeparator : "\r\n";
		options.whiteSpaceAtEndOfSelfclosingTag = options.whiteSpaceAtEndOfSelfclosingTag === true;
		options.throwOnFailure = options.throwOnFailure !== false;
		try {
			const parsedXml = (0, xml_parser_xo_1.default)(xml, {
				filter: options.filter,
				strictMode: options.strictMode
			});
			const state = {
				content: "",
				level: 0,
				options,
				path: []
			};
			if (parsedXml.declaration) processProcessingIntruction(parsedXml.declaration, state);
			parsedXml.children.forEach(function(child) {
				processNode(child, state, false);
			});
			if (!options.lineSeparator) return state.content;
			return state.content.replace(/\r\n/g, "\n").replace(/\n/g, options.lineSeparator);
		} catch (err) {
			if (options.throwOnFailure) throw err;
			return xml;
		}
	}
	formatXml.minify = (xml, options = {}) => {
		return formatXml(xml, Object.assign(Object.assign({}, options), {
			indentation: "",
			lineSeparator: ""
		}));
	};
	if (typeof module !== "undefined" && typeof exports === "object") module.exports = formatXml;
	exports.default = formatXml;
}) });

//#endregion
//#region src/testing/prompts/renderPrompt.ts
var import_cjs = /* @__PURE__ */ __toESM(require_cjs(), 1);
async function renderPrompt(input) {
	let content;
	if (typeof input === "string") content = input;
	else if (typeof input === "function") content = await input();
	else if (input && typeof input.then === "function") content = await input;
	else throw new Error("renderPrompt expects a string, a promise that returns a string, or a function that returns a string");
	return formatPromptContent(content);
}
function formatPromptContent(content) {
	content = content.trim();
	if (content.includes("<") && content.includes(">")) try {
		const fileElements = /* @__PURE__ */ new Map();
		let fileIndex = 0;
		let processedContent = content.replace(/<file\s+[^>]*>[\s\S]*?<\/file>/g, (match$1) => {
			const pathMatch = match$1.match(/path="([^"]*)"/);
			const path$19 = pathMatch ? pathMatch[1] : "";
			let fileContent = match$1.match(/<file[^>]*>([\s\S]*?)<\/file>/)?.[1] ?? "";
			fileContent = fileContent.replace(/^<!\[CDATA\[([\s\S]*?)\]\]>$/, "$1");
			const placeholder = `__FILE_PLACEHOLDER_${fileIndex}__`;
			if (path$19 === void 0) throw new Error("path is undefined");
			fileElements.set(placeholder, {
				path: path$19,
				content: fileContent
			});
			fileIndex++;
			return placeholder;
		});
		const cdataMap = /* @__PURE__ */ new Map();
		let cdataIndex = 0;
		processedContent = processedContent.replace(/<!\[CDATA\[([\s\S]*?)\]\]>/g, (match$1, cdataContent) => {
			const placeholder = `__CDATA_PLACEHOLDER_${cdataIndex}__`;
			cdataMap.set(placeholder, cdataContent);
			cdataIndex++;
			return placeholder;
		});
		const hasMultipleRoots = !processedContent.match(/^<([^>\s]+)[^>]*>[\s\S]*<\/\1>$/);
		let formatted = (0, import_cjs.default)(hasMultipleRoots ? `<root>${processedContent}</root>` : processedContent, {
			indentation: "  ",
			collapseContent: false,
			lineSeparator: "\n",
			whiteSpaceAtEndOfSelfclosingTag: true
		});
		if (hasMultipleRoots) formatted = formatted.replace(/^<root>\n?/, "").replace(/\n?<\/root>$/, "").split("\n").map((line) => line.startsWith("  ") ? line.substring(2) : line).join("\n");
		cdataMap.forEach((cdataContent, placeholder) => {
			formatted = formatted.replace(placeholder, cdataContent);
		});
		fileElements.forEach((fileData, placeholder) => {
			const placeholderIndex = formatted.indexOf(placeholder);
			if (placeholderIndex === -1) return;
			const lineStart = formatted.lastIndexOf("\n", placeholderIndex) + 1;
			const indent$1 = formatted.substring(lineStart, placeholderIndex);
			let fileElement;
			if (fileData.content.trim()) {
				const contentLines = fileData.content.split("\n");
				if (contentLines.length > 1) {
					const indentedContent = contentLines.map((line, i$8) => {
						if (i$8 === 0) return line;
						return indent$1 + "    " + line;
					}).join("\n");
					fileElement = `<file path="${fileData.path}">\n${indent$1}    ${indentedContent}\n${indent$1}  </file>`;
				} else fileElement = `<file path="${fileData.path}">${fileData.content}</file>`;
			} else fileElement = `<file path="${fileData.path}"></file>`;
			formatted = formatted.replace(placeholder, fileElement);
		});
		content = formatted;
	} catch (e) {
		console.warn("XML formatting failed, using original content");
	}
	content = formatEmbeddedJson(content);
	content = addXmlSpacing(content);
	return content;
}
function formatEmbeddedJson(content) {
	return content.replace(/>(\s*[\[{][\s\S]*?[\]}]\s*)</g, (match$1, json$1) => {
		try {
			const parsed = JSON.parse(json$1);
			const formatted = JSON.stringify(parsed, null, 2);
			const lines = content.substring(0, content.indexOf(match$1)).split("\n");
			const indent$1 = (lines[lines.length - 1] ?? "").match(/^(\s*)/)?.[1] ?? "";
			return `>\n${indent$1}  ${formatted.split("\n").map((line, i$8) => i$8 === 0 ? line : indent$1 + "  " + line).join("\n")}\n${indent$1}<`;
		} catch {
			return match$1;
		}
	});
}
function addXmlSpacing(content) {
	const lines = content.split("\n");
	const spacedLines = [];
	let previousWasClosingTag = false;
	for (let i$8 = 0; i$8 < lines.length; i$8++) {
		const line = lines[i$8];
		if (!line) continue;
		const trimmedLine = line.trim();
		const isTopLevel = !line.startsWith("  ");
		const isOpeningTag = /^<[^\/]/.test(trimmedLine);
		const isClosingTag = /^<\//.test(trimmedLine);
		if (isTopLevel && isOpeningTag && previousWasClosingTag && spacedLines.length > 0) spacedLines.push("");
		spacedLines.push(line);
		previousWasClosingTag = isTopLevel && isClosingTag;
	}
	return spacedLines.join("\n");
}

//#endregion
//#region src/testing/prompts/message.ts
function isHumanMessage(msg) {
	return msg instanceof HumanMessage;
}

//#endregion
//#region src/testing/prompts/chatHistory.ts
/**
* The chatHistory function renders a <chat-history> tag,
* listing messages as <message> sub-elements with "role: content".
*
* @param messages - An array of message objects with "role" and "content".
*
* @example
* ```ts
* const messages = [
*   { role: 'system', content: 'You are a helpful AI assistant.' },
*   { role: 'user', content: 'Hello!' }
* ];
*
* chatHistory({ messages })
* ```
*/
async function chatHistoryPrompt({ messages }) {
	return renderPrompt(`<chat-history>${messages?.map((message) => {
		return `<message>${isHumanMessage(message) ? "human" : "assistant"}: ${JSON.stringify(message.content, null, 4)}</message>`;
	}).join("") || ""}</chat-history>`);
}

//#endregion
//#region src/testing/prompts/structuredOutput.ts
const structuredOutputPrompt = async ({ schema, tag = "structured-output" }) => {
	return renderPrompt(`
    <${tag}>
      ${StructuredOutputParser.fromZodSchema(schema).getFormatInstructions()}
    </${tag}>
  `);
};

//#endregion
//#region src/testing/graphs/agent/sampleAgent.ts
async function readAnswersFromJSON(filePath = "./brainstorm-answers.json") {
	try {
		const fileContent = await readFile(filePath, "utf-8");
		return JSON.parse(fileContent);
	} catch (err) {
		return {};
	}
}
/**
* Helper function to write answers to a JSON file by key
* Merges new data with existing data in the file
* @param data - Object containing the answers keyed by topic
* @param filePath - Path to the JSON file (defaults to ./brainstorm-answers.json)
*/
async function writeAnswersToJSON(data, filePath = "./brainstorm-answers.json") {
	try {
		const mergedData = {
			...await readAnswersFromJSON(filePath),
			...data
		};
		await writeFile(filePath, JSON.stringify(mergedData, null, 2), "utf-8");
	} catch (error) {
		console.error("Error writing answers to JSON:", error);
		throw error;
	}
}
const TopicDescriptions = {
	idea: `The core business idea. What does the business do? What makes them different?`,
	audience: `The target audience. What are their pain points? What are their goals?`,
	solution: `How does the user's business solve the audience's pain points, or help them reach their goals?`,
	socialProof: `Social proof or testimonials to include on the landing page. Remember, anything can be social proof: the user's background, experience, beliefs, founder story, etc.`,
	lookAndFeel: `The look and feel of the landing page.`
};
const sortedTopics = (topics) => {
	return topics.sort((a, b) => brainstormTopics.indexOf(a) - brainstormTopics.indexOf(b));
};
const remainingTopics = (topics) => {
	return sortedTopics(topics).map((topic) => `${topic}: ${TopicDescriptions[topic]}`).join("\n\n");
};
const collectedData = (state) => {
	return Object.entries(state.brainstorm).filter(([_, value]) => value !== void 0 && value !== "");
};
const getPrompt = async (state, config) => {
	const lastHumanMessage = state.messages.filter(isHumanMessage).at(-1);
	if (!lastHumanMessage) throw new Error("No human message found");
	const chatHistory = await chatHistoryPrompt({ messages: state.messages });
	const hasUserContext = state.userContext && Object.keys(state.userContext).length > 0;
	return renderPrompt(`
            <role>
                You are a highly paid marketing consultant and strategist who specializes in helping businesses develop
                HIGHLY PERSUASIVE marketing copy for their landing pages to differentiate their business ideas.
            </role>

            <rules>
                1. You MUST understand the user's business idea and audience. You are good natured, but critical of bad ideas. You MUST help the user find a GREAT angle.
                2. You have a reputation to uphold. You won't accept a bad business idea, but will help the user find a better angle.
                3. If the user is struggling, you can find creative angles to answer a question.
                4. You do not save an answer unless the user has given you a GREAT response. Continue refining UNTIL the user has given you a GREAT response in their own words.
                ${hasUserContext ? "5. IMPORTANT: Tailor your questions and feedback based on the user context provided below." : ""}
            </rules>

            <task>
                Help the user brainstorm marketing copy for their landing page.
                Guide them through each question until you have enough context to generate effective marketing copy.
            </task>

            ${hasUserContext ? `<user_context>
                ${toJSON({ values: state.userContext })}
            </user_context>` : ""}

            <collected_data>
                ${toJSON({ values: collectedData(state) })}
            </collected_data>

            ${chatHistory}

            <remaining_topics>
                ${remainingTopics(state.remainingTopics)}
            </remaining_topics>

            <users_last_message>
                ${lastHumanMessage.content}
            </users_last_message>

            <workflow>
                1. If the user has answered any topics with a GREAT response, call the save_answers tool
                2. If they haven't, continue helping them refine their answer until they give you a GREAT response.
                3. Then, if:
                   - The user has answered ALL topics, generate a marketingTemplate with compelling landing page copy
                   - OTHERWISE, ask the next question, following the output_format_rules
            </workflow>

            <important>
                Do not miss anything important the user said! Any important
                business context they give you should be saved to the answers.
            </important>

            <ensure_understanding>
                Ensure you actually understand the answer in the user's own words.
                If unclear, use simpleQuestion to ask for clarification.
            </ensure_understanding>

            <output_format_rules>
                IMPORTANT: Your response MUST be in one of these exact formats:

                To ask a question:
                {
                  "type": "question",
                  "text": "Brief intro to the question",
                  "examples": ["Example 1", "Example 2", "Example 3"], // Optional
                  "conclusion": "Restate what you're asking for" // Optional
                }

                When the user has answered ALL brainstorming topics, generate marketing copy:
                {
                  "type": "marketingTemplate",
                  "headline": "Compelling, benefit-focused headline",
                  "subheadline": "Supporting detail that expands the promise", // Optional
                  "valueProposition": "Clear unique value statement",
                  "bulletPoints": ["Benefit 1", "Benefit 2", "Benefit 3"], // Optional, 3-5 items
                  "callToAction": "Strong action-oriented CTA",
                  "tone": "professional|friendly|urgent|authoritative|playful",
                  "socialProofSnippet": "Brief testimonial or proof element" // Optional
                }

                You MUST output valid JSON in one of these formats. NO other text.
            </output_format_rules>

            ${await structuredOutputPrompt({ schema: questionSchema })}
        `);
};
const SaveAnswersTool = (state, config) => {
	const saveAnswersInputSchema = z.object({ answers: z.array(z.object({
		topic: z.enum(brainstormTopics),
		answer: z.string()
	})) });
	async function saveAnswers(args) {
		await writeAnswersToJSON(args?.answers?.reduce((acc, { topic, answer }) => {
			if (!topic || !answer) return acc;
			acc[topic] = answer;
			return acc;
		}, {}) || {});
		return { success: true };
	}
	return tool(saveAnswers, {
		name: "save_answers",
		description: `
            Save answers to the brainstorming session. 
            Call this when the user has answered one or more of the remaining topics.
            IMPORTANT: When saving answers, save AS MUCH context as possible. We need a LOT of high quality content IN THE USER'S OWN WORDS to generate effective marketing copy.
        `,
		schema: saveAnswersInputSchema
	});
};
/**
* Node that asks a question to the user during brainstorming mode
*/
const brainstormAgent = async (state, config) => {
	try {
		const prompt = await getPrompt(state, config);
		const tools = [SaveAnswersTool(state, config)];
		const structuredResponse = (await (await createAgent({
			model: getLLM().withConfig({ tags: ["notify"] }),
			tools,
			systemPrompt: prompt,
			responseFormat: agentOutputSchema
		})).invoke(state, config)).structuredResponse;
		const aiMessage = new AIMessage({
			content: JSON.stringify(structuredResponse, null, 2),
			response_metadata: structuredResponse
		});
		const answers = await readAnswersFromJSON();
		const questionsAnswered = Object.keys(answers);
		const remainingTopics$1 = state.remainingTopics.filter((topic) => !questionsAnswered.includes(topic));
		return {
			messages: [...state.messages || [], aiMessage],
			remainingTopics: remainingTopics$1
		};
	} catch (error) {
		console.error("==========================================");
		console.error("BRAINSTORM AGENT ERROR:");
		console.error("==========================================");
		console.error("Error details:", error);
		console.error("Error stack:", error instanceof Error ? error.stack : "No stack trace");
		console.error("State:", JSON.stringify(state, null, 2));
		console.error("==========================================");
		throw error;
	}
};
/**
* Simple test graph for the new brainstorm agent
* Usage: Load this in LangGraph Studio to test the agent
*/
function createSampleAgent(checkpointer, graphName = "sample") {
	return new StateGraph(BrainstormStateAnnotation).addNode("agent", NodeMiddleware.use({}, brainstormAgent)).addEdge(START, "agent").addEdge("agent", END).compile({
		checkpointer,
		name: graphName
	});
}

//#endregion
export { BrainstormStateAnnotation, ErrorReporters, NodeMiddleware, NodeMiddlewareFactory, SampleGraphAnnotation, agentOutputSchema, brainstormAgent, brainstormTopics, configureResponses, configureResponses$1 as configureTestResponses, coreLLMConfig, createSampleAgent, createSampleGraph, getCoreLLM, getLLM, getNodeContext, getTestLLM, hasConfiguredResponses, marketingTemplateSchema, nameProjectNode, questionSchema, resetLLMConfig, resetLLMConfig$1 as resetTestConfig, responseNode, structuredMessageSchema, withContext, withErrorHandling, withNotifications };